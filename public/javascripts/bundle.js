(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a)return a(o, !0);
                if (i)return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f
            }
            var l = n[o] = {exports: {}};
            t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }

    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)s(r[o]);
    return s
})({
    1: [function (require, module, exports) {
        /**
         * The main JS entry point to run the application
         * Created by Henry on 6/27/2015.
         */
        var Detector = require("./lib/detector.js");
        var Main = require("./main.js");

        if (!Detector.webgl) Detector.addGetWebGLMessage();
        Main.init();
    }, {"./lib/detector.js": 3, "./main.js": 8}],
    2: [function (require, module, exports) {
        /**
         * Static singleton class that handle inputs
         * Created by Henry on 6/27/2015.
         */

        var $ = require("./lib/jquery.js");
        var _ = require("./lib/underscore.js");
        var Main = require("./main.js");

        var Input = new function () {
            var self = this;

            /**
             * The current selected object
             * @type {Box}
             */
            self.selected = null;

            /**
             * A set of pressed keycodes
             * @type {Array}
             */
            self.pressed = [];

            //Bind keys
            $(document).bind("keydown", function (event) {
                self.pressed.push(event.keyCode);
            });

            $(document).bind("keyup", function (event) {
                self.pressed = _.without(self.pressed, event.keyCode);
            });


            /**
             * Does a raytrace to find the object currently hit
             * @returns {Entity} The hit entity
             */
            self.getHit = function () {
                Main.raycaster.setFromCamera(self.mouse, self.camera);
                var intersects = self.raycaster.intersectObjects(world.entities);

                if (intersects.length > 0) {
                    return intersects[0];
                }

                return null;
            }
        };

        module.exports = Input;
    }, {"./lib/jquery.js": 4, "./lib/underscore.js": 7, "./main.js": 8}],
    3: [function (require, module, exports) {
        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mr.doob / http://mrdoob.com/
         */
        var Detector = {
            canvas: !!window.CanvasRenderingContext2D,
            webgl: (function () {
                try {
                    var canvas = document.createElement('canvas');
                    return !!( window.WebGLRenderingContext && ( canvas.getContext('webgl') || canvas.getContext('experimental-webgl') ) );
                } catch (e) {
                    return false;
                }
            })(),
            workers: !!window.Worker,
            fileapi: window.File && window.FileReader && window.FileList && window.Blob,

            getWebGLErrorMessage: function () {

                var element = document.createElement('div');
                element.id = 'webgl-error-message';
                element.style.fontFamily = 'monospace';
                element.style.fontSize = '13px';
                element.style.fontWeight = 'normal';
                element.style.textAlign = 'center';
                element.style.background = '#fff';
                element.style.color = '#000';
                element.style.padding = '1.5em';
                element.style.width = '400px';
                element.style.margin = '5em auto 0';

                if (!this.webgl) {

                    element.innerHTML = window.WebGLRenderingContext ? [
                        'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />',
                        'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
                    ].join('\n') : [
                        'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>',
                        'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
                    ].join('\n');

                }

                return element;

            },

            addGetWebGLMessage: function (parameters) {

                var parent, id, element;

                parameters = parameters || {};

                parent = parameters.parent !== undefined ? parameters.parent : document.body;
                id = parameters.id !== undefined ? parameters.id : 'oldie';

                element = Detector.getWebGLErrorMessage();
                element.id = id;

                parent.appendChild(element);

            }
        };

        module.exports = Detector;
    }, {}],
    4: [function (require, module, exports) {
        /*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
        !function (a, b) {
            "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function (a) {
                if (!a.document)throw new Error("jQuery requires a window with a document");
                return b(a)
            } : b(a)
        }("undefined" != typeof window ? window : this, function (a, b) {
            var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = {}, l = a.document, m = "2.1.4", n = function (a, b) {
                return new n.fn.init(a, b)
            }, o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, p = /^-ms-/, q = /-([\da-z])/gi, r = function (a, b) {
                return b.toUpperCase()
            };
            n.fn = n.prototype = {
                jquery: m, constructor: n, selector: "", length: 0, toArray: function () {
                    return d.call(this)
                }, get: function (a) {
                    return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this)
                }, pushStack: function (a) {
                    var b = n.merge(this.constructor(), a);
                    return b.prevObject = this, b.context = this.context, b
                }, each: function (a, b) {
                    return n.each(this, a, b)
                }, map: function (a) {
                    return this.pushStack(n.map(this, function (b, c) {
                        return a.call(b, c, b)
                    }))
                }, slice: function () {
                    return this.pushStack(d.apply(this, arguments))
                }, first: function () {
                    return this.eq(0)
                }, last: function () {
                    return this.eq(-1)
                }, eq: function (a) {
                    var b = this.length, c = +a + (0 > a ? b : 0);
                    return this.pushStack(c >= 0 && b > c ? [this[c]] : [])
                }, end: function () {
                    return this.prevObject || this.constructor(null)
                }, push: f, sort: c.sort, splice: c.splice
            }, n.extend = n.fn.extend = function () {
                var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
                for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)if (null != (a = arguments[h]))for (b in a)c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));
                return g
            }, n.extend({
                expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (a) {
                    throw new Error(a)
                }, noop: function () {
                }, isFunction: function (a) {
                    return "function" === n.type(a)
                }, isArray: Array.isArray, isWindow: function (a) {
                    return null != a && a === a.window
                }, isNumeric: function (a) {
                    return !n.isArray(a) && a - parseFloat(a) + 1 >= 0
                }, isPlainObject: function (a) {
                    return "object" !== n.type(a) || a.nodeType || n.isWindow(a) ? !1 : a.constructor && !j.call(a.constructor.prototype, "isPrototypeOf") ? !1 : !0
                }, isEmptyObject: function (a) {
                    var b;
                    for (b in a)return !1;
                    return !0
                }, type: function (a) {
                    return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a
                }, globalEval: function (a) {
                    var b, c = eval;
                    a = n.trim(a), a && (1 === a.indexOf("use strict") ? (b = l.createElement("script"), b.text = a, l.head.appendChild(b).parentNode.removeChild(b)) : c(a))
                }, camelCase: function (a) {
                    return a.replace(p, "ms-").replace(q, r)
                }, nodeName: function (a, b) {
                    return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
                }, each: function (a, b, c) {
                    var d, e = 0, f = a.length, g = s(a);
                    if (c) {
                        if (g) {
                            for (; f > e; e++)if (d = b.apply(a[e], c), d === !1)break
                        } else for (e in a)if (d = b.apply(a[e], c), d === !1)break
                    } else if (g) {
                        for (; f > e; e++)if (d = b.call(a[e], e, a[e]), d === !1)break
                    } else for (e in a)if (d = b.call(a[e], e, a[e]), d === !1)break;
                    return a
                }, trim: function (a) {
                    return null == a ? "" : (a + "").replace(o, "")
                }, makeArray: function (a, b) {
                    var c = b || [];
                    return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c
                }, inArray: function (a, b, c) {
                    return null == b ? -1 : g.call(b, a, c)
                }, merge: function (a, b) {
                    for (var c = +b.length, d = 0, e = a.length; c > d; d++)a[e++] = b[d];
                    return a.length = e, a
                }, grep: function (a, b, c) {
                    for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++)d = !b(a[f], f), d !== h && e.push(a[f]);
                    return e
                }, map: function (a, b, c) {
                    var d, f = 0, g = a.length, h = s(a), i = [];
                    if (h)for (; g > f; f++)d = b(a[f], f, c), null != d && i.push(d); else for (f in a)d = b(a[f], f, c), null != d && i.push(d);
                    return e.apply([], i)
                }, guid: 1, proxy: function (a, b) {
                    var c, e, f;
                    return "string" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (e = d.call(arguments, 2), f = function () {
                        return a.apply(b || this, e.concat(d.call(arguments)))
                    }, f.guid = a.guid = a.guid || n.guid++, f) : void 0
                }, now: Date.now, support: k
            }), n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (a, b) {
                h["[object " + b + "]"] = b.toLowerCase()
            });
            function s(a) {
                var b = "length"in a && a.length, c = n.type(a);
                return "function" === c || n.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a
            }

            var t = function (a) {
                var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date, v = a.document, w = 0, x = 0, y = ha(), z = ha(), A = ha(), B = function (a, b) {
                    return a === b && (l = !0), 0
                }, C = 1 << 31, D = {}.hasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice, J = function (a, b) {
                    for (var c = 0, d = a.length; d > c; c++)if (a[c] === b)return c;
                    return -1
                }, K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", L = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", N = M.replace("w", "w#"), O = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + N + "))|)" + L + "*\\]", P = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + O + ")*)|.*)\\)|)", Q = new RegExp(L + "+", "g"), R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"), S = new RegExp("^" + L + "*," + L + "*"), T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"), U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"), V = new RegExp(P), W = new RegExp("^" + N + "$"), X = {
                    ID: new RegExp("^#(" + M + ")"),
                    CLASS: new RegExp("^\\.(" + M + ")"),
                    TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
                    ATTR: new RegExp("^" + O),
                    PSEUDO: new RegExp("^" + P),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + K + ")$", "i"),
                    needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
                }, Y = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, $ = /^[^{]+\{\s*\[native \w/, _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, aa = /[+~]/, ba = /'|\\/g, ca = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"), da = function (a, b, c) {
                    var d = "0x" + b - 65536;
                    return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
                }, ea = function () {
                    m()
                };
                try {
                    H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType
                } catch (fa) {
                    H = {
                        apply: E.length ? function (a, b) {
                            G.apply(a, I.call(b))
                        } : function (a, b) {
                            var c = a.length, d = 0;
                            while (a[c++] = b[d++]);
                            a.length = c - 1
                        }
                    }
                }
                function ga(a, b, d, e) {
                    var f, h, j, k, l, o, r, s, w, x;
                    if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], k = b.nodeType, "string" != typeof a || !a || 1 !== k && 9 !== k && 11 !== k)return d;
                    if (!e && p) {
                        if (11 !== k && (f = _.exec(a)))if (j = f[1]) {
                            if (9 === k) {
                                if (h = b.getElementById(j), !h || !h.parentNode)return d;
                                if (h.id === j)return d.push(h), d
                            } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j)return d.push(h), d
                        } else {
                            if (f[2])return H.apply(d, b.getElementsByTagName(a)), d;
                            if ((j = f[3]) && c.getElementsByClassName)return H.apply(d, b.getElementsByClassName(j)), d
                        }
                        if (c.qsa && (!q || !q.test(a))) {
                            if (s = r = u, w = b, x = 1 !== k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
                                o = g(a), (r = b.getAttribute("id")) ? s = r.replace(ba, "\\$&") : b.setAttribute("id", s), s = "[id='" + s + "'] ", l = o.length;
                                while (l--)o[l] = s + ra(o[l]);
                                w = aa.test(a) && pa(b.parentNode) || b, x = o.join(",")
                            }
                            if (x)try {
                                return H.apply(d, w.querySelectorAll(x)), d
                            } catch (y) {
                            } finally {
                                r || b.removeAttribute("id")
                            }
                        }
                    }
                    return i(a.replace(R, "$1"), b, d, e)
                }

                function ha() {
                    var a = [];

                    function b(c, e) {
                        return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e
                    }

                    return b
                }

                function ia(a) {
                    return a[u] = !0, a
                }

                function ja(a) {
                    var b = n.createElement("div");
                    try {
                        return !!a(b)
                    } catch (c) {
                        return !1
                    } finally {
                        b.parentNode && b.parentNode.removeChild(b), b = null
                    }
                }

                function ka(a, b) {
                    var c = a.split("|"), e = a.length;
                    while (e--)d.attrHandle[c[e]] = b
                }

                function la(a, b) {
                    var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);
                    if (d)return d;
                    if (c)while (c = c.nextSibling)if (c === b)return -1;
                    return a ? 1 : -1
                }

                function ma(a) {
                    return function (b) {
                        var c = b.nodeName.toLowerCase();
                        return "input" === c && b.type === a
                    }
                }

                function na(a) {
                    return function (b) {
                        var c = b.nodeName.toLowerCase();
                        return ("input" === c || "button" === c) && b.type === a
                    }
                }

                function oa(a) {
                    return ia(function (b) {
                        return b = +b, ia(function (c, d) {
                            var e, f = a([], c.length, b), g = f.length;
                            while (g--)c[e = f[g]] && (c[e] = !(d[e] = c[e]))
                        })
                    })
                }

                function pa(a) {
                    return a && "undefined" != typeof a.getElementsByTagName && a
                }

                c = ga.support = {}, f = ga.isXML = function (a) {
                    var b = a && (a.ownerDocument || a).documentElement;
                    return b ? "HTML" !== b.nodeName : !1
                }, m = ga.setDocument = function (a) {
                    var b, e, g = a ? a.ownerDocument || a : v;
                    return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = g.documentElement, e = g.defaultView, e && e !== e.top && (e.addEventListener ? e.addEventListener("unload", ea, !1) : e.attachEvent && e.attachEvent("onunload", ea)), p = !f(g), c.attributes = ja(function (a) {
                        return a.className = "i", !a.getAttribute("className")
                    }), c.getElementsByTagName = ja(function (a) {
                        return a.appendChild(g.createComment("")), !a.getElementsByTagName("*").length
                    }), c.getElementsByClassName = $.test(g.getElementsByClassName), c.getById = ja(function (a) {
                        return o.appendChild(a).id = u, !g.getElementsByName || !g.getElementsByName(u).length
                    }), c.getById ? (d.find.ID = function (a, b) {
                        if ("undefined" != typeof b.getElementById && p) {
                            var c = b.getElementById(a);
                            return c && c.parentNode ? [c] : []
                        }
                    }, d.filter.ID = function (a) {
                        var b = a.replace(ca, da);
                        return function (a) {
                            return a.getAttribute("id") === b
                        }
                    }) : (delete d.find.ID, d.filter.ID = function (a) {
                        var b = a.replace(ca, da);
                        return function (a) {
                            var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
                            return c && c.value === b
                        }
                    }), d.find.TAG = c.getElementsByTagName ? function (a, b) {
                        return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0
                    } : function (a, b) {
                        var c, d = [], e = 0, f = b.getElementsByTagName(a);
                        if ("*" === a) {
                            while (c = f[e++])1 === c.nodeType && d.push(c);
                            return d
                        }
                        return f
                    }, d.find.CLASS = c.getElementsByClassName && function (a, b) {
                            return p ? b.getElementsByClassName(a) : void 0
                        }, r = [], q = [], (c.qsa = $.test(g.querySelectorAll)) && (ja(function (a) {
                        o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\f]' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]")
                    }), ja(function (a) {
                        var b = g.createElement("input");
                        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:")
                    })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function (a) {
                        c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", P)
                    }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function (a, b) {
                        var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode;
                        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
                    } : function (a, b) {
                        if (b)while (b = b.parentNode)if (b === a)return !0;
                        return !1
                    }, B = b ? function (a, b) {
                        if (a === b)return l = !0, 0;
                        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === g || a.ownerDocument === v && t(v, a) ? -1 : b === g || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1)
                    } : function (a, b) {
                        if (a === b)return l = !0, 0;
                        var c, d = 0, e = a.parentNode, f = b.parentNode, h = [a], i = [b];
                        if (!e || !f)return a === g ? -1 : b === g ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
                        if (e === f)return la(a, b);
                        c = a;
                        while (c = c.parentNode)h.unshift(c);
                        c = b;
                        while (c = c.parentNode)i.unshift(c);
                        while (h[d] === i[d])d++;
                        return d ? la(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0
                    }, g) : n
                }, ga.matches = function (a, b) {
                    return ga(a, null, null, b)
                }, ga.matchesSelector = function (a, b) {
                    if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b)))try {
                        var d = s.call(a, b);
                        if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType)return d
                    } catch (e) {
                    }
                    return ga(b, n, null, [a]).length > 0
                }, ga.contains = function (a, b) {
                    return (a.ownerDocument || a) !== n && m(a), t(a, b)
                }, ga.attr = function (a, b) {
                    (a.ownerDocument || a) !== n && m(a);
                    var e = d.attrHandle[b.toLowerCase()], f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
                    return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null
                }, ga.error = function (a) {
                    throw new Error("Syntax error, unrecognized expression: " + a)
                }, ga.uniqueSort = function (a) {
                    var b, d = [], e = 0, f = 0;
                    if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
                        while (b = a[f++])b === a[f] && (e = d.push(f));
                        while (e--)a.splice(d[e], 1)
                    }
                    return k = null, a
                }, e = ga.getText = function (a) {
                    var b, c = "", d = 0, f = a.nodeType;
                    if (f) {
                        if (1 === f || 9 === f || 11 === f) {
                            if ("string" == typeof a.textContent)return a.textContent;
                            for (a = a.firstChild; a; a = a.nextSibling)c += e(a)
                        } else if (3 === f || 4 === f)return a.nodeValue
                    } else while (b = a[d++])c += e(b);
                    return c
                }, d = ga.selectors = {
                    cacheLength: 50,
                    createPseudo: ia,
                    match: X,
                    attrHandle: {},
                    find: {},
                    relative: {">": {dir: "parentNode", first: !0}, " ": {dir: "parentNode"}, "+": {dir: "previousSibling", first: !0}, "~": {dir: "previousSibling"}},
                    preFilter: {
                        ATTR: function (a) {
                            return a[1] = a[1].replace(ca, da), a[3] = (a[3] || a[4] || a[5] || "").replace(ca, da), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
                        }, CHILD: function (a) {
                            return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]), a
                        }, PSEUDO: function (a) {
                            var b, c = !a[6] && a[2];
                            return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function (a) {
                            var b = a.replace(ca, da).toLowerCase();
                            return "*" === a ? function () {
                                return !0
                            } : function (a) {
                                return a.nodeName && a.nodeName.toLowerCase() === b
                            }
                        }, CLASS: function (a) {
                            var b = y[a + " "];
                            return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function (a) {
                                    return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
                                })
                        }, ATTR: function (a, b, c) {
                            return function (d) {
                                var e = ga.attr(d, a);
                                return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0
                            }
                        }, CHILD: function (a, b, c, d, e) {
                            var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b;
                            return 1 === d && 0 === e ? function (a) {
                                return !!a.parentNode
                            } : function (b, c, i) {
                                var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h;
                                if (q) {
                                    if (f) {
                                        while (p) {
                                            l = b;
                                            while (l = l[p])if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType)return !1;
                                            o = p = "only" === a && !o && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (o = [g ? q.firstChild : q.lastChild], g && s) {
                                        k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], l = n && q.childNodes[n];
                                        while (l = ++n && l && l[p] || (m = n = 0) || o.pop())if (1 === l.nodeType && ++m && l === b) {
                                            k[a] = [w, n, m];
                                            break
                                        }
                                    } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w)m = j[1]; else while (l = ++n && l && l[p] || (m = n = 0) || o.pop())if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (s && ((l[u] || (l[u] = {}))[a] = [w, m]), l === b))break;
                                    return m -= e, m === d || m % d === 0 && m / d >= 0
                                }
                            }
                        }, PSEUDO: function (a, b) {
                            var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);
                            return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function (a, c) {
                                var d, f = e(a, b), g = f.length;
                                while (g--)d = J(a, f[g]), a[d] = !(c[d] = f[g])
                            }) : function (a) {
                                return e(a, 0, c)
                            }) : e
                        }
                    },
                    pseudos: {
                        not: ia(function (a) {
                            var b = [], c = [], d = h(a.replace(R, "$1"));
                            return d[u] ? ia(function (a, b, c, e) {
                                var f, g = d(a, null, e, []), h = a.length;
                                while (h--)(f = g[h]) && (a[h] = !(b[h] = f))
                            }) : function (a, e, f) {
                                return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop()
                            }
                        }), has: ia(function (a) {
                            return function (b) {
                                return ga(a, b).length > 0
                            }
                        }), contains: ia(function (a) {
                            return a = a.replace(ca, da), function (b) {
                                return (b.textContent || b.innerText || e(b)).indexOf(a) > -1
                            }
                        }), lang: ia(function (a) {
                            return W.test(a || "") || ga.error("unsupported lang: " + a), a = a.replace(ca, da).toLowerCase(), function (b) {
                                var c;
                                do if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang"))return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
                                return !1
                            }
                        }), target: function (b) {
                            var c = a.location && a.location.hash;
                            return c && c.slice(1) === b.id
                        }, root: function (a) {
                            return a === o
                        }, focus: function (a) {
                            return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
                        }, enabled: function (a) {
                            return a.disabled === !1
                        }, disabled: function (a) {
                            return a.disabled === !0
                        }, checked: function (a) {
                            var b = a.nodeName.toLowerCase();
                            return "input" === b && !!a.checked || "option" === b && !!a.selected
                        }, selected: function (a) {
                            return a.parentNode && a.parentNode.selectedIndex, a.selected === !0
                        }, empty: function (a) {
                            for (a = a.firstChild; a; a = a.nextSibling)if (a.nodeType < 6)return !1;
                            return !0
                        }, parent: function (a) {
                            return !d.pseudos.empty(a)
                        }, header: function (a) {
                            return Z.test(a.nodeName)
                        }, input: function (a) {
                            return Y.test(a.nodeName)
                        }, button: function (a) {
                            var b = a.nodeName.toLowerCase();
                            return "input" === b && "button" === a.type || "button" === b
                        }, text: function (a) {
                            var b;
                            return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
                        }, first: oa(function () {
                            return [0]
                        }), last: oa(function (a, b) {
                            return [b - 1]
                        }), eq: oa(function (a, b, c) {
                            return [0 > c ? c + b : c]
                        }), even: oa(function (a, b) {
                            for (var c = 0; b > c; c += 2)a.push(c);
                            return a
                        }), odd: oa(function (a, b) {
                            for (var c = 1; b > c; c += 2)a.push(c);
                            return a
                        }), lt: oa(function (a, b, c) {
                            for (var d = 0 > c ? c + b : c; --d >= 0;)a.push(d);
                            return a
                        }), gt: oa(function (a, b, c) {
                            for (var d = 0 > c ? c + b : c; ++d < b;)a.push(d);
                            return a
                        })
                    }
                }, d.pseudos.nth = d.pseudos.eq;
                for (b in{radio: !0, checkbox: !0, file: !0, password: !0, image: !0})d.pseudos[b] = ma(b);
                for (b in{submit: !0, reset: !0})d.pseudos[b] = na(b);
                function qa() {
                }

                qa.prototype = d.filters = d.pseudos, d.setFilters = new qa, g = ga.tokenize = function (a, b) {
                    var c, e, f, g, h, i, j, k = z[a + " "];
                    if (k)return b ? 0 : k.slice(0);
                    h = a, i = [], j = d.preFilter;
                    while (h) {
                        (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({
                            value: c,
                            type: e[0].replace(R, " ")
                        }), h = h.slice(c.length));
                        for (g in d.filter)!(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({value: c, type: g, matches: e}), h = h.slice(c.length));
                        if (!c)break
                    }
                    return b ? h.length : h ? ga.error(a) : z(a, i).slice(0)
                };
                function ra(a) {
                    for (var b = 0, c = a.length, d = ""; c > b; b++)d += a[b].value;
                    return d
                }

                function sa(a, b, c) {
                    var d = b.dir, e = c && "parentNode" === d, f = x++;
                    return b.first ? function (b, c, f) {
                        while (b = b[d])if (1 === b.nodeType || e)return a(b, c, f)
                    } : function (b, c, g) {
                        var h, i, j = [w, f];
                        if (g) {
                            while (b = b[d])if ((1 === b.nodeType || e) && a(b, c, g))return !0
                        } else while (b = b[d])if (1 === b.nodeType || e) {
                            if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f)return j[2] = h[2];
                            if (i[d] = j, j[2] = a(b, c, g))return !0
                        }
                    }
                }

                function ta(a) {
                    return a.length > 1 ? function (b, c, d) {
                        var e = a.length;
                        while (e--)if (!a[e](b, c, d))return !1;
                        return !0
                    } : a[0]
                }

                function ua(a, b, c) {
                    for (var d = 0, e = b.length; e > d; d++)ga(a, b[d], c);
                    return c
                }

                function va(a, b, c, d, e) {
                    for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));
                    return g
                }

                function wa(a, b, c, d, e, f) {
                    return d && !d[u] && (d = wa(d)), e && !e[u] && (e = wa(e, f)), ia(function (f, g, h, i) {
                        var j, k, l, m = [], n = [], o = g.length, p = f || ua(b || "*", h.nodeType ? [h] : h, []), q = !a || !f && b ? p : va(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q;
                        if (c && c(q, r, h, i), d) {
                            j = va(r, n), d(j, [], h, i), k = j.length;
                            while (k--)(l = j[k]) && (r[n[k]] = !(q[n[k]] = l))
                        }
                        if (f) {
                            if (e || a) {
                                if (e) {
                                    j = [], k = r.length;
                                    while (k--)(l = r[k]) && j.push(q[k] = l);
                                    e(null, r = [], j, i)
                                }
                                k = r.length;
                                while (k--)(l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))
                            }
                        } else r = va(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r)
                    })
                }

                function xa(a) {
                    for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = sa(function (a) {
                        return a === b
                    }, h, !0), l = sa(function (a) {
                        return J(b, a) > -1
                    }, h, !0), m = [function (a, c, d) {
                        var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
                        return b = null, e
                    }]; f > i; i++)if (c = d.relative[a[i].type])m = [sa(ta(m), c)]; else {
                        if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
                            for (e = ++i; f > e; e++)if (d.relative[a[e].type])break;
                            return wa(i > 1 && ta(m), i > 1 && ra(a.slice(0, i - 1).concat({value: " " === a[i - 2].type ? "*" : ""})).replace(R, "$1"), c, e > i && xa(a.slice(i, e)), f > e && xa(a = a.slice(e)), f > e && ra(a))
                        }
                        m.push(c)
                    }
                    return ta(m)
                }

                function ya(a, b) {
                    var c = b.length > 0, e = a.length > 0, f = function (f, g, h, i, k) {
                        var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d.find.TAG("*", k), v = w += null == t ? 1 : Math.random() || .1, x = u.length;
                        for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
                            if (e && l) {
                                m = 0;
                                while (o = a[m++])if (o(l, g, h)) {
                                    i.push(l);
                                    break
                                }
                                k && (w = v)
                            }
                            c && ((l = !o && l) && p--, f && r.push(l))
                        }
                        if (p += q, c && q !== p) {
                            m = 0;
                            while (o = b[m++])o(r, s, g, h);
                            if (f) {
                                if (p > 0)while (q--)r[q] || s[q] || (s[q] = F.call(i));
                                s = va(s)
                            }
                            H.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && ga.uniqueSort(i)
                        }
                        return k && (w = v, j = t), r
                    };
                    return c ? ia(f) : f
                }

                return h = ga.compile = function (a, b) {
                    var c, d = [], e = [], f = A[a + " "];
                    if (!f) {
                        b || (b = g(a)), c = b.length;
                        while (c--)f = xa(b[c]), f[u] ? d.push(f) : e.push(f);
                        f = A(a, ya(e, d)), f.selector = a
                    }
                    return f
                }, i = ga.select = function (a, b, e, f) {
                    var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a);
                    if (e = e || [], 1 === o.length) {
                        if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
                            if (b = (d.find.ID(k.matches[0].replace(ca, da), b) || [])[0], !b)return e;
                            n && (b = b.parentNode), a = a.slice(j.shift().value.length)
                        }
                        i = X.needsContext.test(a) ? 0 : j.length;
                        while (i--) {
                            if (k = j[i], d.relative[l = k.type])break;
                            if ((m = d.find[l]) && (f = m(k.matches[0].replace(ca, da), aa.test(j[0].type) && pa(b.parentNode) || b))) {
                                if (j.splice(i, 1), a = f.length && ra(j), !a)return H.apply(e, f), e;
                                break
                            }
                        }
                    }
                    return (n || h(a, o))(f, b, !p, e, aa.test(a) && pa(b.parentNode) || b), e
                }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ja(function (a) {
                    return 1 & a.compareDocumentPosition(n.createElement("div"))
                }), ja(function (a) {
                    return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
                }) || ka("type|href|height|width", function (a, b, c) {
                    return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
                }), c.attributes && ja(function (a) {
                    return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
                }) || ka("value", function (a, b, c) {
                    return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
                }), ja(function (a) {
                    return null == a.getAttribute("disabled")
                }) || ka(K, function (a, b, c) {
                    var d;
                    return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
                }), ga
            }(a);
            n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;
            var u = n.expr.match.needsContext, v = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, w = /^.[^:#\[\.,]*$/;

            function x(a, b, c) {
                if (n.isFunction(b))return n.grep(a, function (a, d) {
                    return !!b.call(a, d, a) !== c
                });
                if (b.nodeType)return n.grep(a, function (a) {
                    return a === b !== c
                });
                if ("string" == typeof b) {
                    if (w.test(b))return n.filter(b, a, c);
                    b = n.filter(b, a)
                }
                return n.grep(a, function (a) {
                    return g.call(b, a) >= 0 !== c
                })
            }

            n.filter = function (a, b, c) {
                var d = b[0];
                return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {
                    return 1 === a.nodeType
                }))
            }, n.fn.extend({
                find: function (a) {
                    var b, c = this.length, d = [], e = this;
                    if ("string" != typeof a)return this.pushStack(n(a).filter(function () {
                        for (b = 0; c > b; b++)if (n.contains(e[b], this))return !0
                    }));
                    for (b = 0; c > b; b++)n.find(a, e[b], d);
                    return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + " " + a : a, d
                }, filter: function (a) {
                    return this.pushStack(x(this, a || [], !1))
                }, not: function (a) {
                    return this.pushStack(x(this, a || [], !0))
                }, is: function (a) {
                    return !!x(this, "string" == typeof a && u.test(a) ? n(a) : a || [], !1).length
                }
            });
            var y, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, A = n.fn.init = function (a, b) {
                var c, d;
                if (!a)return this;
                if ("string" == typeof a) {
                    if (c = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b)return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);
                    if (c[1]) {
                        if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : l, !0)), v.test(c[1]) && n.isPlainObject(b))for (c in b)n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                        return this
                    }
                    return d = l.getElementById(c[2]), d && d.parentNode && (this.length = 1, this[0] = d), this.context = l, this.selector = a, this
                }
                return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? "undefined" != typeof y.ready ? y.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this))
            };
            A.prototype = n.fn, y = n(l);
            var B = /^(?:parents|prev(?:Until|All))/, C = {children: !0, contents: !0, next: !0, prev: !0};
            n.extend({
                dir: function (a, b, c) {
                    var d = [], e = void 0 !== c;
                    while ((a = a[b]) && 9 !== a.nodeType)if (1 === a.nodeType) {
                        if (e && n(a).is(c))break;
                        d.push(a)
                    }
                    return d
                }, sibling: function (a, b) {
                    for (var c = []; a; a = a.nextSibling)1 === a.nodeType && a !== b && c.push(a);
                    return c
                }
            }), n.fn.extend({
                has: function (a) {
                    var b = n(a, this), c = b.length;
                    return this.filter(function () {
                        for (var a = 0; c > a; a++)if (n.contains(this, b[a]))return !0
                    })
                }, closest: function (a, b) {
                    for (var c, d = 0, e = this.length, f = [], g = u.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++)for (c = this[d]; c && c !== b; c = c.parentNode)if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {
                        f.push(c);
                        break
                    }
                    return this.pushStack(f.length > 1 ? n.unique(f) : f)
                }, index: function (a) {
                    return a ? "string" == typeof a ? g.call(n(a), this[0]) : g.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                }, add: function (a, b) {
                    return this.pushStack(n.unique(n.merge(this.get(), n(a, b))))
                }, addBack: function (a) {
                    return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
                }
            });
            function D(a, b) {
                while ((a = a[b]) && 1 !== a.nodeType);
                return a
            }

            n.each({
                parent: function (a) {
                    var b = a.parentNode;
                    return b && 11 !== b.nodeType ? b : null
                }, parents: function (a) {
                    return n.dir(a, "parentNode")
                }, parentsUntil: function (a, b, c) {
                    return n.dir(a, "parentNode", c)
                }, next: function (a) {
                    return D(a, "nextSibling")
                }, prev: function (a) {
                    return D(a, "previousSibling")
                }, nextAll: function (a) {
                    return n.dir(a, "nextSibling")
                }, prevAll: function (a) {
                    return n.dir(a, "previousSibling")
                }, nextUntil: function (a, b, c) {
                    return n.dir(a, "nextSibling", c)
                }, prevUntil: function (a, b, c) {
                    return n.dir(a, "previousSibling", c)
                }, siblings: function (a) {
                    return n.sibling((a.parentNode || {}).firstChild, a)
                }, children: function (a) {
                    return n.sibling(a.firstChild)
                }, contents: function (a) {
                    return a.contentDocument || n.merge([], a.childNodes)
                }
            }, function (a, b) {
                n.fn[a] = function (c, d) {
                    var e = n.map(this, b, c);
                    return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = n.filter(d, e)), this.length > 1 && (C[a] || n.unique(e), B.test(a) && e.reverse()), this.pushStack(e)
                }
            });
            var E = /\S+/g, F = {};

            function G(a) {
                var b = F[a] = {};
                return n.each(a.match(E) || [], function (a, c) {
                    b[c] = !0
                }), b
            }

            n.Callbacks = function (a) {
                a = "string" == typeof a ? F[a] || G(a) : n.extend({}, a);
                var b, c, d, e, f, g, h = [], i = !a.once && [], j = function (l) {
                    for (b = a.memory && l, c = !0, g = e || 0, e = 0, f = h.length, d = !0; h && f > g; g++)if (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
                        b = !1;
                        break
                    }
                    d = !1, h && (i ? i.length && j(i.shift()) : b ? h = [] : k.disable())
                }, k = {
                    add: function () {
                        if (h) {
                            var c = h.length;
                            !function g(b) {
                                n.each(b, function (b, c) {
                                    var d = n.type(c);
                                    "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && g(c)
                                })
                            }(arguments), d ? f = h.length : b && (e = c, j(b))
                        }
                        return this
                    }, remove: function () {
                        return h && n.each(arguments, function (a, b) {
                            var c;
                            while ((c = n.inArray(b, h, c)) > -1)h.splice(c, 1), d && (f >= c && f--, g >= c && g--)
                        }), this
                    }, has: function (a) {
                        return a ? n.inArray(a, h) > -1 : !(!h || !h.length)
                    }, empty: function () {
                        return h = [], f = 0, this
                    }, disable: function () {
                        return h = i = b = void 0, this
                    }, disabled: function () {
                        return !h
                    }, lock: function () {
                        return i = void 0, b || k.disable(), this
                    }, locked: function () {
                        return !i
                    }, fireWith: function (a, b) {
                        return !h || c && !i || (b = b || [], b = [a, b.slice ? b.slice() : b], d ? i.push(b) : j(b)), this
                    }, fire: function () {
                        return k.fireWith(this, arguments), this
                    }, fired: function () {
                        return !!c
                    }
                };
                return k
            }, n.extend({
                Deferred: function (a) {
                    var b = [["resolve", "done", n.Callbacks("once memory"), "resolved"], ["reject", "fail", n.Callbacks("once memory"), "rejected"], ["notify", "progress", n.Callbacks("memory")]], c = "pending", d = {
                        state: function () {
                            return c
                        }, always: function () {
                            return e.done(arguments).fail(arguments), this
                        }, then: function () {
                            var a = arguments;
                            return n.Deferred(function (c) {
                                n.each(b, function (b, f) {
                                    var g = n.isFunction(a[b]) && a[b];
                                    e[f[1]](function () {
                                        var a = g && g.apply(this, arguments);
                                        a && n.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                                    })
                                }), a = null
                            }).promise()
                        }, promise: function (a) {
                            return null != a ? n.extend(a, d) : d
                        }
                    }, e = {};
                    return d.pipe = d.then, n.each(b, function (a, f) {
                        var g = f[2], h = f[3];
                        d[f[1]] = g.add, h && g.add(function () {
                            c = h
                        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {
                            return e[f[0] + "With"](this === e ? d : this, arguments), this
                        }, e[f[0] + "With"] = g.fireWith
                    }), d.promise(e), a && a.call(e, e), e
                }, when: function (a) {
                    var b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && n.isFunction(a.promise) ? e : 0, g = 1 === f ? a : n.Deferred(), h = function (a, b, c) {
                        return function (e) {
                            b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)
                        }
                    }, i, j, k;
                    if (e > 1)for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++)c[b] && n.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
                    return f || g.resolveWith(k, c), g.promise()
                }
            });
            var H;
            n.fn.ready = function (a) {
                return n.ready.promise().done(a), this
            }, n.extend({
                isReady: !1, readyWait: 1, holdReady: function (a) {
                    a ? n.readyWait++ : n.ready(!0)
                }, ready: function (a) {
                    (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (H.resolveWith(l, [n]), n.fn.triggerHandler && (n(l).triggerHandler("ready"), n(l).off("ready"))))
                }
            });
            function I() {
                l.removeEventListener("DOMContentLoaded", I, !1), a.removeEventListener("load", I, !1), n.ready()
            }

            n.ready.promise = function (b) {
                return H || (H = n.Deferred(), "complete" === l.readyState ? setTimeout(n.ready) : (l.addEventListener("DOMContentLoaded", I, !1), a.addEventListener("load", I, !1))), H.promise(b)
            }, n.ready.promise();
            var J = n.access = function (a, b, c, d, e, f, g) {
                var h = 0, i = a.length, j = null == c;
                if ("object" === n.type(c)) {
                    e = !0;
                    for (h in c)n.access(a, b, h, c[h], !0, f, g)
                } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function (a, b, c) {
                        return j.call(n(a), c)
                    })), b))for (; i > h; h++)b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
                return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
            };
            n.acceptData = function (a) {
                return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType
            };
            function K() {
                Object.defineProperty(this.cache = {}, 0, {
                    get: function () {
                        return {}
                    }
                }), this.expando = n.expando + K.uid++
            }

            K.uid = 1, K.accepts = n.acceptData, K.prototype = {
                key: function (a) {
                    if (!K.accepts(a))return 0;
                    var b = {}, c = a[this.expando];
                    if (!c) {
                        c = K.uid++;
                        try {
                            b[this.expando] = {value: c}, Object.defineProperties(a, b)
                        } catch (d) {
                            b[this.expando] = c, n.extend(a, b)
                        }
                    }
                    return this.cache[c] || (this.cache[c] = {}), c
                }, set: function (a, b, c) {
                    var d, e = this.key(a), f = this.cache[e];
                    if ("string" == typeof b)f[b] = c; else if (n.isEmptyObject(f))n.extend(this.cache[e], b); else for (d in b)f[d] = b[d];
                    return f
                }, get: function (a, b) {
                    var c = this.cache[this.key(a)];
                    return void 0 === b ? c : c[b]
                }, access: function (a, b, c) {
                    var d;
                    return void 0 === b || b && "string" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b)
                }, remove: function (a, b) {
                    var c, d, e, f = this.key(a), g = this.cache[f];
                    if (void 0 === b)this.cache[f] = {}; else {
                        n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in g ? d = [b, e] : (d = e, d = d in g ? [d] : d.match(E) || [])), c = d.length;
                        while (c--)delete g[d[c]]
                    }
                }, hasData: function (a) {
                    return !n.isEmptyObject(this.cache[a[this.expando]] || {})
                }, discard: function (a) {
                    a[this.expando] && delete this.cache[a[this.expando]]
                }
            };
            var L = new K, M = new K, N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, O = /([A-Z])/g;

            function P(a, b, c) {
                var d;
                if (void 0 === c && 1 === a.nodeType)if (d = "data-" + b.replace(O, "-$1").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
                    try {
                        c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : N.test(c) ? n.parseJSON(c) : c
                    } catch (e) {
                    }
                    M.set(a, b, c)
                } else c = void 0;
                return c
            }

            n.extend({
                hasData: function (a) {
                    return M.hasData(a) || L.hasData(a)
                }, data: function (a, b, c) {
                    return M.access(a, b, c)
                }, removeData: function (a, b) {
                    M.remove(a, b)
                }, _data: function (a, b, c) {
                    return L.access(a, b, c)
                }, _removeData: function (a, b) {
                    L.remove(a, b)
                }
            }), n.fn.extend({
                data: function (a, b) {
                    var c, d, e, f = this[0], g = f && f.attributes;
                    if (void 0 === a) {
                        if (this.length && (e = M.get(f), 1 === f.nodeType && !L.get(f, "hasDataAttrs"))) {
                            c = g.length;
                            while (c--)g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)), P(f, d, e[d])));
                            L.set(f, "hasDataAttrs", !0)
                        }
                        return e
                    }
                    return "object" == typeof a ? this.each(function () {
                        M.set(this, a)
                    }) : J(this, function (b) {
                        var c, d = n.camelCase(a);
                        if (f && void 0 === b) {
                            if (c = M.get(f, a), void 0 !== c)return c;
                            if (c = M.get(f, d), void 0 !== c)return c;
                            if (c = P(f, d, void 0), void 0 !== c)return c
                        } else this.each(function () {
                            var c = M.get(this, d);
                            M.set(this, d, b), -1 !== a.indexOf("-") && void 0 !== c && M.set(this, a, b)
                        })
                    }, null, b, arguments.length > 1, null, !0)
                }, removeData: function (a) {
                    return this.each(function () {
                        M.remove(this, a)
                    })
                }
            }), n.extend({
                queue: function (a, b, c) {
                    var d;
                    return a ? (b = (b || "fx") + "queue", d = L.get(a, b), c && (!d || n.isArray(c) ? d = L.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0
                }, dequeue: function (a, b) {
                    b = b || "fx";
                    var c = n.queue(a, b), d = c.length, e = c.shift(), f = n._queueHooks(a, b), g = function () {
                        n.dequeue(a, b)
                    };
                    "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
                }, _queueHooks: function (a, b) {
                    var c = b + "queueHooks";
                    return L.get(a, c) || L.access(a, c, {
                            empty: n.Callbacks("once memory").add(function () {
                                L.remove(a, [b + "queue", c])
                            })
                        })
                }
            }), n.fn.extend({
                queue: function (a, b) {
                    var c = 2;
                    return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {
                        var c = n.queue(this, a, b);
                        n._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a)
                    })
                }, dequeue: function (a) {
                    return this.each(function () {
                        n.dequeue(this, a)
                    })
                }, clearQueue: function (a) {
                    return this.queue(a || "fx", [])
                }, promise: function (a, b) {
                    var c, d = 1, e = n.Deferred(), f = this, g = this.length, h = function () {
                        --d || e.resolveWith(f, [f])
                    };
                    "string" != typeof a && (b = a, a = void 0), a = a || "fx";
                    while (g--)c = L.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
                    return h(), e.promise(b)
                }
            });
            var Q = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, R = ["Top", "Right", "Bottom", "Left"], S = function (a, b) {
                return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
            }, T = /^(?:checkbox|radio)$/i;
            !function () {
                var a = l.createDocumentFragment(), b = a.appendChild(l.createElement("div")), c = l.createElement("input");
                c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue
            }();
            var U = "undefined";
            k.focusinBubbles = "onfocusin"in a;
            var V = /^key/, W = /^(?:mouse|pointer|contextmenu)|click/, X = /^(?:focusinfocus|focusoutblur)$/, Y = /^([^.]*)(?:\.(.+)|)$/;

            function Z() {
                return !0
            }

            function $() {
                return !1
            }

            function _() {
                try {
                    return l.activeElement
                } catch (a) {
                }
            }

            n.event = {
                global: {},
                add: function (a, b, c, d, e) {
                    var f, g, h, i, j, k, l, m, o, p, q, r = L.get(a);
                    if (r) {
                        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {
                            return typeof n !== U && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0
                        }), b = (b || "").match(E) || [""], j = b.length;
                        while (j--)h = Y.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({
                            type: o,
                            origType: q,
                            data: d,
                            handler: c,
                            guid: c.guid,
                            selector: e,
                            needsContext: e && n.expr.match.needsContext.test(e),
                            namespace: p.join(".")
                        }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g, !1)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0)
                    }
                },
                remove: function (a, b, c, d, e) {
                    var f, g, h, i, j, k, l, m, o, p, q, r = L.hasData(a) && L.get(a);
                    if (r && (i = r.events)) {
                        b = (b || "").match(E) || [""], j = b.length;
                        while (j--)if (h = Y.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
                            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length;
                            while (f--)k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
                            g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o])
                        } else for (o in i)n.event.remove(a, o + b[j], c, d, !0);
                        n.isEmptyObject(i) && (delete r.handle, L.remove(a, "events"))
                    }
                },
                trigger: function (b, c, d, e) {
                    var f, g, h, i, k, m, o, p = [d || l], q = j.call(b, "type") ? b.type : b, r = j.call(b, "namespace") ? b.namespace.split(".") : [];
                    if (g = h = d = d || l, 3 !== d.nodeType && 8 !== d.nodeType && !X.test(q + n.event.triggered) && (q.indexOf(".") >= 0 && (r = q.split("."), q = r.shift(), r.sort()), k = q.indexOf(":") < 0 && "on" + q, b = b[n.expando] ? b : new n.Event(q, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = r.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, e || !o.trigger || o.trigger.apply(d, c) !== !1)) {
                        if (!e && !o.noBubble && !n.isWindow(d)) {
                            for (i = o.delegateType || q, X.test(i + q) || (g = g.parentNode); g; g = g.parentNode)p.push(g), h = g;
                            h === (d.ownerDocument || l) && p.push(h.defaultView || h.parentWindow || a)
                        }
                        f = 0;
                        while ((g = p[f++]) && !b.isPropagationStopped())b.type = f > 1 ? i : o.bindType || q, m = (L.get(g, "events") || {})[b.type] && L.get(g, "handle"), m && m.apply(g, c), m = k && g[k], m && m.apply && n.acceptData(g) && (b.result = m.apply(g, c), b.result === !1 && b.preventDefault());
                        return b.type = q, e || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !n.acceptData(d) || k && n.isFunction(d[q]) && !n.isWindow(d) && (h = d[k], h && (d[k] = null), n.event.triggered = q, d[q](), n.event.triggered = void 0, h && (d[k] = h)), b.result
                    }
                },
                dispatch: function (a) {
                    a = n.event.fix(a);
                    var b, c, e, f, g, h = [], i = d.call(arguments), j = (L.get(this, "events") || {})[a.type] || [], k = n.event.special[a.type] || {};
                    if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
                        h = n.event.handlers.call(this, a, j), b = 0;
                        while ((f = h[b++]) && !a.isPropagationStopped()) {
                            a.currentTarget = f.elem, c = 0;
                            while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped())(!a.namespace_re || a.namespace_re.test(g.namespace)) && (a.handleObj = g, a.data = g.data, e = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (a.result = e) === !1 && (a.preventDefault(), a.stopPropagation()))
                        }
                        return k.postDispatch && k.postDispatch.call(this, a), a.result
                    }
                },
                handlers: function (a, b) {
                    var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
                    if (h && i.nodeType && (!a.button || "click" !== a.type))for (; i !== this; i = i.parentNode || this)if (i.disabled !== !0 || "click" !== a.type) {
                        for (d = [], c = 0; h > c; c++)f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) >= 0 : n.find(e, this, null, [i]).length), d[e] && d.push(f);
                        d.length && g.push({elem: i, handlers: d})
                    }
                    return h < b.length && g.push({elem: this, handlers: b.slice(h)}), g
                },
                props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
                fixHooks: {},
                keyHooks: {
                    props: "char charCode key keyCode".split(" "), filter: function (a, b) {
                        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a
                    }
                },
                mouseHooks: {
                    props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function (a, b) {
                        var c, d, e, f = b.button;
                        return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || l, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e.scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e.clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a
                    }
                },
                fix: function (a) {
                    if (a[n.expando])return a;
                    var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
                    g || (this.fixHooks[e] = g = W.test(e) ? this.mouseHooks : V.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new n.Event(f), b = d.length;
                    while (b--)c = d[b], a[c] = f[c];
                    return a.target || (a.target = l), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter ? g.filter(a, f) : a
                },
                special: {
                    load: {noBubble: !0}, focus: {
                        trigger: function () {
                            return this !== _() && this.focus ? (this.focus(), !1) : void 0
                        }, delegateType: "focusin"
                    }, blur: {
                        trigger: function () {
                            return this === _() && this.blur ? (this.blur(), !1) : void 0
                        }, delegateType: "focusout"
                    }, click: {
                        trigger: function () {
                            return "checkbox" === this.type && this.click && n.nodeName(this, "input") ? (this.click(), !1) : void 0
                        }, _default: function (a) {
                            return n.nodeName(a.target, "a")
                        }
                    }, beforeunload: {
                        postDispatch: function (a) {
                            void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
                        }
                    }
                },
                simulate: function (a, b, c, d) {
                    var e = n.extend(new n.Event, c, {type: a, isSimulated: !0, originalEvent: {}});
                    d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault()
                }
            }, n.removeEvent = function (a, b, c) {
                a.removeEventListener && a.removeEventListener(b, c, !1)
            }, n.Event = function (a, b) {
                return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? Z : $) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(a, b)
            }, n.Event.prototype = {
                isDefaultPrevented: $, isPropagationStopped: $, isImmediatePropagationStopped: $, preventDefault: function () {
                    var a = this.originalEvent;
                    this.isDefaultPrevented = Z, a && a.preventDefault && a.preventDefault()
                }, stopPropagation: function () {
                    var a = this.originalEvent;
                    this.isPropagationStopped = Z, a && a.stopPropagation && a.stopPropagation()
                }, stopImmediatePropagation: function () {
                    var a = this.originalEvent;
                    this.isImmediatePropagationStopped = Z, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation()
                }
            }, n.each({mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"}, function (a, b) {
                n.event.special[a] = {
                    delegateType: b, bindType: b, handle: function (a) {
                        var c, d = this, e = a.relatedTarget, f = a.handleObj;
                        return (!e || e !== d && !n.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
                    }
                }
            }), k.focusinBubbles || n.each({focus: "focusin", blur: "focusout"}, function (a, b) {
                var c = function (a) {
                    n.event.simulate(b, a.target, n.event.fix(a), !0)
                };
                n.event.special[b] = {
                    setup: function () {
                        var d = this.ownerDocument || this, e = L.access(d, b);
                        e || d.addEventListener(a, c, !0), L.access(d, b, (e || 0) + 1)
                    }, teardown: function () {
                        var d = this.ownerDocument || this, e = L.access(d, b) - 1;
                        e ? L.access(d, b, e) : (d.removeEventListener(a, c, !0), L.remove(d, b))
                    }
                }
            }), n.fn.extend({
                on: function (a, b, c, d, e) {
                    var f, g;
                    if ("object" == typeof a) {
                        "string" != typeof b && (c = c || b, b = void 0);
                        for (g in a)this.on(g, b, c, a[g], e);
                        return this
                    }
                    if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1)d = $; else if (!d)return this;
                    return 1 === e && (f = d, d = function (a) {
                        return n().off(a), f.apply(this, arguments)
                    }, d.guid = f.guid || (f.guid = n.guid++)), this.each(function () {
                        n.event.add(this, a, d, c, b)
                    })
                }, one: function (a, b, c, d) {
                    return this.on(a, b, c, d, 1)
                }, off: function (a, b, c) {
                    var d, e;
                    if (a && a.preventDefault && a.handleObj)return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
                    if ("object" == typeof a) {
                        for (e in a)this.off(e, b, a[e]);
                        return this
                    }
                    return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = $), this.each(function () {
                        n.event.remove(this, a, c, b)
                    })
                }, trigger: function (a, b) {
                    return this.each(function () {
                        n.event.trigger(a, b, this)
                    })
                }, triggerHandler: function (a, b) {
                    var c = this[0];
                    return c ? n.event.trigger(a, b, c, !0) : void 0
                }
            });
            var aa = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, ba = /<([\w:]+)/, ca = /<|&#?\w+;/, da = /<(?:script|style|link)/i, ea = /checked\s*(?:[^=]|=\s*.checked.)/i, fa = /^$|\/(?:java|ecma)script/i, ga = /^true\/(.*)/, ha = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, ia = {
                option: [1, "<select multiple='multiple'>", "</select>"],
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };
            ia.optgroup = ia.option, ia.tbody = ia.tfoot = ia.colgroup = ia.caption = ia.thead, ia.th = ia.td;
            function ja(a, b) {
                return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
            }

            function ka(a) {
                return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a
            }

            function la(a) {
                var b = ga.exec(a.type);
                return b ? a.type = b[1] : a.removeAttribute("type"), a
            }

            function ma(a, b) {
                for (var c = 0, d = a.length; d > c; c++)L.set(a[c], "globalEval", !b || L.get(b[c], "globalEval"))
            }

            function na(a, b) {
                var c, d, e, f, g, h, i, j;
                if (1 === b.nodeType) {
                    if (L.hasData(a) && (f = L.access(a), g = L.set(b, f), j = f.events)) {
                        delete g.handle, g.events = {};
                        for (e in j)for (c = 0, d = j[e].length; d > c; c++)n.event.add(b, e, j[e][c])
                    }
                    M.hasData(a) && (h = M.access(a), i = n.extend({}, h), M.set(b, i))
                }
            }

            function oa(a, b) {
                var c = a.getElementsByTagName ? a.getElementsByTagName(b || "*") : a.querySelectorAll ? a.querySelectorAll(b || "*") : [];
                return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c
            }

            function pa(a, b) {
                var c = b.nodeName.toLowerCase();
                "input" === c && T.test(a.type) ? b.checked = a.checked : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue)
            }

            n.extend({
                clone: function (a, b, c) {
                    var d, e, f, g, h = a.cloneNode(!0), i = n.contains(a.ownerDocument, a);
                    if (!(k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a)))for (g = oa(h), f = oa(a), d = 0, e = f.length; e > d; d++)pa(f[d], g[d]);
                    if (b)if (c)for (f = f || oa(a), g = g || oa(h), d = 0, e = f.length; e > d; d++)na(f[d], g[d]); else na(a, h);
                    return g = oa(h, "script"), g.length > 0 && ma(g, !i && oa(a, "script")), h
                }, buildFragment: function (a, b, c, d) {
                    for (var e, f, g, h, i, j, k = b.createDocumentFragment(), l = [], m = 0, o = a.length; o > m; m++)if (e = a[m], e || 0 === e)if ("object" === n.type(e))n.merge(l, e.nodeType ? [e] : e); else if (ca.test(e)) {
                        f = f || k.appendChild(b.createElement("div")), g = (ba.exec(e) || ["", ""])[1].toLowerCase(), h = ia[g] || ia._default, f.innerHTML = h[1] + e.replace(aa, "<$1></$2>") + h[2], j = h[0];
                        while (j--)f = f.lastChild;
                        n.merge(l, f.childNodes), f = k.firstChild, f.textContent = ""
                    } else l.push(b.createTextNode(e));
                    k.textContent = "", m = 0;
                    while (e = l[m++])if ((!d || -1 === n.inArray(e, d)) && (i = n.contains(e.ownerDocument, e), f = oa(k.appendChild(e), "script"), i && ma(f), c)) {
                        j = 0;
                        while (e = f[j++])fa.test(e.type || "") && c.push(e)
                    }
                    return k
                }, cleanData: function (a) {
                    for (var b, c, d, e, f = n.event.special, g = 0; void 0 !== (c = a[g]); g++) {
                        if (n.acceptData(c) && (e = c[L.expando], e && (b = L.cache[e]))) {
                            if (b.events)for (d in b.events)f[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);
                            L.cache[e] && delete L.cache[e]
                        }
                        delete M.cache[c[M.expando]]
                    }
                }
            }), n.fn.extend({
                text: function (a) {
                    return J(this, function (a) {
                        return void 0 === a ? n.text(this) : this.empty().each(function () {
                            (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a)
                        })
                    }, null, a, arguments.length)
                }, append: function () {
                    return this.domManip(arguments, function (a) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var b = ja(this, a);
                            b.appendChild(a)
                        }
                    })
                }, prepend: function () {
                    return this.domManip(arguments, function (a) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var b = ja(this, a);
                            b.insertBefore(a, b.firstChild)
                        }
                    })
                }, before: function () {
                    return this.domManip(arguments, function (a) {
                        this.parentNode && this.parentNode.insertBefore(a, this)
                    })
                }, after: function () {
                    return this.domManip(arguments, function (a) {
                        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
                    })
                }, remove: function (a, b) {
                    for (var c, d = a ? n.filter(a, this) : this, e = 0; null != (c = d[e]); e++)b || 1 !== c.nodeType || n.cleanData(oa(c)), c.parentNode && (b && n.contains(c.ownerDocument, c) && ma(oa(c, "script")), c.parentNode.removeChild(c));
                    return this
                }, empty: function () {
                    for (var a, b = 0; null != (a = this[b]); b++)1 === a.nodeType && (n.cleanData(oa(a, !1)), a.textContent = "");
                    return this
                }, clone: function (a, b) {
                    return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {
                        return n.clone(this, a, b)
                    })
                }, html: function (a) {
                    return J(this, function (a) {
                        var b = this[0] || {}, c = 0, d = this.length;
                        if (void 0 === a && 1 === b.nodeType)return b.innerHTML;
                        if ("string" == typeof a && !da.test(a) && !ia[(ba.exec(a) || ["", ""])[1].toLowerCase()]) {
                            a = a.replace(aa, "<$1></$2>");
                            try {
                                for (; d > c; c++)b = this[c] || {}, 1 === b.nodeType && (n.cleanData(oa(b, !1)), b.innerHTML = a);
                                b = 0
                            } catch (e) {
                            }
                        }
                        b && this.empty().append(a)
                    }, null, a, arguments.length)
                }, replaceWith: function () {
                    var a = arguments[0];
                    return this.domManip(arguments, function (b) {
                        a = this.parentNode, n.cleanData(oa(this)), a && a.replaceChild(b, this)
                    }), a && (a.length || a.nodeType) ? this : this.remove()
                }, detach: function (a) {
                    return this.remove(a, !0)
                }, domManip: function (a, b) {
                    a = e.apply([], a);
                    var c, d, f, g, h, i, j = 0, l = this.length, m = this, o = l - 1, p = a[0], q = n.isFunction(p);
                    if (q || l > 1 && "string" == typeof p && !k.checkClone && ea.test(p))return this.each(function (c) {
                        var d = m.eq(c);
                        q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b)
                    });
                    if (l && (c = n.buildFragment(a, this[0].ownerDocument, !1, this), d = c.firstChild, 1 === c.childNodes.length && (c = d), d)) {
                        for (f = n.map(oa(c, "script"), ka), g = f.length; l > j; j++)h = c, j !== o && (h = n.clone(h, !0, !0), g && n.merge(f, oa(h, "script"))), b.call(this[j], h, j);
                        if (g)for (i = f[f.length - 1].ownerDocument, n.map(f, la), j = 0; g > j; j++)h = f[j], fa.test(h.type || "") && !L.access(h, "globalEval") && n.contains(i, h) && (h.src ? n._evalUrl && n._evalUrl(h.src) : n.globalEval(h.textContent.replace(ha, "")))
                    }
                    return this
                }
            }), n.each({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, function (a, b) {
                n.fn[a] = function (a) {
                    for (var c, d = [], e = n(a), g = e.length - 1, h = 0; g >= h; h++)c = h === g ? this : this.clone(!0), n(e[h])[b](c), f.apply(d, c.get());
                    return this.pushStack(d)
                }
            });
            var qa, ra = {};

            function sa(b, c) {
                var d, e = n(c.createElement(b)).appendTo(c.body), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : n.css(e[0], "display");
                return e.detach(), f
            }

            function ta(a) {
                var b = l, c = ra[a];
                return c || (c = sa(a, b), "none" !== c && c || (qa = (qa || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = qa[0].contentDocument, b.write(), b.close(), c = sa(a, b), qa.detach()), ra[a] = c), c
            }

            var ua = /^margin/, va = new RegExp("^(" + Q + ")(?!px)[a-z%]+$", "i"), wa = function (b) {
                return b.ownerDocument.defaultView.opener ? b.ownerDocument.defaultView.getComputedStyle(b, null) : a.getComputedStyle(b, null)
            };

            function xa(a, b, c) {
                var d, e, f, g, h = a.style;
                return c = c || wa(a), c && (g = c.getPropertyValue(b) || c[b]), c && ("" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), va.test(g) && ua.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + "" : g
            }

            function ya(a, b) {
                return {
                    get: function () {
                        return a() ? void delete this.get : (this.get = b).apply(this, arguments)
                    }
                }
            }

            !function () {
                var b, c, d = l.documentElement, e = l.createElement("div"), f = l.createElement("div");
                if (f.style) {
                    f.style.backgroundClip = "content-box", f.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === f.style.backgroundClip, e.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", e.appendChild(f);
                    function g() {
                        f.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", f.innerHTML = "", d.appendChild(e);
                        var g = a.getComputedStyle(f, null);
                        b = "1%" !== g.top, c = "4px" === g.width, d.removeChild(e)
                    }

                    a.getComputedStyle && n.extend(k, {
                        pixelPosition: function () {
                            return g(), b
                        }, boxSizingReliable: function () {
                            return null == c && g(), c
                        }, reliableMarginRight: function () {
                            var b, c = f.appendChild(l.createElement("div"));
                            return c.style.cssText = f.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", c.style.marginRight = c.style.width = "0", f.style.width = "1px", d.appendChild(e), b = !parseFloat(a.getComputedStyle(c, null).marginRight), d.removeChild(e), f.removeChild(c), b
                        }
                    })
                }
            }(), n.swap = function (a, b, c, d) {
                var e, f, g = {};
                for (f in b)g[f] = a.style[f], a.style[f] = b[f];
                e = c.apply(a, d || []);
                for (f in b)a.style[f] = g[f];
                return e
            };
            var za = /^(none|table(?!-c[ea]).+)/, Aa = new RegExp("^(" + Q + ")(.*)$", "i"), Ba = new RegExp("^([+-])=(" + Q + ")", "i"), Ca = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            }, Da = {letterSpacing: "0", fontWeight: "400"}, Ea = ["Webkit", "O", "Moz", "ms"];

            function Fa(a, b) {
                if (b in a)return b;
                var c = b[0].toUpperCase() + b.slice(1), d = b, e = Ea.length;
                while (e--)if (b = Ea[e] + c, b in a)return b;
                return d
            }

            function Ga(a, b, c) {
                var d = Aa.exec(b);
                return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b
            }

            function Ha(a, b, c, d, e) {
                for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2)"margin" === c && (g += n.css(a, c + R[f], !0, e)), d ? ("content" === c && (g -= n.css(a, "padding" + R[f], !0, e)), "margin" !== c && (g -= n.css(a, "border" + R[f] + "Width", !0, e))) : (g += n.css(a, "padding" + R[f], !0, e), "padding" !== c && (g += n.css(a, "border" + R[f] + "Width", !0, e)));
                return g
            }

            function Ia(a, b, c) {
                var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = wa(a), g = "border-box" === n.css(a, "boxSizing", !1, f);
                if (0 >= e || null == e) {
                    if (e = xa(a, b, f), (0 > e || null == e) && (e = a.style[b]), va.test(e))return e;
                    d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0
                }
                return e + Ha(a, b, c || (g ? "border" : "content"), d, f) + "px"
            }

            function Ja(a, b) {
                for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++)d = a[g], d.style && (f[g] = L.get(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && S(d) && (f[g] = L.access(d, "olddisplay", ta(d.nodeName)))) : (e = S(d), "none" === c && e || L.set(d, "olddisplay", e ? c : n.css(d, "display"))));
                for (g = 0; h > g; g++)d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
                return a
            }

            n.extend({
                cssHooks: {
                    opacity: {
                        get: function (a, b) {
                            if (b) {
                                var c = xa(a, "opacity");
                                return "" === c ? "1" : c
                            }
                        }
                    }
                },
                cssNumber: {columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0},
                cssProps: {"float": "cssFloat"},
                style: function (a, b, c, d) {
                    if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                        var e, f, g, h = n.camelCase(b), i = a.style;
                        return b = n.cssProps[h] || (n.cssProps[h] = Fa(i, h)), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && "get"in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, "string" === f && (e = Ba.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b)), f = "number"), null != c && c === c && ("number" !== f || n.cssNumber[h] || (c += "px"), k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), g && "set"in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0)
                    }
                },
                css: function (a, b, c, d) {
                    var e, f, g, h = n.camelCase(b);
                    return b = n.cssProps[h] || (n.cssProps[h] = Fa(a.style, h)), g = n.cssHooks[b] || n.cssHooks[h], g && "get"in g && (e = g.get(a, !0, c)), void 0 === e && (e = xa(a, b, d)), "normal" === e && b in Da && (e = Da[b]), "" === c || c ? (f = parseFloat(e), c === !0 || n.isNumeric(f) ? f || 0 : e) : e
                }
            }), n.each(["height", "width"], function (a, b) {
                n.cssHooks[b] = {
                    get: function (a, c, d) {
                        return c ? za.test(n.css(a, "display")) && 0 === a.offsetWidth ? n.swap(a, Ca, function () {
                            return Ia(a, b, d)
                        }) : Ia(a, b, d) : void 0
                    }, set: function (a, c, d) {
                        var e = d && wa(a);
                        return Ga(a, c, d ? Ha(a, b, d, "border-box" === n.css(a, "boxSizing", !1, e), e) : 0)
                    }
                }
            }), n.cssHooks.marginRight = ya(k.reliableMarginRight, function (a, b) {
                return b ? n.swap(a, {display: "inline-block"}, xa, [a, "marginRight"]) : void 0
            }), n.each({margin: "", padding: "", border: "Width"}, function (a, b) {
                n.cssHooks[a + b] = {
                    expand: function (c) {
                        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++)e[a + R[d] + b] = f[d] || f[d - 2] || f[0];
                        return e
                    }
                }, ua.test(a) || (n.cssHooks[a + b].set = Ga)
            }), n.fn.extend({
                css: function (a, b) {
                    return J(this, function (a, b, c) {
                        var d, e, f = {}, g = 0;
                        if (n.isArray(b)) {
                            for (d = wa(a), e = b.length; e > g; g++)f[b[g]] = n.css(a, b[g], !1, d);
                            return f
                        }
                        return void 0 !== c ? n.style(a, b, c) : n.css(a, b)
                    }, a, b, arguments.length > 1)
                }, show: function () {
                    return Ja(this, !0)
                }, hide: function () {
                    return Ja(this)
                }, toggle: function (a) {
                    return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () {
                        S(this) ? n(this).show() : n(this).hide()
                    })
                }
            });
            function Ka(a, b, c, d, e) {
                return new Ka.prototype.init(a, b, c, d, e)
            }

            n.Tween = Ka, Ka.prototype = {
                constructor: Ka, init: function (a, b, c, d, e, f) {
                    this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px")
                }, cur: function () {
                    var a = Ka.propHooks[this.prop];
                    return a && a.get ? a.get(this) : Ka.propHooks._default.get(this)
                }, run: function (a) {
                    var b, c = Ka.propHooks[this.prop];
                    return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ka.propHooks._default.set(this), this
                }
            }, Ka.prototype.init.prototype = Ka.prototype, Ka.propHooks = {
                _default: {
                    get: function (a) {
                        var b;
                        return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = n.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) : a.elem[a.prop]
                    }, set: function (a) {
                        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[n.cssProps[a.prop]] || n.cssHooks[a.prop]) ? n.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now
                    }
                }
            }, Ka.propHooks.scrollTop = Ka.propHooks.scrollLeft = {
                set: function (a) {
                    a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
                }
            }, n.easing = {
                linear: function (a) {
                    return a
                }, swing: function (a) {
                    return .5 - Math.cos(a * Math.PI) / 2
                }
            }, n.fx = Ka.prototype.init, n.fx.step = {};
            var La, Ma, Na = /^(?:toggle|show|hide)$/, Oa = new RegExp("^(?:([+-])=|)(" + Q + ")([a-z%]*)$", "i"), Pa = /queueHooks$/, Qa = [Va], Ra = {
                "*": [function (a, b) {
                    var c = this.createTween(a, b), d = c.cur(), e = Oa.exec(b), f = e && e[3] || (n.cssNumber[a] ? "" : "px"), g = (n.cssNumber[a] || "px" !== f && +d) && Oa.exec(n.css(c.elem, a)), h = 1, i = 20;
                    if (g && g[3] !== f) {
                        f = f || g[3], e = e || [], g = +d || 1;
                        do h = h || ".5", g /= h, n.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i)
                    }
                    return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c
                }]
            };

            function Sa() {
                return setTimeout(function () {
                    La = void 0
                }), La = n.now()
            }

            function Ta(a, b) {
                var c, d = 0, e = {height: a};
                for (b = b ? 1 : 0; 4 > d; d += 2 - b)c = R[d], e["margin" + c] = e["padding" + c] = a;
                return b && (e.opacity = e.width = a), e
            }

            function Ua(a, b, c) {
                for (var d, e = (Ra[b] || []).concat(Ra["*"]), f = 0, g = e.length; g > f; f++)if (d = e[f].call(c, b, a))return d
            }

            function Va(a, b, c) {
                var d, e, f, g, h, i, j, k, l = this, m = {}, o = a.style, p = a.nodeType && S(a), q = L.get(a, "fxshow");
                c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {
                    h.unqueued || i()
                }), h.unqueued++, l.always(function () {
                    l.always(function () {
                        h.unqueued--, n.queue(a, "fx").length || h.empty.fire()
                    })
                })), 1 === a.nodeType && ("height"in b || "width"in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, "display"), k = "none" === j ? L.get(a, "olddisplay") || ta(a.nodeName) : j, "inline" === k && "none" === n.css(a, "float") && (o.display = "inline-block")), c.overflow && (o.overflow = "hidden", l.always(function () {
                    o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2]
                }));
                for (d in b)if (e = b[d], Na.exec(e)) {
                    if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
                        if ("show" !== e || !q || void 0 === q[d])continue;
                        p = !0
                    }
                    m[d] = q && q[d] || n.style(a, d)
                } else j = void 0;
                if (n.isEmptyObject(m))"inline" === ("none" === j ? ta(a.nodeName) : j) && (o.display = j); else {
                    q ? "hidden"in q && (p = q.hidden) : q = L.access(a, "fxshow", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () {
                        n(a).hide()
                    }), l.done(function () {
                        var b;
                        L.remove(a, "fxshow");
                        for (b in m)n.style(a, b, m[b])
                    });
                    for (d in m)g = Ua(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0))
                }
            }

            function Wa(a, b) {
                var c, d, e, f, g;
                for (c in a)if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && "expand"in g) {
                    f = g.expand(f), delete a[d];
                    for (c in f)c in a || (a[c] = f[c], b[c] = e)
                } else b[d] = e
            }

            function Xa(a, b, c) {
                var d, e, f = 0, g = Qa.length, h = n.Deferred().always(function () {
                    delete i.elem
                }), i = function () {
                    if (e)return !1;
                    for (var b = La || Sa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++)j.tweens[g].run(f);
                    return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1)
                }, j = h.promise({
                    elem: a,
                    props: n.extend({}, b),
                    opts: n.extend(!0, {specialEasing: {}}, c),
                    originalProperties: b,
                    originalOptions: c,
                    startTime: La || Sa(),
                    duration: c.duration,
                    tweens: [],
                    createTween: function (b, c) {
                        var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                        return j.tweens.push(d), d
                    },
                    stop: function (b) {
                        var c = 0, d = b ? j.tweens.length : 0;
                        if (e)return this;
                        for (e = !0; d > c; c++)j.tweens[c].run(1);
                        return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this
                    }
                }), k = j.props;
                for (Wa(k, j.opts.specialEasing); g > f; f++)if (d = Qa[f].call(j, a, k, j.opts))return d;
                return n.map(k, Ua, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, {
                    elem: a,
                    anim: j,
                    queue: j.opts.queue
                })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
            }

            n.Animation = n.extend(Xa, {
                tweener: function (a, b) {
                    n.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" ");
                    for (var c, d = 0, e = a.length; e > d; d++)c = a[d], Ra[c] = Ra[c] || [], Ra[c].unshift(b)
                }, prefilter: function (a, b) {
                    b ? Qa.unshift(a) : Qa.push(a)
                }
            }), n.speed = function (a, b, c) {
                var d = a && "object" == typeof a ? n.extend({}, a) : {complete: c || !c && b || n.isFunction(a) && a, duration: a, easing: c && b || b && !n.isFunction(b) && b};
                return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function () {
                    n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue)
                }, d
            }, n.fn.extend({
                fadeTo: function (a, b, c, d) {
                    return this.filter(S).css("opacity", 0).show().end().animate({opacity: b}, a, c, d)
                }, animate: function (a, b, c, d) {
                    var e = n.isEmptyObject(a), f = n.speed(b, c, d), g = function () {
                        var b = Xa(this, n.extend({}, a), f);
                        (e || L.get(this, "finish")) && b.stop(!0)
                    };
                    return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
                }, stop: function (a, b, c) {
                    var d = function (a) {
                        var b = a.stop;
                        delete a.stop, b(c)
                    };
                    return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function () {
                        var b = !0, e = null != a && a + "queueHooks", f = n.timers, g = L.get(this);
                        if (e)g[e] && g[e].stop && d(g[e]); else for (e in g)g[e] && g[e].stop && Pa.test(e) && d(g[e]);
                        for (e = f.length; e--;)f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
                        (b || !c) && n.dequeue(this, a)
                    })
                }, finish: function (a) {
                    return a !== !1 && (a = a || "fx"), this.each(function () {
                        var b, c = L.get(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = n.timers, g = d ? d.length : 0;
                        for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;)f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
                        for (b = 0; g > b; b++)d[b] && d[b].finish && d[b].finish.call(this);
                        delete c.finish
                    })
                }
            }), n.each(["toggle", "show", "hide"], function (a, b) {
                var c = n.fn[b];
                n.fn[b] = function (a, d, e) {
                    return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Ta(b, !0), a, d, e)
                }
            }), n.each({
                slideDown: Ta("show"),
                slideUp: Ta("hide"),
                slideToggle: Ta("toggle"),
                fadeIn: {opacity: "show"},
                fadeOut: {opacity: "hide"},
                fadeToggle: {opacity: "toggle"}
            }, function (a, b) {
                n.fn[a] = function (a, c, d) {
                    return this.animate(b, a, c, d)
                }
            }), n.timers = [], n.fx.tick = function () {
                var a, b = 0, c = n.timers;
                for (La = n.now(); b < c.length; b++)a = c[b], a() || c[b] !== a || c.splice(b--, 1);
                c.length || n.fx.stop(), La = void 0
            }, n.fx.timer = function (a) {
                n.timers.push(a), a() ? n.fx.start() : n.timers.pop()
            }, n.fx.interval = 13, n.fx.start = function () {
                Ma || (Ma = setInterval(n.fx.tick, n.fx.interval))
            }, n.fx.stop = function () {
                clearInterval(Ma), Ma = null
            }, n.fx.speeds = {slow: 600, fast: 200, _default: 400}, n.fn.delay = function (a, b) {
                return a = n.fx ? n.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function (b, c) {
                    var d = setTimeout(b, a);
                    c.stop = function () {
                        clearTimeout(d)
                    }
                })
            }, function () {
                var a = l.createElement("input"), b = l.createElement("select"), c = b.appendChild(l.createElement("option"));
                a.type = "checkbox", k.checkOn = "" !== a.value, k.optSelected = c.selected, b.disabled = !0, k.optDisabled = !c.disabled, a = l.createElement("input"), a.value = "t", a.type = "radio", k.radioValue = "t" === a.value
            }();
            var Ya, Za, $a = n.expr.attrHandle;
            n.fn.extend({
                attr: function (a, b) {
                    return J(this, n.attr, a, b, arguments.length > 1)
                }, removeAttr: function (a) {
                    return this.each(function () {
                        n.removeAttr(this, a)
                    })
                }
            }), n.extend({
                attr: function (a, b, c) {
                    var d, e, f = a.nodeType;
                    if (a && 3 !== f && 8 !== f && 2 !== f)return typeof a.getAttribute === U ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? Za : Ya)),
                        void 0 === c ? d && "get"in d && null !== (e = d.get(a, b)) ? e : (e = n.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && "set"in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void n.removeAttr(a, b))
                }, removeAttr: function (a, b) {
                    var c, d, e = 0, f = b && b.match(E);
                    if (f && 1 === a.nodeType)while (c = f[e++])d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c)
                }, attrHooks: {
                    type: {
                        set: function (a, b) {
                            if (!k.radioValue && "radio" === b && n.nodeName(a, "input")) {
                                var c = a.value;
                                return a.setAttribute("type", b), c && (a.value = c), b
                            }
                        }
                    }
                }
            }), Za = {
                set: function (a, b, c) {
                    return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c
                }
            }, n.each(n.expr.match.bool.source.match(/\w+/g), function (a, b) {
                var c = $a[b] || n.find.attr;
                $a[b] = function (a, b, d) {
                    var e, f;
                    return d || (f = $a[b], $a[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, $a[b] = f), e
                }
            });
            var _a = /^(?:input|select|textarea|button)$/i;
            n.fn.extend({
                prop: function (a, b) {
                    return J(this, n.prop, a, b, arguments.length > 1)
                }, removeProp: function (a) {
                    return this.each(function () {
                        delete this[n.propFix[a] || a]
                    })
                }
            }), n.extend({
                propFix: {"for": "htmlFor", "class": "className"}, prop: function (a, b, c) {
                    var d, e, f, g = a.nodeType;
                    if (a && 3 !== g && 8 !== g && 2 !== g)return f = 1 !== g || !n.isXMLDoc(a), f && (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && "set"in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get"in e && null !== (d = e.get(a, b)) ? d : a[b]
                }, propHooks: {
                    tabIndex: {
                        get: function (a) {
                            return a.hasAttribute("tabindex") || _a.test(a.nodeName) || a.href ? a.tabIndex : -1
                        }
                    }
                }
            }), k.optSelected || (n.propHooks.selected = {
                get: function (a) {
                    var b = a.parentNode;
                    return b && b.parentNode && b.parentNode.selectedIndex, null
                }
            }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
                n.propFix[this.toLowerCase()] = this
            });
            var ab = /[\t\r\n\f]/g;
            n.fn.extend({
                addClass: function (a) {
                    var b, c, d, e, f, g, h = "string" == typeof a && a, i = 0, j = this.length;
                    if (n.isFunction(a))return this.each(function (b) {
                        n(this).addClass(a.call(this, b, this.className))
                    });
                    if (h)for (b = (a || "").match(E) || []; j > i; i++)if (c = this[i], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ab, " ") : " ")) {
                        f = 0;
                        while (e = b[f++])d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                        g = n.trim(d), c.className !== g && (c.className = g)
                    }
                    return this
                }, removeClass: function (a) {
                    var b, c, d, e, f, g, h = 0 === arguments.length || "string" == typeof a && a, i = 0, j = this.length;
                    if (n.isFunction(a))return this.each(function (b) {
                        n(this).removeClass(a.call(this, b, this.className))
                    });
                    if (h)for (b = (a || "").match(E) || []; j > i; i++)if (c = this[i], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ab, " ") : "")) {
                        f = 0;
                        while (e = b[f++])while (d.indexOf(" " + e + " ") >= 0)d = d.replace(" " + e + " ", " ");
                        g = a ? n.trim(d) : "", c.className !== g && (c.className = g)
                    }
                    return this
                }, toggleClass: function (a, b) {
                    var c = typeof a;
                    return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(n.isFunction(a) ? function (c) {
                        n(this).toggleClass(a.call(this, c, this.className, b), b)
                    } : function () {
                        if ("string" === c) {
                            var b, d = 0, e = n(this), f = a.match(E) || [];
                            while (b = f[d++])e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
                        } else(c === U || "boolean" === c) && (this.className && L.set(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : L.get(this, "__className__") || "")
                    })
                }, hasClass: function (a) {
                    for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++)if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(ab, " ").indexOf(b) >= 0)return !0;
                    return !1
                }
            });
            var bb = /\r/g;
            n.fn.extend({
                val: function (a) {
                    var b, c, d, e = this[0];
                    {
                        if (arguments.length)return d = n.isFunction(a), this.each(function (c) {
                            var e;
                            1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function (a) {
                                return null == a ? "" : a + ""
                            })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && "set"in b && void 0 !== b.set(this, e, "value") || (this.value = e))
                        });
                        if (e)return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && "get"in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(bb, "") : null == c ? "" : c)
                    }
                }
            }), n.extend({
                valHooks: {
                    option: {
                        get: function (a) {
                            var b = n.find.attr(a, "value");
                            return null != b ? b : n.trim(n.text(a))
                        }
                    }, select: {
                        get: function (a) {
                            for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)if (c = d[i], !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && n.nodeName(c.parentNode, "optgroup"))) {
                                if (b = n(c).val(), f)return b;
                                g.push(b)
                            }
                            return g
                        }, set: function (a, b) {
                            var c, d, e = a.options, f = n.makeArray(b), g = e.length;
                            while (g--)d = e[g], (d.selected = n.inArray(d.value, f) >= 0) && (c = !0);
                            return c || (a.selectedIndex = -1), f
                        }
                    }
                }
            }), n.each(["radio", "checkbox"], function () {
                n.valHooks[this] = {
                    set: function (a, b) {
                        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) >= 0 : void 0
                    }
                }, k.checkOn || (n.valHooks[this].get = function (a) {
                    return null === a.getAttribute("value") ? "on" : a.value
                })
            }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) {
                n.fn[b] = function (a, c) {
                    return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
                }
            }), n.fn.extend({
                hover: function (a, b) {
                    return this.mouseenter(a).mouseleave(b || a)
                }, bind: function (a, b, c) {
                    return this.on(a, null, b, c)
                }, unbind: function (a, b) {
                    return this.off(a, null, b)
                }, delegate: function (a, b, c, d) {
                    return this.on(b, a, c, d)
                }, undelegate: function (a, b, c) {
                    return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
                }
            });
            var cb = n.now(), db = /\?/;
            n.parseJSON = function (a) {
                return JSON.parse(a + "")
            }, n.parseXML = function (a) {
                var b, c;
                if (!a || "string" != typeof a)return null;
                try {
                    c = new DOMParser, b = c.parseFromString(a, "text/xml")
                } catch (d) {
                    b = void 0
                }
                return (!b || b.getElementsByTagName("parsererror").length) && n.error("Invalid XML: " + a), b
            };
            var eb = /#.*$/, fb = /([?&])_=[^&]*/, gb = /^(.*?):[ \t]*([^\r\n]*)$/gm, hb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, ib = /^(?:GET|HEAD)$/, jb = /^\/\//, kb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, lb = {}, mb = {}, nb = "*/".concat("*"), ob = a.location.href, pb = kb.exec(ob.toLowerCase()) || [];

            function qb(a) {
                return function (b, c) {
                    "string" != typeof b && (c = b, b = "*");
                    var d, e = 0, f = b.toLowerCase().match(E) || [];
                    if (n.isFunction(c))while (d = f[e++])"+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
                }
            }

            function rb(a, b, c, d) {
                var e = {}, f = a === mb;

                function g(h) {
                    var i;
                    return e[h] = !0, n.each(a[h] || [], function (a, h) {
                        var j = h(b, c, d);
                        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
                    }), i
                }

                return g(b.dataTypes[0]) || !e["*"] && g("*")
            }

            function sb(a, b) {
                var c, d, e = n.ajaxSettings.flatOptions || {};
                for (c in b)void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
                return d && n.extend(!0, a, d), a
            }

            function tb(a, b, c) {
                var d, e, f, g, h = a.contents, i = a.dataTypes;
                while ("*" === i[0])i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
                if (d)for (e in h)if (h[e] && h[e].test(d)) {
                    i.unshift(e);
                    break
                }
                if (i[0]in c)f = i[0]; else {
                    for (e in c) {
                        if (!i[0] || a.converters[e + " " + i[0]]) {
                            f = e;
                            break
                        }
                        g || (g = e)
                    }
                    f = f || g
                }
                return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0
            }

            function ub(a, b, c, d) {
                var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
                if (k[1])for (g in a.converters)j[g.toLowerCase()] = a.converters[g];
                f = k.shift();
                while (f)if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())if ("*" === f)f = i; else if ("*" !== i && i !== f) {
                    if (g = j[i + " " + f] || j["* " + f], !g)for (e in j)if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                        g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                        break
                    }
                    if (g !== !0)if (g && a["throws"])b = g(b); else try {
                        b = g(b)
                    } catch (l) {
                        return {state: "parsererror", error: g ? l : "No conversion from " + i + " to " + f}
                    }
                }
                return {state: "success", data: b}
            }

            n.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: ob,
                    type: "GET",
                    isLocal: hb.test(pb[1]),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    accepts: {"*": nb, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript"},
                    contents: {xml: /xml/, html: /html/, json: /json/},
                    responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"},
                    converters: {"* text": String, "text html": !0, "text json": n.parseJSON, "text xml": n.parseXML},
                    flatOptions: {url: !0, context: !0}
                },
                ajaxSetup: function (a, b) {
                    return b ? sb(sb(a, n.ajaxSettings), b) : sb(n.ajaxSettings, a)
                },
                ajaxPrefilter: qb(lb),
                ajaxTransport: qb(mb),
                ajax: function (a, b) {
                    "object" == typeof a && (b = a, a = void 0), b = b || {};
                    var c, d, e, f, g, h, i, j, k = n.ajaxSetup({}, b), l = k.context || k, m = k.context && (l.nodeType || l.jquery) ? n(l) : n.event, o = n.Deferred(), p = n.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                        readyState: 0,
                        getResponseHeader: function (a) {
                            var b;
                            if (2 === t) {
                                if (!f) {
                                    f = {};
                                    while (b = gb.exec(e))f[b[1].toLowerCase()] = b[2]
                                }
                                b = f[a.toLowerCase()]
                            }
                            return null == b ? null : b
                        },
                        getAllResponseHeaders: function () {
                            return 2 === t ? e : null
                        },
                        setRequestHeader: function (a, b) {
                            var c = a.toLowerCase();
                            return t || (a = s[c] = s[c] || a, r[a] = b), this
                        },
                        overrideMimeType: function (a) {
                            return t || (k.mimeType = a), this
                        },
                        statusCode: function (a) {
                            var b;
                            if (a)if (2 > t)for (b in a)q[b] = [q[b], a[b]]; else v.always(a[v.status]);
                            return this
                        },
                        abort: function (a) {
                            var b = a || u;
                            return c && c.abort(b), x(0, b), this
                        }
                    };
                    if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || ob) + "").replace(eb, "").replace(jb, pb[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim(k.dataType || "*").toLowerCase().match(E) || [""], null == k.crossDomain && (h = kb.exec(k.url.toLowerCase()), k.crossDomain = !(!h || h[1] === pb[1] && h[2] === pb[2] && (h[3] || ("http:" === h[1] ? "80" : "443")) === (pb[3] || ("http:" === pb[1] ? "80" : "443")))), k.data && k.processData && "string" != typeof k.data && (k.data = n.param(k.data, k.traditional)), rb(lb, k, b, v), 2 === t)return v;
                    i = n.event && k.global, i && 0 === n.active++ && n.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !ib.test(k.type), d = k.url, k.hasContent || (k.data && (d = k.url += (db.test(d) ? "&" : "?") + k.data, delete k.data), k.cache === !1 && (k.url = fb.test(d) ? d.replace(fb, "$1_=" + cb++) : d + (db.test(d) ? "&" : "?") + "_=" + cb++)), k.ifModified && (n.lastModified[d] && v.setRequestHeader("If-Modified-Since", n.lastModified[d]), n.etag[d] && v.setRequestHeader("If-None-Match", n.etag[d])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + nb + "; q=0.01" : "") : k.accepts["*"]);
                    for (j in k.headers)v.setRequestHeader(j, k.headers[j]);
                    if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t))return v.abort();
                    u = "abort";
                    for (j in{success: 1, error: 1, complete: 1})v[j](k[j]);
                    if (c = rb(mb, k, b, v)) {
                        v.readyState = 1, i && m.trigger("ajaxSend", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function () {
                            v.abort("timeout")
                        }, k.timeout));
                        try {
                            t = 1, c.send(r, x)
                        } catch (w) {
                            if (!(2 > t))throw w;
                            x(-1, w)
                        }
                    } else x(-1, "No Transport");
                    function x(a, b, f, h) {
                        var j, r, s, u, w, x = b;
                        2 !== t && (t = 2, g && clearTimeout(g), c = void 0, e = h || "", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, f && (u = tb(k, v, f)), u = ub(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (n.lastModified[d] = w), w = v.getResponseHeader("etag"), w && (n.etag[d] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, i && m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), i && (m.trigger("ajaxComplete", [v, k]), --n.active || n.event.trigger("ajaxStop")))
                    }

                    return v
                },
                getJSON: function (a, b, c) {
                    return n.get(a, b, c, "json")
                },
                getScript: function (a, b) {
                    return n.get(a, void 0, b, "script")
                }
            }), n.each(["get", "post"], function (a, b) {
                n[b] = function (a, c, d, e) {
                    return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax({url: a, type: b, dataType: e, data: c, success: d})
                }
            }), n._evalUrl = function (a) {
                return n.ajax({url: a, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0})
            }, n.fn.extend({
                wrapAll: function (a) {
                    var b;
                    return n.isFunction(a) ? this.each(function (b) {
                        n(this).wrapAll(a.call(this, b))
                    }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {
                        var a = this;
                        while (a.firstElementChild)a = a.firstElementChild;
                        return a
                    }).append(this)), this)
                }, wrapInner: function (a) {
                    return this.each(n.isFunction(a) ? function (b) {
                        n(this).wrapInner(a.call(this, b))
                    } : function () {
                        var b = n(this), c = b.contents();
                        c.length ? c.wrapAll(a) : b.append(a)
                    })
                }, wrap: function (a) {
                    var b = n.isFunction(a);
                    return this.each(function (c) {
                        n(this).wrapAll(b ? a.call(this, c) : a)
                    })
                }, unwrap: function () {
                    return this.parent().each(function () {
                        n.nodeName(this, "body") || n(this).replaceWith(this.childNodes)
                    }).end()
                }
            }), n.expr.filters.hidden = function (a) {
                return a.offsetWidth <= 0 && a.offsetHeight <= 0
            }, n.expr.filters.visible = function (a) {
                return !n.expr.filters.hidden(a)
            };
            var vb = /%20/g, wb = /\[\]$/, xb = /\r?\n/g, yb = /^(?:submit|button|image|reset|file)$/i, zb = /^(?:input|select|textarea|keygen)/i;

            function Ab(a, b, c, d) {
                var e;
                if (n.isArray(b))n.each(b, function (b, e) {
                    c || wb.test(a) ? d(a, e) : Ab(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d)
                }); else if (c || "object" !== n.type(b))d(a, b); else for (e in b)Ab(a + "[" + e + "]", b[e], c, d)
            }

            n.param = function (a, b) {
                var c, d = [], e = function (a, b) {
                    b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
                };
                if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a))n.each(a, function () {
                    e(this.name, this.value)
                }); else for (c in a)Ab(c, a[c], b, e);
                return d.join("&").replace(vb, "+")
            }, n.fn.extend({
                serialize: function () {
                    return n.param(this.serializeArray())
                }, serializeArray: function () {
                    return this.map(function () {
                        var a = n.prop(this, "elements");
                        return a ? n.makeArray(a) : this
                    }).filter(function () {
                        var a = this.type;
                        return this.name && !n(this).is(":disabled") && zb.test(this.nodeName) && !yb.test(a) && (this.checked || !T.test(a))
                    }).map(function (a, b) {
                        var c = n(this).val();
                        return null == c ? null : n.isArray(c) ? n.map(c, function (a) {
                            return {name: b.name, value: a.replace(xb, "\r\n")}
                        }) : {name: b.name, value: c.replace(xb, "\r\n")}
                    }).get()
                }
            }), n.ajaxSettings.xhr = function () {
                try {
                    return new XMLHttpRequest
                } catch (a) {
                }
            };
            var Bb = 0, Cb = {}, Db = {0: 200, 1223: 204}, Eb = n.ajaxSettings.xhr();
            a.attachEvent && a.attachEvent("onunload", function () {
                for (var a in Cb)Cb[a]()
            }), k.cors = !!Eb && "withCredentials"in Eb, k.ajax = Eb = !!Eb, n.ajaxTransport(function (a) {
                var b;
                return k.cors || Eb && !a.crossDomain ? {
                    send: function (c, d) {
                        var e, f = a.xhr(), g = ++Bb;
                        if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)for (e in a.xhrFields)f[e] = a.xhrFields[e];
                        a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
                        for (e in c)f.setRequestHeader(e, c[e]);
                        b = function (a) {
                            return function () {
                                b && (delete Cb[g], b = f.onload = f.onerror = null, "abort" === a ? f.abort() : "error" === a ? d(f.status, f.statusText) : d(Db[f.status] || f.status, f.statusText, "string" == typeof f.responseText ? {text: f.responseText} : void 0, f.getAllResponseHeaders()))
                            }
                        }, f.onload = b(), f.onerror = b("error"), b = Cb[g] = b("abort");
                        try {
                            f.send(a.hasContent && a.data || null)
                        } catch (h) {
                            if (b)throw h
                        }
                    }, abort: function () {
                        b && b()
                    }
                } : void 0
            }), n.ajaxSetup({
                accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
                contents: {script: /(?:java|ecma)script/},
                converters: {
                    "text script": function (a) {
                        return n.globalEval(a), a
                    }
                }
            }), n.ajaxPrefilter("script", function (a) {
                void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET")
            }), n.ajaxTransport("script", function (a) {
                if (a.crossDomain) {
                    var b, c;
                    return {
                        send: function (d, e) {
                            b = n("<script>").prop({async: !0, charset: a.scriptCharset, src: a.url}).on("load error", c = function (a) {
                                b.remove(), c = null, a && e("error" === a.type ? 404 : 200, a.type)
                            }), l.head.appendChild(b[0])
                        }, abort: function () {
                            c && c()
                        }
                    }
                }
            });
            var Fb = [], Gb = /(=)\?(?=&|$)|\?\?/;
            n.ajaxSetup({
                jsonp: "callback", jsonpCallback: function () {
                    var a = Fb.pop() || n.expando + "_" + cb++;
                    return this[a] = !0, a
                }
            }), n.ajaxPrefilter("json jsonp", function (b, c, d) {
                var e, f, g, h = b.jsonp !== !1 && (Gb.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && Gb.test(b.data) && "data");
                return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Gb, "$1" + e) : b.jsonp !== !1 && (b.url += (db.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function () {
                    return g || n.error(e + " was not called"), g[0]
                }, b.dataTypes[0] = "json", f = a[e], a[e] = function () {
                    g = arguments
                }, d.always(function () {
                    a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Fb.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0
                }), "script") : void 0
            }), n.parseHTML = function (a, b, c) {
                if (!a || "string" != typeof a)return null;
                "boolean" == typeof b && (c = b, b = !1), b = b || l;
                var d = v.exec(a), e = !c && [];
                return d ? [b.createElement(d[1])] : (d = n.buildFragment([a], b, e), e && e.length && n(e).remove(), n.merge([], d.childNodes))
            };
            var Hb = n.fn.load;
            n.fn.load = function (a, b, c) {
                if ("string" != typeof a && Hb)return Hb.apply(this, arguments);
                var d, e, f, g = this, h = a.indexOf(" ");
                return h >= 0 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && n.ajax({
                    url: a,
                    type: e,
                    dataType: "html",
                    data: b
                }).done(function (a) {
                    f = arguments, g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a)
                }).complete(c && function (a, b) {
                        g.each(c, f || [a.responseText, b, a])
                    }), this
            }, n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) {
                n.fn[b] = function (a) {
                    return this.on(b, a)
                }
            }), n.expr.filters.animated = function (a) {
                return n.grep(n.timers, function (b) {
                    return a === b.elem
                }).length
            };
            var Ib = a.document.documentElement;

            function Jb(a) {
                return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView
            }

            n.offset = {
                setOffset: function (a, b, c) {
                    var d, e, f, g, h, i, j, k = n.css(a, "position"), l = n(a), m = {};
                    "static" === k && (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using"in b ? b.using.call(a, m) : l.css(m)
                }
            }, n.fn.extend({
                offset: function (a) {
                    if (arguments.length)return void 0 === a ? this : this.each(function (b) {
                        n.offset.setOffset(this, a, b)
                    });
                    var b, c, d = this[0], e = {top: 0, left: 0}, f = d && d.ownerDocument;
                    if (f)return b = f.documentElement, n.contains(b, d) ? (typeof d.getBoundingClientRect !== U && (e = d.getBoundingClientRect()), c = Jb(f), {
                        top: e.top + c.pageYOffset - b.clientTop,
                        left: e.left + c.pageXOffset - b.clientLeft
                    }) : e
                }, position: function () {
                    if (this[0]) {
                        var a, b, c = this[0], d = {top: 0, left: 0};
                        return "fixed" === n.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (d = a.offset()), d.top += n.css(a[0], "borderTopWidth", !0), d.left += n.css(a[0], "borderLeftWidth", !0)), {
                            top: b.top - d.top - n.css(c, "marginTop", !0),
                            left: b.left - d.left - n.css(c, "marginLeft", !0)
                        }
                    }
                }, offsetParent: function () {
                    return this.map(function () {
                        var a = this.offsetParent || Ib;
                        while (a && !n.nodeName(a, "html") && "static" === n.css(a, "position"))a = a.offsetParent;
                        return a || Ib
                    })
                }
            }), n.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (b, c) {
                var d = "pageYOffset" === c;
                n.fn[b] = function (e) {
                    return J(this, function (b, e, f) {
                        var g = Jb(b);
                        return void 0 === f ? g ? g[c] : b[e] : void(g ? g.scrollTo(d ? a.pageXOffset : f, d ? f : a.pageYOffset) : b[e] = f)
                    }, b, e, arguments.length, null)
                }
            }), n.each(["top", "left"], function (a, b) {
                n.cssHooks[b] = ya(k.pixelPosition, function (a, c) {
                    return c ? (c = xa(a, b), va.test(c) ? n(a).position()[b] + "px" : c) : void 0
                })
            }), n.each({Height: "height", Width: "width"}, function (a, b) {
                n.each({padding: "inner" + a, content: b, "": "outer" + a}, function (c, d) {
                    n.fn[d] = function (d, e) {
                        var f = arguments.length && (c || "boolean" != typeof d), g = c || (d === !0 || e === !0 ? "margin" : "border");
                        return J(this, function (b, c, d) {
                            var e;
                            return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g)
                        }, b, f ? d : void 0, f, null)
                    }
                })
            }), n.fn.size = function () {
                return this.length
            }, n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () {
                return n
            });
            var Kb = a.jQuery, Lb = a.$;
            return n.noConflict = function (b) {
                return a.$ === n && (a.$ = Lb), b && a.jQuery === n && (a.jQuery = Kb), n
            }, typeof b === U && (a.jQuery = a.$ = n), n
        });

    }, {}],
    5: [function (require, module, exports) {
        /**
         * @author qiao / https://github.com/qiao
         * @author mrdoob / http://mrdoob.com
         * @author alteredq / http://alteredqualia.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author erich666 / http://erichaines.com
         */
        /*global THREE, console */

// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
// supported.
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe
        var THREE = require("./three.js");

        var OrbitControls = function (object, domElement) {

            this.object = object;
            this.domElement = ( domElement !== undefined ) ? domElement : document;

            // API

            // Set to false to disable this control
            this.enabled = true;

            // "target" sets the location of focus, where the control orbits around
            // and where it pans with respect to.
            this.target = new THREE.Vector3();

            // center is old, deprecated; use "target" instead
            this.center = this.target;

            // This option actually enables dollying in and out; left as "zoom" for
            // backwards compatibility
            this.noZoom = false;
            this.zoomSpeed = 1.0;

            // Limits to how far you can dolly in and out ( PerspectiveCamera only )
            this.minDistance = 0;
            this.maxDistance = Infinity;

            // Limits to how far you can zoom in and out ( OrthographicCamera only )
            this.minZoom = 0;
            this.maxZoom = Infinity;

            // Set to true to disable this control
            this.noRotate = false;
            this.rotateSpeed = 1.0;

            // Set to true to disable this control
            this.noPan = false;
            this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

            // Set to true to automatically rotate around the target
            this.autoRotate = false;
            this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

            // How far you can orbit vertically, upper and lower limits.
            // Range is 0 to Math.PI radians.
            this.minPolarAngle = 0; // radians
            this.maxPolarAngle = Math.PI; // radians

            // How far you can orbit horizontally, upper and lower limits.
            // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
            this.minAzimuthAngle = -Infinity; // radians
            this.maxAzimuthAngle = Infinity; // radians

            // Set to true to disable use of the keys
            this.noKeys = false;

            // The four arrow keys
            this.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40};

            // Mouse buttons
            this.mouseButtons = {ORBIT: THREE.MOUSE.MIDDLE, ZOOM: 3, PAN: 3};

            ////////////
            // internals

            var scope = this;

            var EPS = 0.000001;

            var rotateStart = new THREE.Vector2();
            var rotateEnd = new THREE.Vector2();
            var rotateDelta = new THREE.Vector2();

            var panStart = new THREE.Vector2();
            var panEnd = new THREE.Vector2();
            var panDelta = new THREE.Vector2();
            var panOffset = new THREE.Vector3();

            var offset = new THREE.Vector3();

            var dollyStart = new THREE.Vector2();
            var dollyEnd = new THREE.Vector2();
            var dollyDelta = new THREE.Vector2();

            var theta;
            var phi;
            var phiDelta = 0;
            var thetaDelta = 0;
            var scale = 1;
            var pan = new THREE.Vector3();

            var lastPosition = new THREE.Vector3();
            var lastQuaternion = new THREE.Quaternion();

            var STATE = {NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5};

            var state = STATE.NONE;

            // for reset

            this.target0 = this.target.clone();
            this.position0 = this.object.position.clone();
            this.zoom0 = this.object.zoom;

            // so camera.up is the orbit axis

            var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
            var quatInverse = quat.clone().inverse();

            // events

            var changeEvent = {type: 'change'};
            var startEvent = {type: 'start'};
            var endEvent = {type: 'end'};

            this.rotateLeft = function (angle) {

                if (angle === undefined) {

                    angle = getAutoRotationAngle();

                }

                thetaDelta -= angle;

            };

            this.rotateUp = function (angle) {

                if (angle === undefined) {

                    angle = getAutoRotationAngle();

                }

                phiDelta -= angle;

            };

            // pass in distance in world space to move left
            this.panLeft = function (distance) {

                var te = this.object.matrix.elements;

                // get X column of matrix
                panOffset.set(te[0], te[1], te[2]);
                panOffset.multiplyScalar(-distance);

                pan.add(panOffset);

            };

            // pass in distance in world space to move up
            this.panUp = function (distance) {

                var te = this.object.matrix.elements;

                // get Y column of matrix
                panOffset.set(te[4], te[5], te[6]);
                panOffset.multiplyScalar(distance);

                pan.add(panOffset);

            };

            // pass in x,y of change desired in pixel space,
            // right and down are positive
            this.pan = function (deltaX, deltaY) {

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                if (scope.object instanceof THREE.PerspectiveCamera) {

                    // perspective
                    var position = scope.object.position;
                    var offset = position.clone().sub(scope.target);
                    var targetDistance = offset.length();

                    // half of the fov is center to top of screen
                    targetDistance *= Math.tan(( scope.object.fov / 2 ) * Math.PI / 180.0);

                    // we actually don't use screenWidth, since perspective camera is fixed to screen height
                    scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);
                    scope.panUp(2 * deltaY * targetDistance / element.clientHeight);

                } else if (scope.object instanceof THREE.OrthographicCamera) {

                    // orthographic
                    scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);
                    scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);

                } else {

                    // camera neither orthographic or perspective
                    console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');

                }

            };

            this.dollyIn = function (dollyScale) {

                if (dollyScale === undefined) {

                    dollyScale = getZoomScale();

                }

                if (scope.object instanceof THREE.PerspectiveCamera) {

                    scale /= dollyScale;

                } else if (scope.object instanceof THREE.OrthographicCamera) {

                    scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));
                    scope.object.updateProjectionMatrix();
                    scope.dispatchEvent(changeEvent);

                } else {

                    console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');

                }

            };

            this.dollyOut = function (dollyScale) {

                if (dollyScale === undefined) {

                    dollyScale = getZoomScale();

                }

                if (scope.object instanceof THREE.PerspectiveCamera) {

                    scale *= dollyScale;

                } else if (scope.object instanceof THREE.OrthographicCamera) {

                    scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));
                    scope.object.updateProjectionMatrix();
                    scope.dispatchEvent(changeEvent);

                } else {

                    console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');

                }

            };

            this.update = function () {

                var position = this.object.position;

                offset.copy(position).sub(this.target);

                // rotate offset to "y-axis-is-up" space
                offset.applyQuaternion(quat);

                // angle from z-axis around y-axis

                theta = Math.atan2(offset.x, offset.z);

                // angle from y-axis

                phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

                if (this.autoRotate && state === STATE.NONE) {

                    this.rotateLeft(getAutoRotationAngle());

                }

                theta += thetaDelta;
                phi += phiDelta;

                // restrict theta to be between desired limits
                theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));

                // restrict phi to be between desired limits
                phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

                // restrict phi to be betwee EPS and PI-EPS
                phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

                var radius = offset.length() * scale;

                // restrict radius to be between desired limits
                radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));

                // move target to panned location
                this.target.add(pan);

                offset.x = radius * Math.sin(phi) * Math.sin(theta);
                offset.y = radius * Math.cos(phi);
                offset.z = radius * Math.sin(phi) * Math.cos(theta);

                // rotate offset back to "camera-up-vector-is-up" space
                offset.applyQuaternion(quatInverse);

                position.copy(this.target).add(offset);

                this.object.lookAt(this.target);

                thetaDelta = 0;
                phiDelta = 0;
                scale = 1;
                pan.set(0, 0, 0);

                // update condition is:
                // min(camera displacement, camera rotation in radians)^2 > EPS
                // using small-angle approximation cos(x/2) = 1 - x^2 / 8

                if (lastPosition.distanceToSquared(this.object.position) > EPS
                    || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {

                    this.dispatchEvent(changeEvent);

                    lastPosition.copy(this.object.position);
                    lastQuaternion.copy(this.object.quaternion);

                }

            };


            this.reset = function () {

                state = STATE.NONE;

                this.target.copy(this.target0);
                this.object.position.copy(this.position0);
                this.object.zoom = this.zoom0;

                this.object.updateProjectionMatrix();
                this.dispatchEvent(changeEvent);

                this.update();

            };

            this.getPolarAngle = function () {

                return phi;

            };

            this.getAzimuthalAngle = function () {

                return theta

            };

            function getAutoRotationAngle() {

                return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

            }

            function getZoomScale() {

                return Math.pow(0.95, scope.zoomSpeed);

            }

            function onMouseDown(event) {

                if (scope.enabled === false) return;
                event.preventDefault();

                if (event.button === scope.mouseButtons.ORBIT) {
                    if (scope.noRotate === true) return;

                    state = STATE.ROTATE;

                    rotateStart.set(event.clientX, event.clientY);

                } else if (event.button === scope.mouseButtons.ZOOM) {
                    if (scope.noZoom === true) return;

                    state = STATE.DOLLY;

                    dollyStart.set(event.clientX, event.clientY);

                } else if (event.button === scope.mouseButtons.PAN) {
                    if (scope.noPan === true) return;

                    state = STATE.PAN;

                    panStart.set(event.clientX, event.clientY);

                }

                if (state !== STATE.NONE) {
                    document.addEventListener('mousemove', onMouseMove, false);
                    document.addEventListener('mouseup', onMouseUp, false);
                    scope.dispatchEvent(startEvent);
                }

            }

            function onMouseMove(event) {

                if (scope.enabled === false) return;

                event.preventDefault();

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                if (state === STATE.ROTATE) {

                    if (scope.noRotate === true) return;

                    rotateEnd.set(event.clientX, event.clientY);
                    rotateDelta.subVectors(rotateEnd, rotateStart);

                    // rotating across whole screen goes 360 degrees around
                    scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

                    // rotating up and down along whole screen attempts to go 360, but limited to 180
                    scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

                    rotateStart.copy(rotateEnd);

                } else if (state === STATE.DOLLY) {

                    if (scope.noZoom === true) return;

                    dollyEnd.set(event.clientX, event.clientY);
                    dollyDelta.subVectors(dollyEnd, dollyStart);

                    if (dollyDelta.y > 0) {

                        scope.dollyIn();

                    } else if (dollyDelta.y < 0) {

                        scope.dollyOut();

                    }

                    dollyStart.copy(dollyEnd);

                } else if (state === STATE.PAN) {

                    if (scope.noPan === true) return;

                    panEnd.set(event.clientX, event.clientY);
                    panDelta.subVectors(panEnd, panStart);

                    scope.pan(panDelta.x, panDelta.y);

                    panStart.copy(panEnd);

                }

                if (state !== STATE.NONE) scope.update();

            }

            function onMouseUp(/* event */) {

                if (scope.enabled === false) return;

                document.removeEventListener('mousemove', onMouseMove, false);
                document.removeEventListener('mouseup', onMouseUp, false);
                scope.dispatchEvent(endEvent);
                state = STATE.NONE;

            }

            function onMouseWheel(event) {

                if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) return;

                event.preventDefault();
                event.stopPropagation();

                var delta = 0;

                if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                    delta = event.wheelDelta;

                } else if (event.detail !== undefined) { // Firefox

                    delta = -event.detail;

                }

                if (delta > 0) {

                    scope.dollyOut();

                } else if (delta < 0) {

                    scope.dollyIn();

                }

                scope.update();
                scope.dispatchEvent(startEvent);
                scope.dispatchEvent(endEvent);

            }

            function onKeyDown(event) {

                if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) return;

                switch (event.keyCode) {

                    case scope.keys.UP:
                        scope.pan(0, scope.keyPanSpeed);
                        scope.update();
                        break;

                    case scope.keys.BOTTOM:
                        scope.pan(0, -scope.keyPanSpeed);
                        scope.update();
                        break;

                    case scope.keys.LEFT:
                        scope.pan(scope.keyPanSpeed, 0);
                        scope.update();
                        break;

                    case scope.keys.RIGHT:
                        scope.pan(-scope.keyPanSpeed, 0);
                        scope.update();
                        break;

                }

            }

            function touchstart(event) {

                if (scope.enabled === false) return;

                switch (event.touches.length) {

                    case 1:	// one-fingered touch: rotate

                        if (scope.noRotate === true) return;

                        state = STATE.TOUCH_ROTATE;

                        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
                        break;

                    case 2:	// two-fingered touch: dolly

                        if (scope.noZoom === true) return;

                        state = STATE.TOUCH_DOLLY;

                        var dx = event.touches[0].pageX - event.touches[1].pageX;
                        var dy = event.touches[0].pageY - event.touches[1].pageY;
                        var distance = Math.sqrt(dx * dx + dy * dy);
                        dollyStart.set(0, distance);
                        break;

                    case 3: // three-fingered touch: pan

                        if (scope.noPan === true) return;

                        state = STATE.TOUCH_PAN;

                        panStart.set(event.touches[0].pageX, event.touches[0].pageY);
                        break;

                    default:

                        state = STATE.NONE;

                }

                if (state !== STATE.NONE) scope.dispatchEvent(startEvent);

            }

            function touchmove(event) {

                if (scope.enabled === false) return;

                event.preventDefault();
                event.stopPropagation();

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                switch (event.touches.length) {

                    case 1: // one-fingered touch: rotate

                        if (scope.noRotate === true) return;
                        if (state !== STATE.TOUCH_ROTATE) return;

                        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
                        rotateDelta.subVectors(rotateEnd, rotateStart);

                        // rotating across whole screen goes 360 degrees around
                        scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
                        // rotating up and down along whole screen attempts to go 360, but limited to 180
                        scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

                        rotateStart.copy(rotateEnd);

                        scope.update();
                        break;

                    case 2: // two-fingered touch: dolly

                        if (scope.noZoom === true) return;
                        if (state !== STATE.TOUCH_DOLLY) return;

                        var dx = event.touches[0].pageX - event.touches[1].pageX;
                        var dy = event.touches[0].pageY - event.touches[1].pageY;
                        var distance = Math.sqrt(dx * dx + dy * dy);

                        dollyEnd.set(0, distance);
                        dollyDelta.subVectors(dollyEnd, dollyStart);

                        if (dollyDelta.y > 0) {

                            scope.dollyOut();

                        } else if (dollyDelta.y < 0) {

                            scope.dollyIn();

                        }

                        dollyStart.copy(dollyEnd);

                        scope.update();
                        break;

                    case 3: // three-fingered touch: pan

                        if (scope.noPan === true) return;
                        if (state !== STATE.TOUCH_PAN) return;

                        panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
                        panDelta.subVectors(panEnd, panStart);

                        scope.pan(panDelta.x, panDelta.y);

                        panStart.copy(panEnd);

                        scope.update();
                        break;

                    default:

                        state = STATE.NONE;

                }

            }

            function touchend(/* event */) {

                if (scope.enabled === false) return;

                scope.dispatchEvent(endEvent);
                state = STATE.NONE;

            }

            this.domElement.addEventListener('contextmenu', function (event) {
                event.preventDefault();
            }, false);
            this.domElement.addEventListener('mousedown', onMouseDown, false);
            this.domElement.addEventListener('mousewheel', onMouseWheel, false);
            this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox

            this.domElement.addEventListener('touchstart', touchstart, false);
            this.domElement.addEventListener('touchend', touchend, false);
            this.domElement.addEventListener('touchmove', touchmove, false);

            window.addEventListener('keydown', onKeyDown, false);

            // force an update at start
            this.update();

        };

        OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
        OrbitControls.prototype.constructor = OrbitControls;

        module.exports = OrbitControls;
    }, {"./three.js": 6}],
    6: [function (require, module, exports) {
// threejs.org/license
        'use strict';
        var THREE = {REVISION: "71"};
        "object" === typeof module && (module.exports = THREE);
        void 0 === Math.sign && (Math.sign = function (a) {
            return 0 > a ? -1 : 0 < a ? 1 : +a
        });
        THREE.log = function () {
            console.log.apply(console, arguments)
        };
        THREE.warn = function () {
            console.warn.apply(console, arguments)
        };
        THREE.error = function () {
            console.error.apply(console, arguments)
        };
        THREE.MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2};
        THREE.CullFaceNone = 0;
        THREE.CullFaceBack = 1;
        THREE.CullFaceFront = 2;
        THREE.CullFaceFrontBack = 3;
        THREE.FrontFaceDirectionCW = 0;
        THREE.FrontFaceDirectionCCW = 1;
        THREE.BasicShadowMap = 0;
        THREE.PCFShadowMap = 1;
        THREE.PCFSoftShadowMap = 2;
        THREE.FrontSide = 0;
        THREE.BackSide = 1;
        THREE.DoubleSide = 2;
        THREE.NoShading = 0;
        THREE.FlatShading = 1;
        THREE.SmoothShading = 2;
        THREE.NoColors = 0;
        THREE.FaceColors = 1;
        THREE.VertexColors = 2;
        THREE.NoBlending = 0;
        THREE.NormalBlending = 1;
        THREE.AdditiveBlending = 2;
        THREE.SubtractiveBlending = 3;
        THREE.MultiplyBlending = 4;
        THREE.CustomBlending = 5;
        THREE.AddEquation = 100;
        THREE.SubtractEquation = 101;
        THREE.ReverseSubtractEquation = 102;
        THREE.MinEquation = 103;
        THREE.MaxEquation = 104;
        THREE.ZeroFactor = 200;
        THREE.OneFactor = 201;
        THREE.SrcColorFactor = 202;
        THREE.OneMinusSrcColorFactor = 203;
        THREE.SrcAlphaFactor = 204;
        THREE.OneMinusSrcAlphaFactor = 205;
        THREE.DstAlphaFactor = 206;
        THREE.OneMinusDstAlphaFactor = 207;
        THREE.DstColorFactor = 208;
        THREE.OneMinusDstColorFactor = 209;
        THREE.SrcAlphaSaturateFactor = 210;
        THREE.MultiplyOperation = 0;
        THREE.MixOperation = 1;
        THREE.AddOperation = 2;
        THREE.UVMapping = 300;
        THREE.CubeReflectionMapping = 301;
        THREE.CubeRefractionMapping = 302;
        THREE.EquirectangularReflectionMapping = 303;
        THREE.EquirectangularRefractionMapping = 304;
        THREE.SphericalReflectionMapping = 305;
        THREE.RepeatWrapping = 1E3;
        THREE.ClampToEdgeWrapping = 1001;
        THREE.MirroredRepeatWrapping = 1002;
        THREE.NearestFilter = 1003;
        THREE.NearestMipMapNearestFilter = 1004;
        THREE.NearestMipMapLinearFilter = 1005;
        THREE.LinearFilter = 1006;
        THREE.LinearMipMapNearestFilter = 1007;
        THREE.LinearMipMapLinearFilter = 1008;
        THREE.UnsignedByteType = 1009;
        THREE.ByteType = 1010;
        THREE.ShortType = 1011;
        THREE.UnsignedShortType = 1012;
        THREE.IntType = 1013;
        THREE.UnsignedIntType = 1014;
        THREE.FloatType = 1015;
        THREE.HalfFloatType = 1025;
        THREE.UnsignedShort4444Type = 1016;
        THREE.UnsignedShort5551Type = 1017;
        THREE.UnsignedShort565Type = 1018;
        THREE.AlphaFormat = 1019;
        THREE.RGBFormat = 1020;
        THREE.RGBAFormat = 1021;
        THREE.LuminanceFormat = 1022;
        THREE.LuminanceAlphaFormat = 1023;
        THREE.RGBEFormat = THREE.RGBAFormat;
        THREE.RGB_S3TC_DXT1_Format = 2001;
        THREE.RGBA_S3TC_DXT1_Format = 2002;
        THREE.RGBA_S3TC_DXT3_Format = 2003;
        THREE.RGBA_S3TC_DXT5_Format = 2004;
        THREE.RGB_PVRTC_4BPPV1_Format = 2100;
        THREE.RGB_PVRTC_2BPPV1_Format = 2101;
        THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
        THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
        THREE.Projector = function () {
            THREE.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
            this.projectVector = function (a, b) {
                THREE.warn("THREE.Projector: .projectVector() is now vector.project().");
                a.project(b)
            };
            this.unprojectVector = function (a, b) {
                THREE.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
                a.unproject(b)
            };
            this.pickingRay = function (a, b) {
                THREE.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
            }
        };
        THREE.CanvasRenderer = function () {
            THREE.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
            this.domElement = document.createElement("canvas");
            this.clear = function () {
            };
            this.render = function () {
            };
            this.setClearColor = function () {
            };
            this.setSize = function () {
            }
        };
        THREE.Color = function (a) {
            return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a)
        };
        THREE.Color.prototype = {
            constructor: THREE.Color, r: 1, g: 1, b: 1, set: function (a) {
                a instanceof THREE.Color ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
                return this
            }, setHex: function (a) {
                a = Math.floor(a);
                this.r = (a >> 16 & 255) / 255;
                this.g = (a >> 8 & 255) / 255;
                this.b = (a & 255) / 255;
                return this
            }, setRGB: function (a, b, c) {
                this.r = a;
                this.g = b;
                this.b = c;
                return this
            }, setHSL: function (a, b, c) {
                if (0 === b)this.r = this.g = this.b = c; else {
                    var d = function (a, b, c) {
                        0 > c && (c += 1);
                        1 < c && (c -= 1);
                        return c < 1 / 6 ? a + 6 * (b - a) *
                        c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
                    };
                    b = .5 >= c ? c * (1 + b) : c + b - c * b;
                    c = 2 * c - b;
                    this.r = d(c, b, a + 1 / 3);
                    this.g = d(c, b, a);
                    this.b = d(c, b, a - 1 / 3)
                }
                return this
            }, setStyle: function (a) {
                if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a))return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;
                if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a))return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), this.r =
                    Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;
                if (/^\#([0-9a-f]{6})$/i.test(a))return a = /^\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;
                if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;
                if (/^(\w+)$/i.test(a))return this.setHex(THREE.ColorKeywords[a]), this
            }, copy: function (a) {
                this.r = a.r;
                this.g =
                    a.g;
                this.b = a.b;
                return this
            }, copyGammaToLinear: function (a, b) {
                void 0 === b && (b = 2);
                this.r = Math.pow(a.r, b);
                this.g = Math.pow(a.g, b);
                this.b = Math.pow(a.b, b);
                return this
            }, copyLinearToGamma: function (a, b) {
                void 0 === b && (b = 2);
                var c = 0 < b ? 1 / b : 1;
                this.r = Math.pow(a.r, c);
                this.g = Math.pow(a.g, c);
                this.b = Math.pow(a.b, c);
                return this
            }, convertGammaToLinear: function () {
                var a = this.r, b = this.g, c = this.b;
                this.r = a * a;
                this.g = b * b;
                this.b = c * c;
                return this
            }, convertLinearToGamma: function () {
                this.r = Math.sqrt(this.r);
                this.g = Math.sqrt(this.g);
                this.b =
                    Math.sqrt(this.b);
                return this
            }, getHex: function () {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }, getHexString: function () {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }, getHSL: function (a) {
                a = a || {h: 0, s: 0, l: 0};
                var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2;
                if (f === e)f = g = 0; else {
                    var k = e - f, f = .5 >= h ? k / (e + f) : k / (2 - e - f);
                    switch (e) {
                        case b:
                            g = (c - d) / k + (c < d ? 6 : 0);
                            break;
                        case c:
                            g = (d - b) / k + 2;
                            break;
                        case d:
                            g = (b - c) / k + 4
                    }
                    g /= 6
                }
                a.h = g;
                a.s = f;
                a.l = h;
                return a
            }, getStyle: function () {
                return "rgb(" +
                    (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }, offsetHSL: function (a, b, c) {
                var d = this.getHSL();
                d.h += a;
                d.s += b;
                d.l += c;
                this.setHSL(d.h, d.s, d.l);
                return this
            }, add: function (a) {
                this.r += a.r;
                this.g += a.g;
                this.b += a.b;
                return this
            }, addColors: function (a, b) {
                this.r = a.r + b.r;
                this.g = a.g + b.g;
                this.b = a.b + b.b;
                return this
            }, addScalar: function (a) {
                this.r += a;
                this.g += a;
                this.b += a;
                return this
            }, multiply: function (a) {
                this.r *= a.r;
                this.g *= a.g;
                this.b *= a.b;
                return this
            }, multiplyScalar: function (a) {
                this.r *= a;
                this.g *= a;
                this.b *= a;
                return this
            }, lerp: function (a, b) {
                this.r += (a.r - this.r) * b;
                this.g += (a.g - this.g) * b;
                this.b += (a.b - this.b) * b;
                return this
            }, equals: function (a) {
                return a.r === this.r && a.g === this.g && a.b === this.b
            }, fromArray: function (a) {
                this.r = a[0];
                this.g = a[1];
                this.b = a[2];
                return this
            }, toArray: function (a, b) {
                void 0 === a && (a = []);
                void 0 === b && (b = 0);
                a[b] = this.r;
                a[b + 1] = this.g;
                a[b + 2] = this.b;
                return a
            }, clone: function () {
                return (new THREE.Color).setRGB(this.r, this.g, this.b)
            }
        };
        THREE.ColorKeywords = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
        THREE.Quaternion = function (a, b, c, d) {
            this._x = a || 0;
            this._y = b || 0;
            this._z = c || 0;
            this._w = void 0 !== d ? d : 1
        };
        THREE.Quaternion.prototype = {
            constructor: THREE.Quaternion, _x: 0, _y: 0, _z: 0, _w: 0, get x() {
                return this._x
            }, set x(a) {
                this._x = a;
                this.onChangeCallback()
            }, get y() {
                return this._y
            }, set y(a) {
                this._y = a;
                this.onChangeCallback()
            }, get z() {
                return this._z
            }, set z(a) {
                this._z = a;
                this.onChangeCallback()
            }, get w() {
                return this._w
            }, set w(a) {
                this._w = a;
                this.onChangeCallback()
            }, set: function (a, b, c, d) {
                this._x = a;
                this._y = b;
                this._z = c;
                this._w = d;
                this.onChangeCallback();
                return this
            }, copy: function (a) {
                this._x = a.x;
                this._y = a.y;
                this._z = a.z;
                this._w = a.w;
                this.onChangeCallback();
                return this
            }, setFromEuler: function (a, b) {
                if (!1 === a instanceof THREE.Euler)throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var c = Math.cos(a._x / 2), d = Math.cos(a._y / 2), e = Math.cos(a._z / 2), f = Math.sin(a._x / 2), g = Math.sin(a._y / 2), h = Math.sin(a._z / 2);
                "XYZ" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z =
                    c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === a.order && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h);
                if (!1 !== b)this.onChangeCallback();
                return this
            }, setFromAxisAngle: function (a,
                                           b) {
                var c = b / 2, d = Math.sin(c);
                this._x = a.x * d;
                this._y = a.y * d;
                this._z = a.z * d;
                this._w = Math.cos(c);
                this.onChangeCallback();
                return this
            }, setFromRotationMatrix: function (a) {
                var b = a.elements, c = b[0];
                a = b[4];
                var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], k = b[6], b = b[10], l = c + f + b;
                0 < l ? (c = .5 / Math.sqrt(l + 1), this._w = .25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y =
                    .25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = .25 * c);
                this.onChangeCallback();
                return this
            }, setFromUnitVectors: function () {
                var a, b;
                return function (c, d) {
                    void 0 === a && (a = new THREE.Vector3);
                    b = c.dot(d) + 1;
                    1E-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);
                    this._x = a.x;
                    this._y = a.y;
                    this._z = a.z;
                    this._w = b;
                    this.normalize();
                    return this
                }
            }(), inverse: function () {
                this.conjugate().normalize();
                return this
            }, conjugate: function () {
                this._x *= -1;
                this._y *= -1;
                this._z *= -1;
                this.onChangeCallback();
                return this
            }, dot: function (a) {
                return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
            }, lengthSq: function () {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }, length: function () {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }, normalize: function () {
                var a = this.length();
                0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
                this.onChangeCallback();
                return this
            },
            multiply: function (a, b) {
                return void 0 !== b ? (THREE.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
            }, multiplyQuaternions: function (a, b) {
                var c = a._x, d = a._y, e = a._z, f = a._w, g = b._x, h = b._y, k = b._z, l = b._w;
                this._x = c * l + f * g + d * k - e * h;
                this._y = d * l + f * h + e * g - c * k;
                this._z = e * l + f * k + c * h - d * g;
                this._w = f * l - c * g - d * h - e * k;
                this.onChangeCallback();
                return this
            }, multiplyVector3: function (a) {
                THREE.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
                return a.applyQuaternion(this)
            }, slerp: function (a, b) {
                if (0 === b)return this;
                if (1 === b)return this.copy(a);
                var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
                0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
                if (1 <= g)return this._w = f, this._x = c, this._y = d, this._z = e, this;
                var h = Math.acos(g), k = Math.sqrt(1 - g * g);
                if (.001 > Math.abs(k))return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
                g = Math.sin((1 - b) * h) / k;
                h =
                    Math.sin(b * h) / k;
                this._w = f * g + this._w * h;
                this._x = c * g + this._x * h;
                this._y = d * g + this._y * h;
                this._z = e * g + this._z * h;
                this.onChangeCallback();
                return this
            }, equals: function (a) {
                return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
            }, fromArray: function (a, b) {
                void 0 === b && (b = 0);
                this._x = a[b];
                this._y = a[b + 1];
                this._z = a[b + 2];
                this._w = a[b + 3];
                this.onChangeCallback();
                return this
            }, toArray: function (a, b) {
                void 0 === a && (a = []);
                void 0 === b && (b = 0);
                a[b] = this._x;
                a[b + 1] = this._y;
                a[b + 2] = this._z;
                a[b + 3] = this._w;
                return a
            }, onChange: function (a) {
                this.onChangeCallback =
                    a;
                return this
            }, onChangeCallback: function () {
            }, clone: function () {
                return new THREE.Quaternion(this._x, this._y, this._z, this._w)
            }
        };
        THREE.Quaternion.slerp = function (a, b, c, d) {
            return c.copy(a).slerp(b, d)
        };
        THREE.Vector2 = function (a, b) {
            this.x = a || 0;
            this.y = b || 0
        };
        THREE.Vector2.prototype = {
            constructor: THREE.Vector2, set: function (a, b) {
                this.x = a;
                this.y = b;
                return this
            }, setX: function (a) {
                this.x = a;
                return this
            }, setY: function (a) {
                this.y = a;
                return this
            }, setComponent: function (a, b) {
                switch (a) {
                    case 0:
                        this.x = b;
                        break;
                    case 1:
                        this.y = b;
                        break;
                    default:
                        throw Error("index is out of range: " + a);
                }
            }, getComponent: function (a) {
                switch (a) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw Error("index is out of range: " + a);
                }
            }, copy: function (a) {
                this.x = a.x;
                this.y = a.y;
                return this
            }, add: function (a,
                              b) {
                if (void 0 !== b)return THREE.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
                this.x += a.x;
                this.y += a.y;
                return this
            }, addScalar: function (a) {
                this.x += a;
                this.y += a;
                return this
            }, addVectors: function (a, b) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                return this
            }, sub: function (a, b) {
                if (void 0 !== b)return THREE.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
                this.x -= a.x;
                this.y -= a.y;
                return this
            },
            subScalar: function (a) {
                this.x -= a;
                this.y -= a;
                return this
            }, subVectors: function (a, b) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                return this
            }, multiply: function (a) {
                this.x *= a.x;
                this.y *= a.y;
                return this
            }, multiplyScalar: function (a) {
                this.x *= a;
                this.y *= a;
                return this
            }, divide: function (a) {
                this.x /= a.x;
                this.y /= a.y;
                return this
            }, divideScalar: function (a) {
                0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;
                return this
            }, min: function (a) {
                this.x > a.x && (this.x = a.x);
                this.y > a.y && (this.y = a.y);
                return this
            }, max: function (a) {
                this.x < a.x && (this.x = a.x);
                this.y < a.y && (this.y = a.y);
                return this
            }, clamp: function (a, b) {
                this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
                this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
                return this
            }, clampScalar: function () {
                var a, b;
                return function (c, d) {
                    void 0 === a && (a = new THREE.Vector2, b = new THREE.Vector2);
                    a.set(c, c);
                    b.set(d, d);
                    return this.clamp(a, b)
                }
            }(), floor: function () {
                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                return this
            }, ceil: function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                return this
            }, round: function () {
                this.x =
                    Math.round(this.x);
                this.y = Math.round(this.y);
                return this
            }, roundToZero: function () {
                this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
                this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
                return this
            }, negate: function () {
                this.x = -this.x;
                this.y = -this.y;
                return this
            }, dot: function (a) {
                return this.x * a.x + this.y * a.y
            }, lengthSq: function () {
                return this.x * this.x + this.y * this.y
            }, length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }, normalize: function () {
                return this.divideScalar(this.length())
            }, distanceTo: function (a) {
                return Math.sqrt(this.distanceToSquared(a))
            },
            distanceToSquared: function (a) {
                var b = this.x - a.x;
                a = this.y - a.y;
                return b * b + a * a
            }, setLength: function (a) {
                var b = this.length();
                0 !== b && a !== b && this.multiplyScalar(a / b);
                return this
            }, lerp: function (a, b) {
                this.x += (a.x - this.x) * b;
                this.y += (a.y - this.y) * b;
                return this
            }, lerpVectors: function (a, b, c) {
                this.subVectors(b, a).multiplyScalar(c).add(a);
                return this
            }, equals: function (a) {
                return a.x === this.x && a.y === this.y
            }, fromArray: function (a, b) {
                void 0 === b && (b = 0);
                this.x = a[b];
                this.y = a[b + 1];
                return this
            }, toArray: function (a, b) {
                void 0 ===
                a && (a = []);
                void 0 === b && (b = 0);
                a[b] = this.x;
                a[b + 1] = this.y;
                return a
            }, fromAttribute: function (a, b, c) {
                void 0 === c && (c = 0);
                b = b * a.itemSize + c;
                this.x = a.array[b];
                this.y = a.array[b + 1];
                return this
            }, clone: function () {
                return new THREE.Vector2(this.x, this.y)
            }
        };
        THREE.Vector3 = function (a, b, c) {
            this.x = a || 0;
            this.y = b || 0;
            this.z = c || 0
        };
        THREE.Vector3.prototype = {
            constructor: THREE.Vector3, set: function (a, b, c) {
                this.x = a;
                this.y = b;
                this.z = c;
                return this
            }, setX: function (a) {
                this.x = a;
                return this
            }, setY: function (a) {
                this.y = a;
                return this
            }, setZ: function (a) {
                this.z = a;
                return this
            }, setComponent: function (a, b) {
                switch (a) {
                    case 0:
                        this.x = b;
                        break;
                    case 1:
                        this.y = b;
                        break;
                    case 2:
                        this.z = b;
                        break;
                    default:
                        throw Error("index is out of range: " + a);
                }
            }, getComponent: function (a) {
                switch (a) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw Error("index is out of range: " +
                            a);
                }
            }, copy: function (a) {
                this.x = a.x;
                this.y = a.y;
                this.z = a.z;
                return this
            }, add: function (a, b) {
                if (void 0 !== b)return THREE.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
                this.x += a.x;
                this.y += a.y;
                this.z += a.z;
                return this
            }, addScalar: function (a) {
                this.x += a;
                this.y += a;
                this.z += a;
                return this
            }, addVectors: function (a, b) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                this.z = a.z + b.z;
                return this
            }, sub: function (a, b) {
                if (void 0 !== b)return THREE.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                    this.subVectors(a, b);
                this.x -= a.x;
                this.y -= a.y;
                this.z -= a.z;
                return this
            }, subScalar: function (a) {
                this.x -= a;
                this.y -= a;
                this.z -= a;
                return this
            }, subVectors: function (a, b) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                this.z = a.z - b.z;
                return this
            }, multiply: function (a, b) {
                if (void 0 !== b)return THREE.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
                this.x *= a.x;
                this.y *= a.y;
                this.z *= a.z;
                return this
            }, multiplyScalar: function (a) {
                this.x *= a;
                this.y *= a;
                this.z *=
                    a;
                return this
            }, multiplyVectors: function (a, b) {
                this.x = a.x * b.x;
                this.y = a.y * b.y;
                this.z = a.z * b.z;
                return this
            }, applyEuler: function () {
                var a;
                return function (b) {
                    !1 === b instanceof THREE.Euler && THREE.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    void 0 === a && (a = new THREE.Quaternion);
                    this.applyQuaternion(a.setFromEuler(b));
                    return this
                }
            }(), applyAxisAngle: function () {
                var a;
                return function (b, c) {
                    void 0 === a && (a = new THREE.Quaternion);
                    this.applyQuaternion(a.setFromAxisAngle(b,
                        c));
                    return this
                }
            }(), applyMatrix3: function (a) {
                var b = this.x, c = this.y, d = this.z;
                a = a.elements;
                this.x = a[0] * b + a[3] * c + a[6] * d;
                this.y = a[1] * b + a[4] * c + a[7] * d;
                this.z = a[2] * b + a[5] * c + a[8] * d;
                return this
            }, applyMatrix4: function (a) {
                var b = this.x, c = this.y, d = this.z;
                a = a.elements;
                this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
                this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
                this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
                return this
            }, applyProjection: function (a) {
                var b = this.x, c = this.y, d = this.z;
                a = a.elements;
                var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
                this.x = (a[0] * b + a[4] *
                    c + a[8] * d + a[12]) * e;
                this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
                this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
                return this
            }, applyQuaternion: function (a) {
                var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
                a = a.w;
                var h = a * b + f * d - g * c, k = a * c + g * b - e * d, l = a * d + e * c - f * b, b = -e * b - f * c - g * d;
                this.x = h * a + b * -e + k * -g - l * -f;
                this.y = k * a + b * -f + l * -e - h * -g;
                this.z = l * a + b * -g + h * -f - k * -e;
                return this
            }, project: function () {
                var a;
                return function (b) {
                    void 0 === a && (a = new THREE.Matrix4);
                    a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld));
                    return this.applyProjection(a)
                }
            }(),
            unproject: function () {
                var a;
                return function (b) {
                    void 0 === a && (a = new THREE.Matrix4);
                    a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix));
                    return this.applyProjection(a)
                }
            }(), transformDirection: function (a) {
                var b = this.x, c = this.y, d = this.z;
                a = a.elements;
                this.x = a[0] * b + a[4] * c + a[8] * d;
                this.y = a[1] * b + a[5] * c + a[9] * d;
                this.z = a[2] * b + a[6] * c + a[10] * d;
                this.normalize();
                return this
            }, divide: function (a) {
                this.x /= a.x;
                this.y /= a.y;
                this.z /= a.z;
                return this
            }, divideScalar: function (a) {
                0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *=
                    a) : this.z = this.y = this.x = 0;
                return this
            }, min: function (a) {
                this.x > a.x && (this.x = a.x);
                this.y > a.y && (this.y = a.y);
                this.z > a.z && (this.z = a.z);
                return this
            }, max: function (a) {
                this.x < a.x && (this.x = a.x);
                this.y < a.y && (this.y = a.y);
                this.z < a.z && (this.z = a.z);
                return this
            }, clamp: function (a, b) {
                this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
                this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
                this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
                return this
            }, clampScalar: function () {
                var a, b;
                return function (c, d) {
                    void 0 === a && (a = new THREE.Vector3,
                        b = new THREE.Vector3);
                    a.set(c, c, c);
                    b.set(d, d, d);
                    return this.clamp(a, b)
                }
            }(), floor: function () {
                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                this.z = Math.floor(this.z);
                return this
            }, ceil: function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                this.z = Math.ceil(this.z);
                return this
            }, round: function () {
                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                this.z = Math.round(this.z);
                return this
            }, roundToZero: function () {
                this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
                this.y = 0 > this.y ? Math.ceil(this.y) :
                    Math.floor(this.y);
                this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
                return this
            }, negate: function () {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                return this
            }, dot: function (a) {
                return this.x * a.x + this.y * a.y + this.z * a.z
            }, lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }, length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }, lengthManhattan: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }, normalize: function () {
                return this.divideScalar(this.length())
            },
            setLength: function (a) {
                var b = this.length();
                0 !== b && a !== b && this.multiplyScalar(a / b);
                return this
            }, lerp: function (a, b) {
                this.x += (a.x - this.x) * b;
                this.y += (a.y - this.y) * b;
                this.z += (a.z - this.z) * b;
                return this
            }, lerpVectors: function (a, b, c) {
                this.subVectors(b, a).multiplyScalar(c).add(a);
                return this
            }, cross: function (a, b) {
                if (void 0 !== b)return THREE.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
                var c = this.x, d = this.y, e = this.z;
                this.x = d * a.z - e * a.y;
                this.y =
                    e * a.x - c * a.z;
                this.z = c * a.y - d * a.x;
                return this
            }, crossVectors: function (a, b) {
                var c = a.x, d = a.y, e = a.z, f = b.x, g = b.y, h = b.z;
                this.x = d * h - e * g;
                this.y = e * f - c * h;
                this.z = c * g - d * f;
                return this
            }, projectOnVector: function () {
                var a, b;
                return function (c) {
                    void 0 === a && (a = new THREE.Vector3);
                    a.copy(c).normalize();
                    b = this.dot(a);
                    return this.copy(a).multiplyScalar(b)
                }
            }(), projectOnPlane: function () {
                var a;
                return function (b) {
                    void 0 === a && (a = new THREE.Vector3);
                    a.copy(this).projectOnVector(b);
                    return this.sub(a)
                }
            }(), reflect: function () {
                var a;
                return function (b) {
                    void 0 ===
                    a && (a = new THREE.Vector3);
                    return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
                }
            }(), angleTo: function (a) {
                a = this.dot(a) / (this.length() * a.length());
                return Math.acos(THREE.Math.clamp(a, -1, 1))
            }, distanceTo: function (a) {
                return Math.sqrt(this.distanceToSquared(a))
            }, distanceToSquared: function (a) {
                var b = this.x - a.x, c = this.y - a.y;
                a = this.z - a.z;
                return b * b + c * c + a * a
            }, setEulerFromRotationMatrix: function (a, b) {
                THREE.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            },
            setEulerFromQuaternion: function (a, b) {
                THREE.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }, getPositionFromMatrix: function (a) {
                THREE.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
                return this.setFromMatrixPosition(a)
            }, getScaleFromMatrix: function (a) {
                THREE.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
                return this.setFromMatrixScale(a)
            }, getColumnFromMatrix: function (a,
                                              b) {
                THREE.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
                return this.setFromMatrixColumn(a, b)
            }, setFromMatrixPosition: function (a) {
                this.x = a.elements[12];
                this.y = a.elements[13];
                this.z = a.elements[14];
                return this
            }, setFromMatrixScale: function (a) {
                var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(), c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
                a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
                this.x = b;
                this.y = c;
                this.z = a;
                return this
            }, setFromMatrixColumn: function (a, b) {
                var c = 4 * a, d = b.elements;
                this.x = d[c];
                this.y = d[c + 1];
                this.z = d[c + 2];
                return this
            }, equals: function (a) {
                return a.x === this.x && a.y === this.y && a.z === this.z
            }, fromArray: function (a, b) {
                void 0 === b && (b = 0);
                this.x = a[b];
                this.y = a[b + 1];
                this.z = a[b + 2];
                return this
            }, toArray: function (a, b) {
                void 0 === a && (a = []);
                void 0 === b && (b = 0);
                a[b] = this.x;
                a[b + 1] = this.y;
                a[b + 2] = this.z;
                return a
            }, fromAttribute: function (a, b, c) {
                void 0 === c && (c = 0);
                b = b * a.itemSize + c;
                this.x = a.array[b];
                this.y = a.array[b + 1];
                this.z =
                    a.array[b + 2];
                return this
            }, clone: function () {
                return new THREE.Vector3(this.x, this.y, this.z)
            }
        };
        THREE.Vector4 = function (a, b, c, d) {
            this.x = a || 0;
            this.y = b || 0;
            this.z = c || 0;
            this.w = void 0 !== d ? d : 1
        };
        THREE.Vector4.prototype = {
            constructor: THREE.Vector4, set: function (a, b, c, d) {
                this.x = a;
                this.y = b;
                this.z = c;
                this.w = d;
                return this
            }, setX: function (a) {
                this.x = a;
                return this
            }, setY: function (a) {
                this.y = a;
                return this
            }, setZ: function (a) {
                this.z = a;
                return this
            }, setW: function (a) {
                this.w = a;
                return this
            }, setComponent: function (a, b) {
                switch (a) {
                    case 0:
                        this.x = b;
                        break;
                    case 1:
                        this.y = b;
                        break;
                    case 2:
                        this.z = b;
                        break;
                    case 3:
                        this.w = b;
                        break;
                    default:
                        throw Error("index is out of range: " + a);
                }
            }, getComponent: function (a) {
                switch (a) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw Error("index is out of range: " + a);
                }
            }, copy: function (a) {
                this.x = a.x;
                this.y = a.y;
                this.z = a.z;
                this.w = void 0 !== a.w ? a.w : 1;
                return this
            }, add: function (a, b) {
                if (void 0 !== b)return THREE.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
                this.x += a.x;
                this.y += a.y;
                this.z += a.z;
                this.w += a.w;
                return this
            }, addScalar: function (a) {
                this.x += a;
                this.y += a;
                this.z += a;
                this.w += a;
                return this
            }, addVectors: function (a,
                                     b) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                this.z = a.z + b.z;
                this.w = a.w + b.w;
                return this
            }, sub: function (a, b) {
                if (void 0 !== b)return THREE.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
                this.x -= a.x;
                this.y -= a.y;
                this.z -= a.z;
                this.w -= a.w;
                return this
            }, subScalar: function (a) {
                this.x -= a;
                this.y -= a;
                this.z -= a;
                this.w -= a;
                return this
            }, subVectors: function (a, b) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                this.z = a.z - b.z;
                this.w = a.w - b.w;
                return this
            }, multiplyScalar: function (a) {
                this.x *=
                    a;
                this.y *= a;
                this.z *= a;
                this.w *= a;
                return this
            }, applyMatrix4: function (a) {
                var b = this.x, c = this.y, d = this.z, e = this.w;
                a = a.elements;
                this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
                this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
                this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
                this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
                return this
            }, divideScalar: function (a) {
                0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);
                return this
            }, setAxisAngleFromQuaternion: function (a) {
                this.w = 2 * Math.acos(a.w);
                var b = Math.sqrt(1 - a.w * a.w);
                1E-4 >
                b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
                return this
            }, setAxisAngleFromRotationMatrix: function (a) {
                var b, c, d;
                a = a.elements;
                var e = a[0];
                d = a[4];
                var f = a[8], g = a[1], h = a[5], k = a[9];
                c = a[2];
                b = a[6];
                var l = a[10];
                if (.01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(k - b)) {
                    if (.1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(k + b) && .1 > Math.abs(e + h + l - 3))return this.set(1, 0, 0, 0), this;
                    a = Math.PI;
                    e = (e + 1) / 2;
                    h = (h + 1) / 2;
                    l = (l + 1) / 2;
                    d = (d + g) / 4;
                    f = (f + c) / 4;
                    k = (k + b) / 4;
                    e > h && e > l ? .01 > e ? (b = 0, d = c = .707106781) : (b =
                        Math.sqrt(e), c = d / b, d = f / b) : h > l ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), b = d / c, d = k / c) : .01 > l ? (c = b = .707106781, d = 0) : (d = Math.sqrt(l), b = f / d, c = k / d);
                    this.set(b, c, d, a);
                    return this
                }
                a = Math.sqrt((b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d));
                .001 > Math.abs(a) && (a = 1);
                this.x = (b - k) / a;
                this.y = (f - c) / a;
                this.z = (g - d) / a;
                this.w = Math.acos((e + h + l - 1) / 2);
                return this
            }, min: function (a) {
                this.x > a.x && (this.x = a.x);
                this.y > a.y && (this.y = a.y);
                this.z > a.z && (this.z = a.z);
                this.w > a.w && (this.w = a.w);
                return this
            }, max: function (a) {
                this.x < a.x &&
                (this.x = a.x);
                this.y < a.y && (this.y = a.y);
                this.z < a.z && (this.z = a.z);
                this.w < a.w && (this.w = a.w);
                return this
            }, clamp: function (a, b) {
                this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
                this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
                this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
                this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
                return this
            }, clampScalar: function () {
                var a, b;
                return function (c, d) {
                    void 0 === a && (a = new THREE.Vector4, b = new THREE.Vector4);
                    a.set(c, c, c, c);
                    b.set(d, d, d, d);
                    return this.clamp(a, b)
                }
            }(), floor: function () {
                this.x =
                    Math.floor(this.x);
                this.y = Math.floor(this.y);
                this.z = Math.floor(this.z);
                this.w = Math.floor(this.w);
                return this
            }, ceil: function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                this.z = Math.ceil(this.z);
                this.w = Math.ceil(this.w);
                return this
            }, round: function () {
                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                this.z = Math.round(this.z);
                this.w = Math.round(this.w);
                return this
            }, roundToZero: function () {
                this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
                this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
                this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
                this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
                return this
            }, negate: function () {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                this.w = -this.w;
                return this
            }, dot: function (a) {
                return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
            }, lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }, length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }, lengthManhattan: function () {
                return Math.abs(this.x) +
                    Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }, normalize: function () {
                return this.divideScalar(this.length())
            }, setLength: function (a) {
                var b = this.length();
                0 !== b && a !== b && this.multiplyScalar(a / b);
                return this
            }, lerp: function (a, b) {
                this.x += (a.x - this.x) * b;
                this.y += (a.y - this.y) * b;
                this.z += (a.z - this.z) * b;
                this.w += (a.w - this.w) * b;
                return this
            }, lerpVectors: function (a, b, c) {
                this.subVectors(b, a).multiplyScalar(c).add(a);
                return this
            }, equals: function (a) {
                return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
            },
            fromArray: function (a, b) {
                void 0 === b && (b = 0);
                this.x = a[b];
                this.y = a[b + 1];
                this.z = a[b + 2];
                this.w = a[b + 3];
                return this
            }, toArray: function (a, b) {
                void 0 === a && (a = []);
                void 0 === b && (b = 0);
                a[b] = this.x;
                a[b + 1] = this.y;
                a[b + 2] = this.z;
                a[b + 3] = this.w;
                return a
            }, fromAttribute: function (a, b, c) {
                void 0 === c && (c = 0);
                b = b * a.itemSize + c;
                this.x = a.array[b];
                this.y = a.array[b + 1];
                this.z = a.array[b + 2];
                this.w = a.array[b + 3];
                return this
            }, clone: function () {
                return new THREE.Vector4(this.x, this.y, this.z, this.w)
            }
        };
        THREE.Euler = function (a, b, c, d) {
            this._x = a || 0;
            this._y = b || 0;
            this._z = c || 0;
            this._order = d || THREE.Euler.DefaultOrder
        };
        THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
        THREE.Euler.DefaultOrder = "XYZ";
        THREE.Euler.prototype = {
            constructor: THREE.Euler, _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder, get x() {
                return this._x
            }, set x(a) {
                this._x = a;
                this.onChangeCallback()
            }, get y() {
                return this._y
            }, set y(a) {
                this._y = a;
                this.onChangeCallback()
            }, get z() {
                return this._z
            }, set z(a) {
                this._z = a;
                this.onChangeCallback()
            }, get order() {
                return this._order
            }, set order(a) {
                this._order = a;
                this.onChangeCallback()
            }, set: function (a, b, c, d) {
                this._x = a;
                this._y = b;
                this._z = c;
                this._order = d || this._order;
                this.onChangeCallback();
                return this
            }, copy: function (a) {
                this._x =
                    a._x;
                this._y = a._y;
                this._z = a._z;
                this._order = a._order;
                this.onChangeCallback();
                return this
            }, setFromRotationMatrix: function (a, b, c) {
                var d = THREE.Math.clamp, e = a.elements;
                a = e[0];
                var f = e[4], g = e[8], h = e[1], k = e[5], l = e[9], p = e[2], q = e[6], e = e[10];
                b = b || this._order;
                "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-l, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(q, k), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(l, -1, 1)), .99999 > Math.abs(l) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h,
                    k)) : (this._y = Math.atan2(-p, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(q, -1, 1)), .99999 > Math.abs(q) ? (this._y = Math.atan2(-p, e), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(p, -1, 1)), .99999 > Math.abs(p) ? (this._x = Math.atan2(q, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, k))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-l, k), this._y = Math.atan2(-p, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z =
                    Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(q, k), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-l, e), this._y = 0)) : THREE.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
                this._order = b;
                if (!1 !== c)this.onChangeCallback();
                return this
            }, setFromQuaternion: function () {
                var a;
                return function (b, c, d) {
                    void 0 === a && (a = new THREE.Matrix4);
                    a.makeRotationFromQuaternion(b);
                    this.setFromRotationMatrix(a, c, d);
                    return this
                }
            }(), setFromVector3: function (a, b) {
                return this.set(a.x, a.y, a.z,
                    b || this._order)
            }, reorder: function () {
                var a = new THREE.Quaternion;
                return function (b) {
                    a.setFromEuler(this);
                    this.setFromQuaternion(a, b)
                }
            }(), equals: function (a) {
                return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
            }, fromArray: function (a) {
                this._x = a[0];
                this._y = a[1];
                this._z = a[2];
                void 0 !== a[3] && (this._order = a[3]);
                this.onChangeCallback();
                return this
            }, toArray: function (a, b) {
                void 0 === a && (a = []);
                void 0 === b && (b = 0);
                a[b] = this._x;
                a[b + 1] = this._y;
                a[b + 2] = this._z;
                a[b + 3] = this._order;
                return a
            }, toVector3: function (a) {
                return a ?
                    a.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z)
            }, onChange: function (a) {
                this.onChangeCallback = a;
                return this
            }, onChangeCallback: function () {
            }, clone: function () {
                return new THREE.Euler(this._x, this._y, this._z, this._order)
            }
        };
        THREE.Line3 = function (a, b) {
            this.start = void 0 !== a ? a : new THREE.Vector3;
            this.end = void 0 !== b ? b : new THREE.Vector3
        };
        THREE.Line3.prototype = {
            constructor: THREE.Line3, set: function (a, b) {
                this.start.copy(a);
                this.end.copy(b);
                return this
            }, copy: function (a) {
                this.start.copy(a.start);
                this.end.copy(a.end);
                return this
            }, center: function (a) {
                return (a || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
            }, delta: function (a) {
                return (a || new THREE.Vector3).subVectors(this.end, this.start)
            }, distanceSq: function () {
                return this.start.distanceToSquared(this.end)
            }, distance: function () {
                return this.start.distanceTo(this.end)
            }, at: function (a,
                             b) {
                var c = b || new THREE.Vector3;
                return this.delta(c).multiplyScalar(a).add(this.start)
            }, closestPointToPointParameter: function () {
                var a = new THREE.Vector3, b = new THREE.Vector3;
                return function (c, d) {
                    a.subVectors(c, this.start);
                    b.subVectors(this.end, this.start);
                    var e = b.dot(b), e = b.dot(a) / e;
                    d && (e = THREE.Math.clamp(e, 0, 1));
                    return e
                }
            }(), closestPointToPoint: function (a, b, c) {
                a = this.closestPointToPointParameter(a, b);
                c = c || new THREE.Vector3;
                return this.delta(c).multiplyScalar(a).add(this.start)
            }, applyMatrix4: function (a) {
                this.start.applyMatrix4(a);
                this.end.applyMatrix4(a);
                return this
            }, equals: function (a) {
                return a.start.equals(this.start) && a.end.equals(this.end)
            }, clone: function () {
                return (new THREE.Line3).copy(this)
            }
        };
        THREE.Box2 = function (a, b) {
            this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
            this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity)
        };
        THREE.Box2.prototype = {
            constructor: THREE.Box2, set: function (a, b) {
                this.min.copy(a);
                this.max.copy(b);
                return this
            }, setFromPoints: function (a) {
                this.makeEmpty();
                for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]);
                return this
            }, setFromCenterAndSize: function () {
                var a = new THREE.Vector2;
                return function (b, c) {
                    var d = a.copy(c).multiplyScalar(.5);
                    this.min.copy(b).sub(d);
                    this.max.copy(b).add(d);
                    return this
                }
            }(), copy: function (a) {
                this.min.copy(a.min);
                this.max.copy(a.max);
                return this
            }, makeEmpty: function () {
                this.min.x =
                    this.min.y = Infinity;
                this.max.x = this.max.y = -Infinity;
                return this
            }, empty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }, center: function (a) {
                return (a || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
            }, size: function (a) {
                return (a || new THREE.Vector2).subVectors(this.max, this.min)
            }, expandByPoint: function (a) {
                this.min.min(a);
                this.max.max(a);
                return this
            }, expandByVector: function (a) {
                this.min.sub(a);
                this.max.add(a);
                return this
            }, expandByScalar: function (a) {
                this.min.addScalar(-a);
                this.max.addScalar(a);
                return this
            }, containsPoint: function (a) {
                return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
            }, containsBox: function (a) {
                return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1
            }, getParameter: function (a, b) {
                return (b || new THREE.Vector2).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
            }, isIntersectionBox: function (a) {
                return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y >
                this.max.y ? !1 : !0
            }, clampPoint: function (a, b) {
                return (b || new THREE.Vector2).copy(a).clamp(this.min, this.max)
            }, distanceToPoint: function () {
                var a = new THREE.Vector2;
                return function (b) {
                    return a.copy(b).clamp(this.min, this.max).sub(b).length()
                }
            }(), intersect: function (a) {
                this.min.max(a.min);
                this.max.min(a.max);
                return this
            }, union: function (a) {
                this.min.min(a.min);
                this.max.max(a.max);
                return this
            }, translate: function (a) {
                this.min.add(a);
                this.max.add(a);
                return this
            }, equals: function (a) {
                return a.min.equals(this.min) &&
                    a.max.equals(this.max)
            }, clone: function () {
                return (new THREE.Box2).copy(this)
            }
        };
        THREE.Box3 = function (a, b) {
            this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
            this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity)
        };
        THREE.Box3.prototype = {
            constructor: THREE.Box3, set: function (a, b) {
                this.min.copy(a);
                this.max.copy(b);
                return this
            }, setFromPoints: function (a) {
                this.makeEmpty();
                for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]);
                return this
            }, setFromCenterAndSize: function () {
                var a = new THREE.Vector3;
                return function (b, c) {
                    var d = a.copy(c).multiplyScalar(.5);
                    this.min.copy(b).sub(d);
                    this.max.copy(b).add(d);
                    return this
                }
            }(), setFromObject: function () {
                var a = new THREE.Vector3;
                return function (b) {
                    var c = this;
                    b.updateMatrixWorld(!0);
                    this.makeEmpty();
                    b.traverse(function (b) {
                        var e = b.geometry;
                        if (void 0 !== e)if (e instanceof THREE.Geometry)for (var f = e.vertices, e = 0, g = f.length; e < g; e++)a.copy(f[e]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a); else if (e instanceof THREE.BufferGeometry && void 0 !== e.attributes.position)for (f = e.attributes.position.array, e = 0, g = f.length; e < g; e += 3)a.set(f[e], f[e + 1], f[e + 2]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a)
                    });
                    return this
                }
            }(), copy: function (a) {
                this.min.copy(a.min);
                this.max.copy(a.max);
                return this
            },
            makeEmpty: function () {
                this.min.x = this.min.y = this.min.z = Infinity;
                this.max.x = this.max.y = this.max.z = -Infinity;
                return this
            }, empty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }, center: function (a) {
                return (a || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
            }, size: function (a) {
                return (a || new THREE.Vector3).subVectors(this.max, this.min)
            }, expandByPoint: function (a) {
                this.min.min(a);
                this.max.max(a);
                return this
            }, expandByVector: function (a) {
                this.min.sub(a);
                this.max.add(a);
                return this
            }, expandByScalar: function (a) {
                this.min.addScalar(-a);
                this.max.addScalar(a);
                return this
            }, containsPoint: function (a) {
                return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
            }, containsBox: function (a) {
                return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1
            }, getParameter: function (a, b) {
                return (b || new THREE.Vector3).set((a.x - this.min.x) / (this.max.x -
                    this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
            }, isIntersectionBox: function (a) {
                return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
            }, clampPoint: function (a, b) {
                return (b || new THREE.Vector3).copy(a).clamp(this.min, this.max)
            }, distanceToPoint: function () {
                var a = new THREE.Vector3;
                return function (b) {
                    return a.copy(b).clamp(this.min, this.max).sub(b).length()
                }
            }(), getBoundingSphere: function () {
                var a =
                    new THREE.Vector3;
                return function (b) {
                    b = b || new THREE.Sphere;
                    b.center = this.center();
                    b.radius = .5 * this.size(a).length();
                    return b
                }
            }(), intersect: function (a) {
                this.min.max(a.min);
                this.max.min(a.max);
                return this
            }, union: function (a) {
                this.min.min(a.min);
                this.max.max(a.max);
                return this
            }, applyMatrix4: function () {
                var a = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
                return function (b) {
                    a[0].set(this.min.x, this.min.y,
                        this.min.z).applyMatrix4(b);
                    a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
                    a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
                    a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
                    a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
                    a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
                    a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
                    a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
                    this.makeEmpty();
                    this.setFromPoints(a);
                    return this
                }
            }(), translate: function (a) {
                this.min.add(a);
                this.max.add(a);
                return this
            }, equals: function (a) {
                return a.min.equals(this.min) && a.max.equals(this.max)
            }, clone: function () {
                return (new THREE.Box3).copy(this)
            }
        };
        THREE.Matrix3 = function () {
            this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
            0 < arguments.length && THREE.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        };
        THREE.Matrix3.prototype = {
            constructor: THREE.Matrix3, set: function (a, b, c, d, e, f, g, h, k) {
                var l = this.elements;
                l[0] = a;
                l[3] = b;
                l[6] = c;
                l[1] = d;
                l[4] = e;
                l[7] = f;
                l[2] = g;
                l[5] = h;
                l[8] = k;
                return this
            }, identity: function () {
                this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
                return this
            }, copy: function (a) {
                a = a.elements;
                this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
                return this
            }, multiplyVector3: function (a) {
                THREE.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
                return a.applyMatrix3(this)
            },
            multiplyVector3Array: function (a) {
                THREE.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
                return this.applyToVector3Array(a)
            }, applyToVector3Array: function () {
                var a = new THREE.Vector3;
                return function (b, c, d) {
                    void 0 === c && (c = 0);
                    void 0 === d && (d = b.length);
                    for (var e = 0; e < d; e += 3, c += 3)a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
                    return b
                }
            }(), multiplyScalar: function (a) {
                var b = this.elements;
                b[0] *= a;
                b[3] *= a;
                b[6] *=
                    a;
                b[1] *= a;
                b[4] *= a;
                b[7] *= a;
                b[2] *= a;
                b[5] *= a;
                b[8] *= a;
                return this
            }, determinant: function () {
                var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], k = a[7], a = a[8];
                return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h
            }, getInverse: function (a, b) {
                var c = a.elements, d = this.elements;
                d[0] = c[10] * c[5] - c[6] * c[9];
                d[1] = -c[10] * c[1] + c[2] * c[9];
                d[2] = c[6] * c[1] - c[2] * c[5];
                d[3] = -c[10] * c[4] + c[6] * c[8];
                d[4] = c[10] * c[0] - c[2] * c[8];
                d[5] = -c[6] * c[0] + c[2] * c[4];
                d[6] = c[9] * c[4] - c[5] * c[8];
                d[7] = -c[9] * c[0] + c[1] * c[8];
                d[8] = c[5] * c[0] - c[1] * c[4];
                c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
                if (0 === c) {
                    if (b)throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
                    THREE.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0");
                    this.identity();
                    return this
                }
                this.multiplyScalar(1 / c);
                return this
            }, transpose: function () {
                var a, b = this.elements;
                a = b[1];
                b[1] = b[3];
                b[3] = a;
                a = b[2];
                b[2] = b[6];
                b[6] = a;
                a = b[5];
                b[5] = b[7];
                b[7] = a;
                return this
            }, flattenToArrayOffset: function (a, b) {
                var c = this.elements;
                a[b] = c[0];
                a[b + 1] = c[1];
                a[b + 2] = c[2];
                a[b + 3] = c[3];
                a[b + 4] = c[4];
                a[b + 5] = c[5];
                a[b + 6] = c[6];
                a[b + 7] = c[7];
                a[b + 8] = c[8];
                return a
            }, getNormalMatrix: function (a) {
                this.getInverse(a).transpose();
                return this
            }, transposeIntoArray: function (a) {
                var b = this.elements;
                a[0] = b[0];
                a[1] = b[3];
                a[2] = b[6];
                a[3] = b[1];
                a[4] = b[4];
                a[5] = b[7];
                a[6] = b[2];
                a[7] = b[5];
                a[8] = b[8];
                return this
            }, fromArray: function (a) {
                this.elements.set(a);
                return this
            }, toArray: function () {
                var a = this.elements;
                return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]]
            }, clone: function () {
                return (new THREE.Matrix3).fromArray(this.elements)
            }
        };
        THREE.Matrix4 = function () {
            this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            0 < arguments.length && THREE.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        };
        THREE.Matrix4.prototype = {
            constructor: THREE.Matrix4, set: function (a, b, c, d, e, f, g, h, k, l, p, q, n, t, r, s) {
                var u = this.elements;
                u[0] = a;
                u[4] = b;
                u[8] = c;
                u[12] = d;
                u[1] = e;
                u[5] = f;
                u[9] = g;
                u[13] = h;
                u[2] = k;
                u[6] = l;
                u[10] = p;
                u[14] = q;
                u[3] = n;
                u[7] = t;
                u[11] = r;
                u[15] = s;
                return this
            }, identity: function () {
                this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                return this
            }, copy: function (a) {
                this.elements.set(a.elements);
                return this
            }, extractPosition: function (a) {
                THREE.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
                return this.copyPosition(a)
            },
            copyPosition: function (a) {
                var b = this.elements;
                a = a.elements;
                b[12] = a[12];
                b[13] = a[13];
                b[14] = a[14];
                return this
            }, extractBasis: function (a, b, c) {
                var d = this.elements;
                a.set(d[0], d[1], d[2]);
                b.set(d[4], d[5], d[6]);
                c.set(d[8], d[9], d[10]);
                return this
            }, makeBasis: function (a, b, c) {
                this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
                return this
            }, extractRotation: function () {
                var a = new THREE.Vector3;
                return function (b) {
                    var c = this.elements;
                    b = b.elements;
                    var d = 1 / a.set(b[0], b[1], b[2]).length(), e = 1 / a.set(b[4], b[5], b[6]).length(),
                        f = 1 / a.set(b[8], b[9], b[10]).length();
                    c[0] = b[0] * d;
                    c[1] = b[1] * d;
                    c[2] = b[2] * d;
                    c[4] = b[4] * e;
                    c[5] = b[5] * e;
                    c[6] = b[6] * e;
                    c[8] = b[8] * f;
                    c[9] = b[9] * f;
                    c[10] = b[10] * f;
                    return this
                }
            }(), makeRotationFromEuler: function (a) {
                !1 === a instanceof THREE.Euler && THREE.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d), d = Math.sin(d), h = Math.cos(e), e = Math.sin(e);
                if ("XYZ" === a.order) {
                    a = f * h;
                    var k = f * e,
                        l = c * h, p = c * e;
                    b[0] = g * h;
                    b[4] = -g * e;
                    b[8] = d;
                    b[1] = k + l * d;
                    b[5] = a - p * d;
                    b[9] = -c * g;
                    b[2] = p - a * d;
                    b[6] = l + k * d;
                    b[10] = f * g
                } else"YXZ" === a.order ? (a = g * h, k = g * e, l = d * h, p = d * e, b[0] = a + p * c, b[4] = l * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - l, b[6] = p + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, k = g * e, l = d * h, p = d * e, b[0] = a - p * c, b[4] = -f * e, b[8] = l + k * c, b[1] = k + l * c, b[5] = f * h, b[9] = p - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, k = f * e, l = c * h, p = c * e, b[0] = g * h, b[4] = l * d - k, b[8] = a * d + p, b[1] = g * e, b[5] = p * d + a, b[9] = k * d - l, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" ===
                a.order ? (a = f * g, k = f * d, l = c * g, p = c * d, b[0] = g * h, b[4] = p - a * e, b[8] = l * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + l, b[10] = a - p * e) : "XZY" === a.order && (a = f * g, k = f * d, l = c * g, p = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + p, b[5] = f * h, b[9] = k * e - l, b[2] = l * e - k, b[6] = c * h, b[10] = p * e + a);
                b[3] = 0;
                b[7] = 0;
                b[11] = 0;
                b[12] = 0;
                b[13] = 0;
                b[14] = 0;
                b[15] = 1;
                return this
            }, setRotationFromQuaternion: function (a) {
                THREE.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
                return this.makeRotationFromQuaternion(a)
            },
            makeRotationFromQuaternion: function (a) {
                var b = this.elements, c = a.x, d = a.y, e = a.z, f = a.w, g = c + c, h = d + d, k = e + e;
                a = c * g;
                var l = c * h, c = c * k, p = d * h, d = d * k, e = e * k, g = f * g, h = f * h, f = f * k;
                b[0] = 1 - (p + e);
                b[4] = l - f;
                b[8] = c + h;
                b[1] = l + f;
                b[5] = 1 - (a + e);
                b[9] = d - g;
                b[2] = c - h;
                b[6] = d + g;
                b[10] = 1 - (a + p);
                b[3] = 0;
                b[7] = 0;
                b[11] = 0;
                b[12] = 0;
                b[13] = 0;
                b[14] = 0;
                b[15] = 1;
                return this
            }, lookAt: function () {
                var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3;
                return function (d, e, f) {
                    var g = this.elements;
                    c.subVectors(d, e).normalize();
                    0 === c.length() && (c.z = 1);
                    a.crossVectors(f,
                        c).normalize();
                    0 === a.length() && (c.x += 1E-4, a.crossVectors(f, c).normalize());
                    b.crossVectors(c, a);
                    g[0] = a.x;
                    g[4] = b.x;
                    g[8] = c.x;
                    g[1] = a.y;
                    g[5] = b.y;
                    g[9] = c.y;
                    g[2] = a.z;
                    g[6] = b.z;
                    g[10] = c.z;
                    return this
                }
            }(), multiply: function (a, b) {
                return void 0 !== b ? (THREE.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
            }, multiplyMatrices: function (a, b) {
                var c = a.elements, d = b.elements, e = this.elements, f = c[0], g = c[4], h = c[8],
                    k = c[12], l = c[1], p = c[5], q = c[9], n = c[13], t = c[2], r = c[6], s = c[10], u = c[14], v = c[3], x = c[7], D = c[11], c = c[15], w = d[0], y = d[4], A = d[8], E = d[12], G = d[1], F = d[5], z = d[9], I = d[13], U = d[2], M = d[6], H = d[10], L = d[14], P = d[3], N = d[7], R = d[11], d = d[15];
                e[0] = f * w + g * G + h * U + k * P;
                e[4] = f * y + g * F + h * M + k * N;
                e[8] = f * A + g * z + h * H + k * R;
                e[12] = f * E + g * I + h * L + k * d;
                e[1] = l * w + p * G + q * U + n * P;
                e[5] = l * y + p * F + q * M + n * N;
                e[9] = l * A + p * z + q * H + n * R;
                e[13] = l * E + p * I + q * L + n * d;
                e[2] = t * w + r * G + s * U + u * P;
                e[6] = t * y + r * F + s * M + u * N;
                e[10] = t * A + r * z + s * H + u * R;
                e[14] = t * E + r * I + s * L + u * d;
                e[3] = v * w + x * G + D * U + c * P;
                e[7] = v * y +
                    x * F + D * M + c * N;
                e[11] = v * A + x * z + D * H + c * R;
                e[15] = v * E + x * I + D * L + c * d;
                return this
            }, multiplyToArray: function (a, b, c) {
                var d = this.elements;
                this.multiplyMatrices(a, b);
                c[0] = d[0];
                c[1] = d[1];
                c[2] = d[2];
                c[3] = d[3];
                c[4] = d[4];
                c[5] = d[5];
                c[6] = d[6];
                c[7] = d[7];
                c[8] = d[8];
                c[9] = d[9];
                c[10] = d[10];
                c[11] = d[11];
                c[12] = d[12];
                c[13] = d[13];
                c[14] = d[14];
                c[15] = d[15];
                return this
            }, multiplyScalar: function (a) {
                var b = this.elements;
                b[0] *= a;
                b[4] *= a;
                b[8] *= a;
                b[12] *= a;
                b[1] *= a;
                b[5] *= a;
                b[9] *= a;
                b[13] *= a;
                b[2] *= a;
                b[6] *= a;
                b[10] *= a;
                b[14] *= a;
                b[3] *= a;
                b[7] *= a;
                b[11] *=
                    a;
                b[15] *= a;
                return this
            }, multiplyVector3: function (a) {
                THREE.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
                return a.applyProjection(this)
            }, multiplyVector4: function (a) {
                THREE.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
                return a.applyMatrix4(this)
            }, multiplyVector3Array: function (a) {
                THREE.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
                return this.applyToVector3Array(a)
            }, applyToVector3Array: function () {
                var a = new THREE.Vector3;
                return function (b, c, d) {
                    void 0 === c && (c = 0);
                    void 0 === d && (d = b.length);
                    for (var e = 0; e < d; e += 3, c += 3)a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix4(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
                    return b
                }
            }(), rotateAxis: function (a) {
                THREE.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
                a.transformDirection(this)
            }, crossVector: function (a) {
                THREE.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
                return a.applyMatrix4(this)
            }, determinant: function () {
                var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], k = a[13], l = a[2], p = a[6], q = a[10], n = a[14];
                return a[3] * (+e * h * p - d * k * p - e * g * q + c * k * q + d * g * n - c * h * n) + a[7] * (+b * h * n - b * k * q + e * f * q - d * f * n + d * k * l - e * h * l) + a[11] * (+b * k * p - b * g * n - e * f * p + c * f * n + e * g * l - c * k * l) + a[15] * (-d * g * l - b * h * p + b * g * q + d * f * p - c * f * q + c * h * l)
            }, transpose: function () {
                var a = this.elements, b;
                b = a[1];
                a[1] = a[4];
                a[4] = b;
                b = a[2];
                a[2] = a[8];
                a[8] = b;
                b = a[6];
                a[6] = a[9];
                a[9] = b;
                b = a[3];
                a[3] = a[12];
                a[12] = b;
                b = a[7];
                a[7] = a[13];
                a[13] = b;
                b = a[11];
                a[11] = a[14];
                a[14] = b;
                return this
            }, flattenToArrayOffset: function (a, b) {
                var c = this.elements;
                a[b] = c[0];
                a[b + 1] = c[1];
                a[b + 2] = c[2];
                a[b + 3] = c[3];
                a[b + 4] = c[4];
                a[b + 5] = c[5];
                a[b + 6] = c[6];
                a[b + 7] = c[7];
                a[b + 8] = c[8];
                a[b + 9] = c[9];
                a[b + 10] = c[10];
                a[b + 11] = c[11];
                a[b + 12] = c[12];
                a[b + 13] = c[13];
                a[b + 14] = c[14];
                a[b + 15] = c[15];
                return a
            }, getPosition: function () {
                var a = new THREE.Vector3;
                return function () {
                    THREE.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                    var b =
                        this.elements;
                    return a.set(b[12], b[13], b[14])
                }
            }(), setPosition: function (a) {
                var b = this.elements;
                b[12] = a.x;
                b[13] = a.y;
                b[14] = a.z;
                return this
            }, getInverse: function (a, b) {
                var c = this.elements, d = a.elements, e = d[0], f = d[4], g = d[8], h = d[12], k = d[1], l = d[5], p = d[9], q = d[13], n = d[2], t = d[6], r = d[10], s = d[14], u = d[3], v = d[7], x = d[11], d = d[15];
                c[0] = p * s * v - q * r * v + q * t * x - l * s * x - p * t * d + l * r * d;
                c[4] = h * r * v - g * s * v - h * t * x + f * s * x + g * t * d - f * r * d;
                c[8] = g * q * v - h * p * v + h * l * x - f * q * x - g * l * d + f * p * d;
                c[12] = h * p * t - g * q * t - h * l * r + f * q * r + g * l * s - f * p * s;
                c[1] = q * r * u - p * s * u - q * n * x +
                    k * s * x + p * n * d - k * r * d;
                c[5] = g * s * u - h * r * u + h * n * x - e * s * x - g * n * d + e * r * d;
                c[9] = h * p * u - g * q * u - h * k * x + e * q * x + g * k * d - e * p * d;
                c[13] = g * q * n - h * p * n + h * k * r - e * q * r - g * k * s + e * p * s;
                c[2] = l * s * u - q * t * u + q * n * v - k * s * v - l * n * d + k * t * d;
                c[6] = h * t * u - f * s * u - h * n * v + e * s * v + f * n * d - e * t * d;
                c[10] = f * q * u - h * l * u + h * k * v - e * q * v - f * k * d + e * l * d;
                c[14] = h * l * n - f * q * n - h * k * t + e * q * t + f * k * s - e * l * s;
                c[3] = p * t * u - l * r * u - p * n * v + k * r * v + l * n * x - k * t * x;
                c[7] = f * r * u - g * t * u + g * n * v - e * r * v - f * n * x + e * t * x;
                c[11] = g * l * u - f * p * u - g * k * v + e * p * v + f * k * x - e * l * x;
                c[15] = f * p * n - g * l * n + g * k * t - e * p * t - f * k * r + e * l * r;
                c = e * c[0] + k * c[4] + n * c[8] + u * c[12];
                if (0 == c) {
                    if (b)throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                    THREE.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                    this.identity();
                    return this
                }
                this.multiplyScalar(1 / c);
                return this
            }, translate: function (a) {
                THREE.error("THREE.Matrix4: .translate() has been removed.")
            }, rotateX: function (a) {
                THREE.error("THREE.Matrix4: .rotateX() has been removed.")
            }, rotateY: function (a) {
                THREE.error("THREE.Matrix4: .rotateY() has been removed.")
            }, rotateZ: function (a) {
                THREE.error("THREE.Matrix4: .rotateZ() has been removed.")
            },
            rotateByAxis: function (a, b) {
                THREE.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }, scale: function (a) {
                var b = this.elements, c = a.x, d = a.y;
                a = a.z;
                b[0] *= c;
                b[4] *= d;
                b[8] *= a;
                b[1] *= c;
                b[5] *= d;
                b[9] *= a;
                b[2] *= c;
                b[6] *= d;
                b[10] *= a;
                b[3] *= c;
                b[7] *= d;
                b[11] *= a;
                return this
            }, getMaxScaleOnAxis: function () {
                var a = this.elements;
                return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])))
            }, makeTranslation: function (a, b, c) {
                this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1,
                    c, 0, 0, 0, 1);
                return this
            }, makeRotationX: function (a) {
                var b = Math.cos(a);
                a = Math.sin(a);
                this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
                return this
            }, makeRotationY: function (a) {
                var b = Math.cos(a);
                a = Math.sin(a);
                this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
                return this
            }, makeRotationZ: function (a) {
                var b = Math.cos(a);
                a = Math.sin(a);
                this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                return this
            }, makeRotationAxis: function (a, b) {
                var c = Math.cos(b), d = Math.sin(b), e = 1 - c, f = a.x, g = a.y, h = a.z, k = e * f, l = e * g;
                this.set(k * f + c, k * g - d * h, k * h + d * g, 0, k * g +
                    d * h, l * g + c, l * h - d * f, 0, k * h - d * g, l * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);
                return this
            }, makeScale: function (a, b, c) {
                this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
                return this
            }, compose: function (a, b, c) {
                this.makeRotationFromQuaternion(b);
                this.scale(c);
                this.setPosition(a);
                return this
            }, decompose: function () {
                var a = new THREE.Vector3, b = new THREE.Matrix4;
                return function (c, d, e) {
                    var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), k = a.set(f[8], f[9], f[10]).length();
                    0 > this.determinant() && (g = -g);
                    c.x = f[12];
                    c.y = f[13];
                    c.z = f[14];
                    b.elements.set(this.elements);
                    c = 1 / g;
                    var f = 1 / h, l = 1 / k;
                    b.elements[0] *= c;
                    b.elements[1] *= c;
                    b.elements[2] *= c;
                    b.elements[4] *= f;
                    b.elements[5] *= f;
                    b.elements[6] *= f;
                    b.elements[8] *= l;
                    b.elements[9] *= l;
                    b.elements[10] *= l;
                    d.setFromRotationMatrix(b);
                    e.x = g;
                    e.y = h;
                    e.z = k;
                    return this
                }
            }(), makeFrustum: function (a, b, c, d, e, f) {
                var g = this.elements;
                g[0] = 2 * e / (b - a);
                g[4] = 0;
                g[8] = (b + a) / (b - a);
                g[12] = 0;
                g[1] = 0;
                g[5] = 2 * e / (d - c);
                g[9] = (d + c) / (d - c);
                g[13] = 0;
                g[2] = 0;
                g[6] = 0;
                g[10] = -(f + e) / (f - e);
                g[14] = -2 * f * e / (f - e);
                g[3] = 0;
                g[7] = 0;
                g[11] = -1;
                g[15] = 0;
                return this
            }, makePerspective: function (a, b, c, d) {
                a = c * Math.tan(THREE.Math.degToRad(.5 * a));
                var e = -a;
                return this.makeFrustum(e * b, a * b, e, a, c, d)
            }, makeOrthographic: function (a, b, c, d, e, f) {
                var g = this.elements, h = b - a, k = c - d, l = f - e;
                g[0] = 2 / h;
                g[4] = 0;
                g[8] = 0;
                g[12] = -((b + a) / h);
                g[1] = 0;
                g[5] = 2 / k;
                g[9] = 0;
                g[13] = -((c + d) / k);
                g[2] = 0;
                g[6] = 0;
                g[10] = -2 / l;
                g[14] = -((f + e) / l);
                g[3] = 0;
                g[7] = 0;
                g[11] = 0;
                g[15] = 1;
                return this
            }, fromArray: function (a) {
                this.elements.set(a);
                return this
            }, toArray: function () {
                var a = this.elements;
                return [a[0],
                    a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]]
            }, clone: function () {
                return (new THREE.Matrix4).fromArray(this.elements)
            }
        };
        THREE.Ray = function (a, b) {
            this.origin = void 0 !== a ? a : new THREE.Vector3;
            this.direction = void 0 !== b ? b : new THREE.Vector3
        };
        THREE.Ray.prototype = {
            constructor: THREE.Ray, set: function (a, b) {
                this.origin.copy(a);
                this.direction.copy(b);
                return this
            }, copy: function (a) {
                this.origin.copy(a.origin);
                this.direction.copy(a.direction);
                return this
            }, at: function (a, b) {
                return (b || new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)
            }, recast: function () {
                var a = new THREE.Vector3;
                return function (b) {
                    this.origin.copy(this.at(b, a));
                    return this
                }
            }(), closestPointToPoint: function (a, b) {
                var c = b || new THREE.Vector3;
                c.subVectors(a, this.origin);
                var d = c.dot(this.direction);
                return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
            }, distanceToPoint: function () {
                var a = new THREE.Vector3;
                return function (b) {
                    var c = a.subVectors(b, this.origin).dot(this.direction);
                    if (0 > c)return this.origin.distanceTo(b);
                    a.copy(this.direction).multiplyScalar(c).add(this.origin);
                    return a.distanceTo(b)
                }
            }(), distanceSqToSegment: function () {
                var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3;
                return function (d, e, f, g) {
                    a.copy(d).add(e).multiplyScalar(.5);
                    b.copy(e).sub(d).normalize();
                    c.copy(this.origin).sub(a);
                    var h = .5 * d.distanceTo(e), k = -this.direction.dot(b), l = c.dot(this.direction), p = -c.dot(b), q = c.lengthSq(), n = Math.abs(1 - k * k), t;
                    0 < n ? (d = k * p - l, e = k * l - p, t = h * n, 0 <= d ? e >= -t ? e <= t ? (h = 1 / n, d *= h, e *= h, k = d * (d + k * e + 2 * l) + e * (k * d + e + 2 * p) + q) : (e = h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * p) + q) : (e = -h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * p) + q) : e <= -t ? (d = Math.max(0, -(-k * h + l)), e = 0 < d ? -h : Math.min(Math.max(-h, -p), h), k = -d * d + e * (e + 2 * p) + q) : e <= t ? (d = 0, e = Math.min(Math.max(-h, -p), h), k = e * (e +
                        2 * p) + q) : (d = Math.max(0, -(k * h + l)), e = 0 < d ? h : Math.min(Math.max(-h, -p), h), k = -d * d + e * (e + 2 * p) + q)) : (e = 0 < k ? -h : h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * p) + q);
                    f && f.copy(this.direction).multiplyScalar(d).add(this.origin);
                    g && g.copy(b).multiplyScalar(e).add(a);
                    return k
                }
            }(), isIntersectionSphere: function (a) {
                return this.distanceToPoint(a.center) <= a.radius
            }, intersectSphere: function () {
                var a = new THREE.Vector3;
                return function (b, c) {
                    a.subVectors(b.center, this.origin);
                    var d = a.dot(this.direction), e = a.dot(a) - d * d, f = b.radius * b.radius;
                    if (e > f)return null;
                    f = Math.sqrt(f - e);
                    e = d - f;
                    d += f;
                    return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c)
                }
            }(), isIntersectionPlane: function (a) {
                var b = a.distanceToPoint(this.origin);
                return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
            }, distanceToPlane: function (a) {
                var b = a.normal.dot(this.direction);
                if (0 == b)return 0 == a.distanceToPoint(this.origin) ? 0 : null;
                a = -(this.origin.dot(a.normal) + a.constant) / b;
                return 0 <= a ? a : null
            }, intersectPlane: function (a, b) {
                var c = this.distanceToPlane(a);
                return null === c ? null : this.at(c, b)
            },
            isIntersectionBox: function () {
                var a = new THREE.Vector3;
                return function (b) {
                    return null !== this.intersectBox(b, a)
                }
            }(), intersectBox: function (a, b) {
                var c, d, e, f, g;
                d = 1 / this.direction.x;
                f = 1 / this.direction.y;
                g = 1 / this.direction.z;
                var h = this.origin;
                0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);
                0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);
                if (c > f || e > d)return null;
                if (e > c || c !== c)c = e;
                if (f < d || d !== d)d = f;
                0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) *
                    g, g *= a.min.z - h.z);
                if (c > g || e > d)return null;
                if (e > c || c !== c)c = e;
                if (g < d || d !== d)d = g;
                return 0 > d ? null : this.at(0 <= c ? c : d, b)
            }, intersectTriangle: function () {
                var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3, d = new THREE.Vector3;
                return function (e, f, g, h, k) {
                    b.subVectors(f, e);
                    c.subVectors(g, e);
                    d.crossVectors(b, c);
                    f = this.direction.dot(d);
                    if (0 < f) {
                        if (h)return null;
                        h = 1
                    } else if (0 > f)h = -1, f = -f; else return null;
                    a.subVectors(this.origin, e);
                    e = h * this.direction.dot(c.crossVectors(a, c));
                    if (0 > e)return null;
                    g = h * this.direction.dot(b.cross(a));
                    if (0 > g || e + g > f)return null;
                    e = -h * a.dot(d);
                    return 0 > e ? null : this.at(e / f, k)
                }
            }(), applyMatrix4: function (a) {
                this.direction.add(this.origin).applyMatrix4(a);
                this.origin.applyMatrix4(a);
                this.direction.sub(this.origin);
                this.direction.normalize();
                return this
            }, equals: function (a) {
                return a.origin.equals(this.origin) && a.direction.equals(this.direction)
            }, clone: function () {
                return (new THREE.Ray).copy(this)
            }
        };
        THREE.Sphere = function (a, b) {
            this.center = void 0 !== a ? a : new THREE.Vector3;
            this.radius = void 0 !== b ? b : 0
        };
        THREE.Sphere.prototype = {
            constructor: THREE.Sphere, set: function (a, b) {
                this.center.copy(a);
                this.radius = b;
                return this
            }, setFromPoints: function () {
                var a = new THREE.Box3;
                return function (b, c) {
                    var d = this.center;
                    void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
                    for (var e = 0, f = 0, g = b.length; f < g; f++)e = Math.max(e, d.distanceToSquared(b[f]));
                    this.radius = Math.sqrt(e);
                    return this
                }
            }(), copy: function (a) {
                this.center.copy(a.center);
                this.radius = a.radius;
                return this
            }, empty: function () {
                return 0 >= this.radius
            }, containsPoint: function (a) {
                return a.distanceToSquared(this.center) <=
                    this.radius * this.radius
            }, distanceToPoint: function (a) {
                return a.distanceTo(this.center) - this.radius
            }, intersectsSphere: function (a) {
                var b = this.radius + a.radius;
                return a.center.distanceToSquared(this.center) <= b * b
            }, clampPoint: function (a, b) {
                var c = this.center.distanceToSquared(a), d = b || new THREE.Vector3;
                d.copy(a);
                c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));
                return d
            }, getBoundingBox: function (a) {
                a = a || new THREE.Box3;
                a.set(this.center, this.center);
                a.expandByScalar(this.radius);
                return a
            }, applyMatrix4: function (a) {
                this.center.applyMatrix4(a);
                this.radius *= a.getMaxScaleOnAxis();
                return this
            }, translate: function (a) {
                this.center.add(a);
                return this
            }, equals: function (a) {
                return a.center.equals(this.center) && a.radius === this.radius
            }, clone: function () {
                return (new THREE.Sphere).copy(this)
            }
        };
        THREE.Frustum = function (a, b, c, d, e, f) {
            this.planes = [void 0 !== a ? a : new THREE.Plane, void 0 !== b ? b : new THREE.Plane, void 0 !== c ? c : new THREE.Plane, void 0 !== d ? d : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== f ? f : new THREE.Plane]
        };
        THREE.Frustum.prototype = {
            constructor: THREE.Frustum, set: function (a, b, c, d, e, f) {
                var g = this.planes;
                g[0].copy(a);
                g[1].copy(b);
                g[2].copy(c);
                g[3].copy(d);
                g[4].copy(e);
                g[5].copy(f);
                return this
            }, copy: function (a) {
                for (var b = this.planes, c = 0; 6 > c; c++)b[c].copy(a.planes[c]);
                return this
            }, setFromMatrix: function (a) {
                var b = this.planes, c = a.elements;
                a = c[0];
                var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], k = c[6], l = c[7], p = c[8], q = c[9], n = c[10], t = c[11], r = c[12], s = c[13], u = c[14], c = c[15];
                b[0].setComponents(f - a, l - g, t - p, c - r).normalize();
                b[1].setComponents(f +
                    a, l + g, t + p, c + r).normalize();
                b[2].setComponents(f + d, l + h, t + q, c + s).normalize();
                b[3].setComponents(f - d, l - h, t - q, c - s).normalize();
                b[4].setComponents(f - e, l - k, t - n, c - u).normalize();
                b[5].setComponents(f + e, l + k, t + n, c + u).normalize();
                return this
            }, intersectsObject: function () {
                var a = new THREE.Sphere;
                return function (b) {
                    var c = b.geometry;
                    null === c.boundingSphere && c.computeBoundingSphere();
                    a.copy(c.boundingSphere);
                    a.applyMatrix4(b.matrixWorld);
                    return this.intersectsSphere(a)
                }
            }(), intersectsSphere: function (a) {
                var b = this.planes,
                    c = a.center;
                a = -a.radius;
                for (var d = 0; 6 > d; d++)if (b[d].distanceToPoint(c) < a)return !1;
                return !0
            }, intersectsBox: function () {
                var a = new THREE.Vector3, b = new THREE.Vector3;
                return function (c) {
                    for (var d = this.planes, e = 0; 6 > e; e++) {
                        var f = d[e];
                        a.x = 0 < f.normal.x ? c.min.x : c.max.x;
                        b.x = 0 < f.normal.x ? c.max.x : c.min.x;
                        a.y = 0 < f.normal.y ? c.min.y : c.max.y;
                        b.y = 0 < f.normal.y ? c.max.y : c.min.y;
                        a.z = 0 < f.normal.z ? c.min.z : c.max.z;
                        b.z = 0 < f.normal.z ? c.max.z : c.min.z;
                        var g = f.distanceToPoint(a), f = f.distanceToPoint(b);
                        if (0 > g && 0 > f)return !1
                    }
                    return !0
                }
            }(),
            containsPoint: function (a) {
                for (var b = this.planes, c = 0; 6 > c; c++)if (0 > b[c].distanceToPoint(a))return !1;
                return !0
            }, clone: function () {
                return (new THREE.Frustum).copy(this)
            }
        };
        THREE.Plane = function (a, b) {
            this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
            this.constant = void 0 !== b ? b : 0
        };
        THREE.Plane.prototype = {
            constructor: THREE.Plane, set: function (a, b) {
                this.normal.copy(a);
                this.constant = b;
                return this
            }, setComponents: function (a, b, c, d) {
                this.normal.set(a, b, c);
                this.constant = d;
                return this
            }, setFromNormalAndCoplanarPoint: function (a, b) {
                this.normal.copy(a);
                this.constant = -b.dot(this.normal);
                return this
            }, setFromCoplanarPoints: function () {
                var a = new THREE.Vector3, b = new THREE.Vector3;
                return function (c, d, e) {
                    d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
                    this.setFromNormalAndCoplanarPoint(d,
                        c);
                    return this
                }
            }(), copy: function (a) {
                this.normal.copy(a.normal);
                this.constant = a.constant;
                return this
            }, normalize: function () {
                var a = 1 / this.normal.length();
                this.normal.multiplyScalar(a);
                this.constant *= a;
                return this
            }, negate: function () {
                this.constant *= -1;
                this.normal.negate();
                return this
            }, distanceToPoint: function (a) {
                return this.normal.dot(a) + this.constant
            }, distanceToSphere: function (a) {
                return this.distanceToPoint(a.center) - a.radius
            }, projectPoint: function (a, b) {
                return this.orthoPoint(a, b).sub(a).negate()
            }, orthoPoint: function (a,
                                     b) {
                var c = this.distanceToPoint(a);
                return (b || new THREE.Vector3).copy(this.normal).multiplyScalar(c)
            }, isIntersectionLine: function (a) {
                var b = this.distanceToPoint(a.start);
                a = this.distanceToPoint(a.end);
                return 0 > b && 0 < a || 0 > a && 0 < b
            }, intersectLine: function () {
                var a = new THREE.Vector3;
                return function (b, c) {
                    var d = c || new THREE.Vector3, e = b.delta(a), f = this.normal.dot(e);
                    if (0 == f) {
                        if (0 == this.distanceToPoint(b.start))return d.copy(b.start)
                    } else return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)
                }
            }(),
            coplanarPoint: function (a) {
                return (a || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
            }, applyMatrix4: function () {
                var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Matrix3;
                return function (d, e) {
                    var f = e || c.getNormalMatrix(d), f = a.copy(this.normal).applyMatrix3(f), g = this.coplanarPoint(b);
                    g.applyMatrix4(d);
                    this.setFromNormalAndCoplanarPoint(f, g);
                    return this
                }
            }(), translate: function (a) {
                this.constant -= a.dot(this.normal);
                return this
            }, equals: function (a) {
                return a.normal.equals(this.normal) &&
                    a.constant == this.constant
            }, clone: function () {
                return (new THREE.Plane).copy(this)
            }
        };
        THREE.Math = {
            generateUUID: function () {
                var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), b = Array(36), c = 0, d;
                return function () {
                    for (var e = 0; 36 > e; e++)8 == e || 13 == e || 18 == e || 23 == e ? b[e] = "-" : 14 == e ? b[e] = "4" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 == e ? d & 3 | 8 : d]);
                    return b.join("")
                }
            }(), clamp: function (a, b, c) {
                return a < b ? b : a > c ? c : a
            }, clampBottom: function (a, b) {
                return a < b ? b : a
            }, mapLinear: function (a, b, c, d, e) {
                return d + (a - b) * (e - d) / (c - b)
            }, smoothstep: function (a, b, c) {
                if (a <=
                    b)return 0;
                if (a >= c)return 1;
                a = (a - b) / (c - b);
                return a * a * (3 - 2 * a)
            }, smootherstep: function (a, b, c) {
                if (a <= b)return 0;
                if (a >= c)return 1;
                a = (a - b) / (c - b);
                return a * a * a * (a * (6 * a - 15) + 10)
            }, random16: function () {
                return (65280 * Math.random() + 255 * Math.random()) / 65535
            }, randInt: function (a, b) {
                return Math.floor(this.randFloat(a, b))
            }, randFloat: function (a, b) {
                return a + Math.random() * (b - a)
            }, randFloatSpread: function (a) {
                return a * (.5 - Math.random())
            }, degToRad: function () {
                var a = Math.PI / 180;
                return function (b) {
                    return b * a
                }
            }(), radToDeg: function () {
                var a =
                    180 / Math.PI;
                return function (b) {
                    return b * a
                }
            }(), isPowerOfTwo: function (a) {
                return 0 === (a & a - 1) && 0 !== a
            }, nextPowerOfTwo: function (a) {
                a--;
                a |= a >> 1;
                a |= a >> 2;
                a |= a >> 4;
                a |= a >> 8;
                a |= a >> 16;
                a++;
                return a
            }
        };
        THREE.Spline = function (a) {
            function b(a, b, c, d, e, f, g) {
                a = .5 * (c - a);
                d = .5 * (d - b);
                return (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b
            }

            this.points = a;
            var c = [], d = {x: 0, y: 0, z: 0}, e, f, g, h, k, l, p, q, n;
            this.initFromArray = function (a) {
                this.points = [];
                for (var b = 0; b < a.length; b++)this.points[b] = {x: a[b][0], y: a[b][1], z: a[b][2]}
            };
            this.getPoint = function (a) {
                e = (this.points.length - 1) * a;
                f = Math.floor(e);
                g = e - f;
                c[0] = 0 === f ? f : f - 1;
                c[1] = f;
                c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;
                c[3] = f > this.points.length - 3 ? this.points.length - 1 : f +
                2;
                l = this.points[c[0]];
                p = this.points[c[1]];
                q = this.points[c[2]];
                n = this.points[c[3]];
                h = g * g;
                k = g * h;
                d.x = b(l.x, p.x, q.x, n.x, g, h, k);
                d.y = b(l.y, p.y, q.y, n.y, g, h, k);
                d.z = b(l.z, p.z, q.z, n.z, g, h, k);
                return d
            };
            this.getControlPointsArray = function () {
                var a, b, c = this.points.length, d = [];
                for (a = 0; a < c; a++)b = this.points[a], d[a] = [b.x, b.y, b.z];
                return d
            };
            this.getLength = function (a) {
                var b, c, d, e = b = b = 0, f = new THREE.Vector3, g = new THREE.Vector3, h = [], k = 0;
                h[0] = 0;
                a || (a = 100);
                c = this.points.length * a;
                f.copy(this.points[0]);
                for (a = 1; a < c; a++)b =
                    a / c, d = this.getPoint(b), g.copy(d), k += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = k, e = b);
                h[h.length] = k;
                return {chunks: h, total: k}
            };
            this.reparametrizeByArcLength = function (a) {
                var b, c, d, e, f, g, h = [], k = new THREE.Vector3, n = this.getLength();
                h.push(k.copy(this.points[0]).clone());
                for (b = 1; b < this.points.length; b++) {
                    c = n.chunks[b] - n.chunks[b - 1];
                    g = Math.ceil(a * c / n.total);
                    e = (b - 1) / (this.points.length - 1);
                    f = b / (this.points.length - 1);
                    for (c = 1; c < g - 1; c++)d = e + 1 / g * c * (f - e), d = this.getPoint(d), h.push(k.copy(d).clone());
                    h.push(k.copy(this.points[b]).clone())
                }
                this.points = h
            }
        };
        THREE.Triangle = function (a, b, c) {
            this.a = void 0 !== a ? a : new THREE.Vector3;
            this.b = void 0 !== b ? b : new THREE.Vector3;
            this.c = void 0 !== c ? c : new THREE.Vector3
        };
        THREE.Triangle.normal = function () {
            var a = new THREE.Vector3;
            return function (b, c, d, e) {
                e = e || new THREE.Vector3;
                e.subVectors(d, c);
                a.subVectors(b, c);
                e.cross(a);
                b = e.lengthSq();
                return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
            }
        }();
        THREE.Triangle.barycoordFromPoint = function () {
            var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3;
            return function (d, e, f, g, h) {
                a.subVectors(g, e);
                b.subVectors(f, e);
                c.subVectors(d, e);
                d = a.dot(a);
                e = a.dot(b);
                f = a.dot(c);
                var k = b.dot(b);
                g = b.dot(c);
                var l = d * k - e * e;
                h = h || new THREE.Vector3;
                if (0 == l)return h.set(-2, -1, -1);
                l = 1 / l;
                k = (k * f - e * g) * l;
                d = (d * g - e * f) * l;
                return h.set(1 - k - d, d, k)
            }
        }();
        THREE.Triangle.containsPoint = function () {
            var a = new THREE.Vector3;
            return function (b, c, d, e) {
                b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
                return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
            }
        }();
        THREE.Triangle.prototype = {
            constructor: THREE.Triangle, set: function (a, b, c) {
                this.a.copy(a);
                this.b.copy(b);
                this.c.copy(c);
                return this
            }, setFromPointsAndIndices: function (a, b, c, d) {
                this.a.copy(a[b]);
                this.b.copy(a[c]);
                this.c.copy(a[d]);
                return this
            }, copy: function (a) {
                this.a.copy(a.a);
                this.b.copy(a.b);
                this.c.copy(a.c);
                return this
            }, area: function () {
                var a = new THREE.Vector3, b = new THREE.Vector3;
                return function () {
                    a.subVectors(this.c, this.b);
                    b.subVectors(this.a, this.b);
                    return .5 * a.cross(b).length()
                }
            }(), midpoint: function (a) {
                return (a ||
                new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }, normal: function (a) {
                return THREE.Triangle.normal(this.a, this.b, this.c, a)
            }, plane: function (a) {
                return (a || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
            }, barycoordFromPoint: function (a, b) {
                return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
            }, containsPoint: function (a) {
                return THREE.Triangle.containsPoint(a, this.a, this.b, this.c)
            }, equals: function (a) {
                return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
            },
            clone: function () {
                return (new THREE.Triangle).copy(this)
            }
        };
        THREE.Clock = function (a) {
            this.autoStart = void 0 !== a ? a : !0;
            this.elapsedTime = this.oldTime = this.startTime = 0;
            this.running = !1
        };
        THREE.Clock.prototype = {
            constructor: THREE.Clock, start: function () {
                this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
                this.running = !0
            }, stop: function () {
                this.getElapsedTime();
                this.running = !1
            }, getElapsedTime: function () {
                this.getDelta();
                return this.elapsedTime
            }, getDelta: function () {
                var a = 0;
                this.autoStart && !this.running && this.start();
                if (this.running) {
                    var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(),
                        a = .001 * (b - this.oldTime);
                    this.oldTime = b;
                    this.elapsedTime += a
                }
                return a
            }
        };
        THREE.EventDispatcher = function () {
        };
        THREE.EventDispatcher.prototype = {
            constructor: THREE.EventDispatcher, apply: function (a) {
                a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
                a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
                a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
                a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
            }, addEventListener: function (a, b) {
                void 0 === this._listeners && (this._listeners = {});
                var c = this._listeners;
                void 0 === c[a] && (c[a] = []);
                -1 === c[a].indexOf(b) &&
                c[a].push(b)
            }, hasEventListener: function (a, b) {
                if (void 0 === this._listeners)return !1;
                var c = this._listeners;
                return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1
            }, removeEventListener: function (a, b) {
                if (void 0 !== this._listeners) {
                    var c = this._listeners[a];
                    if (void 0 !== c) {
                        var d = c.indexOf(b);
                        -1 !== d && c.splice(d, 1)
                    }
                }
            }, dispatchEvent: function (a) {
                if (void 0 !== this._listeners) {
                    var b = this._listeners[a.type];
                    if (void 0 !== b) {
                        a.target = this;
                        for (var c = [], d = b.length, e = 0; e < d; e++)c[e] = b[e];
                        for (e = 0; e < d; e++)c[e].call(this, a)
                    }
                }
            }
        };
        (function (a) {
            a.Raycaster = function (b, c, f, g) {
                this.ray = new a.Ray(b, c);
                this.near = f || 0;
                this.far = g || Infinity;
                this.params = {Sprite: {}, Mesh: {}, PointCloud: {threshold: 1}, LOD: {}, Line: {}}
            };
            var b = function (a, b) {
                return a.distance - b.distance
            }, c = function (a, b, f, g) {
                a.raycast(b, f);
                if (!0 === g) {
                    a = a.children;
                    g = 0;
                    for (var h = a.length; g < h; g++)c(a[g], b, f, !0)
                }
            };
            a.Raycaster.prototype = {
                constructor: a.Raycaster, precision: 1E-4, linePrecision: 1, set: function (a, b) {
                    this.ray.set(a, b)
                }, setFromCamera: function (b, c) {
                    c instanceof a.PerspectiveCamera ?
                        (this.ray.origin.copy(c.position), this.ray.direction.set(b.x, b.y, .5).unproject(c).sub(c.position).normalize()) : c instanceof a.OrthographicCamera ? (this.ray.origin.set(b.x, b.y, -1).unproject(c), this.ray.direction.set(0, 0, -1).transformDirection(c.matrixWorld)) : a.error("THREE.Raycaster: Unsupported camera type.")
                }, intersectObject: function (a, e) {
                    var f = [];
                    c(a, this, f, e);
                    f.sort(b);
                    return f
                }, intersectObjects: function (d, e) {
                    var f = [];
                    if (!1 === d instanceof Array)return a.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                        f;
                    for (var g = 0, h = d.length; g < h; g++)c(d[g], this, f, e);
                    f.sort(b);
                    return f
                }
            }
        })(THREE);
        THREE.Object3D = function () {
            Object.defineProperty(this, "id", {value: THREE.Object3DIdCount++});
            this.uuid = THREE.Math.generateUUID();
            this.name = "";
            this.type = "Object3D";
            this.parent = void 0;
            this.children = [];
            this.up = THREE.Object3D.DefaultUp.clone();
            var a = new THREE.Vector3, b = new THREE.Euler, c = new THREE.Quaternion, d = new THREE.Vector3(1, 1, 1);
            b.onChange(function () {
                c.setFromEuler(b, !1)
            });
            c.onChange(function () {
                b.setFromQuaternion(c, void 0, !1)
            });
            Object.defineProperties(this, {
                position: {enumerable: !0, value: a}, rotation: {
                    enumerable: !0,
                    value: b
                }, quaternion: {enumerable: !0, value: c}, scale: {enumerable: !0, value: d}
            });
            this.rotationAutoUpdate = !0;
            this.matrix = new THREE.Matrix4;
            this.matrixWorld = new THREE.Matrix4;
            this.matrixAutoUpdate = !0;
            this.matrixWorldNeedsUpdate = !1;
            this.visible = !0;
            this.receiveShadow = this.castShadow = !1;
            this.frustumCulled = !0;
            this.renderOrder = 0;
            this.userData = {}
        };
        THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
        THREE.Object3D.prototype = {
            constructor: THREE.Object3D, get eulerOrder() {
                THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");
                return this.rotation.order
            }, set eulerOrder(a) {
                THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");
                this.rotation.order = a
            }, get useQuaternion() {
                THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }, set useQuaternion(a) {
                THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            applyMatrix: function (a) {
                this.matrix.multiplyMatrices(a, this.matrix);
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }, setRotationFromAxisAngle: function (a, b) {
                this.quaternion.setFromAxisAngle(a, b)
            }, setRotationFromEuler: function (a) {
                this.quaternion.setFromEuler(a, !0)
            }, setRotationFromMatrix: function (a) {
                this.quaternion.setFromRotationMatrix(a)
            }, setRotationFromQuaternion: function (a) {
                this.quaternion.copy(a)
            }, rotateOnAxis: function () {
                var a = new THREE.Quaternion;
                return function (b, c) {
                    a.setFromAxisAngle(b,
                        c);
                    this.quaternion.multiply(a);
                    return this
                }
            }(), rotateX: function () {
                var a = new THREE.Vector3(1, 0, 0);
                return function (b) {
                    return this.rotateOnAxis(a, b)
                }
            }(), rotateY: function () {
                var a = new THREE.Vector3(0, 1, 0);
                return function (b) {
                    return this.rotateOnAxis(a, b)
                }
            }(), rotateZ: function () {
                var a = new THREE.Vector3(0, 0, 1);
                return function (b) {
                    return this.rotateOnAxis(a, b)
                }
            }(), translateOnAxis: function () {
                var a = new THREE.Vector3;
                return function (b, c) {
                    a.copy(b).applyQuaternion(this.quaternion);
                    this.position.add(a.multiplyScalar(c));
                    return this
                }
            }(), translate: function (a, b) {
                THREE.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
                return this.translateOnAxis(b, a)
            }, translateX: function () {
                var a = new THREE.Vector3(1, 0, 0);
                return function (b) {
                    return this.translateOnAxis(a, b)
                }
            }(), translateY: function () {
                var a = new THREE.Vector3(0, 1, 0);
                return function (b) {
                    return this.translateOnAxis(a, b)
                }
            }(), translateZ: function () {
                var a = new THREE.Vector3(0, 0, 1);
                return function (b) {
                    return this.translateOnAxis(a,
                        b)
                }
            }(), localToWorld: function (a) {
                return a.applyMatrix4(this.matrixWorld)
            }, worldToLocal: function () {
                var a = new THREE.Matrix4;
                return function (b) {
                    return b.applyMatrix4(a.getInverse(this.matrixWorld))
                }
            }(), lookAt: function () {
                var a = new THREE.Matrix4;
                return function (b) {
                    a.lookAt(b, this.position, this.up);
                    this.quaternion.setFromRotationMatrix(a)
                }
            }(), add: function (a) {
                if (1 < arguments.length) {
                    for (var b = 0; b < arguments.length; b++)this.add(arguments[b]);
                    return this
                }
                if (a === this)return THREE.error("THREE.Object3D.add: object can't be added as a child of itself.",
                    a), this;
                a instanceof THREE.Object3D ? (void 0 !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type: "added"}), this.children.push(a)) : THREE.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
                return this
            }, remove: function (a) {
                if (1 < arguments.length)for (var b = 0; b < arguments.length; b++)this.remove(arguments[b]);
                b = this.children.indexOf(a);
                -1 !== b && (a.parent = void 0, a.dispatchEvent({type: "removed"}), this.children.splice(b, 1))
            }, getChildByName: function (a) {
                THREE.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
                return this.getObjectByName(a)
            }, getObjectById: function (a) {
                return this.getObjectByProperty("id", a)
            }, getObjectByName: function (a) {
                return this.getObjectByProperty("name", a)
            }, getObjectByProperty: function (a, b) {
                if (this[a] === b)return this;
                for (var c = 0, d = this.children.length; c < d; c++) {
                    var e = this.children[c].getObjectByProperty(a, b);
                    if (void 0 !== e)return e
                }
            }, getWorldPosition: function (a) {
                a = a || new THREE.Vector3;
                this.updateMatrixWorld(!0);
                return a.setFromMatrixPosition(this.matrixWorld)
            }, getWorldQuaternion: function () {
                var a =
                    new THREE.Vector3, b = new THREE.Vector3;
                return function (c) {
                    c = c || new THREE.Quaternion;
                    this.updateMatrixWorld(!0);
                    this.matrixWorld.decompose(a, c, b);
                    return c
                }
            }(), getWorldRotation: function () {
                var a = new THREE.Quaternion;
                return function (b) {
                    b = b || new THREE.Euler;
                    this.getWorldQuaternion(a);
                    return b.setFromQuaternion(a, this.rotation.order, !1)
                }
            }(), getWorldScale: function () {
                var a = new THREE.Vector3, b = new THREE.Quaternion;
                return function (c) {
                    c = c || new THREE.Vector3;
                    this.updateMatrixWorld(!0);
                    this.matrixWorld.decompose(a,
                        b, c);
                    return c
                }
            }(), getWorldDirection: function () {
                var a = new THREE.Quaternion;
                return function (b) {
                    b = b || new THREE.Vector3;
                    this.getWorldQuaternion(a);
                    return b.set(0, 0, 1).applyQuaternion(a)
                }
            }(), raycast: function () {
            }, traverse: function (a) {
                a(this);
                for (var b = 0, c = this.children.length; b < c; b++)this.children[b].traverse(a)
            }, traverseVisible: function (a) {
                if (!1 !== this.visible) {
                    a(this);
                    for (var b = 0, c = this.children.length; b < c; b++)this.children[b].traverseVisible(a)
                }
            }, traverseAncestors: function (a) {
                this.parent && (a(this.parent),
                    this.parent.traverseAncestors(a))
            }, updateMatrix: function () {
                this.matrix.compose(this.position, this.quaternion, this.scale);
                this.matrixWorldNeedsUpdate = !0
            }, updateMatrixWorld: function (a) {
                !0 === this.matrixAutoUpdate && this.updateMatrix();
                if (!0 === this.matrixWorldNeedsUpdate || !0 === a)void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
                for (var b = 0, c = this.children.length; b < c; b++)this.children[b].updateMatrixWorld(a)
            },
            toJSON: function () {
                var a = {metadata: {version: 4.3, type: "Object", generator: "ObjectExporter"}}, b = {}, c = {}, d = function (b) {
                    void 0 === a.materials && (a.materials = []);
                    if (void 0 === c[b.uuid]) {
                        var d = b.toJSON();
                        delete d.metadata;
                        c[b.uuid] = d;
                        a.materials.push(d)
                    }
                    return b.uuid
                }, e = function (c) {
                    var g = {};
                    g.uuid = c.uuid;
                    g.type = c.type;
                    "" !== c.name && (g.name = c.name);
                    "{}" !== JSON.stringify(c.userData) && (g.userData = c.userData);
                    !0 !== c.visible && (g.visible = c.visible);
                    if (c instanceof THREE.PerspectiveCamera)g.fov = c.fov, g.aspect = c.aspect,
                        g.near = c.near, g.far = c.far; else if (c instanceof THREE.OrthographicCamera)g.left = c.left, g.right = c.right, g.top = c.top, g.bottom = c.bottom, g.near = c.near, g.far = c.far; else if (c instanceof THREE.AmbientLight)g.color = c.color.getHex(); else if (c instanceof THREE.DirectionalLight)g.color = c.color.getHex(), g.intensity = c.intensity; else if (c instanceof THREE.PointLight)g.color = c.color.getHex(), g.intensity = c.intensity, g.distance = c.distance, g.decay = c.decay; else if (c instanceof THREE.SpotLight)g.color = c.color.getHex(),
                        g.intensity = c.intensity, g.distance = c.distance, g.angle = c.angle, g.exponent = c.exponent, g.decay = c.decay; else if (c instanceof THREE.HemisphereLight)g.color = c.color.getHex(), g.groundColor = c.groundColor.getHex(); else if (c instanceof THREE.Mesh || c instanceof THREE.Line || c instanceof THREE.PointCloud) {
                        var h = c.geometry;
                        void 0 === a.geometries && (a.geometries = []);
                        if (void 0 === b[h.uuid]) {
                            var k = h.toJSON();
                            delete k.metadata;
                            b[h.uuid] = k;
                            a.geometries.push(k)
                        }
                        g.geometry = h.uuid;
                        g.material = d(c.material);
                        c instanceof THREE.Line &&
                        (g.mode = c.mode)
                    } else c instanceof THREE.Sprite && (g.material = d(c.material));
                    g.matrix = c.matrix.toArray();
                    if (0 < c.children.length)for (g.children = [], h = 0; h < c.children.length; h++)g.children.push(e(c.children[h]));
                    return g
                };
                a.object = e(this);
                return a
            }, clone: function (a, b) {
                void 0 === a && (a = new THREE.Object3D);
                void 0 === b && (b = !0);
                a.name = this.name;
                a.up.copy(this.up);
                a.position.copy(this.position);
                a.quaternion.copy(this.quaternion);
                a.scale.copy(this.scale);
                a.rotationAutoUpdate = this.rotationAutoUpdate;
                a.matrix.copy(this.matrix);
                a.matrixWorld.copy(this.matrixWorld);
                a.matrixAutoUpdate = this.matrixAutoUpdate;
                a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
                a.visible = this.visible;
                a.castShadow = this.castShadow;
                a.receiveShadow = this.receiveShadow;
                a.frustumCulled = this.frustumCulled;
                a.userData = JSON.parse(JSON.stringify(this.userData));
                if (!0 === b)for (var c = 0; c < this.children.length; c++)a.add(this.children[c].clone());
                return a
            }
        };
        THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
        THREE.Object3DIdCount = 0;
        THREE.Face3 = function (a, b, c, d, e, f) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3;
            this.vertexNormals = d instanceof Array ? d : [];
            this.color = e instanceof THREE.Color ? e : new THREE.Color;
            this.vertexColors = e instanceof Array ? e : [];
            this.vertexTangents = [];
            this.materialIndex = void 0 !== f ? f : 0
        };
        THREE.Face3.prototype = {
            constructor: THREE.Face3, clone: function () {
                var a = new THREE.Face3(this.a, this.b, this.c);
                a.normal.copy(this.normal);
                a.color.copy(this.color);
                a.materialIndex = this.materialIndex;
                for (var b = 0, c = this.vertexNormals.length; b < c; b++)a.vertexNormals[b] = this.vertexNormals[b].clone();
                b = 0;
                for (c = this.vertexColors.length; b < c; b++)a.vertexColors[b] = this.vertexColors[b].clone();
                b = 0;
                for (c = this.vertexTangents.length; b < c; b++)a.vertexTangents[b] = this.vertexTangents[b].clone();
                return a
            }
        };
        THREE.Face4 = function (a, b, c, d, e, f, g) {
            THREE.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
            return new THREE.Face3(a, b, c, e, f, g)
        };
        THREE.BufferAttribute = function (a, b) {
            this.array = a;
            this.itemSize = b;
            this.needsUpdate = !1
        };
        THREE.BufferAttribute.prototype = {
            constructor: THREE.BufferAttribute, get length() {
                return this.array.length
            }, copyAt: function (a, b, c) {
                a *= this.itemSize;
                c *= b.itemSize;
                for (var d = 0, e = this.itemSize; d < e; d++)this.array[a + d] = b.array[c + d];
                return this
            }, set: function (a, b) {
                void 0 === b && (b = 0);
                this.array.set(a, b);
                return this
            }, setX: function (a, b) {
                this.array[a * this.itemSize] = b;
                return this
            }, setY: function (a, b) {
                this.array[a * this.itemSize + 1] = b;
                return this
            }, setZ: function (a, b) {
                this.array[a * this.itemSize + 2] = b;
                return this
            }, setXY: function (a,
                                b, c) {
                a *= this.itemSize;
                this.array[a] = b;
                this.array[a + 1] = c;
                return this
            }, setXYZ: function (a, b, c, d) {
                a *= this.itemSize;
                this.array[a] = b;
                this.array[a + 1] = c;
                this.array[a + 2] = d;
                return this
            }, setXYZW: function (a, b, c, d, e) {
                a *= this.itemSize;
                this.array[a] = b;
                this.array[a + 1] = c;
                this.array[a + 2] = d;
                this.array[a + 3] = e;
                return this
            }, clone: function () {
                return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize)
            }
        };
        THREE.Int8Attribute = function (a, b) {
            THREE.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
            return new THREE.BufferAttribute(a, b)
        };
        THREE.Uint8Attribute = function (a, b) {
            THREE.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
            return new THREE.BufferAttribute(a, b)
        };
        THREE.Uint8ClampedAttribute = function (a, b) {
            THREE.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
            return new THREE.BufferAttribute(a, b)
        };
        THREE.Int16Attribute = function (a, b) {
            THREE.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
            return new THREE.BufferAttribute(a, b)
        };
        THREE.Uint16Attribute = function (a, b) {
            THREE.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
            return new THREE.BufferAttribute(a, b)
        };
        THREE.Int32Attribute = function (a, b) {
            THREE.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
            return new THREE.BufferAttribute(a, b)
        };
        THREE.Uint32Attribute = function (a, b) {
            THREE.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
            return new THREE.BufferAttribute(a, b)
        };
        THREE.Float32Attribute = function (a, b) {
            THREE.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
            return new THREE.BufferAttribute(a, b)
        };
        THREE.Float64Attribute = function (a, b) {
            THREE.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
            return new THREE.BufferAttribute(a, b)
        };
        THREE.DynamicBufferAttribute = function (a, b) {
            THREE.BufferAttribute.call(this, a, b);
            this.updateRange = {offset: 0, count: -1}
        };
        THREE.DynamicBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
        THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;
        THREE.DynamicBufferAttribute.prototype.clone = function () {
            return new THREE.DynamicBufferAttribute(new this.array.constructor(this.array), this.itemSize)
        };
        THREE.BufferGeometry = function () {
            Object.defineProperty(this, "id", {value: THREE.GeometryIdCount++});
            this.uuid = THREE.Math.generateUUID();
            this.name = "";
            this.type = "BufferGeometry";
            this.attributes = {};
            this.attributesKeys = [];
            this.offsets = this.drawcalls = [];
            this.boundingSphere = this.boundingBox = null
        };
        THREE.BufferGeometry.prototype = {
            constructor: THREE.BufferGeometry, addAttribute: function (a, b, c) {
                !1 === b instanceof THREE.BufferAttribute ? (THREE.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.attributes[a] = {
                    array: b,
                    itemSize: c
                }) : (this.attributes[a] = b, this.attributesKeys = Object.keys(this.attributes))
            }, getAttribute: function (a) {
                return this.attributes[a]
            }, addDrawCall: function (a, b, c) {
                this.drawcalls.push({start: a, count: b, index: void 0 !== c ? c : 0})
            }, applyMatrix: function (a) {
                var b =
                    this.attributes.position;
                void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0);
                b = this.attributes.normal;
                void 0 !== b && ((new THREE.Matrix3).getNormalMatrix(a).applyToVector3Array(b.array), b.needsUpdate = !0);
                null !== this.boundingBox && this.computeBoundingBox();
                null !== this.boundingSphere && this.computeBoundingSphere()
            }, center: function () {
                this.computeBoundingBox();
                var a = this.boundingBox.center().negate();
                this.applyMatrix((new THREE.Matrix4).setPosition(a));
                return a
            }, fromGeometry: function (a, b) {
                b = b || {vertexColors: THREE.NoColors};
                var c = a.vertices, d = a.faces, e = a.faceVertexUvs, f = b.vertexColors, g = 0 < e[0].length, h = 3 == d[0].vertexNormals.length, k = new Float32Array(9 * d.length);
                this.addAttribute("position", new THREE.BufferAttribute(k, 3));
                var l = new Float32Array(9 * d.length);
                this.addAttribute("normal", new THREE.BufferAttribute(l, 3));
                if (f !== THREE.NoColors) {
                    var p = new Float32Array(9 * d.length);
                    this.addAttribute("color", new THREE.BufferAttribute(p, 3))
                }
                if (!0 === g) {
                    var q = new Float32Array(6 * d.length);
                    this.addAttribute("uv", new THREE.BufferAttribute(q,
                        2))
                }
                for (var n = 0, t = 0, r = 0; n < d.length; n++, t += 6, r += 9) {
                    var s = d[n], u = c[s.a], v = c[s.b], x = c[s.c];
                    k[r] = u.x;
                    k[r + 1] = u.y;
                    k[r + 2] = u.z;
                    k[r + 3] = v.x;
                    k[r + 4] = v.y;
                    k[r + 5] = v.z;
                    k[r + 6] = x.x;
                    k[r + 7] = x.y;
                    k[r + 8] = x.z;
                    !0 === h ? (u = s.vertexNormals[0], v = s.vertexNormals[1], x = s.vertexNormals[2], l[r] = u.x, l[r + 1] = u.y, l[r + 2] = u.z, l[r + 3] = v.x, l[r + 4] = v.y, l[r + 5] = v.z, l[r + 6] = x.x, l[r + 7] = x.y, l[r + 8] = x.z) : (u = s.normal, l[r] = u.x, l[r + 1] = u.y, l[r + 2] = u.z, l[r + 3] = u.x, l[r + 4] = u.y, l[r + 5] = u.z, l[r + 6] = u.x, l[r + 7] = u.y, l[r + 8] = u.z);
                    f === THREE.FaceColors ? (s = s.color, p[r] =
                        s.r, p[r + 1] = s.g, p[r + 2] = s.b, p[r + 3] = s.r, p[r + 4] = s.g, p[r + 5] = s.b, p[r + 6] = s.r, p[r + 7] = s.g, p[r + 8] = s.b) : f === THREE.VertexColors && (u = s.vertexColors[0], v = s.vertexColors[1], s = s.vertexColors[2], p[r] = u.r, p[r + 1] = u.g, p[r + 2] = u.b, p[r + 3] = v.r, p[r + 4] = v.g, p[r + 5] = v.b, p[r + 6] = s.r, p[r + 7] = s.g, p[r + 8] = s.b);
                    !0 === g && (s = e[0][n][0], u = e[0][n][1], v = e[0][n][2], q[t] = s.x, q[t + 1] = s.y, q[t + 2] = u.x, q[t + 3] = u.y, q[t + 4] = v.x, q[t + 5] = v.y)
                }
                this.computeBoundingSphere();
                return this
            }, computeBoundingBox: function () {
                var a = new THREE.Vector3;
                return function () {
                    null ===
                    this.boundingBox && (this.boundingBox = new THREE.Box3);
                    var b = this.attributes.position.array;
                    if (b) {
                        var c = this.boundingBox;
                        c.makeEmpty();
                        for (var d = 0, e = b.length; d < e; d += 3)a.set(b[d], b[d + 1], b[d + 2]), c.expandByPoint(a)
                    }
                    if (void 0 === b || 0 === b.length)this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && THREE.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.')
                }
            }(),
            computeBoundingSphere: function () {
                var a = new THREE.Box3, b = new THREE.Vector3;
                return function () {
                    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
                    var c = this.attributes.position.array;
                    if (c) {
                        a.makeEmpty();
                        for (var d = this.boundingSphere.center, e = 0, f = c.length; e < f; e += 3)b.set(c[e], c[e + 1], c[e + 2]), a.expandByPoint(b);
                        a.center(d);
                        for (var g = 0, e = 0, f = c.length; e < f; e += 3)b.set(c[e], c[e + 1], c[e + 2]), g = Math.max(g, d.distanceToSquared(b));
                        this.boundingSphere.radius = Math.sqrt(g);
                        isNaN(this.boundingSphere.radius) &&
                        THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
                    }
                }
            }(), computeFaceNormals: function () {
            }, computeVertexNormals: function () {
                var a = this.attributes;
                if (a.position) {
                    var b = a.position.array;
                    if (void 0 === a.normal)this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(b.length), 3)); else for (var c = a.normal.array, d = 0, e = c.length; d < e; d++)c[d] = 0;
                    var c = a.normal.array, f, g, h, k = new THREE.Vector3, l = new THREE.Vector3,
                        p = new THREE.Vector3, q = new THREE.Vector3, n = new THREE.Vector3;
                    if (a.index)for (var t = a.index.array, r = 0 < this.offsets.length ? this.offsets : [{start: 0, count: t.length, index: 0}], s = 0, u = r.length; s < u; ++s) {
                        e = r[s].start;
                        f = r[s].count;
                        for (var v = r[s].index, d = e, e = e + f; d < e; d += 3)f = 3 * (v + t[d]), g = 3 * (v + t[d + 1]), h = 3 * (v + t[d + 2]), k.fromArray(b, f), l.fromArray(b, g), p.fromArray(b, h), q.subVectors(p, l), n.subVectors(k, l), q.cross(n), c[f] += q.x, c[f + 1] += q.y, c[f + 2] += q.z, c[g] += q.x, c[g + 1] += q.y, c[g + 2] += q.z, c[h] += q.x, c[h + 1] += q.y, c[h + 2] += q.z
                    } else for (d =
                                    0, e = b.length; d < e; d += 9)k.fromArray(b, d), l.fromArray(b, d + 3), p.fromArray(b, d + 6), q.subVectors(p, l), n.subVectors(k, l), q.cross(n), c[d] = q.x, c[d + 1] = q.y, c[d + 2] = q.z, c[d + 3] = q.x, c[d + 4] = q.y, c[d + 5] = q.z, c[d + 6] = q.x, c[d + 7] = q.y, c[d + 8] = q.z;
                    this.normalizeNormals();
                    a.normal.needsUpdate = !0
                }
            }, computeTangents: function () {
                function a(a, b, c) {
                    q.fromArray(d, 3 * a);
                    n.fromArray(d, 3 * b);
                    t.fromArray(d, 3 * c);
                    r.fromArray(f, 2 * a);
                    s.fromArray(f, 2 * b);
                    u.fromArray(f, 2 * c);
                    v = n.x - q.x;
                    x = t.x - q.x;
                    D = n.y - q.y;
                    w = t.y - q.y;
                    y = n.z - q.z;
                    A = t.z - q.z;
                    E = s.x - r.x;
                    G =
                        u.x - r.x;
                    F = s.y - r.y;
                    z = u.y - r.y;
                    I = 1 / (E * z - G * F);
                    U.set((z * v - F * x) * I, (z * D - F * w) * I, (z * y - F * A) * I);
                    M.set((E * x - G * v) * I, (E * w - G * D) * I, (E * A - G * y) * I);
                    k[a].add(U);
                    k[b].add(U);
                    k[c].add(U);
                    l[a].add(M);
                    l[b].add(M);
                    l[c].add(M)
                }

                function b(a) {
                    ha.fromArray(e, 3 * a);
                    O.copy(ha);
                    ba = k[a];
                    oa.copy(ba);
                    oa.sub(ha.multiplyScalar(ha.dot(ba))).normalize();
                    ja.crossVectors(O, ba);
                    qa = ja.dot(l[a]);
                    ca = 0 > qa ? -1 : 1;
                    h[4 * a] = oa.x;
                    h[4 * a + 1] = oa.y;
                    h[4 * a + 2] = oa.z;
                    h[4 * a + 3] = ca
                }

                if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal ||
                    void 0 === this.attributes.uv)THREE.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()"); else {
                    var c = this.attributes.index.array, d = this.attributes.position.array, e = this.attributes.normal.array, f = this.attributes.uv.array, g = d.length / 3;
                    void 0 === this.attributes.tangent && this.addAttribute("tangent", new THREE.BufferAttribute(new Float32Array(4 * g), 4));
                    for (var h = this.attributes.tangent.array, k = [], l = [], p = 0; p < g; p++)k[p] = new THREE.Vector3,
                        l[p] = new THREE.Vector3;
                    var q = new THREE.Vector3, n = new THREE.Vector3, t = new THREE.Vector3, r = new THREE.Vector2, s = new THREE.Vector2, u = new THREE.Vector2, v, x, D, w, y, A, E, G, F, z, I, U = new THREE.Vector3, M = new THREE.Vector3, H, L, P, N, R;
                    0 === this.drawcalls.length && this.addDrawCall(0, c.length, 0);
                    var V = this.drawcalls, p = 0;
                    for (L = V.length; p < L; ++p) {
                        H = V[p].start;
                        P = V[p].count;
                        var J = V[p].index, g = H;
                        for (H += P; g < H; g += 3)P = J + c[g], N = J + c[g + 1], R = J + c[g + 2], a(P, N, R)
                    }
                    var oa = new THREE.Vector3, ja = new THREE.Vector3, ha = new THREE.Vector3, O = new THREE.Vector3,
                        ca, ba, qa, p = 0;
                    for (L = V.length; p < L; ++p)for (H = V[p].start, P = V[p].count, J = V[p].index, g = H, H += P; g < H; g += 3)P = J + c[g], N = J + c[g + 1], R = J + c[g + 2], b(P), b(N), b(R)
                }
            }, computeOffsets: function (a) {
                void 0 === a && (a = 65535);
                for (var b = this.attributes.index.array, c = this.attributes.position.array, d = b.length / 3, e = new Uint16Array(b.length), f = 0, g = 0, h = [{
                    start: 0,
                    count: 0,
                    index: 0
                }], k = h[0], l = 0, p = 0, q = new Int32Array(6), n = new Int32Array(c.length), t = new Int32Array(c.length), r = 0; r < c.length; r++)n[r] = -1, t[r] = -1;
                for (c = 0; c < d; c++) {
                    for (var s = p = 0; 3 >
                    s; s++)r = b[3 * c + s], -1 == n[r] ? (q[2 * s] = r, q[2 * s + 1] = -1, p++) : n[r] < k.index ? (q[2 * s] = r, q[2 * s + 1] = -1, l++) : (q[2 * s] = r, q[2 * s + 1] = n[r]);
                    if (g + p > k.index + a)for (k = {start: f, count: 0, index: g}, h.push(k), p = 0; 6 > p; p += 2)s = q[p + 1], -1 < s && s < k.index && (q[p + 1] = -1);
                    for (p = 0; 6 > p; p += 2)r = q[p], s = q[p + 1], -1 === s && (s = g++), n[r] = s, t[s] = r, e[f++] = s - k.index, k.count++
                }
                this.reorderBuffers(e, t, g);
                return this.drawcalls = this.offsets = h
            }, merge: function (a, b) {
                if (!1 === a instanceof THREE.BufferGeometry)THREE.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                    a); else {
                    void 0 === b && (b = 0);
                    var c = this.attributes, d;
                    for (d in c)if (void 0 !== a.attributes[d])for (var e = c[d].array, f = a.attributes[d], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, f++)e[f] = g[h];
                    return this
                }
            }, normalizeNormals: function () {
                for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length; e < f; e += 3)b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b
            }, reorderBuffers: function (a, b, c) {
                var d = {}, e;
                for (e in this.attributes)"index" != e && (d[e] = new this.attributes[e].array.constructor(this.attributes[e].itemSize *
                    c));
                for (var f = 0; f < c; f++) {
                    var g = b[f];
                    for (e in this.attributes)if ("index" != e)for (var h = this.attributes[e].array, k = this.attributes[e].itemSize, l = d[e], p = 0; p < k; p++)l[f * k + p] = h[g * k + p]
                }
                this.attributes.index.array = a;
                for (e in this.attributes)"index" != e && (this.attributes[e].array = d[e], this.attributes[e].numItems = this.attributes[e].itemSize * c)
            }, toJSON: function () {
                var a = {metadata: {version: 4, type: "BufferGeometry", generator: "BufferGeometryExporter"}, uuid: this.uuid, type: this.type, data: {attributes: {}}}, b = this.attributes,
                    c = this.offsets, d = this.boundingSphere, e;
                for (e in b) {
                    var f = b[e], g = Array.prototype.slice.call(f.array);
                    a.data.attributes[e] = {itemSize: f.itemSize, type: f.array.constructor.name, array: g}
                }
                0 < c.length && (a.data.offsets = JSON.parse(JSON.stringify(c)));
                null !== d && (a.data.boundingSphere = {center: d.center.toArray(), radius: d.radius});
                return a
            }, clone: function () {
                var a = new THREE.BufferGeometry, b;
                for (b in this.attributes)a.addAttribute(b, this.attributes[b].clone());
                b = 0;
                for (var c = this.offsets.length; b < c; b++) {
                    var d = this.offsets[b];
                    a.offsets.push({start: d.start, index: d.index, count: d.count})
                }
                return a
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        };
        THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
        THREE.Geometry = function () {
            Object.defineProperty(this, "id", {value: THREE.GeometryIdCount++});
            this.uuid = THREE.Math.generateUUID();
            this.name = "";
            this.type = "Geometry";
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphColors = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingSphere = this.boundingBox = null;
            this.hasTangents = !1;
            this.dynamic = !0;
            this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate =
                this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
        };
        THREE.Geometry.prototype = {
            constructor: THREE.Geometry, applyMatrix: function (a) {
                for (var b = (new THREE.Matrix3).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++)this.vertices[c].applyMatrix4(a);
                c = 0;
                for (d = this.faces.length; c < d; c++) {
                    a = this.faces[c];
                    a.normal.applyMatrix3(b).normalize();
                    for (var e = 0, f = a.vertexNormals.length; e < f; e++)a.vertexNormals[e].applyMatrix3(b).normalize()
                }
                null !== this.boundingBox && this.computeBoundingBox();
                null !== this.boundingSphere && this.computeBoundingSphere();
                this.normalsNeedUpdate =
                    this.verticesNeedUpdate = !0
            }, fromBufferGeometry: function (a) {
                for (var b = this, c = a.attributes, d = c.position.array, e = void 0 !== c.index ? c.index.array : void 0, f = void 0 !== c.normal ? c.normal.array : void 0, g = void 0 !== c.color ? c.color.array : void 0, h = void 0 !== c.uv ? c.uv.array : void 0, k = [], l = [], p = c = 0; c < d.length; c += 3, p += 2)b.vertices.push(new THREE.Vector3(d[c], d[c + 1], d[c + 2])), void 0 !== f && k.push(new THREE.Vector3(f[c], f[c + 1], f[c + 2])), void 0 !== g && b.colors.push(new THREE.Color(g[c], g[c + 1], g[c + 2])), void 0 !== h && l.push(new THREE.Vector2(h[p],
                    h[p + 1]));
                var q = function (a, c, d) {
                    var e = void 0 !== f ? [k[a].clone(), k[c].clone(), k[d].clone()] : [], n = void 0 !== g ? [b.colors[a].clone(), b.colors[c].clone(), b.colors[d].clone()] : [];
                    b.faces.push(new THREE.Face3(a, c, d, e, n));
                    void 0 !== h && b.faceVertexUvs[0].push([l[a].clone(), l[c].clone(), l[d].clone()])
                };
                if (void 0 !== e)if (d = a.drawcalls, 0 < d.length)for (c = 0; c < d.length; c++)for (var p = d[c], n = p.start, t = p.count, r = p.index, p = n, n = n + t; p < n; p += 3)q(r + e[p], r + e[p + 1], r + e[p + 2]); else for (c = 0; c < e.length; c += 3)q(e[c], e[c + 1], e[c + 2]); else for (c =
                                                                                                                                                                                                                                                                                                                     0; c < d.length / 3; c += 3)q(c, c + 1, c + 2);
                this.computeFaceNormals();
                null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
                null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
                return this
            }, center: function () {
                this.computeBoundingBox();
                var a = this.boundingBox.center().negate();
                this.applyMatrix((new THREE.Matrix4).setPosition(a));
                return a
            }, computeFaceNormals: function () {
                for (var a = new THREE.Vector3, b = new THREE.Vector3, c = 0, d = this.faces.length; c < d; c++) {
                    var e = this.faces[c], f = this.vertices[e.a],
                        g = this.vertices[e.b];
                    a.subVectors(this.vertices[e.c], g);
                    b.subVectors(f, g);
                    a.cross(b);
                    a.normalize();
                    e.normal.copy(a)
                }
            }, computeVertexNormals: function (a) {
                var b, c, d;
                d = Array(this.vertices.length);
                b = 0;
                for (c = this.vertices.length; b < c; b++)d[b] = new THREE.Vector3;
                if (a) {
                    var e, f, g, h = new THREE.Vector3, k = new THREE.Vector3;
                    a = 0;
                    for (b = this.faces.length; a < b; a++)c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), k.subVectors(e, f), h.cross(k), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h)
                } else for (a =
                                0, b = this.faces.length; a < b; a++)c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
                b = 0;
                for (c = this.vertices.length; b < c; b++)d[b].normalize();
                a = 0;
                for (b = this.faces.length; a < b; a++)c = this.faces[a], c.vertexNormals[0] = d[c.a].clone(), c.vertexNormals[1] = d[c.b].clone(), c.vertexNormals[2] = d[c.c].clone()
            }, computeMorphNormals: function () {
                var a, b, c, d, e;
                c = 0;
                for (d = this.faces.length; c < d; c++)for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal =
                    e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++)e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
                var f = new THREE.Geometry;
                f.faces = this.faces;
                a = 0;
                for (b = this.morphTargets.length; a < b; a++) {
                    if (!this.morphNormals[a]) {
                        this.morphNormals[a] = {};
                        this.morphNormals[a].faceNormals = [];
                        this.morphNormals[a].vertexNormals = [];
                        e = this.morphNormals[a].faceNormals;
                        var g =
                            this.morphNormals[a].vertexNormals, h, k;
                        c = 0;
                        for (d = this.faces.length; c < d; c++)h = new THREE.Vector3, k = {a: new THREE.Vector3, b: new THREE.Vector3, c: new THREE.Vector3}, e.push(h), g.push(k)
                    }
                    g = this.morphNormals[a];
                    f.vertices = this.morphTargets[a].vertices;
                    f.computeFaceNormals();
                    f.computeVertexNormals();
                    c = 0;
                    for (d = this.faces.length; c < d; c++)e = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(e.normal), k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2])
                }
                c = 0;
                for (d = this.faces.length; c <
                d; c++)e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
            }, computeTangents: function () {
                var a, b, c, d, e, f, g, h, k, l, p, q, n, t, r, s, u, v = [], x = [];
                c = new THREE.Vector3;
                var D = new THREE.Vector3, w = new THREE.Vector3, y = new THREE.Vector3, A = new THREE.Vector3;
                a = 0;
                for (b = this.vertices.length; a < b; a++)v[a] = new THREE.Vector3, x[a] = new THREE.Vector3;
                a = 0;
                for (b = this.faces.length; a < b; a++)e = this.faces[a], f = this.faceVertexUvs[0][a], d = e.a, u = e.b, e = e.c, g = this.vertices[d], h = this.vertices[u], k = this.vertices[e],
                    l = f[0], p = f[1], q = f[2], f = h.x - g.x, n = k.x - g.x, t = h.y - g.y, r = k.y - g.y, h = h.z - g.z, g = k.z - g.z, k = p.x - l.x, s = q.x - l.x, p = p.y - l.y, l = q.y - l.y, q = 1 / (k * l - s * p), c.set((l * f - p * n) * q, (l * t - p * r) * q, (l * h - p * g) * q), D.set((k * n - s * f) * q, (k * r - s * t) * q, (k * g - s * h) * q), v[d].add(c), v[u].add(c), v[e].add(c), x[d].add(D), x[u].add(D), x[e].add(D);
                D = ["a", "b", "c", "d"];
                a = 0;
                for (b = this.faces.length; a < b; a++)for (e = this.faces[a], c = 0; c < Math.min(e.vertexNormals.length, 3); c++)A.copy(e.vertexNormals[c]), d = e[D[c]], u = v[d], w.copy(u), w.sub(A.multiplyScalar(A.dot(u))).normalize(),
                    y.crossVectors(e.vertexNormals[c], u), d = y.dot(x[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(w.x, w.y, w.z, d);
                this.hasTangents = !0
            }, computeLineDistances: function () {
                for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++)0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
            }, computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new THREE.Box3);
                this.boundingBox.setFromPoints(this.vertices)
            }, computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
                this.boundingSphere.setFromPoints(this.vertices)
            }, merge: function (a, b, c) {
                if (!1 === a instanceof THREE.Geometry)THREE.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a); else {
                    var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, k = a.faces, l = this.faceVertexUvs[0];
                    a = a.faceVertexUvs[0];
                    void 0 === c && (c = 0);
                    void 0 !== b && (d = (new THREE.Matrix3).getNormalMatrix(b));
                    for (var p = 0, q = g.length; p < q; p++) {
                        var n = g[p].clone();
                        void 0 !== b && n.applyMatrix4(b);
                        f.push(n)
                    }
                    p = 0;
                    for (q = k.length; p <
                    q; p++) {
                        var g = k[p], t, r = g.vertexNormals, s = g.vertexColors, n = new THREE.Face3(g.a + e, g.b + e, g.c + e);
                        n.normal.copy(g.normal);
                        void 0 !== d && n.normal.applyMatrix3(d).normalize();
                        b = 0;
                        for (f = r.length; b < f; b++)t = r[b].clone(), void 0 !== d && t.applyMatrix3(d).normalize(), n.vertexNormals.push(t);
                        n.color.copy(g.color);
                        b = 0;
                        for (f = s.length; b < f; b++)t = s[b], n.vertexColors.push(t.clone());
                        n.materialIndex = g.materialIndex + c;
                        h.push(n)
                    }
                    p = 0;
                    for (q = a.length; p < q; p++)if (c = a[p], d = [], void 0 !== c) {
                        b = 0;
                        for (f = c.length; b < f; b++)d.push(c[b].clone());
                        l.push(d)
                    }
                }
            }, mergeMesh: function (a) {
                !1 === a instanceof THREE.Mesh ? THREE.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix))
            }, mergeVertices: function () {
                var a = {}, b = [], c = [], d, e = Math.pow(10, 4), f, g;
                f = 0;
                for (g = this.vertices.length; f < g; f++)d = this.vertices[f], d = Math.round(d.x * e) + "_" + Math.round(d.y * e) + "_" + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
                a = [];
                f = 0;
                for (g = this.faces.length; f <
                g; f++)for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [e.a, e.b, e.c], d = 0; 3 > d; d++)if (e[d] == e[(d + 1) % 3]) {
                    a.push(f);
                    break
                }
                for (f = a.length - 1; 0 <= f; f--)for (e = a[f], this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length; c < g; c++)this.faceVertexUvs[c].splice(e, 1);
                f = this.vertices.length - b.length;
                this.vertices = b;
                return f
            }, toJSON: function () {
                function a(a, b, c) {
                    return c ? a | 1 << b : a & ~(1 << b)
                }

                function b(a) {
                    var b = a.x.toString() + a.y.toString() + a.z.toString();
                    if (void 0 !== l[b])return l[b];
                    l[b] = k.length / 3;
                    k.push(a.x, a.y,
                        a.z);
                    return l[b]
                }

                function c(a) {
                    var b = a.r.toString() + a.g.toString() + a.b.toString();
                    if (void 0 !== q[b])return q[b];
                    q[b] = p.length;
                    p.push(a.getHex());
                    return q[b]
                }

                function d(a) {
                    var b = a.x.toString() + a.y.toString();
                    if (void 0 !== t[b])return t[b];
                    t[b] = n.length / 2;
                    n.push(a.x, a.y);
                    return t[b]
                }

                var e = {metadata: {version: 4, type: "BufferGeometry", generator: "BufferGeometryExporter"}, uuid: this.uuid, type: this.type};
                "" !== this.name && (e.name = this.name);
                if (void 0 !== this.parameters) {
                    var f = this.parameters, g;
                    for (g in f)void 0 !==
                    f[g] && (e[g] = f[g]);
                    return e
                }
                f = [];
                for (g = 0; g < this.vertices.length; g++) {
                    var h = this.vertices[g];
                    f.push(h.x, h.y, h.z)
                }
                var h = [], k = [], l = {}, p = [], q = {}, n = [], t = {};
                for (g = 0; g < this.faces.length; g++) {
                    var r = this.faces[g], s = void 0 !== this.faceVertexUvs[0][g], u = 0 < r.normal.length(), v = 0 < r.vertexNormals.length, x = 1 !== r.color.r || 1 !== r.color.g || 1 !== r.color.b, D = 0 < r.vertexColors.length, w = 0, w = a(w, 0, 0), w = a(w, 1, !1), w = a(w, 2, !1), w = a(w, 3, s), w = a(w, 4, u), w = a(w, 5, v), w = a(w, 6, x), w = a(w, 7, D);
                    h.push(w);
                    h.push(r.a, r.b, r.c);
                    s && (s = this.faceVertexUvs[0][g],
                        h.push(d(s[0]), d(s[1]), d(s[2])));
                    u && h.push(b(r.normal));
                    v && (u = r.vertexNormals, h.push(b(u[0]), b(u[1]), b(u[2])));
                    x && h.push(c(r.color));
                    D && (r = r.vertexColors, h.push(c(r[0]), c(r[1]), c(r[2])))
                }
                e.data = {};
                e.data.vertices = f;
                e.data.normals = k;
                0 < p.length && (e.data.colors = p);
                0 < n.length && (e.data.uvs = [n]);
                e.data.faces = h;
                return e
            }, clone: function () {
                for (var a = new THREE.Geometry, b = this.vertices, c = 0, d = b.length; c < d; c++)a.vertices.push(b[c].clone());
                b = this.faces;
                c = 0;
                for (d = b.length; c < d; c++)a.faces.push(b[c].clone());
                c = 0;
                for (d = this.faceVertexUvs.length; c < d; c++) {
                    b = this.faceVertexUvs[c];
                    void 0 === a.faceVertexUvs[c] && (a.faceVertexUvs[c] = []);
                    for (var e = 0, f = b.length; e < f; e++) {
                        for (var g = b[e], h = [], k = 0, l = g.length; k < l; k++)h.push(g[k].clone());
                        a.faceVertexUvs[c].push(h)
                    }
                }
                return a
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        };
        THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
        THREE.GeometryIdCount = 0;
        THREE.Camera = function () {
            THREE.Object3D.call(this);
            this.type = "Camera";
            this.matrixWorldInverse = new THREE.Matrix4;
            this.projectionMatrix = new THREE.Matrix4
        };
        THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Camera.prototype.constructor = THREE.Camera;
        THREE.Camera.prototype.getWorldDirection = function () {
            var a = new THREE.Quaternion;
            return function (b) {
                b = b || new THREE.Vector3;
                this.getWorldQuaternion(a);
                return b.set(0, 0, -1).applyQuaternion(a)
            }
        }();
        THREE.Camera.prototype.lookAt = function () {
            var a = new THREE.Matrix4;
            return function (b) {
                a.lookAt(this.position, b, this.up);
                this.quaternion.setFromRotationMatrix(a)
            }
        }();
        THREE.Camera.prototype.clone = function (a) {
            void 0 === a && (a = new THREE.Camera);
            THREE.Object3D.prototype.clone.call(this, a);
            a.matrixWorldInverse.copy(this.matrixWorldInverse);
            a.projectionMatrix.copy(this.projectionMatrix);
            return a
        };
        THREE.CubeCamera = function (a, b, c) {
            THREE.Object3D.call(this);
            this.type = "CubeCamera";
            var d = new THREE.PerspectiveCamera(90, 1, a, b);
            d.up.set(0, -1, 0);
            d.lookAt(new THREE.Vector3(1, 0, 0));
            this.add(d);
            var e = new THREE.PerspectiveCamera(90, 1, a, b);
            e.up.set(0, -1, 0);
            e.lookAt(new THREE.Vector3(-1, 0, 0));
            this.add(e);
            var f = new THREE.PerspectiveCamera(90, 1, a, b);
            f.up.set(0, 0, 1);
            f.lookAt(new THREE.Vector3(0, 1, 0));
            this.add(f);
            var g = new THREE.PerspectiveCamera(90, 1, a, b);
            g.up.set(0, 0, -1);
            g.lookAt(new THREE.Vector3(0, -1, 0));
            this.add(g);
            var h = new THREE.PerspectiveCamera(90, 1, a, b);
            h.up.set(0, -1, 0);
            h.lookAt(new THREE.Vector3(0, 0, 1));
            this.add(h);
            var k = new THREE.PerspectiveCamera(90, 1, a, b);
            k.up.set(0, -1, 0);
            k.lookAt(new THREE.Vector3(0, 0, -1));
            this.add(k);
            this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter});
            this.updateCubeMap = function (a, b) {
                var c = this.renderTarget, n = c.generateMipmaps;
                c.generateMipmaps = !1;
                c.activeCubeFace = 0;
                a.render(b, d, c);
                c.activeCubeFace =
                    1;
                a.render(b, e, c);
                c.activeCubeFace = 2;
                a.render(b, f, c);
                c.activeCubeFace = 3;
                a.render(b, g, c);
                c.activeCubeFace = 4;
                a.render(b, h, c);
                c.generateMipmaps = n;
                c.activeCubeFace = 5;
                a.render(b, k, c)
            }
        };
        THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
        THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
        THREE.OrthographicCamera = function (a, b, c, d, e, f) {
            THREE.Camera.call(this);
            this.type = "OrthographicCamera";
            this.zoom = 1;
            this.left = a;
            this.right = b;
            this.top = c;
            this.bottom = d;
            this.near = void 0 !== e ? e : .1;
            this.far = void 0 !== f ? f : 2E3;
            this.updateProjectionMatrix()
        };
        THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
        THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
        THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
            var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2;
            this.projectionMatrix.makeOrthographic(c - a, c + a, d + b, d - b, this.near, this.far)
        };
        THREE.OrthographicCamera.prototype.clone = function () {
            var a = new THREE.OrthographicCamera;
            THREE.Camera.prototype.clone.call(this, a);
            a.zoom = this.zoom;
            a.left = this.left;
            a.right = this.right;
            a.top = this.top;
            a.bottom = this.bottom;
            a.near = this.near;
            a.far = this.far;
            a.projectionMatrix.copy(this.projectionMatrix);
            return a
        };
        THREE.PerspectiveCamera = function (a, b, c, d) {
            THREE.Camera.call(this);
            this.type = "PerspectiveCamera";
            this.zoom = 1;
            this.fov = void 0 !== a ? a : 50;
            this.aspect = void 0 !== b ? b : 1;
            this.near = void 0 !== c ? c : .1;
            this.far = void 0 !== d ? d : 2E3;
            this.updateProjectionMatrix()
        };
        THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
        THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
        THREE.PerspectiveCamera.prototype.setLens = function (a, b) {
            void 0 === b && (b = 24);
            this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
            this.updateProjectionMatrix()
        };
        THREE.PerspectiveCamera.prototype.setViewOffset = function (a, b, c, d, e, f) {
            this.fullWidth = a;
            this.fullHeight = b;
            this.x = c;
            this.y = d;
            this.width = e;
            this.height = f;
            this.updateProjectionMatrix()
        };
        THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
            var a = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));
            if (this.fullWidth) {
                var b = this.fullWidth / this.fullHeight, a = Math.tan(THREE.Math.degToRad(.5 * a)) * this.near, c = -a, d = b * c, b = Math.abs(b * a - d), c = Math.abs(a - c);
                this.projectionMatrix.makeFrustum(d + this.x * b / this.fullWidth, d + (this.x + this.width) * b / this.fullWidth, a - (this.y + this.height) * c / this.fullHeight, a - this.y * c / this.fullHeight, this.near, this.far)
            } else this.projectionMatrix.makePerspective(a,
                this.aspect, this.near, this.far)
        };
        THREE.PerspectiveCamera.prototype.clone = function () {
            var a = new THREE.PerspectiveCamera;
            THREE.Camera.prototype.clone.call(this, a);
            a.zoom = this.zoom;
            a.fov = this.fov;
            a.aspect = this.aspect;
            a.near = this.near;
            a.far = this.far;
            a.projectionMatrix.copy(this.projectionMatrix);
            return a
        };
        THREE.Light = function (a) {
            THREE.Object3D.call(this);
            this.type = "Light";
            this.color = new THREE.Color(a)
        };
        THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Light.prototype.constructor = THREE.Light;
        THREE.Light.prototype.clone = function (a) {
            void 0 === a && (a = new THREE.Light);
            THREE.Object3D.prototype.clone.call(this, a);
            a.color.copy(this.color);
            return a
        };
        THREE.AmbientLight = function (a) {
            THREE.Light.call(this, a);
            this.type = "AmbientLight"
        };
        THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
        THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
        THREE.AmbientLight.prototype.clone = function () {
            var a = new THREE.AmbientLight;
            THREE.Light.prototype.clone.call(this, a);
            return a
        };
        THREE.AreaLight = function (a, b) {
            THREE.Light.call(this, a);
            this.type = "AreaLight";
            this.normal = new THREE.Vector3(0, -1, 0);
            this.right = new THREE.Vector3(1, 0, 0);
            this.intensity = void 0 !== b ? b : 1;
            this.height = this.width = 1;
            this.constantAttenuation = 1.5;
            this.linearAttenuation = .5;
            this.quadraticAttenuation = .1
        };
        THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
        THREE.AreaLight.prototype.constructor = THREE.AreaLight;
        THREE.DirectionalLight = function (a, b) {
            THREE.Light.call(this, a);
            this.type = "DirectionalLight";
            this.position.set(0, 1, 0);
            this.target = new THREE.Object3D;
            this.intensity = void 0 !== b ? b : 1;
            this.onlyShadow = this.castShadow = !1;
            this.shadowCameraNear = 50;
            this.shadowCameraFar = 5E3;
            this.shadowCameraLeft = -500;
            this.shadowCameraTop = this.shadowCameraRight = 500;
            this.shadowCameraBottom = -500;
            this.shadowCameraVisible = !1;
            this.shadowBias = 0;
            this.shadowDarkness = .5;
            this.shadowMapHeight = this.shadowMapWidth = 512;
            this.shadowCascade = !1;
            this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1E3);
            this.shadowCascadeCount = 2;
            this.shadowCascadeBias = [0, 0, 0];
            this.shadowCascadeWidth = [512, 512, 512];
            this.shadowCascadeHeight = [512, 512, 512];
            this.shadowCascadeNearZ = [-1, .99, .998];
            this.shadowCascadeFarZ = [.99, .998, 1];
            this.shadowCascadeArray = [];
            this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
        };
        THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
        THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
        THREE.DirectionalLight.prototype.clone = function () {
            var a = new THREE.DirectionalLight;
            THREE.Light.prototype.clone.call(this, a);
            a.target = this.target.clone();
            a.intensity = this.intensity;
            a.castShadow = this.castShadow;
            a.onlyShadow = this.onlyShadow;
            a.shadowCameraNear = this.shadowCameraNear;
            a.shadowCameraFar = this.shadowCameraFar;
            a.shadowCameraLeft = this.shadowCameraLeft;
            a.shadowCameraRight = this.shadowCameraRight;
            a.shadowCameraTop = this.shadowCameraTop;
            a.shadowCameraBottom = this.shadowCameraBottom;
            a.shadowCameraVisible =
                this.shadowCameraVisible;
            a.shadowBias = this.shadowBias;
            a.shadowDarkness = this.shadowDarkness;
            a.shadowMapWidth = this.shadowMapWidth;
            a.shadowMapHeight = this.shadowMapHeight;
            a.shadowCascade = this.shadowCascade;
            a.shadowCascadeOffset.copy(this.shadowCascadeOffset);
            a.shadowCascadeCount = this.shadowCascadeCount;
            a.shadowCascadeBias = this.shadowCascadeBias.slice(0);
            a.shadowCascadeWidth = this.shadowCascadeWidth.slice(0);
            a.shadowCascadeHeight = this.shadowCascadeHeight.slice(0);
            a.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0);
            a.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0);
            return a
        };
        THREE.HemisphereLight = function (a, b, c) {
            THREE.Light.call(this, a);
            this.type = "HemisphereLight";
            this.position.set(0, 100, 0);
            this.groundColor = new THREE.Color(b);
            this.intensity = void 0 !== c ? c : 1
        };
        THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
        THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
        THREE.HemisphereLight.prototype.clone = function () {
            var a = new THREE.HemisphereLight;
            THREE.Light.prototype.clone.call(this, a);
            a.groundColor.copy(this.groundColor);
            a.intensity = this.intensity;
            return a
        };
        THREE.PointLight = function (a, b, c, d) {
            THREE.Light.call(this, a);
            this.type = "PointLight";
            this.intensity = void 0 !== b ? b : 1;
            this.distance = void 0 !== c ? c : 0;
            this.decay = void 0 !== d ? d : 1
        };
        THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
        THREE.PointLight.prototype.constructor = THREE.PointLight;
        THREE.PointLight.prototype.clone = function () {
            var a = new THREE.PointLight;
            THREE.Light.prototype.clone.call(this, a);
            a.intensity = this.intensity;
            a.distance = this.distance;
            a.decay = this.decay;
            return a
        };
        THREE.SpotLight = function (a, b, c, d, e, f) {
            THREE.Light.call(this, a);
            this.type = "SpotLight";
            this.position.set(0, 1, 0);
            this.target = new THREE.Object3D;
            this.intensity = void 0 !== b ? b : 1;
            this.distance = void 0 !== c ? c : 0;
            this.angle = void 0 !== d ? d : Math.PI / 3;
            this.exponent = void 0 !== e ? e : 10;
            this.decay = void 0 !== f ? f : 1;
            this.onlyShadow = this.castShadow = !1;
            this.shadowCameraNear = 50;
            this.shadowCameraFar = 5E3;
            this.shadowCameraFov = 50;
            this.shadowCameraVisible = !1;
            this.shadowBias = 0;
            this.shadowDarkness = .5;
            this.shadowMapHeight = this.shadowMapWidth =
                512;
            this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
        };
        THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
        THREE.SpotLight.prototype.constructor = THREE.SpotLight;
        THREE.SpotLight.prototype.clone = function () {
            var a = new THREE.SpotLight;
            THREE.Light.prototype.clone.call(this, a);
            a.target = this.target.clone();
            a.intensity = this.intensity;
            a.distance = this.distance;
            a.angle = this.angle;
            a.exponent = this.exponent;
            a.decay = this.decay;
            a.castShadow = this.castShadow;
            a.onlyShadow = this.onlyShadow;
            a.shadowCameraNear = this.shadowCameraNear;
            a.shadowCameraFar = this.shadowCameraFar;
            a.shadowCameraFov = this.shadowCameraFov;
            a.shadowCameraVisible = this.shadowCameraVisible;
            a.shadowBias = this.shadowBias;
            a.shadowDarkness = this.shadowDarkness;
            a.shadowMapWidth = this.shadowMapWidth;
            a.shadowMapHeight = this.shadowMapHeight;
            return a
        };
        THREE.Cache = {
            files: {}, add: function (a, b) {
                this.files[a] = b
            }, get: function (a) {
                return this.files[a]
            }, remove: function (a) {
                delete this.files[a]
            }, clear: function () {
                this.files = {}
            }
        };
        THREE.Loader = function (a) {
            this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;
            this.imageLoader = new THREE.ImageLoader;
            this.onLoadStart = function () {
            };
            this.onLoadProgress = function () {
            };
            this.onLoadComplete = function () {
            }
        };
        THREE.Loader.prototype = {
            constructor: THREE.Loader, crossOrigin: void 0, addStatusElement: function () {
                var a = document.createElement("div");
                a.style.position = "absolute";
                a.style.right = "0px";
                a.style.top = "0px";
                a.style.fontSize = "0.8em";
                a.style.textAlign = "left";
                a.style.background = "rgba(0,0,0,0.25)";
                a.style.color = "#fff";
                a.style.width = "120px";
                a.style.padding = "0.5em 0.5em 0.5em 0.5em";
                a.style.zIndex = 1E3;
                a.innerHTML = "Loading ...";
                return a
            }, updateProgress: function (a) {
                var b = "Loaded ", b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) +
                "%") : b + ((a.loaded / 1024).toFixed(2) + " KB");
                this.statusDomElement.innerHTML = b
            }, extractUrlBase: function (a) {
                a = a.split("/");
                if (1 === a.length)return "./";
                a.pop();
                return a.join("/") + "/"
            }, initMaterials: function (a, b) {
                for (var c = [], d = 0; d < a.length; ++d)c[d] = this.createMaterial(a[d], b);
                return c
            }, needsTangents: function (a) {
                for (var b = 0, c = a.length; b < c; b++)if (a[b]instanceof THREE.ShaderMaterial)return !0;
                return !1
            }, createMaterial: function (a, b) {
                function c(a) {
                    a = Math.log(a) / Math.LN2;
                    return Math.pow(2, Math.round(a))
                }

                function d(a,
                           d, e, g, h, k, s) {
                    var u = b + e, v, x = THREE.Loader.Handlers.get(u);
                    null !== x ? v = x.load(u) : (v = new THREE.Texture, x = f.imageLoader, x.crossOrigin = f.crossOrigin, x.load(u, function (a) {
                        if (!1 === THREE.Math.isPowerOfTwo(a.width) || !1 === THREE.Math.isPowerOfTwo(a.height)) {
                            var b = c(a.width), d = c(a.height), e = document.createElement("canvas");
                            e.width = b;
                            e.height = d;
                            e.getContext("2d").drawImage(a, 0, 0, b, d);
                            v.image = e
                        } else v.image = a;
                        v.needsUpdate = !0
                    }));
                    v.sourceFile = e;
                    g && (v.repeat.set(g[0], g[1]), 1 !== g[0] && (v.wrapS = THREE.RepeatWrapping),
                    1 !== g[1] && (v.wrapT = THREE.RepeatWrapping));
                    h && v.offset.set(h[0], h[1]);
                    k && (e = {repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping}, void 0 !== e[k[0]] && (v.wrapS = e[k[0]]), void 0 !== e[k[1]] && (v.wrapT = e[k[1]]));
                    s && (v.anisotropy = s);
                    a[d] = v
                }

                function e(a) {
                    return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2]
                }

                var f = this, g = "MeshLambertMaterial", h = {color: 15658734, opacity: 1, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: !1};
                if (a.shading) {
                    var k = a.shading.toLowerCase();
                    "phong" === k ? g = "MeshPhongMaterial" :
                    "basic" === k && (g = "MeshBasicMaterial")
                }
                void 0 !== a.blending && void 0 !== THREE[a.blending] && (h.blending = THREE[a.blending]);
                void 0 !== a.transparent && (h.transparent = a.transparent);
                void 0 !== a.opacity && 1 > a.opacity && (h.transparent = !0);
                void 0 !== a.depthTest && (h.depthTest = a.depthTest);
                void 0 !== a.depthWrite && (h.depthWrite = a.depthWrite);
                void 0 !== a.visible && (h.visible = a.visible);
                void 0 !== a.flipSided && (h.side = THREE.BackSide);
                void 0 !== a.doubleSided && (h.side = THREE.DoubleSide);
                void 0 !== a.wireframe && (h.wireframe = a.wireframe);
                void 0 !== a.vertexColors && ("face" === a.vertexColors ? h.vertexColors = THREE.FaceColors : a.vertexColors && (h.vertexColors = THREE.VertexColors));
                a.colorDiffuse ? h.color = e(a.colorDiffuse) : a.DbgColor && (h.color = a.DbgColor);
                a.colorSpecular && (h.specular = e(a.colorSpecular));
                a.colorEmissive && (h.emissive = e(a.colorEmissive));
                void 0 !== a.transparency && (console.warn("THREE.Loader: transparency has been renamed to opacity"), a.opacity = a.transparency);
                void 0 !== a.opacity && (h.opacity = a.opacity);
                a.specularCoef && (h.shininess =
                    a.specularCoef);
                a.mapDiffuse && b && d(h, "map", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
                a.mapLight && b && d(h, "lightMap", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
                a.mapBump && b && d(h, "bumpMap", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
                a.mapNormal && b && d(h, "normalMap", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
                a.mapSpecular && b && d(h, "specularMap",
                    a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
                a.mapAlpha && b && d(h, "alphaMap", a.mapAlpha, a.mapAlphaRepeat, a.mapAlphaOffset, a.mapAlphaWrap, a.mapAlphaAnisotropy);
                a.mapBumpScale && (h.bumpScale = a.mapBumpScale);
                a.mapNormalFactor && (h.normalScale = new THREE.Vector2(a.mapNormalFactor, a.mapNormalFactor));
                g = new THREE[g](h);
                void 0 !== a.DbgName && (g.name = a.DbgName);
                return g
            }
        };
        THREE.Loader.Handlers = {
            handlers: [], add: function (a, b) {
                this.handlers.push(a, b)
            }, get: function (a) {
                for (var b = 0, c = this.handlers.length; b < c; b += 2) {
                    var d = this.handlers[b + 1];
                    if (this.handlers[b].test(a))return d
                }
                return null
            }
        };
        THREE.XHRLoader = function (a) {
            this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
        };
        THREE.XHRLoader.prototype = {
            constructor: THREE.XHRLoader, load: function (a, b, c, d) {
                var e = this, f = THREE.Cache.get(a);
                void 0 !== f ? b && b(f) : (f = new XMLHttpRequest, f.open("GET", a, !0), f.addEventListener("load", function (c) {
                    THREE.Cache.add(a, this.response);
                    b && b(this.response);
                    e.manager.itemEnd(a)
                }, !1), void 0 !== c && f.addEventListener("progress", function (a) {
                    c(a)
                }, !1), void 0 !== d && f.addEventListener("error", function (a) {
                    d(a)
                }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (f.responseType =
                    this.responseType), f.send(null), e.manager.itemStart(a))
            }, setResponseType: function (a) {
                this.responseType = a
            }, setCrossOrigin: function (a) {
                this.crossOrigin = a
            }
        };
        THREE.ImageLoader = function (a) {
            this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
        };
        THREE.ImageLoader.prototype = {
            constructor: THREE.ImageLoader, load: function (a, b, c, d) {
                var e = this, f = THREE.Cache.get(a);
                if (void 0 !== f)b(f); else return f = document.createElement("img"), f.addEventListener("load", function (c) {
                    THREE.Cache.add(a, this);
                    b && b(this);
                    e.manager.itemEnd(a)
                }, !1), void 0 !== c && f.addEventListener("progress", function (a) {
                    c(a)
                }, !1), void 0 !== d && f.addEventListener("error", function (a) {
                    d(a)
                }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), f.src = a, e.manager.itemStart(a), f
            }, setCrossOrigin: function (a) {
                this.crossOrigin =
                    a
            }
        };
        THREE.JSONLoader = function (a) {
            THREE.Loader.call(this, a);
            this.withCredentials = !1
        };
        THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
        THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;
        THREE.JSONLoader.prototype.load = function (a, b, c) {
            c = c && "string" === typeof c ? c : this.extractUrlBase(a);
            this.onLoadStart();
            this.loadAjaxJSON(this, a, b, c)
        };
        THREE.JSONLoader.prototype.loadAjaxJSON = function (a, b, c, d, e) {
            var f = new XMLHttpRequest, g = 0;
            f.onreadystatechange = function () {
                if (f.readyState === f.DONE)if (200 === f.status || 0 === f.status) {
                    if (f.responseText) {
                        var h = JSON.parse(f.responseText), k = h.metadata;
                        if (void 0 !== k) {
                            if ("object" === k.type) {
                                THREE.error("THREE.JSONLoader: " + b + " should be loaded with THREE.ObjectLoader instead.");
                                return
                            }
                            if ("scene" === k.type) {
                                THREE.error("THREE.JSONLoader: " + b + " seems to be a Scene. Use THREE.SceneLoader instead.");
                                return
                            }
                        }
                        h = a.parse(h,
                            d);
                        c(h.geometry, h.materials)
                    } else THREE.error("THREE.JSONLoader: " + b + " seems to be unreachable or the file is empty.");
                    a.onLoadComplete()
                } else THREE.error("THREE.JSONLoader: Couldn't load " + b + " (" + f.status + ")"); else f.readyState === f.LOADING ? e && (0 === g && (g = f.getResponseHeader("Content-Length")), e({
                    total: g,
                    loaded: f.responseText.length
                })) : f.readyState === f.HEADERS_RECEIVED && void 0 !== e && (g = f.getResponseHeader("Content-Length"))
            };
            f.open("GET", b, !0);
            f.withCredentials = this.withCredentials;
            f.send(null)
        };
        THREE.JSONLoader.prototype.parse = function (a, b) {
            var c = new THREE.Geometry, d = void 0 !== a.scale ? 1 / a.scale : 1;
            (function (b) {
                var d, g, h, k, l, p, q, n, t, r, s, u, v, x = a.faces;
                p = a.vertices;
                var D = a.normals, w = a.colors, y = 0;
                if (void 0 !== a.uvs) {
                    for (d = 0; d < a.uvs.length; d++)a.uvs[d].length && y++;
                    for (d = 0; d < y; d++)c.faceVertexUvs[d] = []
                }
                k = 0;
                for (l = p.length; k < l;)d = new THREE.Vector3, d.x = p[k++] * b, d.y = p[k++] * b, d.z = p[k++] * b, c.vertices.push(d);
                k = 0;
                for (l = x.length; k < l;)if (b = x[k++], t = b & 1, h = b & 2, d = b & 8, q = b & 16, r = b & 32, p = b & 64, b &= 128, t) {
                    t = new THREE.Face3;
                    t.a = x[k];
                    t.b = x[k + 1];
                    t.c = x[k + 3];
                    s = new THREE.Face3;
                    s.a = x[k + 1];
                    s.b = x[k + 2];
                    s.c = x[k + 3];
                    k += 4;
                    h && (h = x[k++], t.materialIndex = h, s.materialIndex = h);
                    h = c.faces.length;
                    if (d)for (d = 0; d < y; d++)for (u = a.uvs[d], c.faceVertexUvs[d][h] = [], c.faceVertexUvs[d][h + 1] = [], g = 0; 4 > g; g++)n = x[k++], v = u[2 * n], n = u[2 * n + 1], v = new THREE.Vector2(v, n), 2 !== g && c.faceVertexUvs[d][h].push(v), 0 !== g && c.faceVertexUvs[d][h + 1].push(v);
                    q && (q = 3 * x[k++], t.normal.set(D[q++], D[q++], D[q]), s.normal.copy(t.normal));
                    if (r)for (d = 0; 4 > d; d++)q = 3 * x[k++], r = new THREE.Vector3(D[q++],
                        D[q++], D[q]), 2 !== d && t.vertexNormals.push(r), 0 !== d && s.vertexNormals.push(r);
                    p && (p = x[k++], p = w[p], t.color.setHex(p), s.color.setHex(p));
                    if (b)for (d = 0; 4 > d; d++)p = x[k++], p = w[p], 2 !== d && t.vertexColors.push(new THREE.Color(p)), 0 !== d && s.vertexColors.push(new THREE.Color(p));
                    c.faces.push(t);
                    c.faces.push(s)
                } else {
                    t = new THREE.Face3;
                    t.a = x[k++];
                    t.b = x[k++];
                    t.c = x[k++];
                    h && (h = x[k++], t.materialIndex = h);
                    h = c.faces.length;
                    if (d)for (d = 0; d < y; d++)for (u = a.uvs[d], c.faceVertexUvs[d][h] = [], g = 0; 3 > g; g++)n = x[k++], v = u[2 * n], n = u[2 * n + 1],
                        v = new THREE.Vector2(v, n), c.faceVertexUvs[d][h].push(v);
                    q && (q = 3 * x[k++], t.normal.set(D[q++], D[q++], D[q]));
                    if (r)for (d = 0; 3 > d; d++)q = 3 * x[k++], r = new THREE.Vector3(D[q++], D[q++], D[q]), t.vertexNormals.push(r);
                    p && (p = x[k++], t.color.setHex(w[p]));
                    if (b)for (d = 0; 3 > d; d++)p = x[k++], t.vertexColors.push(new THREE.Color(w[p]));
                    c.faces.push(t)
                }
            })(d);
            (function () {
                var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
                if (a.skinWeights)for (var d = 0, g = a.skinWeights.length; d < g; d += b)c.skinWeights.push(new THREE.Vector4(a.skinWeights[d],
                    1 < b ? a.skinWeights[d + 1] : 0, 2 < b ? a.skinWeights[d + 2] : 0, 3 < b ? a.skinWeights[d + 3] : 0));
                if (a.skinIndices)for (d = 0, g = a.skinIndices.length; d < g; d += b)c.skinIndices.push(new THREE.Vector4(a.skinIndices[d], 1 < b ? a.skinIndices[d + 1] : 0, 2 < b ? a.skinIndices[d + 2] : 0, 3 < b ? a.skinIndices[d + 3] : 0));
                c.bones = a.bones;
                c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && THREE.warn("THREE.JSONLoader: When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" +
                    c.skinIndices.length + "), and skinWeights (" + c.skinWeights.length + ") should match.");
                c.animation = a.animation;
                c.animations = a.animations
            })();
            (function (b) {
                if (void 0 !== a.morphTargets) {
                    var d, g, h, k, l, p;
                    d = 0;
                    for (g = a.morphTargets.length; d < g; d++)for (c.morphTargets[d] = {}, c.morphTargets[d].name = a.morphTargets[d].name, c.morphTargets[d].vertices = [], l = c.morphTargets[d].vertices, p = a.morphTargets[d].vertices, h = 0, k = p.length; h < k; h += 3) {
                        var q = new THREE.Vector3;
                        q.x = p[h] * b;
                        q.y = p[h + 1] * b;
                        q.z = p[h + 2] * b;
                        l.push(q)
                    }
                }
                if (void 0 !==
                    a.morphColors)for (d = 0, g = a.morphColors.length; d < g; d++)for (c.morphColors[d] = {}, c.morphColors[d].name = a.morphColors[d].name, c.morphColors[d].colors = [], k = c.morphColors[d].colors, l = a.morphColors[d].colors, b = 0, h = l.length; b < h; b += 3)p = new THREE.Color(16755200), p.setRGB(l[b], l[b + 1], l[b + 2]), k.push(p)
            })(d);
            c.computeFaceNormals();
            c.computeBoundingSphere();
            if (void 0 === a.materials || 0 === a.materials.length)return {geometry: c};
            d = this.initMaterials(a.materials, b);
            this.needsTangents(d) && c.computeTangents();
            return {
                geometry: c,
                materials: d
            }
        };
        THREE.LoadingManager = function (a, b, c) {
            var d = this, e = 0, f = 0;
            this.onLoad = a;
            this.onProgress = b;
            this.onError = c;
            this.itemStart = function (a) {
                f++
            };
            this.itemEnd = function (a) {
                e++;
                if (void 0 !== d.onProgress)d.onProgress(a, e, f);
                if (e === f && void 0 !== d.onLoad)d.onLoad()
            }
        };
        THREE.DefaultLoadingManager = new THREE.LoadingManager;
        THREE.BufferGeometryLoader = function (a) {
            this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
        };
        THREE.BufferGeometryLoader.prototype = {
            constructor: THREE.BufferGeometryLoader, load: function (a, b, c, d) {
                var e = this, f = new THREE.XHRLoader(e.manager);
                f.setCrossOrigin(this.crossOrigin);
                f.load(a, function (a) {
                    b(e.parse(JSON.parse(a)))
                }, c, d)
            }, setCrossOrigin: function (a) {
                this.crossOrigin = a
            }, parse: function (a) {
                var b = new THREE.BufferGeometry, c = a.data.attributes, d;
                for (d in c) {
                    var e = c[d], f = new self[e.type](e.array);
                    b.addAttribute(d, new THREE.BufferAttribute(f, e.itemSize))
                }
                c = a.data.offsets;
                void 0 !== c && (b.offsets = JSON.parse(JSON.stringify(c)));
                a = a.data.boundingSphere;
                void 0 !== a && (c = new THREE.Vector3, void 0 !== a.center && c.fromArray(a.center), b.boundingSphere = new THREE.Sphere(c, a.radius));
                return b
            }
        };
        THREE.MaterialLoader = function (a) {
            this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
        };
        THREE.MaterialLoader.prototype = {
            constructor: THREE.MaterialLoader, load: function (a, b, c, d) {
                var e = this, f = new THREE.XHRLoader(e.manager);
                f.setCrossOrigin(this.crossOrigin);
                f.load(a, function (a) {
                    b(e.parse(JSON.parse(a)))
                }, c, d)
            }, setCrossOrigin: function (a) {
                this.crossOrigin = a
            }, parse: function (a) {
                var b = new THREE[a.type];
                void 0 !== a.color && b.color.setHex(a.color);
                void 0 !== a.emissive && b.emissive.setHex(a.emissive);
                void 0 !== a.specular && b.specular.setHex(a.specular);
                void 0 !== a.shininess && (b.shininess = a.shininess);
                void 0 !== a.uniforms && (b.uniforms = a.uniforms);
                void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader);
                void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader);
                void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
                void 0 !== a.shading && (b.shading = a.shading);
                void 0 !== a.blending && (b.blending = a.blending);
                void 0 !== a.side && (b.side = a.side);
                void 0 !== a.opacity && (b.opacity = a.opacity);
                void 0 !== a.transparent && (b.transparent = a.transparent);
                void 0 !== a.wireframe && (b.wireframe = a.wireframe);
                void 0 !== a.size &&
                (b.size = a.size);
                void 0 !== a.sizeAttenuation && (b.sizeAttenuation = a.sizeAttenuation);
                if (void 0 !== a.materials)for (var c = 0, d = a.materials.length; c < d; c++)b.materials.push(this.parse(a.materials[c]));
                return b
            }
        };
        THREE.ObjectLoader = function (a) {
            this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
            this.texturePath = ""
        };
        THREE.ObjectLoader.prototype = {
            constructor: THREE.ObjectLoader, load: function (a, b, c, d) {
                "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
                var e = this, f = new THREE.XHRLoader(e.manager);
                f.setCrossOrigin(this.crossOrigin);
                f.load(a, function (a) {
                    e.parse(JSON.parse(a), b)
                }, c, d)
            }, setTexturePath: function (a) {
                this.texturePath = a
            }, setCrossOrigin: function (a) {
                this.crossOrigin = a
            }, parse: function (a, b) {
                var c = this.parseGeometries(a.geometries), d = this.parseImages(a.images, function () {
                        void 0 !== b && b(e)
                    }),
                    d = this.parseTextures(a.textures, d), d = this.parseMaterials(a.materials, d), e = this.parseObject(a.object, c, d);
                void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
                return e
            }, parseGeometries: function (a) {
                var b = {};
                if (void 0 !== a)for (var c = new THREE.JSONLoader, d = new THREE.BufferGeometryLoader, e = 0, f = a.length; e < f; e++) {
                    var g, h = a[e];
                    switch (h.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            g = new THREE[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "CubeGeometry":
                            g =
                                new THREE.BoxGeometry(h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                            break;
                        case "CircleGeometry":
                            g = new THREE.CircleGeometry(h.radius, h.segments);
                            break;
                        case "CylinderGeometry":
                            g = new THREE.CylinderGeometry(h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded);
                            break;
                        case "SphereGeometry":
                            g = new THREE.SphereGeometry(h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                            break;
                        case "IcosahedronGeometry":
                            g = new THREE.IcosahedronGeometry(h.radius,
                                h.detail);
                            break;
                        case "TorusGeometry":
                            g = new THREE.TorusGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                            break;
                        case "TorusKnotGeometry":
                            g = new THREE.TorusKnotGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.p, h.q, h.heightScale);
                            break;
                        case "BufferGeometry":
                            g = d.parse(h);
                            break;
                        case "Geometry":
                            g = c.parse(h.data).geometry
                    }
                    g.uuid = h.uuid;
                    void 0 !== h.name && (g.name = h.name);
                    b[h.uuid] = g
                }
                return b
            }, parseMaterials: function (a, b) {
                var c = {};
                if (void 0 !== a)for (var d = function (a) {
                    void 0 === b[a] &&
                    THREE.warn("THREE.ObjectLoader: Undefined texture", a);
                    return b[a]
                }, e = new THREE.MaterialLoader, f = 0, g = a.length; f < g; f++) {
                    var h = a[f], k = e.parse(h);
                    k.uuid = h.uuid;
                    void 0 !== h.name && (k.name = h.name);
                    void 0 !== h.map && (k.map = d(h.map));
                    void 0 !== h.bumpMap && (k.bumpMap = d(h.bumpMap), h.bumpScale && (k.bumpScale = new THREE.Vector2(h.bumpScale, h.bumpScale)));
                    void 0 !== h.alphaMap && (k.alphaMap = d(h.alphaMap));
                    void 0 !== h.envMap && (k.envMap = d(h.envMap));
                    void 0 !== h.normalMap && (k.normalMap = d(h.normalMap), h.normalScale && (k.normalScale =
                        new THREE.Vector2(h.normalScale, h.normalScale)));
                    void 0 !== h.lightMap && (k.lightMap = d(h.lightMap));
                    void 0 !== h.specularMap && (k.specularMap = d(h.specularMap));
                    c[h.uuid] = k
                }
                return c
            }, parseImages: function (a, b) {
                var c = this, d = {};
                if (void 0 !== a && 0 < a.length) {
                    var e = new THREE.LoadingManager(b), f = new THREE.ImageLoader(e);
                    f.setCrossOrigin(this.crossOrigin);
                    for (var e = function (a) {
                        c.manager.itemStart(a);
                        return f.load(a, function () {
                            c.manager.itemEnd(a)
                        })
                    }, g = 0, h = a.length; g < h; g++) {
                        var k = a[g], l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(k.url) ?
                            k.url : c.texturePath + k.url;
                        d[k.uuid] = e(l)
                    }
                }
                return d
            }, parseTextures: function (a, b) {
                var c = {};
                if (void 0 !== a)for (var d = 0, e = a.length; d < e; d++) {
                    var f = a[d];
                    void 0 === f.image && THREE.warn('THREE.ObjectLoader: No "image" speficied for', f.uuid);
                    void 0 === b[f.image] && THREE.warn("THREE.ObjectLoader: Undefined image", f.image);
                    var g = new THREE.Texture(b[f.image]);
                    g.needsUpdate = !0;
                    g.uuid = f.uuid;
                    void 0 !== f.name && (g.name = f.name);
                    void 0 !== f.repeat && (g.repeat = new THREE.Vector2(f.repeat[0], f.repeat[1]));
                    void 0 !== f.minFilter &&
                    (g.minFilter = THREE[f.minFilter]);
                    void 0 !== f.magFilter && (g.magFilter = THREE[f.magFilter]);
                    void 0 !== f.anisotropy && (g.anisotropy = f.anisotropy);
                    f.wrap instanceof Array && (g.wrapS = THREE[f.wrap[0]], g.wrapT = THREE[f.wrap[1]]);
                    c[f.uuid] = g
                }
                return c
            }, parseObject: function () {
                var a = new THREE.Matrix4;
                return function (b, c, d) {
                    var e;
                    e = function (a) {
                        void 0 === c[a] && THREE.warn("THREE.ObjectLoader: Undefined geometry", a);
                        return c[a]
                    };
                    var f = function (a) {
                        void 0 === d[a] && THREE.warn("THREE.ObjectLoader: Undefined material", a);
                        return d[a]
                    };
                    switch (b.type) {
                        case "Scene":
                            e = new THREE.Scene;
                            break;
                        case "PerspectiveCamera":
                            e = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
                            break;
                        case "OrthographicCamera":
                            e = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
                            break;
                        case "AmbientLight":
                            e = new THREE.AmbientLight(b.color);
                            break;
                        case "DirectionalLight":
                            e = new THREE.DirectionalLight(b.color, b.intensity);
                            break;
                        case "PointLight":
                            e = new THREE.PointLight(b.color, b.intensity, b.distance, b.decay);
                            break;
                        case "SpotLight":
                            e = new THREE.SpotLight(b.color,
                                b.intensity, b.distance, b.angle, b.exponent, b.decay);
                            break;
                        case "HemisphereLight":
                            e = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
                            break;
                        case "Mesh":
                            e = new THREE.Mesh(e(b.geometry), f(b.material));
                            break;
                        case "Line":
                            e = new THREE.Line(e(b.geometry), f(b.material), b.mode);
                            break;
                        case "PointCloud":
                            e = new THREE.PointCloud(e(b.geometry), f(b.material));
                            break;
                        case "Sprite":
                            e = new THREE.Sprite(f(b.material));
                            break;
                        case "Group":
                            e = new THREE.Group;
                            break;
                        default:
                            e = new THREE.Object3D
                    }
                    e.uuid = b.uuid;
                    void 0 !==
                    b.name && (e.name = b.name);
                    void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(e.position, e.quaternion, e.scale)) : (void 0 !== b.position && e.position.fromArray(b.position), void 0 !== b.rotation && e.rotation.fromArray(b.rotation), void 0 !== b.scale && e.scale.fromArray(b.scale));
                    void 0 !== b.visible && (e.visible = b.visible);
                    void 0 !== b.userData && (e.userData = b.userData);
                    if (void 0 !== b.children)for (var g in b.children)e.add(this.parseObject(b.children[g], c, d));
                    return e
                }
            }()
        };
        THREE.TextureLoader = function (a) {
            this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
        };
        THREE.TextureLoader.prototype = {
            constructor: THREE.TextureLoader, load: function (a, b, c, d) {
                var e = new THREE.ImageLoader(this.manager);
                e.setCrossOrigin(this.crossOrigin);
                e.load(a, function (a) {
                    a = new THREE.Texture(a);
                    a.needsUpdate = !0;
                    void 0 !== b && b(a)
                }, c, d)
            }, setCrossOrigin: function (a) {
                this.crossOrigin = a
            }
        };
        THREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {
            this._parser = null
        };
        THREE.BinaryTextureLoader.prototype = {
            constructor: THREE.BinaryTextureLoader, load: function (a, b, c, d) {
                var e = this, f = new THREE.DataTexture, g = new THREE.XHRLoader;
                g.setResponseType("arraybuffer");
                g.load(a, function (a) {
                    if (a = e._parser(a))void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : THREE.ClampToEdgeWrapping, f.wrapT = void 0 !== a.wrapT ? a.wrapT : THREE.ClampToEdgeWrapping, f.magFilter = void 0 !== a.magFilter ? a.magFilter :
                        THREE.LinearFilter, f.minFilter = void 0 !== a.minFilter ? a.minFilter : THREE.LinearMipMapLinearFilter, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.needsUpdate = !0, b && b(f, a)
                }, c, d);
                return f
            }
        };
        THREE.CompressedTextureLoader = function () {
            this._parser = null
        };
        THREE.CompressedTextureLoader.prototype = {
            constructor: THREE.CompressedTextureLoader, load: function (a, b, c) {
                var d = this, e = [], f = new THREE.CompressedTexture;
                f.image = e;
                var g = new THREE.XHRLoader;
                g.setResponseType("arraybuffer");
                if (a instanceof Array) {
                    var h = 0;
                    c = function (c) {
                        g.load(a[c], function (a) {
                            a = d._parser(a, !0);
                            e[c] = {width: a.width, height: a.height, format: a.format, mipmaps: a.mipmaps};
                            h += 1;
                            6 === h && (1 == a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.format = a.format, f.needsUpdate = !0, b && b(f))
                        })
                    };
                    for (var k = 0, l =
                        a.length; k < l; ++k)c(k)
                } else g.load(a, function (a) {
                    a = d._parser(a, !0);
                    if (a.isCubemap)for (var c = a.mipmaps.length / a.mipmapCount, g = 0; g < c; g++) {
                        e[g] = {mipmaps: []};
                        for (var h = 0; h < a.mipmapCount; h++)e[g].mipmaps.push(a.mipmaps[g * a.mipmapCount + h]), e[g].format = a.format, e[g].width = a.width, e[g].height = a.height
                    } else f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
                    1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter);
                    f.format = a.format;
                    f.needsUpdate = !0;
                    b && b(f)
                });
                return f
            }
        };
        THREE.Material = function () {
            Object.defineProperty(this, "id", {value: THREE.MaterialIdCount++});
            this.uuid = THREE.Math.generateUUID();
            this.name = "";
            this.type = "Material";
            this.side = THREE.FrontSide;
            this.opacity = 1;
            this.transparent = !1;
            this.blending = THREE.NormalBlending;
            this.blendSrc = THREE.SrcAlphaFactor;
            this.blendDst = THREE.OneMinusSrcAlphaFactor;
            this.blendEquation = THREE.AddEquation;
            this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
            this.colorWrite = this.depthWrite = this.depthTest = !0;
            this.polygonOffset = !1;
            this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
            this._needsUpdate = this.visible = !0
        };
        THREE.Material.prototype = {
            constructor: THREE.Material, get needsUpdate() {
                return this._needsUpdate
            }, set needsUpdate(a) {
                !0 === a && this.update();
                this._needsUpdate = a
            }, setValues: function (a) {
                if (void 0 !== a)for (var b in a) {
                    var c = a[b];
                    if (void 0 === c)THREE.warn("THREE.Material: '" + b + "' parameter is undefined."); else if (b in this) {
                        var d = this[b];
                        d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = "overdraw" == b ? Number(c) : c
                    }
                }
            }, toJSON: function () {
                var a = {
                    metadata: {
                        version: 4.2,
                        type: "material", generator: "MaterialExporter"
                    }, uuid: this.uuid, type: this.type
                };
                "" !== this.name && (a.name = this.name);
                this instanceof THREE.MeshBasicMaterial ? (a.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshLambertMaterial ? (a.color = this.color.getHex(), a.emissive = this.emissive.getHex(), this.vertexColors !== THREE.NoColors &&
                (a.vertexColors = this.vertexColors), this.shading !== THREE.SmoothShading && (a.shading = this.shading), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshPhongMaterial ? (a.color = this.color.getHex(), a.emissive = this.emissive.getHex(), a.specular = this.specular.getHex(), a.shininess = this.shininess, this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.shading !== THREE.SmoothShading && (a.shading = this.shading),
                this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshNormalMaterial ? (this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshDepthMaterial ? (this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.PointCloudMaterial ? (a.size = this.size, a.sizeAttenuation =
                    this.sizeAttenuation, a.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending)) : this instanceof THREE.ShaderMaterial ? (a.uniforms = this.uniforms, a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader) : this instanceof THREE.SpriteMaterial && (a.color = this.color.getHex());
                1 > this.opacity && (a.opacity = this.opacity);
                !1 !== this.transparent && (a.transparent = this.transparent);
                !1 !== this.wireframe &&
                (a.wireframe = this.wireframe);
                return a
            }, clone: function (a) {
                void 0 === a && (a = new THREE.Material);
                a.name = this.name;
                a.side = this.side;
                a.opacity = this.opacity;
                a.transparent = this.transparent;
                a.blending = this.blending;
                a.blendSrc = this.blendSrc;
                a.blendDst = this.blendDst;
                a.blendEquation = this.blendEquation;
                a.blendSrcAlpha = this.blendSrcAlpha;
                a.blendDstAlpha = this.blendDstAlpha;
                a.blendEquationAlpha = this.blendEquationAlpha;
                a.depthTest = this.depthTest;
                a.depthWrite = this.depthWrite;
                a.polygonOffset = this.polygonOffset;
                a.polygonOffsetFactor =
                    this.polygonOffsetFactor;
                a.polygonOffsetUnits = this.polygonOffsetUnits;
                a.alphaTest = this.alphaTest;
                a.overdraw = this.overdraw;
                a.visible = this.visible;
                return a
            }, update: function () {
                this.dispatchEvent({type: "update"})
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        };
        THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
        THREE.MaterialIdCount = 0;
        THREE.LineBasicMaterial = function (a) {
            THREE.Material.call(this);
            this.type = "LineBasicMaterial";
            this.color = new THREE.Color(16777215);
            this.linewidth = 1;
            this.linejoin = this.linecap = "round";
            this.vertexColors = THREE.NoColors;
            this.fog = !0;
            this.setValues(a)
        };
        THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
        THREE.LineBasicMaterial.prototype.clone = function () {
            var a = new THREE.LineBasicMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.color.copy(this.color);
            a.linewidth = this.linewidth;
            a.linecap = this.linecap;
            a.linejoin = this.linejoin;
            a.vertexColors = this.vertexColors;
            a.fog = this.fog;
            return a
        };
        THREE.LineDashedMaterial = function (a) {
            THREE.Material.call(this);
            this.type = "LineDashedMaterial";
            this.color = new THREE.Color(16777215);
            this.scale = this.linewidth = 1;
            this.dashSize = 3;
            this.gapSize = 1;
            this.vertexColors = !1;
            this.fog = !0;
            this.setValues(a)
        };
        THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
        THREE.LineDashedMaterial.prototype.clone = function () {
            var a = new THREE.LineDashedMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.color.copy(this.color);
            a.linewidth = this.linewidth;
            a.scale = this.scale;
            a.dashSize = this.dashSize;
            a.gapSize = this.gapSize;
            a.vertexColors = this.vertexColors;
            a.fog = this.fog;
            return a
        };
        THREE.MeshBasicMaterial = function (a) {
            THREE.Material.call(this);
            this.type = "MeshBasicMaterial";
            this.color = new THREE.Color(16777215);
            this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null;
            this.combine = THREE.MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = .98;
            this.fog = !0;
            this.shading = THREE.SmoothShading;
            this.wireframe = !1;
            this.wireframeLinewidth = 1;
            this.wireframeLinejoin = this.wireframeLinecap = "round";
            this.vertexColors = THREE.NoColors;
            this.morphTargets = this.skinning = !1;
            this.setValues(a)
        };
        THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
        THREE.MeshBasicMaterial.prototype.clone = function () {
            var a = new THREE.MeshBasicMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.color.copy(this.color);
            a.map = this.map;
            a.lightMap = this.lightMap;
            a.specularMap = this.specularMap;
            a.alphaMap = this.alphaMap;
            a.envMap = this.envMap;
            a.combine = this.combine;
            a.reflectivity = this.reflectivity;
            a.refractionRatio = this.refractionRatio;
            a.fog = this.fog;
            a.shading = this.shading;
            a.wireframe = this.wireframe;
            a.wireframeLinewidth = this.wireframeLinewidth;
            a.wireframeLinecap = this.wireframeLinecap;
            a.wireframeLinejoin = this.wireframeLinejoin;
            a.vertexColors = this.vertexColors;
            a.skinning = this.skinning;
            a.morphTargets = this.morphTargets;
            return a
        };
        THREE.MeshLambertMaterial = function (a) {
            THREE.Material.call(this);
            this.type = "MeshLambertMaterial";
            this.color = new THREE.Color(16777215);
            this.emissive = new THREE.Color(0);
            this.wrapAround = !1;
            this.wrapRGB = new THREE.Vector3(1, 1, 1);
            this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null;
            this.combine = THREE.MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = .98;
            this.fog = !0;
            this.shading = THREE.SmoothShading;
            this.wireframe = !1;
            this.wireframeLinewidth = 1;
            this.wireframeLinejoin = this.wireframeLinecap =
                "round";
            this.vertexColors = THREE.NoColors;
            this.morphNormals = this.morphTargets = this.skinning = !1;
            this.setValues(a)
        };
        THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
        THREE.MeshLambertMaterial.prototype.clone = function () {
            var a = new THREE.MeshLambertMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.color.copy(this.color);
            a.emissive.copy(this.emissive);
            a.wrapAround = this.wrapAround;
            a.wrapRGB.copy(this.wrapRGB);
            a.map = this.map;
            a.lightMap = this.lightMap;
            a.specularMap = this.specularMap;
            a.alphaMap = this.alphaMap;
            a.envMap = this.envMap;
            a.combine = this.combine;
            a.reflectivity = this.reflectivity;
            a.refractionRatio = this.refractionRatio;
            a.fog = this.fog;
            a.shading = this.shading;
            a.wireframe =
                this.wireframe;
            a.wireframeLinewidth = this.wireframeLinewidth;
            a.wireframeLinecap = this.wireframeLinecap;
            a.wireframeLinejoin = this.wireframeLinejoin;
            a.vertexColors = this.vertexColors;
            a.skinning = this.skinning;
            a.morphTargets = this.morphTargets;
            a.morphNormals = this.morphNormals;
            return a
        };
        THREE.MeshPhongMaterial = function (a) {
            THREE.Material.call(this);
            this.type = "MeshPhongMaterial";
            this.color = new THREE.Color(16777215);
            this.emissive = new THREE.Color(0);
            this.specular = new THREE.Color(1118481);
            this.shininess = 30;
            this.wrapAround = this.metal = !1;
            this.wrapRGB = new THREE.Vector3(1, 1, 1);
            this.bumpMap = this.lightMap = this.map = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalScale = new THREE.Vector2(1, 1);
            this.envMap = this.alphaMap = this.specularMap = null;
            this.combine = THREE.MultiplyOperation;
            this.reflectivity =
                1;
            this.refractionRatio = .98;
            this.fog = !0;
            this.shading = THREE.SmoothShading;
            this.wireframe = !1;
            this.wireframeLinewidth = 1;
            this.wireframeLinejoin = this.wireframeLinecap = "round";
            this.vertexColors = THREE.NoColors;
            this.morphNormals = this.morphTargets = this.skinning = !1;
            this.setValues(a)
        };
        THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
        THREE.MeshPhongMaterial.prototype.clone = function () {
            var a = new THREE.MeshPhongMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.color.copy(this.color);
            a.emissive.copy(this.emissive);
            a.specular.copy(this.specular);
            a.shininess = this.shininess;
            a.metal = this.metal;
            a.wrapAround = this.wrapAround;
            a.wrapRGB.copy(this.wrapRGB);
            a.map = this.map;
            a.lightMap = this.lightMap;
            a.bumpMap = this.bumpMap;
            a.bumpScale = this.bumpScale;
            a.normalMap = this.normalMap;
            a.normalScale.copy(this.normalScale);
            a.specularMap = this.specularMap;
            a.alphaMap = this.alphaMap;
            a.envMap = this.envMap;
            a.combine = this.combine;
            a.reflectivity = this.reflectivity;
            a.refractionRatio = this.refractionRatio;
            a.fog = this.fog;
            a.shading = this.shading;
            a.wireframe = this.wireframe;
            a.wireframeLinewidth = this.wireframeLinewidth;
            a.wireframeLinecap = this.wireframeLinecap;
            a.wireframeLinejoin = this.wireframeLinejoin;
            a.vertexColors = this.vertexColors;
            a.skinning = this.skinning;
            a.morphTargets = this.morphTargets;
            a.morphNormals = this.morphNormals;
            return a
        };
        THREE.MeshDepthMaterial = function (a) {
            THREE.Material.call(this);
            this.type = "MeshDepthMaterial";
            this.wireframe = this.morphTargets = !1;
            this.wireframeLinewidth = 1;
            this.setValues(a)
        };
        THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
        THREE.MeshDepthMaterial.prototype.clone = function () {
            var a = new THREE.MeshDepthMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.wireframe = this.wireframe;
            a.wireframeLinewidth = this.wireframeLinewidth;
            return a
        };
        THREE.MeshNormalMaterial = function (a) {
            THREE.Material.call(this, a);
            this.type = "MeshNormalMaterial";
            this.wireframe = !1;
            this.wireframeLinewidth = 1;
            this.morphTargets = !1;
            this.setValues(a)
        };
        THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
        THREE.MeshNormalMaterial.prototype.clone = function () {
            var a = new THREE.MeshNormalMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.wireframe = this.wireframe;
            a.wireframeLinewidth = this.wireframeLinewidth;
            return a
        };
        THREE.MeshFaceMaterial = function (a) {
            this.uuid = THREE.Math.generateUUID();
            this.type = "MeshFaceMaterial";
            this.materials = a instanceof Array ? a : []
        };
        THREE.MeshFaceMaterial.prototype = {
            constructor: THREE.MeshFaceMaterial, toJSON: function () {
                for (var a = {
                    metadata: {version: 4.2, type: "material", generator: "MaterialExporter"},
                    uuid: this.uuid,
                    type: this.type,
                    materials: []
                }, b = 0, c = this.materials.length; b < c; b++)a.materials.push(this.materials[b].toJSON());
                return a
            }, clone: function () {
                for (var a = new THREE.MeshFaceMaterial, b = 0; b < this.materials.length; b++)a.materials.push(this.materials[b].clone());
                return a
            }
        };
        THREE.PointCloudMaterial = function (a) {
            THREE.Material.call(this);
            this.type = "PointCloudMaterial";
            this.color = new THREE.Color(16777215);
            this.map = null;
            this.size = 1;
            this.sizeAttenuation = !0;
            this.vertexColors = THREE.NoColors;
            this.fog = !0;
            this.setValues(a)
        };
        THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;
        THREE.PointCloudMaterial.prototype.clone = function () {
            var a = new THREE.PointCloudMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.color.copy(this.color);
            a.map = this.map;
            a.size = this.size;
            a.sizeAttenuation = this.sizeAttenuation;
            a.vertexColors = this.vertexColors;
            a.fog = this.fog;
            return a
        };
        THREE.ParticleBasicMaterial = function (a) {
            THREE.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.");
            return new THREE.PointCloudMaterial(a)
        };
        THREE.ParticleSystemMaterial = function (a) {
            THREE.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.");
            return new THREE.PointCloudMaterial(a)
        };
        THREE.ShaderMaterial = function (a) {
            THREE.Material.call(this);
            this.type = "ShaderMaterial";
            this.defines = {};
            this.uniforms = {};
            this.attributes = null;
            this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
            this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
            this.shading = THREE.SmoothShading;
            this.linewidth = 1;
            this.wireframe = !1;
            this.wireframeLinewidth = 1;
            this.lights = this.fog = !1;
            this.vertexColors = THREE.NoColors;
            this.morphNormals =
                this.morphTargets = this.skinning = !1;
            this.defaultAttributeValues = {color: [1, 1, 1], uv: [0, 0], uv2: [0, 0]};
            this.index0AttributeName = void 0;
            this.setValues(a)
        };
        THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
        THREE.ShaderMaterial.prototype.clone = function () {
            var a = new THREE.ShaderMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.fragmentShader = this.fragmentShader;
            a.vertexShader = this.vertexShader;
            a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
            a.attributes = this.attributes;
            a.defines = this.defines;
            a.shading = this.shading;
            a.wireframe = this.wireframe;
            a.wireframeLinewidth = this.wireframeLinewidth;
            a.fog = this.fog;
            a.lights = this.lights;
            a.vertexColors = this.vertexColors;
            a.skinning = this.skinning;
            a.morphTargets =
                this.morphTargets;
            a.morphNormals = this.morphNormals;
            return a
        };
        THREE.RawShaderMaterial = function (a) {
            THREE.ShaderMaterial.call(this, a);
            this.type = "RawShaderMaterial"
        };
        THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
        THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
        THREE.RawShaderMaterial.prototype.clone = function () {
            var a = new THREE.RawShaderMaterial;
            THREE.ShaderMaterial.prototype.clone.call(this, a);
            return a
        };
        THREE.SpriteMaterial = function (a) {
            THREE.Material.call(this);
            this.type = "SpriteMaterial";
            this.color = new THREE.Color(16777215);
            this.map = null;
            this.rotation = 0;
            this.fog = !1;
            this.setValues(a)
        };
        THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
        THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
        THREE.SpriteMaterial.prototype.clone = function () {
            var a = new THREE.SpriteMaterial;
            THREE.Material.prototype.clone.call(this, a);
            a.color.copy(this.color);
            a.map = this.map;
            a.rotation = this.rotation;
            a.fog = this.fog;
            return a
        };
        THREE.Texture = function (a, b, c, d, e, f, g, h, k) {
            Object.defineProperty(this, "id", {value: THREE.TextureIdCount++});
            this.uuid = THREE.Math.generateUUID();
            this.sourceFile = this.name = "";
            this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE;
            this.mipmaps = [];
            this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING;
            this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
            this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
            this.magFilter = void 0 !== e ? e : THREE.LinearFilter;
            this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;
            this.anisotropy = void 0 !== k ? k : 1;
            this.format = void 0 !== g ? g : THREE.RGBAFormat;
            this.type = void 0 !== h ? h : THREE.UnsignedByteType;
            this.offset = new THREE.Vector2(0, 0);
            this.repeat = new THREE.Vector2(1, 1);
            this.generateMipmaps = !0;
            this.premultiplyAlpha = !1;
            this.flipY = !0;
            this.unpackAlignment = 4;
            this._needsUpdate = !1;
            this.onUpdate = null
        };
        THREE.Texture.DEFAULT_IMAGE = void 0;
        THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
        THREE.Texture.prototype = {
            constructor: THREE.Texture, get needsUpdate() {
                return this._needsUpdate
            }, set needsUpdate(a) {
                !0 === a && this.update();
                this._needsUpdate = a
            }, clone: function (a) {
                void 0 === a && (a = new THREE.Texture);
                a.image = this.image;
                a.mipmaps = this.mipmaps.slice(0);
                a.mapping = this.mapping;
                a.wrapS = this.wrapS;
                a.wrapT = this.wrapT;
                a.magFilter = this.magFilter;
                a.minFilter = this.minFilter;
                a.anisotropy = this.anisotropy;
                a.format = this.format;
                a.type = this.type;
                a.offset.copy(this.offset);
                a.repeat.copy(this.repeat);
                a.generateMipmaps =
                    this.generateMipmaps;
                a.premultiplyAlpha = this.premultiplyAlpha;
                a.flipY = this.flipY;
                a.unpackAlignment = this.unpackAlignment;
                return a
            }, update: function () {
                this.dispatchEvent({type: "update"})
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        };
        THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
        THREE.TextureIdCount = 0;
        THREE.CubeTexture = function (a, b, c, d, e, f, g, h, k) {
            b = void 0 !== b ? b : THREE.CubeReflectionMapping;
            THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);
            this.images = a
        };
        THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
        THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
        THREE.CubeTexture.clone = function (a) {
            void 0 === a && (a = new THREE.CubeTexture);
            THREE.Texture.prototype.clone.call(this, a);
            a.images = this.images;
            return a
        };
        THREE.CompressedTexture = function (a, b, c, d, e, f, g, h, k, l, p) {
            THREE.Texture.call(this, null, f, g, h, k, l, d, e, p);
            this.image = {width: b, height: c};
            this.mipmaps = a;
            this.generateMipmaps = this.flipY = !1
        };
        THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
        THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
        THREE.CompressedTexture.prototype.clone = function () {
            var a = new THREE.CompressedTexture;
            THREE.Texture.prototype.clone.call(this, a);
            return a
        };
        THREE.DataTexture = function (a, b, c, d, e, f, g, h, k, l, p) {
            THREE.Texture.call(this, null, f, g, h, k, l, d, e, p);
            this.image = {data: a, width: b, height: c}
        };
        THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
        THREE.DataTexture.prototype.constructor = THREE.DataTexture;
        THREE.DataTexture.prototype.clone = function () {
            var a = new THREE.DataTexture;
            THREE.Texture.prototype.clone.call(this, a);
            return a
        };
        THREE.VideoTexture = function (a, b, c, d, e, f, g, h, k) {
            THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);
            this.generateMipmaps = !1;
            var l = this, p = function () {
                requestAnimationFrame(p);
                a.readyState === a.HAVE_ENOUGH_DATA && (l.needsUpdate = !0)
            };
            p()
        };
        THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
        THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
        THREE.Group = function () {
            THREE.Object3D.call(this);
            this.type = "Group"
        };
        THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Group.prototype.constructor = THREE.Group;
        THREE.PointCloud = function (a, b) {
            THREE.Object3D.call(this);
            this.type = "PointCloud";
            this.geometry = void 0 !== a ? a : new THREE.Geometry;
            this.material = void 0 !== b ? b : new THREE.PointCloudMaterial({color: 16777215 * Math.random()})
        };
        THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype);
        THREE.PointCloud.prototype.constructor = THREE.PointCloud;
        THREE.PointCloud.prototype.raycast = function () {
            var a = new THREE.Matrix4, b = new THREE.Ray;
            return function (c, d) {
                var e = this, f = e.geometry, g = c.params.PointCloud.threshold;
                a.getInverse(this.matrixWorld);
                b.copy(c.ray).applyMatrix4(a);
                if (null === f.boundingBox || !1 !== b.isIntersectionBox(f.boundingBox)) {
                    var h = g / ((this.scale.x + this.scale.y + this.scale.z) / 3), k = new THREE.Vector3, g = function (a, f) {
                        var g = b.distanceToPoint(a);
                        if (g < h) {
                            var k = b.closestPointToPoint(a);
                            k.applyMatrix4(e.matrixWorld);
                            var n = c.ray.origin.distanceTo(k);
                            d.push({distance: n, distanceToRay: g, point: k.clone(), index: f, face: null, object: e})
                        }
                    };
                    if (f instanceof THREE.BufferGeometry) {
                        var l = f.attributes, p = l.position.array;
                        if (void 0 !== l.index) {
                            var l = l.index.array, q = f.offsets;
                            0 === q.length && (q = [{start: 0, count: l.length, index: 0}]);
                            for (var n = 0, t = q.length; n < t; ++n)for (var r = q[n].start, s = q[n].index, f = r, r = r + q[n].count; f < r; f++) {
                                var u = s + l[f];
                                k.fromArray(p, 3 * u);
                                g(k, u)
                            }
                        } else for (l = p.length / 3, f = 0; f < l; f++)k.set(p[3 * f], p[3 * f + 1], p[3 * f + 2]), g(k, f)
                    } else for (k = this.geometry.vertices,
                                    f = 0; f < k.length; f++)g(k[f], f)
                }
            }
        }();
        THREE.PointCloud.prototype.clone = function (a) {
            void 0 === a && (a = new THREE.PointCloud(this.geometry, this.material));
            THREE.Object3D.prototype.clone.call(this, a);
            return a
        };
        THREE.ParticleSystem = function (a, b) {
            THREE.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud.");
            return new THREE.PointCloud(a, b)
        };
        THREE.Line = function (a, b, c) {
            THREE.Object3D.call(this);
            this.type = "Line";
            this.geometry = void 0 !== a ? a : new THREE.Geometry;
            this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({color: 16777215 * Math.random()});
            this.mode = void 0 !== c ? c : THREE.LineStrip
        };
        THREE.LineStrip = 0;
        THREE.LinePieces = 1;
        THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Line.prototype.constructor = THREE.Line;
        THREE.Line.prototype.raycast = function () {
            var a = new THREE.Matrix4, b = new THREE.Ray, c = new THREE.Sphere;
            return function (d, e) {
                var f = d.linePrecision, f = f * f, g = this.geometry;
                null === g.boundingSphere && g.computeBoundingSphere();
                c.copy(g.boundingSphere);
                c.applyMatrix4(this.matrixWorld);
                if (!1 !== d.ray.isIntersectionSphere(c)) {
                    a.getInverse(this.matrixWorld);
                    b.copy(d.ray).applyMatrix4(a);
                    var h = new THREE.Vector3, k = new THREE.Vector3, l = new THREE.Vector3, p = new THREE.Vector3, q = this.mode === THREE.LineStrip ? 1 : 2;
                    if (g instanceof
                        THREE.BufferGeometry) {
                        var n = g.attributes;
                        if (void 0 !== n.index) {
                            var t = n.index.array, n = n.position.array, r = g.offsets;
                            0 === r.length && (r = [{start: 0, count: t.length, index: 0}]);
                            for (var s = 0; s < r.length; s++)for (var u = r[s].start, v = r[s].count, x = r[s].index, g = u; g < u + v - 1; g += q) {
                                var D = x + t[g + 1];
                                h.fromArray(n, 3 * (x + t[g]));
                                k.fromArray(n, 3 * D);
                                D = b.distanceSqToSegment(h, k, p, l);
                                D > f || (D = b.origin.distanceTo(p), D < d.near || D > d.far || e.push({
                                    distance: D, point: l.clone().applyMatrix4(this.matrixWorld), index: g, offsetIndex: s, face: null, faceIndex: null,
                                    object: this
                                }))
                            }
                        } else for (n = n.position.array, g = 0; g < n.length / 3 - 1; g += q)h.fromArray(n, 3 * g), k.fromArray(n, 3 * g + 3), D = b.distanceSqToSegment(h, k, p, l), D > f || (D = b.origin.distanceTo(p), D < d.near || D > d.far || e.push({
                            distance: D,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            index: g,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                    } else if (g instanceof THREE.Geometry)for (h = g.vertices, k = h.length, g = 0; g < k - 1; g += q)D = b.distanceSqToSegment(h[g], h[g + 1], p, l), D > f || (D = b.origin.distanceTo(p), D < d.near || D > d.far || e.push({
                        distance: D, point: l.clone().applyMatrix4(this.matrixWorld),
                        index: g, face: null, faceIndex: null, object: this
                    }))
                }
            }
        }();
        THREE.Line.prototype.clone = function (a) {
            void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.mode));
            THREE.Object3D.prototype.clone.call(this, a);
            return a
        };
        THREE.Mesh = function (a, b) {
            THREE.Object3D.call(this);
            this.type = "Mesh";
            this.geometry = void 0 !== a ? a : new THREE.Geometry;
            this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({color: 16777215 * Math.random()});
            this.updateMorphTargets()
        };
        THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Mesh.prototype.constructor = THREE.Mesh;
        THREE.Mesh.prototype.updateMorphTargets = function () {
            if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
                this.morphTargetBase = -1;
                this.morphTargetForcedOrder = [];
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++)this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a
            }
        };
        THREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {
            if (void 0 !== this.morphTargetDictionary[a])return this.morphTargetDictionary[a];
            THREE.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0.");
            return 0
        };
        THREE.Mesh.prototype.raycast = function () {
            var a = new THREE.Matrix4, b = new THREE.Ray, c = new THREE.Sphere, d = new THREE.Vector3, e = new THREE.Vector3, f = new THREE.Vector3;
            return function (g, h) {
                var k = this.geometry;
                null === k.boundingSphere && k.computeBoundingSphere();
                c.copy(k.boundingSphere);
                c.applyMatrix4(this.matrixWorld);
                if (!1 !== g.ray.isIntersectionSphere(c) && (a.getInverse(this.matrixWorld), b.copy(g.ray).applyMatrix4(a), null === k.boundingBox || !1 !== b.isIntersectionBox(k.boundingBox)))if (k instanceof THREE.BufferGeometry) {
                    var l =
                        this.material;
                    if (void 0 !== l) {
                        var p = k.attributes, q, n, t = g.precision;
                        if (void 0 !== p.index) {
                            var r = p.index.array, s = p.position.array, u = k.offsets;
                            0 === u.length && (u = [{start: 0, count: r.length, index: 0}]);
                            for (var v = 0, x = u.length; v < x; ++v)for (var p = u[v].start, D = u[v].index, k = p, w = p + u[v].count; k < w; k += 3) {
                                p = D + r[k];
                                q = D + r[k + 1];
                                n = D + r[k + 2];
                                d.fromArray(s, 3 * p);
                                e.fromArray(s, 3 * q);
                                f.fromArray(s, 3 * n);
                                var y = l.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, l.side !== THREE.DoubleSide);
                                if (null !== y) {
                                    y.applyMatrix4(this.matrixWorld);
                                    var A = g.ray.origin.distanceTo(y);
                                    A < t || A < g.near || A > g.far || h.push({distance: A, point: y, face: new THREE.Face3(p, q, n, THREE.Triangle.normal(d, e, f)), faceIndex: null, object: this})
                                }
                            }
                        } else for (s = p.position.array, r = k = 0, w = s.length; k < w; k += 3, r += 9)p = k, q = k + 1, n = k + 2, d.fromArray(s, r), e.fromArray(s, r + 3), f.fromArray(s, r + 6), y = l.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, l.side !== THREE.DoubleSide), null !== y && (y.applyMatrix4(this.matrixWorld), A = g.ray.origin.distanceTo(y), A < t || A < g.near || A >
                        g.far || h.push({distance: A, point: y, face: new THREE.Face3(p, q, n, THREE.Triangle.normal(d, e, f)), faceIndex: null, object: this}))
                    }
                } else if (k instanceof THREE.Geometry)for (r = this.material instanceof THREE.MeshFaceMaterial, s = !0 === r ? this.material.materials : null, t = g.precision, u = k.vertices, v = 0, x = k.faces.length; v < x; v++)if (D = k.faces[v], l = !0 === r ? s[D.materialIndex] : this.material, void 0 !== l) {
                    p = u[D.a];
                    q = u[D.b];
                    n = u[D.c];
                    if (!0 === l.morphTargets) {
                        y = k.morphTargets;
                        A = this.morphTargetInfluences;
                        d.set(0, 0, 0);
                        e.set(0, 0, 0);
                        f.set(0,
                            0, 0);
                        for (var w = 0, E = y.length; w < E; w++) {
                            var G = A[w];
                            if (0 !== G) {
                                var F = y[w].vertices;
                                d.x += (F[D.a].x - p.x) * G;
                                d.y += (F[D.a].y - p.y) * G;
                                d.z += (F[D.a].z - p.z) * G;
                                e.x += (F[D.b].x - q.x) * G;
                                e.y += (F[D.b].y - q.y) * G;
                                e.z += (F[D.b].z - q.z) * G;
                                f.x += (F[D.c].x - n.x) * G;
                                f.y += (F[D.c].y - n.y) * G;
                                f.z += (F[D.c].z - n.z) * G
                            }
                        }
                        d.add(p);
                        e.add(q);
                        f.add(n);
                        p = d;
                        q = e;
                        n = f
                    }
                    y = l.side === THREE.BackSide ? b.intersectTriangle(n, q, p, !0) : b.intersectTriangle(p, q, n, l.side !== THREE.DoubleSide);
                    null !== y && (y.applyMatrix4(this.matrixWorld), A = g.ray.origin.distanceTo(y), A < t ||
                    A < g.near || A > g.far || h.push({distance: A, point: y, face: D, faceIndex: v, object: this}))
                }
            }
        }();
        THREE.Mesh.prototype.clone = function (a, b) {
            void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));
            THREE.Object3D.prototype.clone.call(this, a, b);
            return a
        };
        THREE.Bone = function (a) {
            THREE.Object3D.call(this);
            this.type = "Bone";
            this.skin = a
        };
        THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Bone.prototype.constructor = THREE.Bone;
        THREE.Skeleton = function (a, b, c) {
            this.useVertexTexture = void 0 !== c ? c : !0;
            this.identityMatrix = new THREE.Matrix4;
            a = a || [];
            this.bones = a.slice(0);
            this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < this.bones.length ? 64 : 64 < this.bones.length ? 32 : 16 < this.bones.length ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType),
                this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length);
            if (void 0 === b)this.calculateInverses(); else if (this.bones.length === b.length)this.boneInverses = b.slice(0); else for (THREE.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], b = 0, a = this.bones.length; b < a; b++)this.boneInverses.push(new THREE.Matrix4)
        };
        THREE.Skeleton.prototype.calculateInverses = function () {
            this.boneInverses = [];
            for (var a = 0, b = this.bones.length; a < b; a++) {
                var c = new THREE.Matrix4;
                this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
                this.boneInverses.push(c)
            }
        };
        THREE.Skeleton.prototype.pose = function () {
            for (var a, b = 0, c = this.bones.length; b < c; b++)(a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
            b = 0;
            for (c = this.bones.length; b < c; b++)if (a = this.bones[b])a.parent ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
        };
        THREE.Skeleton.prototype.update = function () {
            var a = new THREE.Matrix4;
            return function () {
                for (var b = 0, c = this.bones.length; b < c; b++)a.multiplyMatrices(this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix, this.boneInverses[b]), a.flattenToArrayOffset(this.boneMatrices, 16 * b);
                this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
            }
        }();
        THREE.SkinnedMesh = function (a, b, c) {
            THREE.Mesh.call(this, a, b);
            this.type = "SkinnedMesh";
            this.bindMode = "attached";
            this.bindMatrix = new THREE.Matrix4;
            this.bindMatrixInverse = new THREE.Matrix4;
            a = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (var d, e, f, g, h = 0, k = this.geometry.bones.length; h < k; ++h)d = this.geometry.bones[h], e = d.pos, f = d.rotq, g = d.scl, b = new THREE.Bone(this), a.push(b), b.name = d.name, b.position.set(e[0], e[1], e[2]), b.quaternion.set(f[0], f[1], f[2], f[3]), void 0 !== g ? b.scale.set(g[0], g[1], g[2]) : b.scale.set(1,
                    1, 1);
                h = 0;
                for (k = this.geometry.bones.length; h < k; ++h)d = this.geometry.bones[h], -1 !== d.parent ? a[d.parent].add(a[h]) : this.add(a[h])
            }
            this.normalizeSkinWeights();
            this.updateMatrixWorld(!0);
            this.bind(new THREE.Skeleton(a, void 0, c))
        };
        THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
        THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
        THREE.SkinnedMesh.prototype.bind = function (a, b) {
            this.skeleton = a;
            void 0 === b && (this.updateMatrixWorld(!0), b = this.matrixWorld);
            this.bindMatrix.copy(b);
            this.bindMatrixInverse.getInverse(b)
        };
        THREE.SkinnedMesh.prototype.pose = function () {
            this.skeleton.pose()
        };
        THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
            if (this.geometry instanceof THREE.Geometry)for (var a = 0; a < this.geometry.skinIndices.length; a++) {
                var b = this.geometry.skinWeights[a], c = 1 / b.lengthManhattan();
                Infinity !== c ? b.multiplyScalar(c) : b.set(1)
            }
        };
        THREE.SkinnedMesh.prototype.updateMatrixWorld = function (a) {
            THREE.Mesh.prototype.updateMatrixWorld.call(this, !0);
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : THREE.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode)
        };
        THREE.SkinnedMesh.prototype.clone = function (a) {
            void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture));
            THREE.Mesh.prototype.clone.call(this, a);
            return a
        };
        THREE.MorphAnimMesh = function (a, b) {
            THREE.Mesh.call(this, a, b);
            this.type = "MorphAnimMesh";
            this.duration = 1E3;
            this.mirroredLoop = !1;
            this.currentKeyframe = this.lastKeyframe = this.time = 0;
            this.direction = 1;
            this.directionBackwards = !1;
            this.setFrameRange(0, this.geometry.morphTargets.length - 1)
        };
        THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
        THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;
        THREE.MorphAnimMesh.prototype.setFrameRange = function (a, b) {
            this.startKeyframe = a;
            this.endKeyframe = b;
            this.length = this.endKeyframe - this.startKeyframe + 1
        };
        THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
            this.direction = 1;
            this.directionBackwards = !1
        };
        THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
            this.direction = -1;
            this.directionBackwards = !0
        };
        THREE.MorphAnimMesh.prototype.parseAnimations = function () {
            var a = this.geometry;
            a.animations || (a.animations = {});
            for (var b, c = a.animations, d = /([a-z]+)_?(\d+)/, e = 0, f = a.morphTargets.length; e < f; e++) {
                var g = a.morphTargets[e].name.match(d);
                if (g && 1 < g.length) {
                    g = g[1];
                    c[g] || (c[g] = {start: Infinity, end: -Infinity});
                    var h = c[g];
                    e < h.start && (h.start = e);
                    e > h.end && (h.end = e);
                    b || (b = g)
                }
            }
            a.firstAnimation = b
        };
        THREE.MorphAnimMesh.prototype.setAnimationLabel = function (a, b, c) {
            this.geometry.animations || (this.geometry.animations = {});
            this.geometry.animations[a] = {start: b, end: c}
        };
        THREE.MorphAnimMesh.prototype.playAnimation = function (a, b) {
            var c = this.geometry.animations[a];
            c ? (this.setFrameRange(c.start, c.end), this.duration = (c.end - c.start) / b * 1E3, this.time = 0) : THREE.warn("THREE.MorphAnimMesh: animation[" + a + "] undefined in .playAnimation()")
        };
        THREE.MorphAnimMesh.prototype.updateAnimation = function (a) {
            var b = this.duration / this.length;
            this.time += this.direction * a;
            if (this.mirroredLoop) {
                if (this.time > this.duration || 0 > this.time)this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1)
            } else this.time %= this.duration, 0 > this.time && (this.time += this.duration);
            a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1);
            a !== this.currentKeyframe &&
            (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a);
            b = this.time % b / b;
            this.directionBackwards && (b = 1 - b);
            this.morphTargetInfluences[this.currentKeyframe] = b;
            this.morphTargetInfluences[this.lastKeyframe] = 1 - b
        };
        THREE.MorphAnimMesh.prototype.interpolateTargets = function (a, b, c) {
            for (var d = this.morphTargetInfluences, e = 0, f = d.length; e < f; e++)d[e] = 0;
            -1 < a && (d[a] = 1 - c);
            -1 < b && (d[b] = c)
        };
        THREE.MorphAnimMesh.prototype.clone = function (a) {
            void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material));
            a.duration = this.duration;
            a.mirroredLoop = this.mirroredLoop;
            a.time = this.time;
            a.lastKeyframe = this.lastKeyframe;
            a.currentKeyframe = this.currentKeyframe;
            a.direction = this.direction;
            a.directionBackwards = this.directionBackwards;
            THREE.Mesh.prototype.clone.call(this, a);
            return a
        };
        THREE.LOD = function () {
            THREE.Object3D.call(this);
            this.entities = []
        };
        THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
        THREE.LOD.prototype.constructor = THREE.LOD;
        THREE.LOD.prototype.addLevel = function (a, b) {
            void 0 === b && (b = 0);
            b = Math.abs(b);
            for (var c = 0; c < this.entities.length && !(b < this.entities[c].distance); c++);
            this.entities.splice(c, 0, {distance: b, object: a});
            this.add(a)
        };
        THREE.LOD.prototype.getObjectForDistance = function (a) {
            for (var b = 1, c = this.entities.length; b < c && !(a < this.entities[b].distance); b++);
            return this.entities[b - 1].object
        };
        THREE.LOD.prototype.raycast = function () {
            var a = new THREE.Vector3;
            return function (b, c) {
                a.setFromMatrixPosition(this.matrixWorld);
                var d = b.ray.origin.distanceTo(a);
                this.getObjectForDistance(d).raycast(b, c)
            }
        }();
        THREE.LOD.prototype.update = function () {
            var a = new THREE.Vector3, b = new THREE.Vector3;
            return function (c) {
                if (1 < this.entities.length) {
                    a.setFromMatrixPosition(c.matrixWorld);
                    b.setFromMatrixPosition(this.matrixWorld);
                    c = a.distanceTo(b);
                    this.entities[0].object.visible = !0;
                    for (var d = 1, e = this.entities.length; d < e; d++)if (c >= this.entities[d].distance)this.entities[d - 1].object.visible = !1, this.entities[d].object.visible = !0; else break;
                    for (; d < e; d++)this.entities[d].object.visible = !1
                }
            }
        }();
        THREE.LOD.prototype.clone = function (a) {
            void 0 === a && (a = new THREE.LOD);
            THREE.Object3D.prototype.clone.call(this, a);
            for (var b = 0, c = this.entities.length; b < c; b++) {
                var d = this.entities[b].object.clone();
                d.visible = 0 === b;
                a.addLevel(d, this.entities[b].distance)
            }
            return a
        };
        THREE.Sprite = function () {
            var a = new Uint16Array([0, 1, 2, 0, 2, 3]), b = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]), c = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), d = new THREE.BufferGeometry;
            d.addAttribute("index", new THREE.BufferAttribute(a, 1));
            d.addAttribute("position", new THREE.BufferAttribute(b, 3));
            d.addAttribute("uv", new THREE.BufferAttribute(c, 2));
            return function (a) {
                THREE.Object3D.call(this);
                this.type = "Sprite";
                this.geometry = d;
                this.material = void 0 !== a ? a : new THREE.SpriteMaterial
            }
        }();
        THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Sprite.prototype.constructor = THREE.Sprite;
        THREE.Sprite.prototype.raycast = function () {
            var a = new THREE.Vector3;
            return function (b, c) {
                a.setFromMatrixPosition(this.matrixWorld);
                var d = b.ray.distanceToPoint(a);
                d > this.scale.x || c.push({distance: d, point: this.position, face: null, object: this})
            }
        }();
        THREE.Sprite.prototype.clone = function (a) {
            void 0 === a && (a = new THREE.Sprite(this.material));
            THREE.Object3D.prototype.clone.call(this, a);
            return a
        };
        THREE.Particle = THREE.Sprite;
        THREE.LensFlare = function (a, b, c, d, e) {
            THREE.Object3D.call(this);
            this.lensFlares = [];
            this.positionScreen = new THREE.Vector3;
            this.customUpdateCallback = void 0;
            void 0 !== a && this.add(a, b, c, d, e)
        };
        THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
        THREE.LensFlare.prototype.constructor = THREE.LensFlare;
        THREE.LensFlare.prototype.add = function (a, b, c, d, e, f) {
            void 0 === b && (b = -1);
            void 0 === c && (c = 0);
            void 0 === f && (f = 1);
            void 0 === e && (e = new THREE.Color(16777215));
            void 0 === d && (d = THREE.NormalBlending);
            c = Math.min(c, Math.max(0, c));
            this.lensFlares.push({texture: a, size: b, distance: c, x: 0, y: 0, z: 0, scale: 1, rotation: 1, opacity: f, color: e, blending: d})
        };
        THREE.LensFlare.prototype.updateLensFlares = function () {
            var a, b = this.lensFlares.length, c, d = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
            for (a = 0; a < b; a++)c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = c.x * Math.PI * .25, c.rotation += .25 * (c.wantedRotation - c.rotation)
        };
        THREE.Scene = function () {
            THREE.Object3D.call(this);
            this.type = "Scene";
            this.overrideMaterial = this.fog = null;
            this.autoUpdate = !0
        };
        THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Scene.prototype.constructor = THREE.Scene;
        THREE.Scene.prototype.clone = function (a) {
            void 0 === a && (a = new THREE.Scene);
            THREE.Object3D.prototype.clone.call(this, a);
            null !== this.fog && (a.fog = this.fog.clone());
            null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
            a.autoUpdate = this.autoUpdate;
            a.matrixAutoUpdate = this.matrixAutoUpdate;
            return a
        };
        THREE.Fog = function (a, b, c) {
            this.name = "";
            this.color = new THREE.Color(a);
            this.near = void 0 !== b ? b : 1;
            this.far = void 0 !== c ? c : 1E3
        };
        THREE.Fog.prototype.clone = function () {
            return new THREE.Fog(this.color.getHex(), this.near, this.far)
        };
        THREE.FogExp2 = function (a, b) {
            this.name = "";
            this.color = new THREE.Color(a);
            this.density = void 0 !== b ? b : 2.5E-4
        };
        THREE.FogExp2.prototype.clone = function () {
            return new THREE.FogExp2(this.color.getHex(), this.density)
        };
        THREE.ShaderChunk = {};
        THREE.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n\tfloat distance = dot( planeNormal, point-pointOnPlane );\n\treturn point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\tif ( decayExponent > 0.0 ) {\n\t  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n\t}\n\treturn 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n\treturn a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n\treturn a;\n#endif\n}\n";
        THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
        THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n\tfloat dotProduct = dot( transformedNormal, dirVector );\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t#endif\n\n\t#endif\n\n\t#ifdef WRAP_AROUND\n\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n\t\t#endif\n\n\t#endif\n\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n\t#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\t\tlVector = normalize( lVector );\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n\t\t\tlVector = normalize( lVector );\n\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n\t\t\t#endif\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n\t\t#endif\n\n\t}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack += ambientLightColor;\n\n#endif\n";
        THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n\n#endif\n";
        THREE.ShaderChunk.default_vertex = "#ifdef USE_SKINNING\n\n\tvec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n\tvec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
        THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif";
        THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\t#ifdef USE_MORPHNORMALS\n\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n\t#else\n\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n\t#endif\n\n#endif\n";
        THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n\tuniform float logDepthBufFC;\n\n#endif";
        THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\n#endif";
        THREE.ShaderChunk.lights_phong_fragment = "#ifndef FLAT_SHADED\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n\t#endif\n\n#else\n\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\t\tlVector = normalize( lVector );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\ttotalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n\t\t\t\t// specular\n\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\ttotalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n\t\tlVector = normalize( lVector );\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\t// diffuse\n\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n\t\t\t#else\n\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t\t#endif\n\n\t\t\ttotalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n\t\t\t// specular\n\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n\t\t\ttotalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\t\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, dirVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\ttotalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n\t\t// specular\n\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n\t\t/*\n\t\t// fresnel term from skin shader\n\t\tconst float F0 = 0.128;\n\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\n\t\tfloat exponential = pow( base, 5.0 );\n\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\n\t\t*/\n\n\t\t/*\n\t\t// fresnel term from fresnel shader\n\t\tconst float mFresnelBias = 0.08;\n\t\tconst float mFresnelScale = 0.3;\n\t\tconst float mFresnelPower = 5.0;\n\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n\t\t*/\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\ttotalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\ttotalDiffuseLight += hemiColor;\n\n\t\t// specular (sky light)\n\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n\t\t// specular (ground light)\n\n\t\tvec3 lVectorGround = -lVector;\n\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n\t\ttotalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n\t}\n\n#endif\n\n#ifdef METAL\n\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n";
        THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n\n#endif";
        THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n\tvec3 morphedNormal = vec3( 0.0 );\n\n\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n\tmorphedNormal += normal;\n\n#endif";
        THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tuniform float refractionRatio;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\n\t#endif\n\n#endif\n";
        THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
        THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n";
        THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n";
        THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\tuniform sampler2D lightMap;\n\n#endif";
        THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n\t}\n\n#endif";
        THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif";
        THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\n\n\tdiffuseColor *= texelColor;\n\n#endif";
        THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n\tvUv2 = uv2;\n\n#endif";
        THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";
        THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";
        THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n\tvColor.xyz = inputToLinear( color.xyz );\n\n#endif";
        THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n\t#ifdef USE_MORPHTARGETS\n\n\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n\t#else\n\n\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n#endif\n";
        THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvarying vec3 vReflect;\n\n\tuniform float refractionRatio;\n\n#endif\n";
        THREE.ShaderChunk.linear_to_gamma_fragment = "\n\toutgoingLight = linearToOutput( outgoingLight );\n";
        THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif";
        THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n";
        THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\n#endif\n";
        THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\n\tenvColor.xyz = inputToLinear( envColor.xyz );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n";
        THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif";
        THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n\t#endif\n\n#endif";
        THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif";
        THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif";
        THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t#else\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t#endif\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n\t\tfogFactor = whiteCompliment( fogFactor );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\n\t#endif\n\t\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";
        THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n";
        THREE.ShaderChunk.defaultnormal_vertex = "#ifdef USE_SKINNING\n\n\tvec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n\tvec3 objectNormal = morphedNormal;\n\n#else\n\n\tvec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n\tobjectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
        THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n";
        THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
        THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
        THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n\toutgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif";
        THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";
        THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif";
        THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n\tvec3 morphed = vec3( 0.0 );\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n\tmorphed += position;\n\n#endif";
        THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t#else\n\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t#endif\n\n#endif\n";
        THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n\t#ifdef SHADOWMAP_DEBUG\n\n\t\tvec3 frustumColors[3];\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n\t#endif\n\n\t#ifdef SHADOWMAP_CASCADE\n\n\t\tint inFrustumCount = 0;\n\n\t#endif\n\n\tfloat fDepth;\n\tvec3 shadowColor = vec3( 1.0 );\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\tinFrustumCount += int( inFrustum );\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n\t\t#else\n\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\t#endif\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\t\t\tshadow += 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tshadow /= 9.0;\n\n\t\t*/\n\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\n\n\t\t\t\tmat3 shadowKernel;\n\t\t\t\tmat3 depthKernel;\n\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\n\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n\t\t\t\tvec4 shadowValues;\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#else\n\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\tif ( fDepth < shadowCoord.z )\n\n\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n\t\t\t#endif\n\n\t\t}\n\n\n\t\t#ifdef SHADOWMAP_DEBUG\n\n\t\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n\t\t\t#else\n\n\t\t\t\tif ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t}\n\n\t// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n\tshadowColor = inputToLinear( shadowColor );\n\n\toutgoingLight = outgoingLight * shadowColor;\n\n#endif\n";
        THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n\t#ifdef USE_SKINNING\n\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\n\t#elif defined( USE_MORPHTARGETS )\n\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n\t#else\n\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n#endif\n";
        THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\n\tuniform float shadowBias[ MAX_SHADOWS ];\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\tfloat depth = dot( rgba_depth, bit_shift );\n\t\treturn depth;\n\n\t}\n\n#endif";
        THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n";
        THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\t#extension GL_EXT_frag_depth : enable\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif";
        THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
        THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n";
        THREE.UniformsUtils = {
            merge: function (a) {
                for (var b = {}, c = 0; c < a.length; c++) {
                    var d = this.clone(a[c]), e;
                    for (e in d)b[e] = d[e]
                }
                return b
            }, clone: function (a) {
                var b = {}, c;
                for (c in a) {
                    b[c] = {};
                    for (var d in a[c]) {
                        var e = a[c][d];
                        b[c][d] = e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? e.clone() : e instanceof Array ? e.slice() : e
                    }
                }
                return b
            }
        };
        THREE.UniformsLib = {
            common: {
                diffuse: {type: "c", value: new THREE.Color(15658734)},
                opacity: {type: "f", value: 1},
                map: {type: "t", value: null},
                offsetRepeat: {type: "v4", value: new THREE.Vector4(0, 0, 1, 1)},
                lightMap: {type: "t", value: null},
                specularMap: {type: "t", value: null},
                alphaMap: {type: "t", value: null},
                envMap: {type: "t", value: null},
                flipEnvMap: {type: "f", value: -1},
                reflectivity: {type: "f", value: 1},
                refractionRatio: {type: "f", value: .98},
                morphTargetInfluences: {type: "f", value: 0}
            },
            bump: {
                bumpMap: {type: "t", value: null}, bumpScale: {
                    type: "f",
                    value: 1
                }
            },
            normalmap: {normalMap: {type: "t", value: null}, normalScale: {type: "v2", value: new THREE.Vector2(1, 1)}},
            fog: {fogDensity: {type: "f", value: 2.5E-4}, fogNear: {type: "f", value: 1}, fogFar: {type: "f", value: 2E3}, fogColor: {type: "c", value: new THREE.Color(16777215)}},
            lights: {
                ambientLightColor: {type: "fv", value: []},
                directionalLightDirection: {type: "fv", value: []},
                directionalLightColor: {type: "fv", value: []},
                hemisphereLightDirection: {type: "fv", value: []},
                hemisphereLightSkyColor: {type: "fv", value: []},
                hemisphereLightGroundColor: {
                    type: "fv",
                    value: []
                },
                pointLightColor: {type: "fv", value: []},
                pointLightPosition: {type: "fv", value: []},
                pointLightDistance: {type: "fv1", value: []},
                pointLightDecay: {type: "fv1", value: []},
                spotLightColor: {type: "fv", value: []},
                spotLightPosition: {type: "fv", value: []},
                spotLightDirection: {type: "fv", value: []},
                spotLightDistance: {type: "fv1", value: []},
                spotLightAngleCos: {type: "fv1", value: []},
                spotLightExponent: {type: "fv1", value: []},
                spotLightDecay: {type: "fv1", value: []}
            },
            particle: {
                psColor: {type: "c", value: new THREE.Color(15658734)},
                opacity: {
                    type: "f",
                    value: 1
                },
                size: {type: "f", value: 1},
                scale: {type: "f", value: 1},
                map: {type: "t", value: null},
                offsetRepeat: {type: "v4", value: new THREE.Vector4(0, 0, 1, 1)},
                fogDensity: {type: "f", value: 2.5E-4},
                fogNear: {type: "f", value: 1},
                fogFar: {type: "f", value: 2E3},
                fogColor: {type: "c", value: new THREE.Color(16777215)}
            },
            shadowmap: {
                shadowMap: {type: "tv", value: []},
                shadowMapSize: {type: "v2v", value: []},
                shadowBias: {type: "fv1", value: []},
                shadowDarkness: {type: "fv1", value: []},
                shadowMatrix: {type: "m4v", value: []}
            }
        };
        THREE.ShaderLib = {
            basic: {
                uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
                vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {",
                    THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "\t#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "\t#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex,
                    "}"].join("\n"),
                fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );",
                    THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "\toutgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
            },
            lambert: {
                uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                    emissive: {
                        type: "c",
                        value: new THREE.Color(0)
                    }, wrapRGB: {type: "v3", value: new THREE.Vector3(1, 1, 1)}
                }]),
                vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex,
                    THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex,
                    THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                fragmentShader: ["uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment,
                    THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment,
                    THREE.ShaderChunk.specularmap_fragment, "\t#ifdef DOUBLE_SIDED\n\t\tif ( gl_FrontFacing )\n\t\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\n\t\telse\n\t\t\toutgoingLight += diffuseColor.rgb * vLightBack + emissive;\n\t#else\n\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\n\t#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
            },
            phong: {
                uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                    emissive: {
                        type: "c",
                        value: new THREE.Color(0)
                    }, specular: {type: "c", value: new THREE.Color(1118481)}, shininess: {type: "f", value: 30}, wrapRGB: {type: "v3", value: new THREE.Vector3(1, 1, 1)}
                }]),
                vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif", THREE.ShaderChunk.common,
                    THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex,
                    THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "\tvViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                fragmentShader: ["#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;",
                    THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment,
                    "void main() {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment,
                    THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
            }, particle_basic: {
                uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
                vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\tgl_Position = projectionMatrix * mvPosition;",
                    THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
                fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( psColor, opacity );",
                    THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphatest_fragment, "\toutgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
            }, dashed: {
                uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
                    scale: {type: "f", value: 1},
                    dashSize: {type: "f", value: 1},
                    totalSize: {type: "f", value: 2}
                }]),
                vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;",
                    THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, "\toutgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
            },
            depth: {
                uniforms: {mNear: {type: "f", value: 1}, mFar: {type: "f", value: 2E3}, opacity: {type: "f", value: 1}},
                vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform float mNear;\nuniform float mFar;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment,
                    "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\n\tgl_FragColor = vec4( vec3( color ), opacity );\n}"].join("\n")
            }, normal: {
                uniforms: {opacity: {type: "f", value: 1}},
                vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex,
                    "void main() {\n\tvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform float opacity;\nvarying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
            }, cube: {
                uniforms: {
                    tCube: {type: "t", value: null},
                    tFlip: {type: "f", value: -1}
                },
                vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment,
                    "void main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
            }, equirect: {
                uniforms: {tEquirect: {type: "t", value: null}, tFlip: {type: "f", value: -1}},
                vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                    THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: ["uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\nvec3 direction = normalize( vWorldPosition );\nvec2 sampleUV;\nsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\nsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\ngl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk.logdepthbuf_fragment,
                    "}"].join("\n")
            }, depthRGBA: {
                uniforms: {},
                vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
                fragmentShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {",
                    THREE.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}"].join("\n")
            }
        };
        THREE.WebGLRenderer = function (a) {
            function b(a) {
                var b = a.geometry;
                a = a.material;
                var c = b.vertices.length;
                if (a.attributes) {
                    void 0 === b.__webglCustomAttributesList && (b.__webglCustomAttributesList = []);
                    for (var d in a.attributes) {
                        var e = a.attributes[d];
                        if (!e.__webglInitialized || e.createUniqueBuffers) {
                            e.__webglInitialized = !0;
                            var f = 1;
                            "v2" === e.type ? f = 2 : "v3" === e.type ? f = 3 : "v4" === e.type ? f = 4 : "c" === e.type && (f = 3);
                            e.size = f;
                            e.array = new Float32Array(c * f);
                            e.buffer = m.createBuffer();
                            e.buffer.belongsToAttribute = d;
                            e.needsUpdate = !0
                        }
                        b.__webglCustomAttributesList.push(e)
                    }
                }
            }

            function c(a, b) {
                return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material
            }

            function d(a, b, c, d) {
                c = c.attributes;
                var e = b.attributes;
                b = b.attributesKeys;
                for (var f = 0, g = b.length; f < g; f++) {
                    var h = b[f], k = e[h];
                    if (0 <= k) {
                        var n = c[h];
                        void 0 !== n ? (h = n.itemSize, m.bindBuffer(m.ARRAY_BUFFER, n.buffer), W.enableAttribute(k), m.vertexAttribPointer(k, h, m.FLOAT, !1, 0, d * h * 4)) : void 0 !== a.defaultAttributeValues && (2 === a.defaultAttributeValues[h].length ?
                            m.vertexAttrib2fv(k, a.defaultAttributeValues[h]) : 3 === a.defaultAttributeValues[h].length && m.vertexAttrib3fv(k, a.defaultAttributeValues[h]))
                    }
                }
                W.disableUnusedAttributes()
            }

            function e(a, b) {
                return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
            }

            function f(a, b) {
                return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
            }

            function g(a,
                       b) {
                return b[0] - a[0]
            }

            function h(a) {
                if (!1 !== a.visible) {
                    if (!(a instanceof THREE.Scene || a instanceof THREE.Group)) {
                        void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4, a._normalMatrix = new THREE.Matrix3, a.addEventListener("removed", wb));
                        var c = a.geometry;
                        if (void 0 !== c && void 0 === c.__webglInit)if (c.__webglInit = !0, c.addEventListener("dispose", jb), c instanceof THREE.BufferGeometry)B.info.memory.geometries++; else if (a instanceof THREE.Mesh)q(a, c); else if (a instanceof THREE.Line) {
                            if (void 0 ===
                                c.__webglVertexBuffer) {
                                c.__webglVertexBuffer = m.createBuffer();
                                c.__webglColorBuffer = m.createBuffer();
                                c.__webglLineDistanceBuffer = m.createBuffer();
                                B.info.memory.geometries++;
                                var d = c.vertices.length;
                                c.__vertexArray = new Float32Array(3 * d);
                                c.__colorArray = new Float32Array(3 * d);
                                c.__lineDistanceArray = new Float32Array(1 * d);
                                c.__webglLineCount = d;
                                b(a);
                                c.verticesNeedUpdate = !0;
                                c.colorsNeedUpdate = !0;
                                c.lineDistancesNeedUpdate = !0
                            }
                        } else a instanceof THREE.PointCloud && void 0 === c.__webglVertexBuffer && (c.__webglVertexBuffer =
                            m.createBuffer(), c.__webglColorBuffer = m.createBuffer(), B.info.memory.geometries++, d = c.vertices.length, c.__vertexArray = new Float32Array(3 * d), c.__colorArray = new Float32Array(3 * d), c.__webglParticleCount = d, b(a), c.verticesNeedUpdate = !0, c.colorsNeedUpdate = !0);
                        if (void 0 === a.__webglActive)if (a.__webglActive = !0, a instanceof THREE.Mesh)if (c instanceof THREE.BufferGeometry)n(ba, c, a); else {
                            if (c instanceof THREE.Geometry)for (var c = Ua[c.id], d = 0, e = c.length; d < e; d++)n(ba, c[d], a)
                        } else a instanceof THREE.Line || a instanceof
                        THREE.PointCloud ? n(ba, c, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && qa.push({
                            id: null,
                            object: a,
                            opaque: null,
                            transparent: null,
                            z: 0
                        });
                        if (a instanceof THREE.Light)ca.push(a); else if (a instanceof THREE.Sprite)Xa.push(a); else if (a instanceof THREE.LensFlare)Ya.push(a); else if ((c = ba[a.id]) && (!1 === a.frustumCulled || !0 === cb.intersectsObject(a)))for (d = 0, e = c.length; d < e; d++) {
                            var f = c[d], g = f, k = g.object, l = g.buffer, p = k.geometry, k = k.material;
                            k instanceof THREE.MeshFaceMaterial ? (k = k.materials[p instanceof
                            THREE.BufferGeometry ? 0 : l.materialIndex], g.material = k, k.transparent ? Qa.push(g) : Ka.push(g)) : k && (g.material = k, k.transparent ? Qa.push(g) : Ka.push(g));
                            f.render = !0;
                            !0 === B.sortObjects && (wa.setFromMatrixPosition(a.matrixWorld), wa.applyProjection(db), f.z = wa.z)
                        }
                    }
                    d = 0;
                    for (e = a.children.length; d < e; d++)h(a.children[d])
                }
            }

            function k(a, b, c, d, e) {
                for (var f, g = 0, h = a.length; g < h; g++) {
                    f = a[g];
                    var k = f.object, m = f.buffer;
                    w(k, b);
                    if (e)f = e; else {
                        f = f.material;
                        if (!f)continue;
                        u(f)
                    }
                    B.setMaterialFaces(f);
                    m instanceof THREE.BufferGeometry ?
                        B.renderBufferDirect(b, c, d, f, m, k) : B.renderBuffer(b, c, d, f, m, k)
                }
            }

            function l(a, b, c, d, e, f) {
                for (var g, h = 0, k = a.length; h < k; h++) {
                    g = a[h];
                    var m = g.object;
                    if (m.visible) {
                        if (f)g = f; else {
                            g = g[b];
                            if (!g)continue;
                            u(g)
                        }
                        B.renderImmediateObject(c, d, e, g, m)
                    }
                }
            }

            function p(a) {
                var b = a.object.material;
                b.transparent ? (a.transparent = b, a.opaque = null) : (a.opaque = b, a.transparent = null)
            }

            function q(a, b) {
                var d = a.material, e = !1;
                if (void 0 === Ua[b.id] || !0 === b.groupsNeedUpdate) {
                    delete ba[a.id];
                    for (var f = Ua, g = b.id, d = d instanceof THREE.MeshFaceMaterial,
                             h = da.get("OES_element_index_uint") ? 4294967296 : 65535, k, e = {}, l = b.morphTargets.length, p = b.morphNormals.length, q, s = {}, t = [], r = 0, w = b.faces.length; r < w; r++) {
                        k = b.faces[r];
                        var u = d ? k.materialIndex : 0;
                        u in e || (e[u] = {hash: u, counter: 0});
                        k = e[u].hash + "_" + e[u].counter;
                        k in s || (q = {id: Qb++, faces3: [], materialIndex: u, vertices: 0, numMorphTargets: l, numMorphNormals: p}, s[k] = q, t.push(q));
                        s[k].vertices + 3 > h && (e[u].counter += 1, k = e[u].hash + "_" + e[u].counter, k in s || (q = {
                            id: Qb++, faces3: [], materialIndex: u, vertices: 0, numMorphTargets: l,
                            numMorphNormals: p
                        }, s[k] = q, t.push(q)));
                        s[k].faces3.push(r);
                        s[k].vertices += 3
                    }
                    f[g] = t;
                    b.groupsNeedUpdate = !1
                }
                f = Ua[b.id];
                g = 0;
                for (d = f.length; g < d; g++) {
                    h = f[g];
                    if (void 0 === h.__webglVertexBuffer) {
                        e = h;
                        e.__webglVertexBuffer = m.createBuffer();
                        e.__webglNormalBuffer = m.createBuffer();
                        e.__webglTangentBuffer = m.createBuffer();
                        e.__webglColorBuffer = m.createBuffer();
                        e.__webglUVBuffer = m.createBuffer();
                        e.__webglUV2Buffer = m.createBuffer();
                        e.__webglSkinIndicesBuffer = m.createBuffer();
                        e.__webglSkinWeightsBuffer = m.createBuffer();
                        e.__webglFaceBuffer = m.createBuffer();
                        e.__webglLineBuffer = m.createBuffer();
                        if (p = e.numMorphTargets)for (e.__webglMorphTargetsBuffers = [], l = 0; l < p; l++)e.__webglMorphTargetsBuffers.push(m.createBuffer());
                        if (p = e.numMorphNormals)for (e.__webglMorphNormalsBuffers = [], l = 0; l < p; l++)e.__webglMorphNormalsBuffers.push(m.createBuffer());
                        B.info.memory.geometries++;
                        e = h;
                        r = a;
                        w = r.geometry;
                        p = e.faces3;
                        l = 3 * p.length;
                        s = 1 * p.length;
                        t = 3 * p.length;
                        p = c(r, e);
                        e.__vertexArray = new Float32Array(3 * l);
                        e.__normalArray = new Float32Array(3 * l);
                        e.__colorArray = new Float32Array(3 * l);
                        e.__uvArray = new Float32Array(2 * l);
                        1 < w.faceVertexUvs.length && (e.__uv2Array = new Float32Array(2 * l));
                        w.hasTangents && (e.__tangentArray = new Float32Array(4 * l));
                        r.geometry.skinWeights.length && r.geometry.skinIndices.length && (e.__skinIndexArray = new Float32Array(4 * l), e.__skinWeightArray = new Float32Array(4 * l));
                        r = null !== da.get("OES_element_index_uint") && 21845 < s ? Uint32Array : Uint16Array;
                        e.__typeArray = r;
                        e.__faceArray = new r(3 * s);
                        e.__lineArray = new r(2 * t);
                        if (w = e.numMorphTargets)for (e.__morphTargetsArrays =
                                                           [], r = 0; r < w; r++)e.__morphTargetsArrays.push(new Float32Array(3 * l));
                        if (w = e.numMorphNormals)for (e.__morphNormalsArrays = [], r = 0; r < w; r++)e.__morphNormalsArrays.push(new Float32Array(3 * l));
                        e.__webglFaceCount = 3 * s;
                        e.__webglLineCount = 2 * t;
                        if (p.attributes)for (s in void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []), s = void 0, p.attributes) {
                            var t = p.attributes[s], r = {}, v;
                            for (v in t)r[v] = t[v];
                            if (!r.__webglInitialized || r.createUniqueBuffers)r.__webglInitialized = !0, w = 1, "v2" === r.type ? w = 2 : "v3" ===
                            r.type ? w = 3 : "v4" === r.type ? w = 4 : "c" === r.type && (w = 3), r.size = w, r.array = new Float32Array(l * w), r.buffer = m.createBuffer(), r.buffer.belongsToAttribute = s, t.needsUpdate = !0, r.__original = t;
                            e.__webglCustomAttributesList.push(r)
                        }
                        e.__inittedArrays = !0;
                        b.verticesNeedUpdate = !0;
                        b.morphTargetsNeedUpdate = !0;
                        b.elementsNeedUpdate = !0;
                        b.uvsNeedUpdate = !0;
                        b.normalsNeedUpdate = !0;
                        b.tangentsNeedUpdate = !0;
                        e = b.colorsNeedUpdate = !0
                    } else e = !1;
                    (e || void 0 === a.__webglActive) && n(ba, h, a)
                }
                a.__webglActive = !0
            }

            function n(a, b, c) {
                var d = c.id;
                a[d] =
                    a[d] || [];
                a[d].push({id: d, buffer: b, object: c, material: null, z: 0})
            }

            function t(a) {
                var b = a.geometry;
                if (b instanceof THREE.BufferGeometry)for (var d = b.attributes, e = b.attributesKeys, f = 0, g = e.length; f < g; f++) {
                    var h = e[f], k = d[h], n = "index" === h ? m.ELEMENT_ARRAY_BUFFER : m.ARRAY_BUFFER;
                    void 0 === k.buffer ? (k.buffer = m.createBuffer(), m.bindBuffer(n, k.buffer), m.bufferData(n, k.array, k instanceof THREE.DynamicBufferAttribute ? m.DYNAMIC_DRAW : m.STATIC_DRAW), k.needsUpdate = !1) : !0 === k.needsUpdate && (m.bindBuffer(n, k.buffer), void 0 ===
                    k.updateRange || -1 === k.updateRange.count ? m.bufferSubData(n, 0, k.array) : 0 === k.updateRange.count ? console.error("THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.") : (m.bufferSubData(n, k.updateRange.offset * k.array.BYTES_PER_ELEMENT, k.array.subarray(k.updateRange.offset, k.updateRange.offset + k.updateRange.count)), k.updateRange.count = 0), k.needsUpdate = !1)
                } else if (a instanceof THREE.Mesh) {
                    !0 ===
                    b.groupsNeedUpdate && q(a, b);
                    for (var l = Ua[b.id], f = 0, p = l.length; f < p; f++) {
                        var t = l[f], w = c(a, t), u = w.attributes && r(w);
                        if (b.verticesNeedUpdate || b.morphTargetsNeedUpdate || b.elementsNeedUpdate || b.uvsNeedUpdate || b.normalsNeedUpdate || b.colorsNeedUpdate || b.tangentsNeedUpdate || u) {
                            var v = t, x = a, D = m.DYNAMIC_DRAW, A = !b.dynamic, E = w;
                            if (v.__inittedArrays) {
                                var G = !1 === E instanceof THREE.MeshPhongMaterial && E.shading === THREE.FlatShading, y = void 0, z = void 0, F = void 0, B = void 0, I = void 0, H = void 0, M = void 0, R = void 0, P = void 0, U = void 0,
                                    O = void 0, J = void 0, L = void 0, N = void 0, Ka = void 0, V = void 0, W = void 0, Qa = void 0, Ya = void 0, Xa = void 0, da = void 0, ba = void 0, ja = void 0, Pa = void 0, ka = void 0, Q = void 0, ha = void 0, ia = void 0, ob = void 0, Y = void 0, ub = void 0, pa = void 0, ab = void 0, oa = void 0, ca = void 0, qa = void 0, Ca = void 0, ta = void 0, na = void 0, wa = void 0, La = 0, Ma = 0, kb = 0, yb = 0, zb = 0, Ra = 0, Aa = 0, eb = 0, Ha = 0, la = 0, ra = 0, K = 0, za = void 0, Sa = v.__vertexArray, Ab = v.__uvArray, lb = v.__uv2Array, Na = v.__normalArray, sa = v.__tangentArray, Da = v.__colorArray, Ea = v.__skinIndexArray, Fa = v.__skinWeightArray,
                                    Gb = v.__morphTargetsArrays, Bb = v.__morphNormalsArrays, mb = v.__webglCustomAttributesList, C = void 0, Va = v.__faceArray, Ta = v.__lineArray, ea = x.geometry, fb = ea.elementsNeedUpdate, vb = ea.uvsNeedUpdate, Mb = ea.normalsNeedUpdate, Ob = ea.tangentsNeedUpdate, ib = ea.colorsNeedUpdate, sb = ea.morphTargetsNeedUpdate, Cb = ea.vertices, $ = v.faces3, xa = ea.faces, Hb = ea.faceVertexUvs[0], Oa = ea.faceVertexUvs[1], $a = ea.skinIndices, Ga = ea.skinWeights, nb = ea.morphTargets, bb = ea.morphNormals;
                                if (ea.verticesNeedUpdate) {
                                    y = 0;
                                    for (z = $.length; y < z; y++)B =
                                        xa[$[y]], J = Cb[B.a], L = Cb[B.b], N = Cb[B.c], Sa[Ma] = J.x, Sa[Ma + 1] = J.y, Sa[Ma + 2] = J.z, Sa[Ma + 3] = L.x, Sa[Ma + 4] = L.y, Sa[Ma + 5] = L.z, Sa[Ma + 6] = N.x, Sa[Ma + 7] = N.y, Sa[Ma + 8] = N.z, Ma += 9;
                                    m.bindBuffer(m.ARRAY_BUFFER, v.__webglVertexBuffer);
                                    m.bufferData(m.ARRAY_BUFFER, Sa, D)
                                }
                                if (sb)for (ca = 0, qa = nb.length; ca < qa; ca++) {
                                    y = ra = 0;
                                    for (z = $.length; y < z; y++)na = $[y], B = xa[na], J = nb[ca].vertices[B.a], L = nb[ca].vertices[B.b], N = nb[ca].vertices[B.c], Ca = Gb[ca], Ca[ra] = J.x, Ca[ra + 1] = J.y, Ca[ra + 2] = J.z, Ca[ra + 3] = L.x, Ca[ra + 4] = L.y, Ca[ra + 5] = L.z, Ca[ra + 6] = N.x, Ca[ra +
                                    7] = N.y, Ca[ra + 8] = N.z, E.morphNormals && (G ? Xa = Ya = Qa = bb[ca].faceNormals[na] : (wa = bb[ca].vertexNormals[na], Qa = wa.a, Ya = wa.b, Xa = wa.c), ta = Bb[ca], ta[ra] = Qa.x, ta[ra + 1] = Qa.y, ta[ra + 2] = Qa.z, ta[ra + 3] = Ya.x, ta[ra + 4] = Ya.y, ta[ra + 5] = Ya.z, ta[ra + 6] = Xa.x, ta[ra + 7] = Xa.y, ta[ra + 8] = Xa.z), ra += 9;
                                    m.bindBuffer(m.ARRAY_BUFFER, v.__webglMorphTargetsBuffers[ca]);
                                    m.bufferData(m.ARRAY_BUFFER, Gb[ca], D);
                                    E.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglMorphNormalsBuffers[ca]), m.bufferData(m.ARRAY_BUFFER, Bb[ca], D))
                                }
                                if (Ga.length) {
                                    y = 0;
                                    for (z = $.length; y < z; y++)B = xa[$[y]], Pa = Ga[B.a], ka = Ga[B.b], Q = Ga[B.c], Fa[la] = Pa.x, Fa[la + 1] = Pa.y, Fa[la + 2] = Pa.z, Fa[la + 3] = Pa.w, Fa[la + 4] = ka.x, Fa[la + 5] = ka.y, Fa[la + 6] = ka.z, Fa[la + 7] = ka.w, Fa[la + 8] = Q.x, Fa[la + 9] = Q.y, Fa[la + 10] = Q.z, Fa[la + 11] = Q.w, ha = $a[B.a], ia = $a[B.b], ob = $a[B.c], Ea[la] = ha.x, Ea[la + 1] = ha.y, Ea[la + 2] = ha.z, Ea[la + 3] = ha.w, Ea[la + 4] = ia.x, Ea[la + 5] = ia.y, Ea[la + 6] = ia.z, Ea[la + 7] = ia.w, Ea[la + 8] = ob.x, Ea[la + 9] = ob.y, Ea[la + 10] = ob.z, Ea[la + 11] = ob.w, la += 12;
                                    0 < la && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglSkinIndicesBuffer),
                                        m.bufferData(m.ARRAY_BUFFER, Ea, D), m.bindBuffer(m.ARRAY_BUFFER, v.__webglSkinWeightsBuffer), m.bufferData(m.ARRAY_BUFFER, Fa, D))
                                }
                                if (ib) {
                                    y = 0;
                                    for (z = $.length; y < z; y++)B = xa[$[y]], M = B.vertexColors, R = B.color, 3 === M.length && E.vertexColors === THREE.VertexColors ? (da = M[0], ba = M[1], ja = M[2]) : ja = ba = da = R, Da[Ha] = da.r, Da[Ha + 1] = da.g, Da[Ha + 2] = da.b, Da[Ha + 3] = ba.r, Da[Ha + 4] = ba.g, Da[Ha + 5] = ba.b, Da[Ha + 6] = ja.r, Da[Ha + 7] = ja.g, Da[Ha + 8] = ja.b, Ha += 9;
                                    0 < Ha && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, Da,
                                        D))
                                }
                                if (Ob && ea.hasTangents) {
                                    y = 0;
                                    for (z = $.length; y < z; y++)B = xa[$[y]], P = B.vertexTangents, Ka = P[0], V = P[1], W = P[2], sa[Aa] = Ka.x, sa[Aa + 1] = Ka.y, sa[Aa + 2] = Ka.z, sa[Aa + 3] = Ka.w, sa[Aa + 4] = V.x, sa[Aa + 5] = V.y, sa[Aa + 6] = V.z, sa[Aa + 7] = V.w, sa[Aa + 8] = W.x, sa[Aa + 9] = W.y, sa[Aa + 10] = W.z, sa[Aa + 11] = W.w, Aa += 12;
                                    m.bindBuffer(m.ARRAY_BUFFER, v.__webglTangentBuffer);
                                    m.bufferData(m.ARRAY_BUFFER, sa, D)
                                }
                                if (Mb) {
                                    y = 0;
                                    for (z = $.length; y < z; y++)if (B = xa[$[y]], I = B.vertexNormals, H = B.normal, 3 === I.length && !1 === G)for (Y = 0; 3 > Y; Y++)pa = I[Y], Na[Ra] = pa.x, Na[Ra + 1] =
                                        pa.y, Na[Ra + 2] = pa.z, Ra += 3; else for (Y = 0; 3 > Y; Y++)Na[Ra] = H.x, Na[Ra + 1] = H.y, Na[Ra + 2] = H.z, Ra += 3;
                                    m.bindBuffer(m.ARRAY_BUFFER, v.__webglNormalBuffer);
                                    m.bufferData(m.ARRAY_BUFFER, Na, D)
                                }
                                if (vb && Hb) {
                                    y = 0;
                                    for (z = $.length; y < z; y++)if (F = $[y], U = Hb[F], void 0 !== U)for (Y = 0; 3 > Y; Y++)ab = U[Y], Ab[kb] = ab.x, Ab[kb + 1] = ab.y, kb += 2;
                                    0 < kb && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglUVBuffer), m.bufferData(m.ARRAY_BUFFER, Ab, D))
                                }
                                if (vb && Oa) {
                                    y = 0;
                                    for (z = $.length; y < z; y++)if (F = $[y], O = Oa[F], void 0 !== O)for (Y = 0; 3 > Y; Y++)oa = O[Y], lb[yb] = oa.x, lb[yb + 1] = oa.y,
                                        yb += 2;
                                    0 < yb && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglUV2Buffer), m.bufferData(m.ARRAY_BUFFER, lb, D))
                                }
                                if (fb) {
                                    y = 0;
                                    for (z = $.length; y < z; y++)Va[zb] = La, Va[zb + 1] = La + 1, Va[zb + 2] = La + 2, zb += 3, Ta[eb] = La, Ta[eb + 1] = La + 1, Ta[eb + 2] = La, Ta[eb + 3] = La + 2, Ta[eb + 4] = La + 1, Ta[eb + 5] = La + 2, eb += 6, La += 3;
                                    m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, v.__webglFaceBuffer);
                                    m.bufferData(m.ELEMENT_ARRAY_BUFFER, Va, D);
                                    m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, v.__webglLineBuffer);
                                    m.bufferData(m.ELEMENT_ARRAY_BUFFER, Ta, D)
                                }
                                if (mb)for (Y = 0, ub = mb.length; Y < ub; Y++)if (C =
                                        mb[Y], C.__original.needsUpdate) {
                                    K = 0;
                                    if (1 === C.size)if (void 0 === C.boundTo || "vertices" === C.boundTo)for (y = 0, z = $.length; y < z; y++)B = xa[$[y]], C.array[K] = C.value[B.a], C.array[K + 1] = C.value[B.b], C.array[K + 2] = C.value[B.c], K += 3; else {
                                        if ("faces" === C.boundTo)for (y = 0, z = $.length; y < z; y++)za = C.value[$[y]], C.array[K] = za, C.array[K + 1] = za, C.array[K + 2] = za, K += 3
                                    } else if (2 === C.size)if (void 0 === C.boundTo || "vertices" === C.boundTo)for (y = 0, z = $.length; y < z; y++)B = xa[$[y]], J = C.value[B.a], L = C.value[B.b], N = C.value[B.c], C.array[K] = J.x,
                                        C.array[K + 1] = J.y, C.array[K + 2] = L.x, C.array[K + 3] = L.y, C.array[K + 4] = N.x, C.array[K + 5] = N.y, K += 6; else {
                                        if ("faces" === C.boundTo)for (y = 0, z = $.length; y < z; y++)N = L = J = za = C.value[$[y]], C.array[K] = J.x, C.array[K + 1] = J.y, C.array[K + 2] = L.x, C.array[K + 3] = L.y, C.array[K + 4] = N.x, C.array[K + 5] = N.y, K += 6
                                    } else if (3 === C.size) {
                                        var T;
                                        T = "c" === C.type ? ["r", "g", "b"] : ["x", "y", "z"];
                                        if (void 0 === C.boundTo || "vertices" === C.boundTo)for (y = 0, z = $.length; y < z; y++)B = xa[$[y]], J = C.value[B.a], L = C.value[B.b], N = C.value[B.c], C.array[K] = J[T[0]], C.array[K + 1] =
                                            J[T[1]], C.array[K + 2] = J[T[2]], C.array[K + 3] = L[T[0]], C.array[K + 4] = L[T[1]], C.array[K + 5] = L[T[2]], C.array[K + 6] = N[T[0]], C.array[K + 7] = N[T[1]], C.array[K + 8] = N[T[2]], K += 9; else if ("faces" === C.boundTo)for (y = 0, z = $.length; y < z; y++)N = L = J = za = C.value[$[y]], C.array[K] = J[T[0]], C.array[K + 1] = J[T[1]], C.array[K + 2] = J[T[2]], C.array[K + 3] = L[T[0]], C.array[K + 4] = L[T[1]], C.array[K + 5] = L[T[2]], C.array[K + 6] = N[T[0]], C.array[K + 7] = N[T[1]], C.array[K + 8] = N[T[2]], K += 9; else if ("faceVertices" === C.boundTo)for (y = 0, z = $.length; y < z; y++)za = C.value[$[y]],
                                            J = za[0], L = za[1], N = za[2], C.array[K] = J[T[0]], C.array[K + 1] = J[T[1]], C.array[K + 2] = J[T[2]], C.array[K + 3] = L[T[0]], C.array[K + 4] = L[T[1]], C.array[K + 5] = L[T[2]], C.array[K + 6] = N[T[0]], C.array[K + 7] = N[T[1]], C.array[K + 8] = N[T[2]], K += 9
                                    } else if (4 === C.size)if (void 0 === C.boundTo || "vertices" === C.boundTo)for (y = 0, z = $.length; y < z; y++)B = xa[$[y]], J = C.value[B.a], L = C.value[B.b], N = C.value[B.c], C.array[K] = J.x, C.array[K + 1] = J.y, C.array[K + 2] = J.z, C.array[K + 3] = J.w, C.array[K + 4] = L.x, C.array[K + 5] = L.y, C.array[K + 6] = L.z, C.array[K + 7] = L.w, C.array[K +
                                    8] = N.x, C.array[K + 9] = N.y, C.array[K + 10] = N.z, C.array[K + 11] = N.w, K += 12; else if ("faces" === C.boundTo)for (y = 0, z = $.length; y < z; y++)N = L = J = za = C.value[$[y]], C.array[K] = J.x, C.array[K + 1] = J.y, C.array[K + 2] = J.z, C.array[K + 3] = J.w, C.array[K + 4] = L.x, C.array[K + 5] = L.y, C.array[K + 6] = L.z, C.array[K + 7] = L.w, C.array[K + 8] = N.x, C.array[K + 9] = N.y, C.array[K + 10] = N.z, C.array[K + 11] = N.w, K += 12; else if ("faceVertices" === C.boundTo)for (y = 0, z = $.length; y < z; y++)za = C.value[$[y]], J = za[0], L = za[1], N = za[2], C.array[K] = J.x, C.array[K + 1] = J.y, C.array[K + 2] =
                                        J.z, C.array[K + 3] = J.w, C.array[K + 4] = L.x, C.array[K + 5] = L.y, C.array[K + 6] = L.z, C.array[K + 7] = L.w, C.array[K + 8] = N.x, C.array[K + 9] = N.y, C.array[K + 10] = N.z, C.array[K + 11] = N.w, K += 12;
                                    m.bindBuffer(m.ARRAY_BUFFER, C.buffer);
                                    m.bufferData(m.ARRAY_BUFFER, C.array, D)
                                }
                                A && (delete v.__inittedArrays, delete v.__colorArray, delete v.__normalArray, delete v.__tangentArray, delete v.__uvArray, delete v.__uv2Array, delete v.__faceArray, delete v.__vertexArray, delete v.__lineArray, delete v.__skinIndexArray, delete v.__skinWeightArray)
                            }
                        }
                    }
                    b.verticesNeedUpdate = !1;
                    b.morphTargetsNeedUpdate = !1;
                    b.elementsNeedUpdate = !1;
                    b.uvsNeedUpdate = !1;
                    b.normalsNeedUpdate = !1;
                    b.colorsNeedUpdate = !1;
                    b.tangentsNeedUpdate = !1;
                    w.attributes && s(w)
                } else if (a instanceof THREE.Line) {
                    w = c(a, b);
                    u = w.attributes && r(w);
                    if (b.verticesNeedUpdate || b.colorsNeedUpdate || b.lineDistancesNeedUpdate || u) {
                        var Db = m.DYNAMIC_DRAW, S, aa, Z, Ba, X, Eb, Rb = b.vertices, Ib = b.colors, gb = b.lineDistances, ya = Rb.length, pb = Ib.length, qb = gb.length, Wa = b.__vertexArray, tb = b.__colorArray, hb = b.__lineDistanceArray, $b = b.colorsNeedUpdate,
                            Fb = b.lineDistancesNeedUpdate, Sb = b.__webglCustomAttributesList, Jb, cb, ua, Kb, Ia, fa;
                        if (b.verticesNeedUpdate) {
                            for (S = 0; S < ya; S++)Ba = Rb[S], X = 3 * S, Wa[X] = Ba.x, Wa[X + 1] = Ba.y, Wa[X + 2] = Ba.z;
                            m.bindBuffer(m.ARRAY_BUFFER, b.__webglVertexBuffer);
                            m.bufferData(m.ARRAY_BUFFER, Wa, Db)
                        }
                        if ($b) {
                            for (aa = 0; aa < pb; aa++)Eb = Ib[aa], X = 3 * aa, tb[X] = Eb.r, tb[X + 1] = Eb.g, tb[X + 2] = Eb.b;
                            m.bindBuffer(m.ARRAY_BUFFER, b.__webglColorBuffer);
                            m.bufferData(m.ARRAY_BUFFER, tb, Db)
                        }
                        if (Fb) {
                            for (Z = 0; Z < qb; Z++)hb[Z] = gb[Z];
                            m.bindBuffer(m.ARRAY_BUFFER, b.__webglLineDistanceBuffer);
                            m.bufferData(m.ARRAY_BUFFER, hb, Db)
                        }
                        if (Sb)for (Jb = 0, cb = Sb.length; Jb < cb; Jb++)if (fa = Sb[Jb], fa.needsUpdate && (void 0 === fa.boundTo || "vertices" === fa.boundTo)) {
                            X = 0;
                            Kb = fa.value.length;
                            if (1 === fa.size)for (ua = 0; ua < Kb; ua++)fa.array[ua] = fa.value[ua]; else if (2 === fa.size)for (ua = 0; ua < Kb; ua++)Ia = fa.value[ua], fa.array[X] = Ia.x, fa.array[X + 1] = Ia.y, X += 2; else if (3 === fa.size)if ("c" === fa.type)for (ua = 0; ua < Kb; ua++)Ia = fa.value[ua], fa.array[X] = Ia.r, fa.array[X + 1] = Ia.g, fa.array[X + 2] = Ia.b, X += 3; else for (ua = 0; ua < Kb; ua++)Ia = fa.value[ua],
                                fa.array[X] = Ia.x, fa.array[X + 1] = Ia.y, fa.array[X + 2] = Ia.z, X += 3; else if (4 === fa.size)for (ua = 0; ua < Kb; ua++)Ia = fa.value[ua], fa.array[X] = Ia.x, fa.array[X + 1] = Ia.y, fa.array[X + 2] = Ia.z, fa.array[X + 3] = Ia.w, X += 4;
                            m.bindBuffer(m.ARRAY_BUFFER, fa.buffer);
                            m.bufferData(m.ARRAY_BUFFER, fa.array, Db);
                            fa.needsUpdate = !1
                        }
                    }
                    b.verticesNeedUpdate = !1;
                    b.colorsNeedUpdate = !1;
                    b.lineDistancesNeedUpdate = !1;
                    w.attributes && s(w)
                } else if (a instanceof THREE.PointCloud) {
                    w = c(a, b);
                    u = w.attributes && r(w);
                    if (b.verticesNeedUpdate || b.colorsNeedUpdate ||
                        u) {
                        var db = m.DYNAMIC_DRAW, Tb, Ub, ac, ma, bc, Nb = b.vertices, Vb = Nb.length, Pb = b.colors, rb = Pb.length, cc = b.__vertexArray, dc = b.__colorArray, wb = b.colorsNeedUpdate, gc = b.__webglCustomAttributesList, ec, jb, va, Lb, Ja, ga;
                        if (b.verticesNeedUpdate) {
                            for (Tb = 0; Tb < Vb; Tb++)ac = Nb[Tb], ma = 3 * Tb, cc[ma] = ac.x, cc[ma + 1] = ac.y, cc[ma + 2] = ac.z;
                            m.bindBuffer(m.ARRAY_BUFFER, b.__webglVertexBuffer);
                            m.bufferData(m.ARRAY_BUFFER, cc, db)
                        }
                        if (wb) {
                            for (Ub = 0; Ub < rb; Ub++)bc = Pb[Ub], ma = 3 * Ub, dc[ma] = bc.r, dc[ma + 1] = bc.g, dc[ma + 2] = bc.b;
                            m.bindBuffer(m.ARRAY_BUFFER,
                                b.__webglColorBuffer);
                            m.bufferData(m.ARRAY_BUFFER, dc, db)
                        }
                        if (gc)for (ec = 0, jb = gc.length; ec < jb; ec++) {
                            ga = gc[ec];
                            if (ga.needsUpdate && (void 0 === ga.boundTo || "vertices" === ga.boundTo))if (Lb = ga.value.length, ma = 0, 1 === ga.size)for (va = 0; va < Lb; va++)ga.array[va] = ga.value[va]; else if (2 === ga.size)for (va = 0; va < Lb; va++)Ja = ga.value[va], ga.array[ma] = Ja.x, ga.array[ma + 1] = Ja.y, ma += 2; else if (3 === ga.size)if ("c" === ga.type)for (va = 0; va < Lb; va++)Ja = ga.value[va], ga.array[ma] = Ja.r, ga.array[ma + 1] = Ja.g, ga.array[ma + 2] = Ja.b, ma += 3; else for (va =
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  0; va < Lb; va++)Ja = ga.value[va], ga.array[ma] = Ja.x, ga.array[ma + 1] = Ja.y, ga.array[ma + 2] = Ja.z, ma += 3; else if (4 === ga.size)for (va = 0; va < Lb; va++)Ja = ga.value[va], ga.array[ma] = Ja.x, ga.array[ma + 1] = Ja.y, ga.array[ma + 2] = Ja.z, ga.array[ma + 3] = Ja.w, ma += 4;
                            m.bindBuffer(m.ARRAY_BUFFER, ga.buffer);
                            m.bufferData(m.ARRAY_BUFFER, ga.array, db);
                            ga.needsUpdate = !1
                        }
                    }
                    b.verticesNeedUpdate = !1;
                    b.colorsNeedUpdate = !1;
                    w.attributes && s(w)
                }
            }

            function r(a) {
                for (var b in a.attributes)if (a.attributes[b].needsUpdate)return !0;
                return !1
            }

            function s(a) {
                for (var b in a.attributes)a.attributes[b].needsUpdate = !1
            }

            function u(a) {
                !0 === a.transparent ? W.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha) : W.setBlending(THREE.NoBlending);
                W.setDepthTest(a.depthTest);
                W.setDepthWrite(a.depthWrite);
                W.setColorWrite(a.colorWrite);
                W.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
            }

            function v(a, b, c, d, e) {
                var f, g, h, k;
                Mb = 0;
                if (d.needsUpdate) {
                    d.program && hc(d);
                    d.addEventListener("dispose", ic);
                    var n = pc[d.type];
                    if (n) {
                        var l = THREE.ShaderLib[n];
                        d.__webglShader = {uniforms: THREE.UniformsUtils.clone(l.uniforms), vertexShader: l.vertexShader, fragmentShader: l.fragmentShader}
                    } else d.__webglShader = {uniforms: d.uniforms, vertexShader: d.vertexShader, fragmentShader: d.fragmentShader};
                    for (var p = 0, q = 0, r = 0, s = 0, t = 0, w = b.length; t < w; t++) {
                        var v = b[t];
                        v.onlyShadow || !1 === v.visible || (v instanceof THREE.DirectionalLight && p++, v instanceof THREE.PointLight && q++, v instanceof THREE.SpotLight && r++, v instanceof THREE.HemisphereLight && s++)
                    }
                    f = p;
                    g = q;
                    h = r;
                    k = s;
                    for (var u, z = 0, G =
                        0, F = b.length; G < F; G++) {
                        var J = b[G];
                        J.castShadow && (J instanceof THREE.SpotLight && z++, J instanceof THREE.DirectionalLight && !J.shadowCascade && z++)
                    }
                    u = z;
                    var H;
                    if (Nb && e && e.skeleton && e.skeleton.useVertexTexture)H = 1024; else {
                        var N = m.getParameter(m.MAX_VERTEX_UNIFORM_VECTORS), M = Math.floor((N - 20) / 4);
                        void 0 !== e && e instanceof THREE.SkinnedMesh && (M = Math.min(e.skeleton.bones.length, M), M < e.skeleton.bones.length && THREE.warn("WebGLRenderer: too many bones - " + e.skeleton.bones.length + ", this GPU supports just " + M + " (try OpenGL instead of ANGLE)"));
                        H = M
                    }
                    var P = {
                        precision: L,
                        supportsVertexTextures: Vb,
                        map: !!d.map,
                        envMap: !!d.envMap,
                        envMapMode: d.envMap && d.envMap.mapping,
                        lightMap: !!d.lightMap,
                        bumpMap: !!d.bumpMap,
                        normalMap: !!d.normalMap,
                        specularMap: !!d.specularMap,
                        alphaMap: !!d.alphaMap,
                        combine: d.combine,
                        vertexColors: d.vertexColors,
                        fog: c,
                        useFog: d.fog,
                        fogExp: c instanceof THREE.FogExp2,
                        flatShading: d.shading === THREE.FlatShading,
                        sizeAttenuation: d.sizeAttenuation,
                        logarithmicDepthBuffer: ja,
                        skinning: d.skinning,
                        maxBones: H,
                        useVertexTexture: Nb && e && e.skeleton &&
                        e.skeleton.useVertexTexture,
                        morphTargets: d.morphTargets,
                        morphNormals: d.morphNormals,
                        maxMorphTargets: B.maxMorphTargets,
                        maxMorphNormals: B.maxMorphNormals,
                        maxDirLights: f,
                        maxPointLights: g,
                        maxSpotLights: h,
                        maxHemiLights: k,
                        maxShadows: u,
                        shadowMapEnabled: B.shadowMapEnabled && e.receiveShadow && 0 < u,
                        shadowMapType: B.shadowMapType,
                        shadowMapDebug: B.shadowMapDebug,
                        shadowMapCascade: B.shadowMapCascade,
                        alphaTest: d.alphaTest,
                        metal: d.metal,
                        wrapAround: d.wrapAround,
                        doubleSided: d.side === THREE.DoubleSide,
                        flipSided: d.side ===
                        THREE.BackSide
                    }, R = [];
                    n ? R.push(n) : (R.push(d.fragmentShader), R.push(d.vertexShader));
                    if (void 0 !== d.defines)for (var O in d.defines)R.push(O), R.push(d.defines[O]);
                    for (O in P)R.push(O), R.push(P[O]);
                    for (var Ka = R.join(), V, W = 0, Qa = Pa.length; W < Qa; W++) {
                        var Ya = Pa[W];
                        if (Ya.code === Ka) {
                            V = Ya;
                            V.usedTimes++;
                            break
                        }
                    }
                    void 0 === V && (V = new THREE.WebGLProgram(B, Ka, d, P), Pa.push(V), B.info.memory.programs = Pa.length);
                    d.program = V;
                    var Xa = V.attributes;
                    if (d.morphTargets) {
                        d.numSupportedMorphTargets = 0;
                        for (var ca, da = "morphTarget", ba =
                            0; ba < B.maxMorphTargets; ba++)ca = da + ba, 0 <= Xa[ca] && d.numSupportedMorphTargets++
                    }
                    if (d.morphNormals)for (d.numSupportedMorphNormals = 0, da = "morphNormal", ba = 0; ba < B.maxMorphNormals; ba++)ca = da + ba, 0 <= Xa[ca] && d.numSupportedMorphNormals++;
                    d.uniformsList = [];
                    for (var ha in d.__webglShader.uniforms) {
                        var ta = d.program.uniforms[ha];
                        ta && d.uniformsList.push([d.__webglShader.uniforms[ha], ta])
                    }
                    d.needsUpdate = !1
                }
                d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(B.maxMorphTargets));
                var ab = !1, oa = !1, qa = !1, Ua = d.program, ka = Ua.uniforms, Q = d.__webglShader.uniforms;
                Ua.id !== ob && (m.useProgram(Ua.program), ob = Ua.id, qa = oa = ab = !0);
                d.id !== ub && (-1 === ub && (qa = !0), ub = d.id, oa = !0);
                if (ab || a !== vb)m.uniformMatrix4fv(ka.projectionMatrix, !1, a.projectionMatrix.elements), ja && m.uniform1f(ka.logDepthBufFC, 2 / (Math.log(a.far + 1) / Math.LN2)), a !== vb && (vb = a), (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== ka.cameraPosition && (wa.setFromMatrixPosition(a.matrixWorld), m.uniform3f(ka.cameraPosition,
                    wa.x, wa.y, wa.z)), (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshBasicMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== ka.viewMatrix && m.uniformMatrix4fv(ka.viewMatrix, !1, a.matrixWorldInverse.elements);
                if (d.skinning)if (e.bindMatrix && null !== ka.bindMatrix && m.uniformMatrix4fv(ka.bindMatrix, !1, e.bindMatrix.elements), e.bindMatrixInverse && null !== ka.bindMatrixInverse && m.uniformMatrix4fv(ka.bindMatrixInverse, !1, e.bindMatrixInverse.elements),
                    Nb && e.skeleton && e.skeleton.useVertexTexture) {
                    if (null !== ka.boneTexture) {
                        var db = D();
                        m.uniform1i(ka.boneTexture, db);
                        B.setTexture(e.skeleton.boneTexture, db)
                    }
                    null !== ka.boneTextureWidth && m.uniform1i(ka.boneTextureWidth, e.skeleton.boneTextureWidth);
                    null !== ka.boneTextureHeight && m.uniform1i(ka.boneTextureHeight, e.skeleton.boneTextureHeight)
                } else e.skeleton && e.skeleton.boneMatrices && null !== ka.boneGlobalMatrices && m.uniformMatrix4fv(ka.boneGlobalMatrices, !1, e.skeleton.boneMatrices);
                if (oa) {
                    c && d.fog && (Q.fogColor.value =
                        c.color, c instanceof THREE.Fog ? (Q.fogNear.value = c.near, Q.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (Q.fogDensity.value = c.density));
                    if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
                        if (Ob) {
                            var qa = !0, ia, Za, Y, bb = 0, cb = 0, ib = 0, xb, pb, qb, Ca, jb, na = jc, rb = na.directional.colors, La = na.directional.positions, Ma = na.point.colors, kb = na.point.positions, yb = na.point.distances, zb = na.point.decays, Ra = na.spot.colors, Aa = na.spot.positions, eb = na.spot.distances, Ha = na.spot.directions,
                                la = na.spot.anglesCos, ra = na.spot.exponents, K = na.spot.decays, za = na.hemi.skyColors, Sa = na.hemi.groundColors, Ab = na.hemi.positions, lb = 0, Na = 0, sa = 0, Da = 0, Ea = 0, Fa = 0, Gb = 0, Bb = 0, mb = 0, C = 0, Va = 0, Ta = 0;
                            ia = 0;
                            for (Za = b.length; ia < Za; ia++)Y = b[ia], Y.onlyShadow || (xb = Y.color, Ca = Y.intensity, jb = Y.distance, Y instanceof THREE.AmbientLight ? Y.visible && (bb += xb.r, cb += xb.g, ib += xb.b) : Y instanceof THREE.DirectionalLight ? (Ea += 1, Y.visible && (pa.setFromMatrixPosition(Y.matrixWorld), wa.setFromMatrixPosition(Y.target.matrixWorld), pa.sub(wa),
                                pa.normalize(), mb = 3 * lb, La[mb] = pa.x, La[mb + 1] = pa.y, La[mb + 2] = pa.z, y(rb, mb, xb, Ca), lb += 1)) : Y instanceof THREE.PointLight ? (Fa += 1, Y.visible && (C = 3 * Na, y(Ma, C, xb, Ca), wa.setFromMatrixPosition(Y.matrixWorld), kb[C] = wa.x, kb[C + 1] = wa.y, kb[C + 2] = wa.z, yb[Na] = jb, zb[Na] = 0 === Y.distance ? 0 : Y.decay, Na += 1)) : Y instanceof THREE.SpotLight ? (Gb += 1, Y.visible && (Va = 3 * sa, y(Ra, Va, xb, Ca), pa.setFromMatrixPosition(Y.matrixWorld), Aa[Va] = pa.x, Aa[Va + 1] = pa.y, Aa[Va + 2] = pa.z, eb[sa] = jb, wa.setFromMatrixPosition(Y.target.matrixWorld), pa.sub(wa),
                                pa.normalize(), Ha[Va] = pa.x, Ha[Va + 1] = pa.y, Ha[Va + 2] = pa.z, la[sa] = Math.cos(Y.angle), ra[sa] = Y.exponent, K[sa] = 0 === Y.distance ? 0 : Y.decay, sa += 1)) : Y instanceof THREE.HemisphereLight && (Bb += 1, Y.visible && (pa.setFromMatrixPosition(Y.matrixWorld), pa.normalize(), Ta = 3 * Da, Ab[Ta] = pa.x, Ab[Ta + 1] = pa.y, Ab[Ta + 2] = pa.z, pb = Y.color, qb = Y.groundColor, y(za, Ta, pb, Ca), y(Sa, Ta, qb, Ca), Da += 1)));
                            ia = 3 * lb;
                            for (Za = Math.max(rb.length, 3 * Ea); ia < Za; ia++)rb[ia] = 0;
                            ia = 3 * Na;
                            for (Za = Math.max(Ma.length, 3 * Fa); ia < Za; ia++)Ma[ia] = 0;
                            ia = 3 * sa;
                            for (Za = Math.max(Ra.length,
                                3 * Gb); ia < Za; ia++)Ra[ia] = 0;
                            ia = 3 * Da;
                            for (Za = Math.max(za.length, 3 * Bb); ia < Za; ia++)za[ia] = 0;
                            ia = 3 * Da;
                            for (Za = Math.max(Sa.length, 3 * Bb); ia < Za; ia++)Sa[ia] = 0;
                            na.directional.length = lb;
                            na.point.length = Na;
                            na.spot.length = sa;
                            na.hemi.length = Da;
                            na.ambient[0] = bb;
                            na.ambient[1] = cb;
                            na.ambient[2] = ib;
                            Ob = !1
                        }
                        if (qa) {
                            var ea = jc;
                            Q.ambientLightColor.value = ea.ambient;
                            Q.directionalLightColor.value = ea.directional.colors;
                            Q.directionalLightDirection.value = ea.directional.positions;
                            Q.pointLightColor.value = ea.point.colors;
                            Q.pointLightPosition.value =
                                ea.point.positions;
                            Q.pointLightDistance.value = ea.point.distances;
                            Q.pointLightDecay.value = ea.point.decays;
                            Q.spotLightColor.value = ea.spot.colors;
                            Q.spotLightPosition.value = ea.spot.positions;
                            Q.spotLightDistance.value = ea.spot.distances;
                            Q.spotLightDirection.value = ea.spot.directions;
                            Q.spotLightAngleCos.value = ea.spot.anglesCos;
                            Q.spotLightExponent.value = ea.spot.exponents;
                            Q.spotLightDecay.value = ea.spot.decays;
                            Q.hemisphereLightSkyColor.value = ea.hemi.skyColors;
                            Q.hemisphereLightGroundColor.value = ea.hemi.groundColors;
                            Q.hemisphereLightDirection.value = ea.hemi.positions;
                            x(Q, !0)
                        } else x(Q, !1)
                    }
                    if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
                        Q.opacity.value = d.opacity;
                        Q.diffuse.value = d.color;
                        Q.map.value = d.map;
                        Q.lightMap.value = d.lightMap;
                        Q.specularMap.value = d.specularMap;
                        Q.alphaMap.value = d.alphaMap;
                        d.bumpMap && (Q.bumpMap.value = d.bumpMap, Q.bumpScale.value = d.bumpScale);
                        d.normalMap && (Q.normalMap.value = d.normalMap, Q.normalScale.value.copy(d.normalScale));
                        var fb;
                        d.map ? fb = d.map : d.specularMap ? fb = d.specularMap : d.normalMap ? fb = d.normalMap : d.bumpMap ? fb = d.bumpMap : d.alphaMap && (fb = d.alphaMap);
                        if (void 0 !== fb) {
                            var wb = fb.offset, Qb = fb.repeat;
                            Q.offsetRepeat.value.set(wb.x, wb.y, Qb.x, Qb.y)
                        }
                        Q.envMap.value = d.envMap;
                        Q.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
                        Q.reflectivity.value = d.reflectivity;
                        Q.refractionRatio.value = d.refractionRatio
                    }
                    if (d instanceof THREE.LineBasicMaterial)Q.diffuse.value = d.color, Q.opacity.value = d.opacity; else if (d instanceof
                        THREE.LineDashedMaterial)Q.diffuse.value = d.color, Q.opacity.value = d.opacity, Q.dashSize.value = d.dashSize, Q.totalSize.value = d.dashSize + d.gapSize, Q.scale.value = d.scale; else if (d instanceof THREE.PointCloudMaterial) {
                        if (Q.psColor.value = d.color, Q.opacity.value = d.opacity, Q.size.value = d.size, Q.scale.value = U.height / 2, Q.map.value = d.map, null !== d.map) {
                            var Wb = d.map.offset, Xb = d.map.repeat;
                            Q.offsetRepeat.value.set(Wb.x, Wb.y, Xb.x, Xb.y)
                        }
                    } else d instanceof THREE.MeshPhongMaterial ? (Q.shininess.value = d.shininess, Q.emissive.value =
                        d.emissive, Q.specular.value = d.specular, d.wrapAround && Q.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (Q.emissive.value = d.emissive, d.wrapAround && Q.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (Q.mNear.value = a.near, Q.mFar.value = a.far, Q.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (Q.opacity.value = d.opacity);
                    if (e.receiveShadow && !d._shadowPass && Q.shadowMatrix)for (var sb = 0, Cb = 0, $ = b.length; Cb < $; Cb++) {
                        var xa = b[Cb];
                        xa.castShadow && (xa instanceof
                        THREE.SpotLight || xa instanceof THREE.DirectionalLight && !xa.shadowCascade) && (Q.shadowMap.value[sb] = xa.shadowMap, Q.shadowMapSize.value[sb] = xa.shadowMapSize, Q.shadowMatrix.value[sb] = xa.shadowMatrix, Q.shadowDarkness.value[sb] = xa.shadowDarkness, Q.shadowBias.value[sb] = xa.shadowBias, sb++)
                    }
                    for (var Hb = d.uniformsList, Oa, $a, Ga, nb = 0, fc = Hb.length; nb < fc; nb++) {
                        var T = Hb[nb][0];
                        if (!1 !== T.needsUpdate) {
                            var Db = T.type, S = T.value, aa = Hb[nb][1];
                            switch (Db) {
                                case "1i":
                                    m.uniform1i(aa, S);
                                    break;
                                case "1f":
                                    m.uniform1f(aa, S);
                                    break;
                                case "2f":
                                    m.uniform2f(aa, S[0], S[1]);
                                    break;
                                case "3f":
                                    m.uniform3f(aa, S[0], S[1], S[2]);
                                    break;
                                case "4f":
                                    m.uniform4f(aa, S[0], S[1], S[2], S[3]);
                                    break;
                                case "1iv":
                                    m.uniform1iv(aa, S);
                                    break;
                                case "3iv":
                                    m.uniform3iv(aa, S);
                                    break;
                                case "1fv":
                                    m.uniform1fv(aa, S);
                                    break;
                                case "2fv":
                                    m.uniform2fv(aa, S);
                                    break;
                                case "3fv":
                                    m.uniform3fv(aa, S);
                                    break;
                                case "4fv":
                                    m.uniform4fv(aa, S);
                                    break;
                                case "Matrix3fv":
                                    m.uniformMatrix3fv(aa, !1, S);
                                    break;
                                case "Matrix4fv":
                                    m.uniformMatrix4fv(aa, !1, S);
                                    break;
                                case "i":
                                    m.uniform1i(aa, S);
                                    break;
                                case "f":
                                    m.uniform1f(aa,
                                        S);
                                    break;
                                case "v2":
                                    m.uniform2f(aa, S.x, S.y);
                                    break;
                                case "v3":
                                    m.uniform3f(aa, S.x, S.y, S.z);
                                    break;
                                case "v4":
                                    m.uniform4f(aa, S.x, S.y, S.z, S.w);
                                    break;
                                case "c":
                                    m.uniform3f(aa, S.r, S.g, S.b);
                                    break;
                                case "iv1":
                                    m.uniform1iv(aa, S);
                                    break;
                                case "iv":
                                    m.uniform3iv(aa, S);
                                    break;
                                case "fv1":
                                    m.uniform1fv(aa, S);
                                    break;
                                case "fv":
                                    m.uniform3fv(aa, S);
                                    break;
                                case "v2v":
                                    void 0 === T._array && (T._array = new Float32Array(2 * S.length));
                                    for (var Z = 0, Ba = S.length; Z < Ba; Z++)Ga = 2 * Z, T._array[Ga] = S[Z].x, T._array[Ga + 1] = S[Z].y;
                                    m.uniform2fv(aa, T._array);
                                    break;
                                case "v3v":
                                    void 0 === T._array && (T._array = new Float32Array(3 * S.length));
                                    Z = 0;
                                    for (Ba = S.length; Z < Ba; Z++)Ga = 3 * Z, T._array[Ga] = S[Z].x, T._array[Ga + 1] = S[Z].y, T._array[Ga + 2] = S[Z].z;
                                    m.uniform3fv(aa, T._array);
                                    break;
                                case "v4v":
                                    void 0 === T._array && (T._array = new Float32Array(4 * S.length));
                                    Z = 0;
                                    for (Ba = S.length; Z < Ba; Z++)Ga = 4 * Z, T._array[Ga] = S[Z].x, T._array[Ga + 1] = S[Z].y, T._array[Ga + 2] = S[Z].z, T._array[Ga + 3] = S[Z].w;
                                    m.uniform4fv(aa, T._array);
                                    break;
                                case "m3":
                                    m.uniformMatrix3fv(aa, !1, S.elements);
                                    break;
                                case "m3v":
                                    void 0 ===
                                    T._array && (T._array = new Float32Array(9 * S.length));
                                    Z = 0;
                                    for (Ba = S.length; Z < Ba; Z++)S[Z].flattenToArrayOffset(T._array, 9 * Z);
                                    m.uniformMatrix3fv(aa, !1, T._array);
                                    break;
                                case "m4":
                                    m.uniformMatrix4fv(aa, !1, S.elements);
                                    break;
                                case "m4v":
                                    void 0 === T._array && (T._array = new Float32Array(16 * S.length));
                                    Z = 0;
                                    for (Ba = S.length; Z < Ba; Z++)S[Z].flattenToArrayOffset(T._array, 16 * Z);
                                    m.uniformMatrix4fv(aa, !1, T._array);
                                    break;
                                case "t":
                                    Oa = S;
                                    $a = D();
                                    m.uniform1i(aa, $a);
                                    if (!Oa)continue;
                                    if (Oa instanceof THREE.CubeTexture || Oa.image instanceof
                                        Array && 6 === Oa.image.length) {
                                        var X = Oa, Eb = $a;
                                        if (6 === X.image.length)if (X.needsUpdate) {
                                            X.image.__webglTextureCube || (X.addEventListener("dispose", Pb), X.image.__webglTextureCube = m.createTexture(), B.info.memory.textures++);
                                            m.activeTexture(m.TEXTURE0 + Eb);
                                            m.bindTexture(m.TEXTURE_CUBE_MAP, X.image.__webglTextureCube);
                                            m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, X.flipY);
                                            for (var Rb = X instanceof THREE.CompressedTexture, Ib = X.image[0]instanceof THREE.DataTexture, gb = [], ya = 0; 6 > ya; ya++)gb[ya] = !B.autoScaleCubemaps || Rb || Ib ? Ib ?
                                                X.image[ya].image : X.image[ya] : E(X.image[ya], qc);
                                            var Yb = gb[0], Zb = THREE.Math.isPowerOfTwo(Yb.width) && THREE.Math.isPowerOfTwo(Yb.height), Wa = I(X.format), tb = I(X.type);
                                            A(m.TEXTURE_CUBE_MAP, X, Zb);
                                            for (ya = 0; 6 > ya; ya++)if (Rb)for (var hb, $b = gb[ya].mipmaps, Fb = 0, Sb = $b.length; Fb < Sb; Fb++)hb = $b[Fb], X.format !== THREE.RGBAFormat && X.format !== THREE.RGBFormat ? -1 < kc().indexOf(Wa) ? m.compressedTexImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + ya, Fb, Wa, hb.width, hb.height, 0, hb.data) : THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") :
                                                m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + ya, Fb, Wa, hb.width, hb.height, 0, Wa, tb, hb.data); else Ib ? m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + ya, 0, Wa, gb[ya].width, gb[ya].height, 0, Wa, tb, gb[ya].data) : m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + ya, 0, Wa, Wa, tb, gb[ya]);
                                            X.generateMipmaps && Zb && m.generateMipmap(m.TEXTURE_CUBE_MAP);
                                            X.needsUpdate = !1;
                                            if (X.onUpdate)X.onUpdate()
                                        } else m.activeTexture(m.TEXTURE0 + Eb), m.bindTexture(m.TEXTURE_CUBE_MAP, X.image.__webglTextureCube)
                                    } else if (Oa instanceof THREE.WebGLRenderTargetCube) {
                                        var Jb =
                                            Oa;
                                        m.activeTexture(m.TEXTURE0 + $a);
                                        m.bindTexture(m.TEXTURE_CUBE_MAP, Jb.__webglTexture)
                                    } else B.setTexture(Oa, $a);
                                    break;
                                case "tv":
                                    void 0 === T._array && (T._array = []);
                                    Z = 0;
                                    for (Ba = T.value.length; Z < Ba; Z++)T._array[Z] = D();
                                    m.uniform1iv(aa, T._array);
                                    Z = 0;
                                    for (Ba = T.value.length; Z < Ba; Z++)Oa = T.value[Z], $a = T._array[Z], Oa && B.setTexture(Oa, $a);
                                    break;
                                default:
                                    THREE.warn("THREE.WebGLRenderer: Unknown uniform type: " + Db)
                            }
                        }
                    }
                }
                m.uniformMatrix4fv(ka.modelViewMatrix, !1, e._modelViewMatrix.elements);
                ka.normalMatrix && m.uniformMatrix3fv(ka.normalMatrix,
                    !1, e._normalMatrix.elements);
                null !== ka.modelMatrix && m.uniformMatrix4fv(ka.modelMatrix, !1, e.matrixWorld.elements);
                return Ua
            }

            function x(a, b) {
                a.ambientLightColor.needsUpdate = b;
                a.directionalLightColor.needsUpdate = b;
                a.directionalLightDirection.needsUpdate = b;
                a.pointLightColor.needsUpdate = b;
                a.pointLightPosition.needsUpdate = b;
                a.pointLightDistance.needsUpdate = b;
                a.pointLightDecay.needsUpdate = b;
                a.spotLightColor.needsUpdate = b;
                a.spotLightPosition.needsUpdate = b;
                a.spotLightDistance.needsUpdate = b;
                a.spotLightDirection.needsUpdate =
                    b;
                a.spotLightAngleCos.needsUpdate = b;
                a.spotLightExponent.needsUpdate = b;
                a.spotLightDecay.needsUpdate = b;
                a.hemisphereLightSkyColor.needsUpdate = b;
                a.hemisphereLightGroundColor.needsUpdate = b;
                a.hemisphereLightDirection.needsUpdate = b
            }

            function D() {
                var a = Mb;
                a >= Wb && THREE.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + Wb);
                Mb += 1;
                return a
            }

            function w(a, b) {
                a._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, a.matrixWorld);
                a._normalMatrix.getNormalMatrix(a._modelViewMatrix)
            }

            function y(a, b, c, d) {
                a[b] = c.r * d;
                a[b + 1] = c.g * d;
                a[b + 2] = c.b * d
            }

            function A(a, b, c) {
                c ? (m.texParameteri(a, m.TEXTURE_WRAP_S, I(b.wrapS)), m.texParameteri(a, m.TEXTURE_WRAP_T, I(b.wrapT)), m.texParameteri(a, m.TEXTURE_MAG_FILTER, I(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, I(b.minFilter))) : (m.texParameteri(a, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(a, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), b.wrapS === THREE.ClampToEdgeWrapping && b.wrapT === THREE.ClampToEdgeWrapping || THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( " +
                    b.sourceFile + " )"), m.texParameteri(a, m.TEXTURE_MAG_FILTER, z(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, z(b.minFilter)), b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter && THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( " + b.sourceFile + " )"));
                (c = da.get("EXT_texture_filter_anisotropic")) && b.type !== THREE.FloatType && b.type !== THREE.HalfFloatType && (1 < b.anisotropy || b.__currentAnisotropy) &&
                (m.texParameterf(a, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, B.getMaxAnisotropy())), b.__currentAnisotropy = b.anisotropy)
            }

            function E(a, b) {
                if (a.width > b || a.height > b) {
                    var c = b / Math.max(a.width, a.height), d = document.createElement("canvas");
                    d.width = Math.floor(a.width * c);
                    d.height = Math.floor(a.height * c);
                    d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height);
                    THREE.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height, a);
                    return d
                }
                return a
            }

            function G(a, b) {
                m.bindRenderbuffer(m.RENDERBUFFER, a);
                b.depthBuffer && !b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_COMPONENT16, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_STENCIL, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a)) : m.renderbufferStorage(m.RENDERBUFFER, m.RGBA4, b.width, b.height)
            }

            function F(a) {
                a instanceof
                THREE.WebGLRenderTargetCube ? (m.bindTexture(m.TEXTURE_CUBE_MAP, a.__webglTexture), m.generateMipmap(m.TEXTURE_CUBE_MAP), m.bindTexture(m.TEXTURE_CUBE_MAP, null)) : (m.bindTexture(m.TEXTURE_2D, a.__webglTexture), m.generateMipmap(m.TEXTURE_2D), m.bindTexture(m.TEXTURE_2D, null))
            }

            function z(a) {
                return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? m.NEAREST : m.LINEAR
            }

            function I(a) {
                var b;
                if (a === THREE.RepeatWrapping)return m.REPEAT;
                if (a === THREE.ClampToEdgeWrapping)return m.CLAMP_TO_EDGE;
                if (a === THREE.MirroredRepeatWrapping)return m.MIRRORED_REPEAT;
                if (a === THREE.NearestFilter)return m.NEAREST;
                if (a === THREE.NearestMipMapNearestFilter)return m.NEAREST_MIPMAP_NEAREST;
                if (a === THREE.NearestMipMapLinearFilter)return m.NEAREST_MIPMAP_LINEAR;
                if (a === THREE.LinearFilter)return m.LINEAR;
                if (a === THREE.LinearMipMapNearestFilter)return m.LINEAR_MIPMAP_NEAREST;
                if (a === THREE.LinearMipMapLinearFilter)return m.LINEAR_MIPMAP_LINEAR;
                if (a === THREE.UnsignedByteType)return m.UNSIGNED_BYTE;
                if (a === THREE.UnsignedShort4444Type)return m.UNSIGNED_SHORT_4_4_4_4;
                if (a === THREE.UnsignedShort5551Type)return m.UNSIGNED_SHORT_5_5_5_1;
                if (a === THREE.UnsignedShort565Type)return m.UNSIGNED_SHORT_5_6_5;
                if (a === THREE.ByteType)return m.BYTE;
                if (a === THREE.ShortType)return m.SHORT;
                if (a === THREE.UnsignedShortType)return m.UNSIGNED_SHORT;
                if (a === THREE.IntType)return m.INT;
                if (a === THREE.UnsignedIntType)return m.UNSIGNED_INT;
                if (a === THREE.FloatType)return m.FLOAT;
                b = da.get("OES_texture_half_float");
                if (null !== b && a === THREE.HalfFloatType)return b.HALF_FLOAT_OES;
                if (a === THREE.AlphaFormat)return m.ALPHA;
                if (a === THREE.RGBFormat)return m.RGB;
                if (a === THREE.RGBAFormat)return m.RGBA;
                if (a === THREE.LuminanceFormat)return m.LUMINANCE;
                if (a === THREE.LuminanceAlphaFormat)return m.LUMINANCE_ALPHA;
                if (a === THREE.AddEquation)return m.FUNC_ADD;
                if (a === THREE.SubtractEquation)return m.FUNC_SUBTRACT;
                if (a === THREE.ReverseSubtractEquation)return m.FUNC_REVERSE_SUBTRACT;
                if (a === THREE.ZeroFactor)return m.ZERO;
                if (a === THREE.OneFactor)return m.ONE;
                if (a === THREE.SrcColorFactor)return m.SRC_COLOR;
                if (a === THREE.OneMinusSrcColorFactor)return m.ONE_MINUS_SRC_COLOR;
                if (a === THREE.SrcAlphaFactor)return m.SRC_ALPHA;
                if (a === THREE.OneMinusSrcAlphaFactor)return m.ONE_MINUS_SRC_ALPHA;
                if (a === THREE.DstAlphaFactor)return m.DST_ALPHA;
                if (a === THREE.OneMinusDstAlphaFactor)return m.ONE_MINUS_DST_ALPHA;
                if (a === THREE.DstColorFactor)return m.DST_COLOR;
                if (a === THREE.OneMinusDstColorFactor)return m.ONE_MINUS_DST_COLOR;
                if (a === THREE.SrcAlphaSaturateFactor)return m.SRC_ALPHA_SATURATE;
                b = da.get("WEBGL_compressed_texture_s3tc");
                if (null !== b) {
                    if (a === THREE.RGB_S3TC_DXT1_Format)return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (a === THREE.RGBA_S3TC_DXT1_Format)return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (a === THREE.RGBA_S3TC_DXT3_Format)return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (a === THREE.RGBA_S3TC_DXT5_Format)return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                b = da.get("WEBGL_compressed_texture_pvrtc");
                if (null !== b) {
                    if (a === THREE.RGB_PVRTC_4BPPV1_Format)return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (a === THREE.RGB_PVRTC_2BPPV1_Format)return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (a === THREE.RGBA_PVRTC_4BPPV1_Format)return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (a === THREE.RGBA_PVRTC_2BPPV1_Format)return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                b = da.get("EXT_blend_minmax");
                if (null !== b) {
                    if (a === THREE.MinEquation)return b.MIN_EXT;
                    if (a === THREE.MaxEquation)return b.MAX_EXT
                }
                return 0
            }

            console.log("THREE.WebGLRenderer", THREE.REVISION);
            a = a || {};
            var U = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"), M = void 0 !== a.context ? a.context : null, H = 1, L = void 0 !== a.precision ? a.precision : "highp", P = void 0 !== a.alpha ? a.alpha : !1, N = void 0 !== a.depth ? a.depth : !0, R = void 0 !== a.stencil ?
                a.stencil : !0, V = void 0 !== a.antialias ? a.antialias : !1, J = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, oa = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, ja = void 0 !== a.logarithmicDepthBuffer ? a.logarithmicDepthBuffer : !1, ha = new THREE.Color(0), O = 0, ca = [], ba = {}, qa = [], Ka = [], Qa = [], Xa = [], Ya = [];
            this.domElement = U;
            this.context = null;
            this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
            this.gammaFactor = 2;
            this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;
            this.shadowMapType = THREE.PCFShadowMap;
            this.shadowMapCullFace = THREE.CullFaceFront;
            this.shadowMapCascade = this.shadowMapDebug = !1;
            this.maxMorphTargets = 8;
            this.maxMorphNormals = 4;
            this.autoScaleCubemaps = !0;
            this.info = {memory: {programs: 0, geometries: 0, textures: 0}, render: {calls: 0, vertices: 0, faces: 0, points: 0}};
            var B = this, Pa = [], ob = null, ab = null, ub = -1, ta = "", vb = null, Mb = 0, ib = 0, bb = 0, pb = U.width, qb = U.height, Xb = 0, fc = 0, cb = new THREE.Frustum, db = new THREE.Matrix4, wa = new THREE.Vector3, pa = new THREE.Vector3, Ob = !0, jc = {
                ambient: [0,
                    0, 0],
                directional: {length: 0, colors: [], positions: []},
                point: {length: 0, colors: [], positions: [], distances: [], decays: []},
                spot: {length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: []},
                hemi: {length: 0, skyColors: [], groundColors: [], positions: []}
            }, m;
            try {
                var Yb = {alpha: P, depth: N, stencil: R, antialias: V, premultipliedAlpha: J, preserveDrawingBuffer: oa};
                m = M || U.getContext("webgl", Yb) || U.getContext("experimental-webgl", Yb);
                if (null === m) {
                    if (null !== U.getContext("webgl"))throw"Error creating WebGL context with your selected attributes.";
                    throw"Error creating WebGL context.";
                }
                U.addEventListener("webglcontextlost", function (a) {
                    a.preventDefault();
                    Zb();
                    lc();
                    ba = {}
                }, !1)
            } catch (rc) {
                THREE.error("THREE.WebGLRenderer: " + rc)
            }
            var W = new THREE.WebGLState(m, I);
            void 0 === m.getShaderPrecisionFormat && (m.getShaderPrecisionFormat = function () {
                return {rangeMin: 1, rangeMax: 1, precision: 1}
            });
            var da = new THREE.WebGLExtensions(m);
            da.get("OES_texture_float");
            da.get("OES_texture_float_linear");
            da.get("OES_texture_half_float");
            da.get("OES_texture_half_float_linear");
            da.get("OES_standard_derivatives");
            ja && da.get("EXT_frag_depth");
            var rb = function (a, b, c, d) {
                !0 === J && (a *= d, b *= d, c *= d);
                m.clearColor(a, b, c, d)
            }, lc = function () {
                m.clearColor(0, 0, 0, 1);
                m.clearDepth(1);
                m.clearStencil(0);
                m.enable(m.DEPTH_TEST);
                m.depthFunc(m.LEQUAL);
                m.frontFace(m.CCW);
                m.cullFace(m.BACK);
                m.enable(m.CULL_FACE);
                m.enable(m.BLEND);
                m.blendEquation(m.FUNC_ADD);
                m.blendFunc(m.SRC_ALPHA, m.ONE_MINUS_SRC_ALPHA);
                m.viewport(ib, bb, pb, qb);
                rb(ha.r, ha.g, ha.b, O)
            }, Zb = function () {
                vb = ob = null;
                ta = "";
                ub = -1;
                Ob = !0;
                W.reset()
            };
            lc();
            this.context = m;
            this.state = W;
            var Wb = m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS), sc = m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS), tc = m.getParameter(m.MAX_TEXTURE_SIZE), qc = m.getParameter(m.MAX_CUBE_MAP_TEXTURE_SIZE), Vb = 0 < sc, Nb = Vb && da.get("OES_texture_float"), uc = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.HIGH_FLOAT), vc = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.MEDIUM_FLOAT), wc = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.HIGH_FLOAT), xc = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.MEDIUM_FLOAT),
                kc = function () {
                    var a;
                    return function () {
                        if (void 0 !== a)return a;
                        a = [];
                        if (da.get("WEBGL_compressed_texture_pvrtc") || da.get("WEBGL_compressed_texture_s3tc"))for (var b = m.getParameter(m.COMPRESSED_TEXTURE_FORMATS), c = 0; c < b.length; c++)a.push(b[c]);
                        return a
                    }
                }(), yc = 0 < uc.precision && 0 < wc.precision, mc = 0 < vc.precision && 0 < xc.precision;
            "highp" !== L || yc || (mc ? (L = "mediump", THREE.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (L = "lowp", THREE.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp.")));
            "mediump" !== L || mc || (L = "lowp", THREE.warn("THREE.WebGLRenderer: mediump not supported, using lowp."));
            var zc = new THREE.ShadowMapPlugin(this, ca, ba, qa), Ac = new THREE.SpritePlugin(this, Xa), Bc = new THREE.LensFlarePlugin(this, Ya);
            this.getContext = function () {
                return m
            };
            this.forceContextLoss = function () {
                da.get("WEBGL_lose_context").loseContext()
            };
            this.supportsVertexTextures = function () {
                return Vb
            };
            this.supportsFloatTextures = function () {
                return da.get("OES_texture_float")
            };
            this.supportsHalfFloatTextures = function () {
                return da.get("OES_texture_half_float")
            };
            this.supportsStandardDerivatives = function () {
                return da.get("OES_standard_derivatives")
            };
            this.supportsCompressedTextureS3TC = function () {
                return da.get("WEBGL_compressed_texture_s3tc")
            };
            this.supportsCompressedTexturePVRTC = function () {
                return da.get("WEBGL_compressed_texture_pvrtc")
            };
            this.supportsBlendMinMax = function () {
                return da.get("EXT_blend_minmax")
            };
            this.getMaxAnisotropy = function () {
                var a;
                return function () {
                    if (void 0 !== a)return a;
                    var b = da.get("EXT_texture_filter_anisotropic");
                    return a = null !== b ? m.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) :
                        0
                }
            }();
            this.getPrecision = function () {
                return L
            };
            this.getPixelRatio = function () {
                return H
            };
            this.setPixelRatio = function (a) {
                H = a
            };
            this.setSize = function (a, b, c) {
                U.width = a * H;
                U.height = b * H;
                !1 !== c && (U.style.width = a + "px", U.style.height = b + "px");
                this.setViewport(0, 0, a, b)
            };
            this.setViewport = function (a, b, c, d) {
                ib = a * H;
                bb = b * H;
                pb = c * H;
                qb = d * H;
                m.viewport(ib, bb, pb, qb)
            };
            this.setScissor = function (a, b, c, d) {
                m.scissor(a * H, b * H, c * H, d * H)
            };
            this.enableScissorTest = function (a) {
                a ? m.enable(m.SCISSOR_TEST) : m.disable(m.SCISSOR_TEST)
            };
            this.getClearColor =
                function () {
                    return ha
                };
            this.setClearColor = function (a, b) {
                ha.set(a);
                O = void 0 !== b ? b : 1;
                rb(ha.r, ha.g, ha.b, O)
            };
            this.getClearAlpha = function () {
                return O
            };
            this.setClearAlpha = function (a) {
                O = a;
                rb(ha.r, ha.g, ha.b, O)
            };
            this.clear = function (a, b, c) {
                var d = 0;
                if (void 0 === a || a)d |= m.COLOR_BUFFER_BIT;
                if (void 0 === b || b)d |= m.DEPTH_BUFFER_BIT;
                if (void 0 === c || c)d |= m.STENCIL_BUFFER_BIT;
                m.clear(d)
            };
            this.clearColor = function () {
                m.clear(m.COLOR_BUFFER_BIT)
            };
            this.clearDepth = function () {
                m.clear(m.DEPTH_BUFFER_BIT)
            };
            this.clearStencil = function () {
                m.clear(m.STENCIL_BUFFER_BIT)
            };
            this.clearTarget = function (a, b, c, d) {
                this.setRenderTarget(a);
                this.clear(b, c, d)
            };
            this.resetGLState = Zb;
            var wb = function (a) {
                    a.target.traverse(function (a) {
                        a.removeEventListener("remove", wb);
                        if (a instanceof THREE.Mesh || a instanceof THREE.PointCloud || a instanceof THREE.Line)delete ba[a.id]; else if (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback)for (var b = qa, c = b.length - 1; 0 <= c; c--)b[c].object === a && b.splice(c, 1);
                        delete a.__webglInit;
                        delete a._modelViewMatrix;
                        delete a._normalMatrix;
                        delete a.__webglActive
                    })
                },
                jb = function (a) {
                    a = a.target;
                    a.removeEventListener("dispose", jb);
                    delete a.__webglInit;
                    if (a instanceof THREE.BufferGeometry) {
                        for (var b in a.attributes) {
                            var c = a.attributes[b];
                            void 0 !== c.buffer && (m.deleteBuffer(c.buffer), delete c.buffer)
                        }
                        B.info.memory.geometries--
                    } else if (b = Ua[a.id], void 0 !== b) {
                        for (var c = 0, d = b.length; c < d; c++) {
                            var e = b[c];
                            if (void 0 !== e.numMorphTargets) {
                                for (var f = 0, g = e.numMorphTargets; f < g; f++)m.deleteBuffer(e.__webglMorphTargetsBuffers[f]);
                                delete e.__webglMorphTargetsBuffers
                            }
                            if (void 0 !== e.numMorphNormals) {
                                f =
                                    0;
                                for (g = e.numMorphNormals; f < g; f++)m.deleteBuffer(e.__webglMorphNormalsBuffers[f]);
                                delete e.__webglMorphNormalsBuffers
                            }
                            nc(e)
                        }
                        delete Ua[a.id]
                    } else nc(a);
                    ta = ""
                }, Pb = function (a) {
                    a = a.target;
                    a.removeEventListener("dispose", Pb);
                    a.image && a.image.__webglTextureCube ? (m.deleteTexture(a.image.__webglTextureCube), delete a.image.__webglTextureCube) : void 0 !== a.__webglInit && (m.deleteTexture(a.__webglTexture), delete a.__webglTexture, delete a.__webglInit);
                    B.info.memory.textures--
                }, oc = function (a) {
                    a = a.target;
                    a.removeEventListener("dispose",
                        oc);
                    if (a && void 0 !== a.__webglTexture) {
                        m.deleteTexture(a.__webglTexture);
                        delete a.__webglTexture;
                        if (a instanceof THREE.WebGLRenderTargetCube)for (var b = 0; 6 > b; b++)m.deleteFramebuffer(a.__webglFramebuffer[b]), m.deleteRenderbuffer(a.__webglRenderbuffer[b]); else m.deleteFramebuffer(a.__webglFramebuffer), m.deleteRenderbuffer(a.__webglRenderbuffer);
                        delete a.__webglFramebuffer;
                        delete a.__webglRenderbuffer
                    }
                    B.info.memory.textures--
                }, ic = function (a) {
                    a = a.target;
                    a.removeEventListener("dispose", ic);
                    hc(a)
                }, nc = function (a) {
                    for (var b =
                        "__webglVertexBuffer __webglNormalBuffer __webglTangentBuffer __webglColorBuffer __webglUVBuffer __webglUV2Buffer __webglSkinIndicesBuffer __webglSkinWeightsBuffer __webglFaceBuffer __webglLineBuffer __webglLineDistanceBuffer".split(" "), c = 0, d = b.length; c < d; c++) {
                        var e = b[c];
                        void 0 !== a[e] && (m.deleteBuffer(a[e]), delete a[e])
                    }
                    if (void 0 !== a.__webglCustomAttributesList) {
                        for (e in a.__webglCustomAttributesList)m.deleteBuffer(a.__webglCustomAttributesList[e].buffer);
                        delete a.__webglCustomAttributesList
                    }
                    B.info.memory.geometries--
                },
                hc = function (a) {
                    var b = a.program.program;
                    if (void 0 !== b) {
                        a.program = void 0;
                        var c, d, e = !1;
                        a = 0;
                        for (c = Pa.length; a < c; a++)if (d = Pa[a], d.program === b) {
                            d.usedTimes--;
                            0 === d.usedTimes && (e = !0);
                            break
                        }
                        if (!0 === e) {
                            e = [];
                            a = 0;
                            for (c = Pa.length; a < c; a++)d = Pa[a], d.program !== b && e.push(d);
                            Pa = e;
                            m.deleteProgram(b);
                            B.info.memory.programs--
                        }
                    }
                };
            this.renderBufferImmediate = function (a, b, c) {
                W.initAttributes();
                a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = m.createBuffer());
                a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer =
                    m.createBuffer());
                a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = m.createBuffer());
                a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = m.createBuffer());
                a.hasPositions && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglVertexBuffer), m.bufferData(m.ARRAY_BUFFER, a.positionArray, m.DYNAMIC_DRAW), W.enableAttribute(b.attributes.position), m.vertexAttribPointer(b.attributes.position, 3, m.FLOAT, !1, 0, 0));
                if (a.hasNormals) {
                    m.bindBuffer(m.ARRAY_BUFFER, a.__webglNormalBuffer);
                    if (!1 === c instanceof THREE.MeshPhongMaterial &&
                        c.shading === THREE.FlatShading) {
                        var d, e, f, g, h, k, n, l, p, q, r, s = 3 * a.count;
                        for (r = 0; r < s; r += 9)q = a.normalArray, d = q[r], e = q[r + 1], f = q[r + 2], g = q[r + 3], k = q[r + 4], l = q[r + 5], h = q[r + 6], n = q[r + 7], p = q[r + 8], d = (d + g + h) / 3, e = (e + k + n) / 3, f = (f + l + p) / 3, q[r] = d, q[r + 1] = e, q[r + 2] = f, q[r + 3] = d, q[r + 4] = e, q[r + 5] = f, q[r + 6] = d, q[r + 7] = e, q[r + 8] = f
                    }
                    m.bufferData(m.ARRAY_BUFFER, a.normalArray, m.DYNAMIC_DRAW);
                    W.enableAttribute(b.attributes.normal);
                    m.vertexAttribPointer(b.attributes.normal, 3, m.FLOAT, !1, 0, 0)
                }
                a.hasUvs && c.map && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglUvBuffer),
                    m.bufferData(m.ARRAY_BUFFER, a.uvArray, m.DYNAMIC_DRAW), W.enableAttribute(b.attributes.uv), m.vertexAttribPointer(b.attributes.uv, 2, m.FLOAT, !1, 0, 0));
                a.hasColors && c.vertexColors !== THREE.NoColors && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, a.colorArray, m.DYNAMIC_DRAW), W.enableAttribute(b.attributes.color), m.vertexAttribPointer(b.attributes.color, 3, m.FLOAT, !1, 0, 0));
                W.disableUnusedAttributes();
                m.drawArrays(m.TRIANGLES, 0, a.count);
                a.count = 0
            };
            this.renderBufferDirect = function (a,
                                                b, c, e, f, g) {
                if (!1 !== e.visible)if (t(g), a = v(a, b, c, e, g), b = !1, c = "direct_" + f.id + "_" + a.id + "_" + (e.wireframe ? 1 : 0), c !== ta && (ta = c, b = !0), b && W.initAttributes(), g instanceof THREE.Mesh) {
                    g = !0 === e.wireframe ? m.LINES : m.TRIANGLES;
                    var h = f.attributes.index;
                    if (h) {
                        var k, n;
                        h.array instanceof Uint32Array && da.get("OES_element_index_uint") ? (k = m.UNSIGNED_INT, n = 4) : (k = m.UNSIGNED_SHORT, n = 2);
                        c = f.offsets;
                        if (0 === c.length)b && (d(e, a, f, 0), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer)), m.drawElements(g, h.array.length, k, 0), B.info.render.calls++,
                            B.info.render.vertices += h.array.length, B.info.render.faces += h.array.length / 3; else {
                            b = !0;
                            for (var l = 0, p = c.length; l < p; l++) {
                                var q = c[l].index;
                                b && (d(e, a, f, q), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer));
                                m.drawElements(g, c[l].count, k, c[l].start * n);
                                B.info.render.calls++;
                                B.info.render.vertices += c[l].count;
                                B.info.render.faces += c[l].count / 3
                            }
                        }
                    } else b && d(e, a, f, 0), e = f.attributes.position, m.drawArrays(g, 0, e.array.length / e.itemSize), B.info.render.calls++, B.info.render.vertices += e.array.length / e.itemSize, B.info.render.faces +=
                        e.array.length / (3 * e.itemSize)
                } else if (g instanceof THREE.PointCloud)if (g = m.POINTS, h = f.attributes.index)if (h.array instanceof Uint32Array && da.get("OES_element_index_uint") ? (k = m.UNSIGNED_INT, n = 4) : (k = m.UNSIGNED_SHORT, n = 2), c = f.offsets, 0 === c.length)b && (d(e, a, f, 0), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer)), m.drawElements(g, h.array.length, k, 0), B.info.render.calls++, B.info.render.points += h.array.length; else for (1 < c.length && (b = !0), l = 0, p = c.length; l < p; l++)q = c[l].index, b && (d(e, a, f, q), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,
                    h.buffer)), m.drawElements(g, c[l].count, k, c[l].start * n), B.info.render.calls++, B.info.render.points += c[l].count; else if (b && d(e, a, f, 0), e = f.attributes.position, c = f.offsets, 0 === c.length)m.drawArrays(g, 0, e.array.length / 3), B.info.render.calls++, B.info.render.points += e.array.length / 3; else for (l = 0, p = c.length; l < p; l++)m.drawArrays(g, c[l].index, c[l].count), B.info.render.calls++, B.info.render.points += c[l].count; else if (g instanceof THREE.Line)if (g = g.mode === THREE.LineStrip ? m.LINE_STRIP : m.LINES, W.setLineWidth(e.linewidth *
                        H), h = f.attributes.index)if (h.array instanceof Uint32Array ? (k = m.UNSIGNED_INT, n = 4) : (k = m.UNSIGNED_SHORT, n = 2), c = f.offsets, 0 === c.length)b && (d(e, a, f, 0), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer)), m.drawElements(g, h.array.length, k, 0), B.info.render.calls++, B.info.render.vertices += h.array.length; else for (1 < c.length && (b = !0), l = 0, p = c.length; l < p; l++)q = c[l].index, b && (d(e, a, f, q), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer)), m.drawElements(g, c[l].count, k, c[l].start * n), B.info.render.calls++, B.info.render.vertices +=
                    c[l].count; else if (b && d(e, a, f, 0), e = f.attributes.position, c = f.offsets, 0 === c.length)m.drawArrays(g, 0, e.array.length / 3), B.info.render.calls++, B.info.render.vertices += e.array.length / 3; else for (l = 0, p = c.length; l < p; l++)m.drawArrays(g, c[l].index, c[l].count), B.info.render.calls++, B.info.render.vertices += c[l].count
            };
            this.renderBuffer = function (a, b, c, d, e, f) {
                if (!1 !== d.visible) {
                    t(f);
                    c = v(a, b, c, d, f);
                    b = c.attributes;
                    a = !1;
                    c = e.id + "_" + c.id + "_" + (d.wireframe ? 1 : 0);
                    c !== ta && (ta = c, a = !0);
                    a && W.initAttributes();
                    if (!d.morphTargets &&
                        0 <= b.position)a && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), W.enableAttribute(b.position), m.vertexAttribPointer(b.position, 3, m.FLOAT, !1, 0, 0)); else if (f.morphTargetBase) {
                        c = d.program.attributes;
                        -1 !== f.morphTargetBase && 0 <= c.position ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[f.morphTargetBase]), W.enableAttribute(c.position), m.vertexAttribPointer(c.position, 3, m.FLOAT, !1, 0, 0)) : 0 <= c.position && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), W.enableAttribute(c.position), m.vertexAttribPointer(c.position,
                            3, m.FLOAT, !1, 0, 0));
                        if (f.morphTargetForcedOrder.length)for (var h = 0, k = f.morphTargetForcedOrder, n = f.morphTargetInfluences, l; h < d.numSupportedMorphTargets && h < k.length;)l = c["morphTarget" + h], 0 <= l && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[k[h]]), W.enableAttribute(l), m.vertexAttribPointer(l, 3, m.FLOAT, !1, 0, 0)), l = c["morphNormal" + h], 0 <= l && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[k[h]]), W.enableAttribute(l), m.vertexAttribPointer(l, 3, m.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[h] =
                            n[k[h]], h++; else {
                            k = [];
                            n = f.morphTargetInfluences;
                            h = f.geometry.morphTargets;
                            n.length > h.length && (console.warn("THREE.WebGLRenderer: Influences array is bigger than morphTargets array."), n.length = h.length);
                            h = 0;
                            for (l = n.length; h < l; h++)k.push([n[h], h]);
                            k.length > d.numSupportedMorphTargets ? (k.sort(g), k.length = d.numSupportedMorphTargets) : k.length > d.numSupportedMorphNormals ? k.sort(g) : 0 === k.length && k.push([0, 0]);
                            for (var h = 0, p = d.numSupportedMorphTargets; h < p; h++)if (k[h]) {
                                var q = k[h][1];
                                l = c["morphTarget" + h];
                                0 <= l &&
                                (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[q]), W.enableAttribute(l), m.vertexAttribPointer(l, 3, m.FLOAT, !1, 0, 0));
                                l = c["morphNormal" + h];
                                0 <= l && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[q]), W.enableAttribute(l), m.vertexAttribPointer(l, 3, m.FLOAT, !1, 0, 0));
                                f.__webglMorphTargetInfluences[h] = n[q]
                            } else f.__webglMorphTargetInfluences[h] = 0
                        }
                        null !== d.program.uniforms.morphTargetInfluences && m.uniform1fv(d.program.uniforms.morphTargetInfluences, f.__webglMorphTargetInfluences)
                    }
                    if (a) {
                        if (e.__webglCustomAttributesList)for (c =
                                                                   0, n = e.__webglCustomAttributesList.length; c < n; c++)k = e.__webglCustomAttributesList[c], 0 <= b[k.buffer.belongsToAttribute] && (m.bindBuffer(m.ARRAY_BUFFER, k.buffer), W.enableAttribute(b[k.buffer.belongsToAttribute]), m.vertexAttribPointer(b[k.buffer.belongsToAttribute], k.size, m.FLOAT, !1, 0, 0));
                        0 <= b.color && (0 < f.geometry.colors.length || 0 < f.geometry.faces.length ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglColorBuffer), W.enableAttribute(b.color), m.vertexAttribPointer(b.color, 3, m.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues &&
                        m.vertexAttrib3fv(b.color, d.defaultAttributeValues.color));
                        0 <= b.normal && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglNormalBuffer), W.enableAttribute(b.normal), m.vertexAttribPointer(b.normal, 3, m.FLOAT, !1, 0, 0));
                        0 <= b.tangent && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglTangentBuffer), W.enableAttribute(b.tangent), m.vertexAttribPointer(b.tangent, 4, m.FLOAT, !1, 0, 0));
                        0 <= b.uv && (f.geometry.faceVertexUvs[0] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUVBuffer), W.enableAttribute(b.uv), m.vertexAttribPointer(b.uv, 2, m.FLOAT, !1, 0,
                            0)) : void 0 !== d.defaultAttributeValues && m.vertexAttrib2fv(b.uv, d.defaultAttributeValues.uv));
                        0 <= b.uv2 && (f.geometry.faceVertexUvs[1] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUV2Buffer), W.enableAttribute(b.uv2), m.vertexAttribPointer(b.uv2, 2, m.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && m.vertexAttrib2fv(b.uv2, d.defaultAttributeValues.uv2));
                        d.skinning && 0 <= b.skinIndex && 0 <= b.skinWeight && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), W.enableAttribute(b.skinIndex), m.vertexAttribPointer(b.skinIndex,
                            4, m.FLOAT, !1, 0, 0), m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), W.enableAttribute(b.skinWeight), m.vertexAttribPointer(b.skinWeight, 4, m.FLOAT, !1, 0, 0));
                        0 <= b.lineDistance && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglLineDistanceBuffer), W.enableAttribute(b.lineDistance), m.vertexAttribPointer(b.lineDistance, 1, m.FLOAT, !1, 0, 0))
                    }
                    W.disableUnusedAttributes();
                    f instanceof THREE.Mesh ? (f = e.__typeArray === Uint32Array ? m.UNSIGNED_INT : m.UNSIGNED_SHORT, d.wireframe ? (W.setLineWidth(d.wireframeLinewidth * H), a && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,
                        e.__webglLineBuffer), m.drawElements(m.LINES, e.__webglLineCount, f, 0)) : (a && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), m.drawElements(m.TRIANGLES, e.__webglFaceCount, f, 0)), B.info.render.calls++, B.info.render.vertices += e.__webglFaceCount, B.info.render.faces += e.__webglFaceCount / 3) : f instanceof THREE.Line ? (f = f.mode === THREE.LineStrip ? m.LINE_STRIP : m.LINES, W.setLineWidth(d.linewidth * H), m.drawArrays(f, 0, e.__webglLineCount), B.info.render.calls++) : f instanceof THREE.PointCloud && (m.drawArrays(m.POINTS,
                        0, e.__webglParticleCount), B.info.render.calls++, B.info.render.points += e.__webglParticleCount)
                }
            };
            this.render = function (a, b, c, d) {
                if (!1 === b instanceof THREE.Camera)THREE.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else {
                    var g = a.fog;
                    ta = "";
                    ub = -1;
                    vb = null;
                    Ob = !0;
                    !0 === a.autoUpdate && a.updateMatrixWorld();
                    void 0 === b.parent && b.updateMatrixWorld();
                    a.traverse(function (a) {
                        a instanceof THREE.SkinnedMesh && a.skeleton.update()
                    });
                    b.matrixWorldInverse.getInverse(b.matrixWorld);
                    db.multiplyMatrices(b.projectionMatrix,
                        b.matrixWorldInverse);
                    cb.setFromMatrix(db);
                    ca.length = 0;
                    Ka.length = 0;
                    Qa.length = 0;
                    Xa.length = 0;
                    Ya.length = 0;
                    h(a);
                    !0 === B.sortObjects && (Ka.sort(e), Qa.sort(f));
                    zc.render(a, b);
                    B.info.render.calls = 0;
                    B.info.render.vertices = 0;
                    B.info.render.faces = 0;
                    B.info.render.points = 0;
                    this.setRenderTarget(c);
                    (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
                    d = 0;
                    for (var n = qa.length; d < n; d++) {
                        var m = qa[d], q = m.object;
                        q.visible && (w(q, b), p(m))
                    }
                    a.overrideMaterial ? (d = a.overrideMaterial, u(d),
                        k(Ka, b, ca, g, d), k(Qa, b, ca, g, d), l(qa, "", b, ca, g, d)) : (W.setBlending(THREE.NoBlending), k(Ka, b, ca, g, null), l(qa, "opaque", b, ca, g, null), k(Qa, b, ca, g, null), l(qa, "transparent", b, ca, g, null));
                    Ac.render(a, b);
                    Bc.render(a, b, Xb, fc);
                    c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && F(c);
                    W.setDepthTest(!0);
                    W.setDepthWrite(!0);
                    W.setColorWrite(!0)
                }
            };
            this.renderImmediateObject = function (a, b, c, d, e) {
                var f = v(a, b, c, d, e);
                ta = "";
                B.setMaterialFaces(d);
                e.immediateRenderCallback ? e.immediateRenderCallback(f,
                    m, cb) : e.render(function (a) {
                    B.renderBufferImmediate(a, f, d)
                })
            };
            var Ua = {}, Qb = 0, pc = {
                MeshDepthMaterial: "depth",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointCloudMaterial: "particle_basic"
            };
            this.setFaceCulling = function (a, b) {
                a === THREE.CullFaceNone ? m.disable(m.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? m.frontFace(m.CW) : m.frontFace(m.CCW), a === THREE.CullFaceBack ? m.cullFace(m.BACK) : a ===
                THREE.CullFaceFront ? m.cullFace(m.FRONT) : m.cullFace(m.FRONT_AND_BACK), m.enable(m.CULL_FACE))
            };
            this.setMaterialFaces = function (a) {
                W.setDoubleSided(a.side === THREE.DoubleSide);
                W.setFlipSided(a.side === THREE.BackSide)
            };
            this.uploadTexture = function (a) {
                void 0 === a.__webglInit && (a.__webglInit = !0, a.addEventListener("dispose", Pb), a.__webglTexture = m.createTexture(), B.info.memory.textures++);
                m.bindTexture(m.TEXTURE_2D, a.__webglTexture);
                m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, a.flipY);
                m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    a.premultiplyAlpha);
                m.pixelStorei(m.UNPACK_ALIGNMENT, a.unpackAlignment);
                a.image = E(a.image, tc);
                var b = a.image, c = THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height), d = I(a.format), e = I(a.type);
                A(m.TEXTURE_2D, a, c);
                var f = a.mipmaps;
                if (a instanceof THREE.DataTexture)if (0 < f.length && c) {
                    for (var g = 0, h = f.length; g < h; g++)b = f[g], m.texImage2D(m.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data);
                    a.generateMipmaps = !1
                } else m.texImage2D(m.TEXTURE_2D, 0, d, b.width, b.height, 0, d, e, b.data); else if (a instanceof THREE.CompressedTexture)for (g =
                                                                                                                                                    0, h = f.length; g < h; g++)b = f[g], a.format !== THREE.RGBAFormat && a.format !== THREE.RGBFormat ? -1 < kc().indexOf(d) ? m.compressedTexImage2D(m.TEXTURE_2D, g, d, b.width, b.height, 0, b.data) : THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : m.texImage2D(m.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data); else if (0 < f.length && c) {
                    g = 0;
                    for (h = f.length; g < h; g++)b = f[g], m.texImage2D(m.TEXTURE_2D, g, d, d, e, b);
                    a.generateMipmaps = !1
                } else m.texImage2D(m.TEXTURE_2D, 0, d, d, e, a.image);
                a.generateMipmaps && c && m.generateMipmap(m.TEXTURE_2D);
                a.needsUpdate = !1;
                if (a.onUpdate)a.onUpdate()
            };
            this.setTexture = function (a, b) {
                m.activeTexture(m.TEXTURE0 + b);
                a.needsUpdate ? B.uploadTexture(a) : m.bindTexture(m.TEXTURE_2D, a.__webglTexture)
            };
            this.setRenderTarget = function (a) {
                var b = a instanceof THREE.WebGLRenderTargetCube;
                if (a && void 0 === a.__webglFramebuffer) {
                    void 0 === a.depthBuffer && (a.depthBuffer = !0);
                    void 0 === a.stencilBuffer && (a.stencilBuffer = !0);
                    a.addEventListener("dispose", oc);
                    a.__webglTexture = m.createTexture();
                    B.info.memory.textures++;
                    var c = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height), d = I(a.format), e = I(a.type);
                    if (b) {
                        a.__webglFramebuffer = [];
                        a.__webglRenderbuffer = [];
                        m.bindTexture(m.TEXTURE_CUBE_MAP, a.__webglTexture);
                        A(m.TEXTURE_CUBE_MAP, a, c);
                        for (var f = 0; 6 > f; f++) {
                            a.__webglFramebuffer[f] = m.createFramebuffer();
                            a.__webglRenderbuffer[f] = m.createRenderbuffer();
                            m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, d, a.width, a.height, 0, d, e, null);
                            var g = a, h = m.TEXTURE_CUBE_MAP_POSITIVE_X + f;
                            m.bindFramebuffer(m.FRAMEBUFFER,
                                a.__webglFramebuffer[f]);
                            m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, h, g.__webglTexture, 0);
                            G(a.__webglRenderbuffer[f], a)
                        }
                        c && m.generateMipmap(m.TEXTURE_CUBE_MAP)
                    } else a.__webglFramebuffer = m.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : m.createRenderbuffer(), m.bindTexture(m.TEXTURE_2D, a.__webglTexture), A(m.TEXTURE_2D, a, c), m.texImage2D(m.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), d = m.TEXTURE_2D, m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer),
                        m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : G(a.__webglRenderbuffer, a), c && m.generateMipmap(m.TEXTURE_2D);
                    b ? m.bindTexture(m.TEXTURE_CUBE_MAP, null) : m.bindTexture(m.TEXTURE_2D, null);
                    m.bindRenderbuffer(m.RENDERBUFFER,
                        null);
                    m.bindFramebuffer(m.FRAMEBUFFER, null)
                }
                a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, a = a.height, e = d = 0) : (b = null, c = pb, a = qb, d = ib, e = bb);
                b !== ab && (m.bindFramebuffer(m.FRAMEBUFFER, b), m.viewport(d, e, c, a), ab = b);
                Xb = c;
                fc = a
            };
            this.readRenderTargetPixels = function (a, b, c, d, e, f) {
                if (!(a instanceof THREE.WebGLRenderTarget))console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); else if (a.__webglFramebuffer)if (a.format !== THREE.RGBAFormat)console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.");
                else {
                    var g = !1;
                    a.__webglFramebuffer !== ab && (m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer), g = !0);
                    m.checkFramebufferStatus(m.FRAMEBUFFER) === m.FRAMEBUFFER_COMPLETE ? m.readPixels(b, c, d, e, m.RGBA, m.UNSIGNED_BYTE, f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
                    g && m.bindFramebuffer(m.FRAMEBUFFER, ab)
                }
            };
            this.initMaterial = function () {
                THREE.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            };
            this.addPrePlugin = function () {
                THREE.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            };
            this.addPostPlugin = function () {
                THREE.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            };
            this.updateShadowMap = function () {
                THREE.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }
        };
        THREE.WebGLRenderTarget = function (a, b, c) {
            this.width = a;
            this.height = b;
            c = c || {};
            this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;
            this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;
            this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;
            this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;
            this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
            this.offset = new THREE.Vector2(0, 0);
            this.repeat = new THREE.Vector2(1, 1);
            this.format = void 0 !== c.format ? c.format :
                THREE.RGBAFormat;
            this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;
            this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
            this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
            this.generateMipmaps = !0;
            this.shareDepthFrom = void 0 !== c.shareDepthFrom ? c.shareDepthFrom : null
        };
        THREE.WebGLRenderTarget.prototype = {
            constructor: THREE.WebGLRenderTarget, setSize: function (a, b) {
                this.width = a;
                this.height = b
            }, clone: function () {
                var a = new THREE.WebGLRenderTarget(this.width, this.height);
                a.wrapS = this.wrapS;
                a.wrapT = this.wrapT;
                a.magFilter = this.magFilter;
                a.minFilter = this.minFilter;
                a.anisotropy = this.anisotropy;
                a.offset.copy(this.offset);
                a.repeat.copy(this.repeat);
                a.format = this.format;
                a.type = this.type;
                a.depthBuffer = this.depthBuffer;
                a.stencilBuffer = this.stencilBuffer;
                a.generateMipmaps = this.generateMipmaps;
                a.shareDepthFrom = this.shareDepthFrom;
                return a
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        };
        THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
        THREE.WebGLRenderTargetCube = function (a, b, c) {
            THREE.WebGLRenderTarget.call(this, a, b, c);
            this.activeCubeFace = 0
        };
        THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
        THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
        THREE.WebGLExtensions = function (a) {
            var b = {};
            this.get = function (c) {
                if (void 0 !== b[c])return b[c];
                var d;
                switch (c) {
                    case "EXT_texture_filter_anisotropic":
                        d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        d = a.getExtension(c)
                }
                null === d && THREE.warn("THREE.WebGLRenderer: " + c + " extension not supported.");
                return b[c] = d
            }
        };
        THREE.WebGLProgram = function () {
            var a = 0;
            return function (b, c, d, e) {
                var f = b.context, g = d.defines, h = d.__webglShader.uniforms, k = d.attributes, l = d.__webglShader.vertexShader, p = d.__webglShader.fragmentShader, q = d.index0AttributeName;
                void 0 === q && !0 === e.morphTargets && (q = "position");
                var n = "SHADOWMAP_TYPE_BASIC";
                e.shadowMapType === THREE.PCFShadowMap ? n = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === THREE.PCFSoftShadowMap && (n = "SHADOWMAP_TYPE_PCF_SOFT");
                var t = "ENVMAP_TYPE_CUBE", r = "ENVMAP_MODE_REFLECTION", s = "ENVMAP_BLENDING_MULTIPLY";
                if (e.envMap) {
                    switch (d.envMap.mapping) {
                        case THREE.CubeReflectionMapping:
                        case THREE.CubeRefractionMapping:
                            t = "ENVMAP_TYPE_CUBE";
                            break;
                        case THREE.EquirectangularReflectionMapping:
                        case THREE.EquirectangularRefractionMapping:
                            t = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case THREE.SphericalReflectionMapping:
                            t = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (d.envMap.mapping) {
                        case THREE.CubeRefractionMapping:
                        case THREE.EquirectangularRefractionMapping:
                            r = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (d.combine) {
                        case THREE.MultiplyOperation:
                            s = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case THREE.MixOperation:
                            s = "ENVMAP_BLENDING_MIX";
                            break;
                        case THREE.AddOperation:
                            s = "ENVMAP_BLENDING_ADD"
                    }
                }
                var u = 0 < b.gammaFactor ? b.gammaFactor : 1, v, x;
                v = [];
                for (var D in g)x = g[D], !1 !== x && (x = "#define " + D + " " + x, v.push(x));
                v = v.join("\n");
                g = f.createProgram();
                d instanceof THREE.RawShaderMaterial ? b = d = "" : (d = ["precision " + e.precision + " float;", "precision " + e.precision + " int;", v, e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" :
                    "", "#define GAMMA_FACTOR " + u, "#define MAX_DIR_LIGHTS " + e.maxDirLights, "#define MAX_POINT_LIGHTS " + e.maxPointLights, "#define MAX_SPOT_LIGHTS " + e.maxSpotLights, "#define MAX_HEMI_LIGHTS " + e.maxHemiLights, "#define MAX_SHADOWS " + e.maxShadows, "#define MAX_BONES " + e.maxBones, e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + r : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" :
                    "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.vertexColors ? "#define USE_COLOR" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.useVertexTexture ? "#define BONE_TEXTURE" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals ? "#define USE_MORPHNORMALS" : "", e.wrapAround ? "#define WRAP_AROUND" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + n : "", e.shadowMapDebug ?
                    "#define SHADOWMAP_DEBUG" : "", e.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n\tattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n"].join("\n"),
                    b = ["precision " + e.precision + " float;", "precision " + e.precision + " int;", e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", v, "#define MAX_DIR_LIGHTS " + e.maxDirLights, "#define MAX_POINT_LIGHTS " + e.maxPointLights, "#define MAX_SPOT_LIGHTS " + e.maxSpotLights, "#define MAX_HEMI_LIGHTS " + e.maxHemiLights, "#define MAX_SHADOWS " + e.maxShadows, e.alphaTest ? "#define ALPHATEST " + e.alphaTest : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " +
                    u, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + t : "", e.envMap ? "#define " + r : "", e.envMap ? "#define " + s : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.vertexColors ? "#define USE_COLOR" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.metal ? "#define METAL" :
                        "", e.wrapAround ? "#define WRAP_AROUND" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + n : "", e.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", e.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n"));
                l = new THREE.WebGLShader(f, f.VERTEX_SHADER, d + l);
                p = new THREE.WebGLShader(f, f.FRAGMENT_SHADER,
                    b + p);
                f.attachShader(g, l);
                f.attachShader(g, p);
                void 0 !== q && f.bindAttribLocation(g, 0, q);
                f.linkProgram(g);
                q = f.getProgramInfoLog(g);
                !1 === f.getProgramParameter(g, f.LINK_STATUS) && THREE.error("THREE.WebGLProgram: shader error: " + f.getError(), "gl.VALIDATE_STATUS", f.getProgramParameter(g, f.VALIDATE_STATUS), "gl.getPRogramInfoLog", q);
                "" !== q && THREE.warn("THREE.WebGLProgram: gl.getProgramInfoLog()" + q);
                f.deleteShader(l);
                f.deleteShader(p);
                q = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse".split(" ");
                e.useVertexTexture ? (q.push("boneTexture"), q.push("boneTextureWidth"), q.push("boneTextureHeight")) : q.push("boneGlobalMatrices");
                e.logarithmicDepthBuffer && q.push("logDepthBufFC");
                for (var w in h)q.push(w);
                h = q;
                w = {};
                q = 0;
                for (b = h.length; q < b; q++)n = h[q], w[n] = f.getUniformLocation(g, n);
                this.uniforms = w;
                q = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" ");
                for (h = 0; h < e.maxMorphTargets; h++)q.push("morphTarget" + h);
                for (h = 0; h < e.maxMorphNormals; h++)q.push("morphNormal" + h);
                for (var y in k)q.push(y);
                e = q;
                k = {};
                y = 0;
                for (h = e.length; y < h; y++)w = e[y], k[w] = f.getAttribLocation(g, w);
                this.attributes = k;
                this.attributesKeys = Object.keys(this.attributes);
                this.id = a++;
                this.code = c;
                this.usedTimes = 1;
                this.program = g;
                this.vertexShader = l;
                this.fragmentShader = p;
                return this
            }
        }();
        THREE.WebGLShader = function () {
            var a = function (a) {
                a = a.split("\n");
                for (var c = 0; c < a.length; c++)a[c] = c + 1 + ": " + a[c];
                return a.join("\n")
            };
            return function (b, c, d) {
                c = b.createShader(c);
                b.shaderSource(c, d);
                b.compileShader(c);
                !1 === b.getShaderParameter(c, b.COMPILE_STATUS) && THREE.error("THREE.WebGLShader: Shader couldn't compile.");
                "" !== b.getShaderInfoLog(c) && THREE.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b.getShaderInfoLog(c), a(d));
                return c
            }
        }();
        THREE.WebGLState = function (a, b) {
            var c = new Uint8Array(16), d = new Uint8Array(16), e = null, f = null, g = null, h = null, k = null, l = null, p = null, q = null, n = null, t = null, r = null, s = null, u = null, v = null, x = null, D = null;
            this.initAttributes = function () {
                for (var a = 0, b = c.length; a < b; a++)c[a] = 0
            };
            this.enableAttribute = function (b) {
                c[b] = 1;
                0 === d[b] && (a.enableVertexAttribArray(b), d[b] = 1)
            };
            this.disableUnusedAttributes = function () {
                for (var b = 0, e = d.length; b < e; b++)d[b] !== c[b] && (a.disableVertexAttribArray(b), d[b] = 0)
            };
            this.setBlending = function (c, d,
                                         n, q, r, s, t) {
                c !== e && (c === THREE.NoBlending ? a.disable(a.BLEND) : c === THREE.AdditiveBlending ? (a.enable(a.BLEND), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : c === THREE.SubtractiveBlending ? (a.enable(a.BLEND), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : c === THREE.MultiplyBlending ? (a.enable(a.BLEND), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : c === THREE.CustomBlending ? a.enable(a.BLEND) : (a.enable(a.BLEND), a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD),
                    a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)), e = c);
                if (c === THREE.CustomBlending) {
                    r = r || d;
                    s = s || n;
                    t = t || q;
                    if (d !== f || r !== k)a.blendEquationSeparate(b(d), b(r)), f = d, k = r;
                    if (n !== g || q !== h || s !== l || t !== p)a.blendFuncSeparate(b(n), b(q), b(s), b(t)), g = n, h = q, l = s, p = t
                } else p = l = k = h = g = f = null
            };
            this.setDepthTest = function (b) {
                q !== b && (b ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), q = b)
            };
            this.setDepthWrite = function (b) {
                n !== b && (a.depthMask(b), n = b)
            };
            this.setColorWrite = function (b) {
                t !== b && (a.colorMask(b,
                    b, b, b), t = b)
            };
            this.setDoubleSided = function (b) {
                r !== b && (b ? a.disable(a.CULL_FACE) : a.enable(a.CULL_FACE), r = b)
            };
            this.setFlipSided = function (b) {
                s !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), s = b)
            };
            this.setLineWidth = function (b) {
                b !== u && (a.lineWidth(b), u = b)
            };
            this.setPolygonOffset = function (b, c, d) {
                v !== b && (b ? a.enable(a.POLYGON_OFFSET_FILL) : a.disable(a.POLYGON_OFFSET_FILL), v = b);
                !b || x === c && D === d || (a.polygonOffset(c, d), x = c, D = d)
            };
            this.reset = function () {
                for (var a = 0; a < d.length; a++)d[a] = 0;
                s = r = t = n = q = e = null
            }
        };
        THREE.LensFlarePlugin = function (a, b) {
            var c, d, e, f, g, h, k, l, p, q, n = a.context, t, r, s, u, v, x;
            this.render = function (D, w, y, A) {
                if (0 !== b.length) {
                    D = new THREE.Vector3;
                    var E = A / y, G = .5 * y, F = .5 * A, z = 16 / A, I = new THREE.Vector2(z * E, z), U = new THREE.Vector3(1, 1, 0), M = new THREE.Vector2(1, 1);
                    if (void 0 === s) {
                        var z = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]), H = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        t = n.createBuffer();
                        r = n.createBuffer();
                        n.bindBuffer(n.ARRAY_BUFFER, t);
                        n.bufferData(n.ARRAY_BUFFER, z, n.STATIC_DRAW);
                        n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,
                            r);
                        n.bufferData(n.ELEMENT_ARRAY_BUFFER, H, n.STATIC_DRAW);
                        v = n.createTexture();
                        x = n.createTexture();
                        n.bindTexture(n.TEXTURE_2D, v);
                        n.texImage2D(n.TEXTURE_2D, 0, n.RGB, 16, 16, 0, n.RGB, n.UNSIGNED_BYTE, null);
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);
                        n.bindTexture(n.TEXTURE_2D, x);
                        n.texImage2D(n.TEXTURE_2D, 0,
                            n.RGBA, 16, 16, 0, n.RGBA, n.UNSIGNED_BYTE, null);
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);
                        var z = (u = 0 < n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) ? {
                                vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                                fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                            } : {
                                vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                                fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                            },
                            H = n.createProgram(), L = n.createShader(n.FRAGMENT_SHADER), P = n.createShader(n.VERTEX_SHADER), N = "precision " + a.getPrecision() + " float;\n";
                        n.shaderSource(L, N + z.fragmentShader);
                        n.shaderSource(P, N + z.vertexShader);
                        n.compileShader(L);
                        n.compileShader(P);
                        n.attachShader(H, L);
                        n.attachShader(H, P);
                        n.linkProgram(H);
                        s = H;
                        p = n.getAttribLocation(s, "position");
                        q = n.getAttribLocation(s, "uv");
                        c = n.getUniformLocation(s, "renderType");
                        d = n.getUniformLocation(s, "map");
                        e = n.getUniformLocation(s, "occlusionMap");
                        f = n.getUniformLocation(s,
                            "opacity");
                        g = n.getUniformLocation(s, "color");
                        h = n.getUniformLocation(s, "scale");
                        k = n.getUniformLocation(s, "rotation");
                        l = n.getUniformLocation(s, "screenPosition")
                    }
                    n.useProgram(s);
                    n.enableVertexAttribArray(p);
                    n.enableVertexAttribArray(q);
                    n.uniform1i(e, 0);
                    n.uniform1i(d, 1);
                    n.bindBuffer(n.ARRAY_BUFFER, t);
                    n.vertexAttribPointer(p, 2, n.FLOAT, !1, 16, 0);
                    n.vertexAttribPointer(q, 2, n.FLOAT, !1, 16, 8);
                    n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, r);
                    n.disable(n.CULL_FACE);
                    n.depthMask(!1);
                    H = 0;
                    for (L = b.length; H < L; H++)if (z = 16 / A, I.set(z *
                            E, z), P = b[H], D.set(P.matrixWorld.elements[12], P.matrixWorld.elements[13], P.matrixWorld.elements[14]), D.applyMatrix4(w.matrixWorldInverse), D.applyProjection(w.projectionMatrix), U.copy(D), M.x = U.x * G + G, M.y = U.y * F + F, u || 0 < M.x && M.x < y && 0 < M.y && M.y < A) {
                        n.activeTexture(n.TEXTURE1);
                        n.bindTexture(n.TEXTURE_2D, v);
                        n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGB, M.x - 8, M.y - 8, 16, 16, 0);
                        n.uniform1i(c, 0);
                        n.uniform2f(h, I.x, I.y);
                        n.uniform3f(l, U.x, U.y, U.z);
                        n.disable(n.BLEND);
                        n.enable(n.DEPTH_TEST);
                        n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT,
                            0);
                        n.activeTexture(n.TEXTURE0);
                        n.bindTexture(n.TEXTURE_2D, x);
                        n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGBA, M.x - 8, M.y - 8, 16, 16, 0);
                        n.uniform1i(c, 1);
                        n.disable(n.DEPTH_TEST);
                        n.activeTexture(n.TEXTURE1);
                        n.bindTexture(n.TEXTURE_2D, v);
                        n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0);
                        P.positionScreen.copy(U);
                        P.customUpdateCallback ? P.customUpdateCallback(P) : P.updateLensFlares();
                        n.uniform1i(c, 2);
                        n.enable(n.BLEND);
                        for (var N = 0, R = P.lensFlares.length; N < R; N++) {
                            var V = P.lensFlares[N];
                            .001 < V.opacity && .001 < V.scale && (U.x = V.x,
                                U.y = V.y, U.z = V.z, z = V.size * V.scale / A, I.x = z * E, I.y = z, n.uniform3f(l, U.x, U.y, U.z), n.uniform2f(h, I.x, I.y), n.uniform1f(k, V.rotation), n.uniform1f(f, V.opacity), n.uniform3f(g, V.color.r, V.color.g, V.color.b), a.state.setBlending(V.blending, V.blendEquation, V.blendSrc, V.blendDst), a.setTexture(V.texture, 1), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0))
                        }
                    }
                    n.enable(n.CULL_FACE);
                    n.enable(n.DEPTH_TEST);
                    n.depthMask(!0);
                    a.resetGLState()
                }
            }
        };
        THREE.ShadowMapPlugin = function (a, b, c, d) {
            function e(a, b, d) {
                if (b.visible) {
                    var f = c[b.id];
                    if (f && b.castShadow && (!1 === b.frustumCulled || !0 === p.intersectsObject(b)))for (var g = 0, h = f.length; g < h; g++) {
                        var k = f[g];
                        b._modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, b.matrixWorld);
                        s.push(k)
                    }
                    g = 0;
                    for (h = b.children.length; g < h; g++)e(a, b.children[g], d)
                }
            }

            var f = a.context, g, h, k, l, p = new THREE.Frustum, q = new THREE.Matrix4, n = new THREE.Vector3, t = new THREE.Vector3, r = new THREE.Vector3, s = [], u = THREE.ShaderLib.depthRGBA, v = THREE.UniformsUtils.clone(u.uniforms);
            g = new THREE.ShaderMaterial({uniforms: v, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader});
            h = new THREE.ShaderMaterial({uniforms: v, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, morphTargets: !0});
            k = new THREE.ShaderMaterial({uniforms: v, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, skinning: !0});
            l = new THREE.ShaderMaterial({uniforms: v, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, morphTargets: !0, skinning: !0});
            g._shadowPass = !0;
            h._shadowPass = !0;
            k._shadowPass = !0;
            l._shadowPass = !0;
            this.render = function (c, v) {
                if (!1 !== a.shadowMapEnabled) {
                    var u, y, A, E, G, F, z, I, U = [];
                    E = 0;
                    f.clearColor(1, 1, 1, 1);
                    f.disable(f.BLEND);
                    f.enable(f.CULL_FACE);
                    f.frontFace(f.CCW);
                    a.shadowMapCullFace === THREE.CullFaceFront ? f.cullFace(f.FRONT) : f.cullFace(f.BACK);
                    a.state.setDepthTest(!0);
                    u = 0;
                    for (y = b.length; u < y; u++)if (A = b[u], A.castShadow)if (A instanceof THREE.DirectionalLight && A.shadowCascade)for (G = 0; G < A.shadowCascadeCount; G++) {
                        var M;
                        if (A.shadowCascadeArray[G])M = A.shadowCascadeArray[G]; else {
                            z = A;
                            var H = G;
                            M = new THREE.DirectionalLight;
                            M.isVirtual = !0;
                            M.onlyShadow = !0;
                            M.castShadow = !0;
                            M.shadowCameraNear = z.shadowCameraNear;
                            M.shadowCameraFar = z.shadowCameraFar;
                            M.shadowCameraLeft = z.shadowCameraLeft;
                            M.shadowCameraRight = z.shadowCameraRight;
                            M.shadowCameraBottom = z.shadowCameraBottom;
                            M.shadowCameraTop = z.shadowCameraTop;
                            M.shadowCameraVisible = z.shadowCameraVisible;
                            M.shadowDarkness = z.shadowDarkness;
                            M.shadowBias = z.shadowCascadeBias[H];
                            M.shadowMapWidth = z.shadowCascadeWidth[H];
                            M.shadowMapHeight = z.shadowCascadeHeight[H];
                            M.pointsWorld = [];
                            M.pointsFrustum = [];
                            I = M.pointsWorld;
                            F = M.pointsFrustum;
                            for (var L = 0; 8 > L; L++)I[L] = new THREE.Vector3, F[L] = new THREE.Vector3;
                            I = z.shadowCascadeNearZ[H];
                            z = z.shadowCascadeFarZ[H];
                            F[0].set(-1, -1, I);
                            F[1].set(1, -1, I);
                            F[2].set(-1, 1, I);
                            F[3].set(1, 1, I);
                            F[4].set(-1, -1, z);
                            F[5].set(1, -1, z);
                            F[6].set(-1, 1, z);
                            F[7].set(1, 1, z);
                            M.originalCamera = v;
                            F = new THREE.Gyroscope;
                            F.position.copy(A.shadowCascadeOffset);
                            F.add(M);
                            F.add(M.target);
                            v.add(F);
                            A.shadowCascadeArray[G] = M
                        }
                        H = A;
                        I = G;
                        z = H.shadowCascadeArray[I];
                        z.position.copy(H.position);
                        z.target.position.copy(H.target.position);
                        z.lookAt(z.target);
                        z.shadowCameraVisible = H.shadowCameraVisible;
                        z.shadowDarkness = H.shadowDarkness;
                        z.shadowBias = H.shadowCascadeBias[I];
                        F = H.shadowCascadeNearZ[I];
                        H = H.shadowCascadeFarZ[I];
                        z = z.pointsFrustum;
                        z[0].z = F;
                        z[1].z = F;
                        z[2].z = F;
                        z[3].z = F;
                        z[4].z = H;
                        z[5].z = H;
                        z[6].z = H;
                        z[7].z = H;
                        U[E] = M;
                        E++
                    } else U[E] = A, E++;
                    u = 0;
                    for (y = U.length; u < y; u++) {
                        A = U[u];
                        A.shadowMap || (G = THREE.LinearFilter, a.shadowMapType === THREE.PCFSoftShadowMap && (G = THREE.NearestFilter), A.shadowMap = new THREE.WebGLRenderTarget(A.shadowMapWidth,
                            A.shadowMapHeight, {
                                minFilter: G,
                                magFilter: G,
                                format: THREE.RGBAFormat
                            }), A.shadowMapSize = new THREE.Vector2(A.shadowMapWidth, A.shadowMapHeight), A.shadowMatrix = new THREE.Matrix4);
                        if (!A.shadowCamera) {
                            if (A instanceof THREE.SpotLight)A.shadowCamera = new THREE.PerspectiveCamera(A.shadowCameraFov, A.shadowMapWidth / A.shadowMapHeight, A.shadowCameraNear, A.shadowCameraFar); else if (A instanceof THREE.DirectionalLight)A.shadowCamera = new THREE.OrthographicCamera(A.shadowCameraLeft, A.shadowCameraRight, A.shadowCameraTop,
                                A.shadowCameraBottom, A.shadowCameraNear, A.shadowCameraFar); else {
                                THREE.error("THREE.ShadowMapPlugin: Unsupported light type for shadow", A);
                                continue
                            }
                            c.add(A.shadowCamera);
                            !0 === c.autoUpdate && c.updateMatrixWorld()
                        }
                        A.shadowCameraVisible && !A.cameraHelper && (A.cameraHelper = new THREE.CameraHelper(A.shadowCamera), c.add(A.cameraHelper));
                        if (A.isVirtual && M.originalCamera == v) {
                            G = v;
                            E = A.shadowCamera;
                            F = A.pointsFrustum;
                            z = A.pointsWorld;
                            n.set(Infinity, Infinity, Infinity);
                            t.set(-Infinity, -Infinity, -Infinity);
                            for (H = 0; 8 >
                            H; H++)I = z[H], I.copy(F[H]), I.unproject(G), I.applyMatrix4(E.matrixWorldInverse), I.x < n.x && (n.x = I.x), I.x > t.x && (t.x = I.x), I.y < n.y && (n.y = I.y), I.y > t.y && (t.y = I.y), I.z < n.z && (n.z = I.z), I.z > t.z && (t.z = I.z);
                            E.left = n.x;
                            E.right = t.x;
                            E.top = t.y;
                            E.bottom = n.y;
                            E.updateProjectionMatrix()
                        }
                        E = A.shadowMap;
                        F = A.shadowMatrix;
                        G = A.shadowCamera;
                        G.position.setFromMatrixPosition(A.matrixWorld);
                        r.setFromMatrixPosition(A.target.matrixWorld);
                        G.lookAt(r);
                        G.updateMatrixWorld();
                        G.matrixWorldInverse.getInverse(G.matrixWorld);
                        A.cameraHelper &&
                        (A.cameraHelper.visible = A.shadowCameraVisible);
                        A.shadowCameraVisible && A.cameraHelper.update();
                        F.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
                        F.multiply(G.projectionMatrix);
                        F.multiply(G.matrixWorldInverse);
                        q.multiplyMatrices(G.projectionMatrix, G.matrixWorldInverse);
                        p.setFromMatrix(q);
                        a.setRenderTarget(E);
                        a.clear();
                        s.length = 0;
                        e(c, c, G);
                        A = 0;
                        for (E = s.length; A < E; A++)z = s[A], F = z.object, z = z.buffer, H = F.material instanceof THREE.MeshFaceMaterial ? F.material.materials[0] : F.material, I = void 0 !== F.geometry.morphTargets &&
                            0 < F.geometry.morphTargets.length && H.morphTargets, L = F instanceof THREE.SkinnedMesh && H.skinning, I = F.customDepthMaterial ? F.customDepthMaterial : L ? I ? l : k : I ? h : g, a.setMaterialFaces(H), z instanceof THREE.BufferGeometry ? a.renderBufferDirect(G, b, null, I, z, F) : a.renderBuffer(G, b, null, I, z, F);
                        A = 0;
                        for (E = d.length; A < E; A++)z = d[A], F = z.object, F.visible && F.castShadow && (F._modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, F.matrixWorld), a.renderImmediateObject(G, b, null, g, F))
                    }
                    u = a.getClearColor();
                    y = a.getClearAlpha();
                    f.clearColor(u.r,
                        u.g, u.b, y);
                    f.enable(f.BLEND);
                    a.shadowMapCullFace === THREE.CullFaceFront && f.cullFace(f.BACK);
                    a.resetGLState()
                }
            }
        };
        THREE.SpritePlugin = function (a, b) {
            var c, d, e, f, g, h, k, l, p, q, n, t, r, s, u, v, x;

            function D(a, b) {
                return a.z !== b.z ? b.z - a.z : b.id - a.id
            }

            var w = a.context, y, A, E, G, F = new THREE.Vector3, z = new THREE.Quaternion, I = new THREE.Vector3;
            this.render = function (U, M) {
                if (0 !== b.length) {
                    if (void 0 === E) {
                        var H = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), L = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        y = w.createBuffer();
                        A = w.createBuffer();
                        w.bindBuffer(w.ARRAY_BUFFER, y);
                        w.bufferData(w.ARRAY_BUFFER, H, w.STATIC_DRAW);
                        w.bindBuffer(w.ELEMENT_ARRAY_BUFFER,
                            A);
                        w.bufferData(w.ELEMENT_ARRAY_BUFFER, L, w.STATIC_DRAW);
                        var H = w.createProgram(), L = w.createShader(w.VERTEX_SHADER), P = w.createShader(w.FRAGMENT_SHADER);
                        w.shaderSource(L, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
                        w.shaderSource(P, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
                        w.compileShader(L);
                        w.compileShader(P);
                        w.attachShader(H, L);
                        w.attachShader(H, P);
                        w.linkProgram(H);
                        E = H;
                        v = w.getAttribLocation(E, "position");
                        x = w.getAttribLocation(E, "uv");
                        c = w.getUniformLocation(E, "uvOffset");
                        d = w.getUniformLocation(E, "uvScale");
                        e = w.getUniformLocation(E, "rotation");
                        f = w.getUniformLocation(E, "scale");
                        g = w.getUniformLocation(E, "color");
                        h = w.getUniformLocation(E, "map");
                        k = w.getUniformLocation(E, "opacity");
                        l = w.getUniformLocation(E, "modelViewMatrix");
                        p = w.getUniformLocation(E, "projectionMatrix");
                        q =
                            w.getUniformLocation(E, "fogType");
                        n = w.getUniformLocation(E, "fogDensity");
                        t = w.getUniformLocation(E, "fogNear");
                        r = w.getUniformLocation(E, "fogFar");
                        s = w.getUniformLocation(E, "fogColor");
                        u = w.getUniformLocation(E, "alphaTest");
                        H = document.createElement("canvas");
                        H.width = 8;
                        H.height = 8;
                        L = H.getContext("2d");
                        L.fillStyle = "white";
                        L.fillRect(0, 0, 8, 8);
                        G = new THREE.Texture(H);
                        G.needsUpdate = !0
                    }
                    w.useProgram(E);
                    w.enableVertexAttribArray(v);
                    w.enableVertexAttribArray(x);
                    w.disable(w.CULL_FACE);
                    w.enable(w.BLEND);
                    w.bindBuffer(w.ARRAY_BUFFER,
                        y);
                    w.vertexAttribPointer(v, 2, w.FLOAT, !1, 16, 0);
                    w.vertexAttribPointer(x, 2, w.FLOAT, !1, 16, 8);
                    w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, A);
                    w.uniformMatrix4fv(p, !1, M.projectionMatrix.elements);
                    w.activeTexture(w.TEXTURE0);
                    w.uniform1i(h, 0);
                    L = H = 0;
                    (P = U.fog) ? (w.uniform3f(s, P.color.r, P.color.g, P.color.b), P instanceof THREE.Fog ? (w.uniform1f(t, P.near), w.uniform1f(r, P.far), w.uniform1i(q, 1), L = H = 1) : P instanceof THREE.FogExp2 && (w.uniform1f(n, P.density), w.uniform1i(q, 2), L = H = 2)) : (w.uniform1i(q, 0), L = H = 0);
                    for (var P = 0, N = b.length; P <
                    N; P++) {
                        var R = b[P];
                        R._modelViewMatrix.multiplyMatrices(M.matrixWorldInverse, R.matrixWorld);
                        R.z = -R._modelViewMatrix.elements[14]
                    }
                    b.sort(D);
                    for (var V = [], P = 0, N = b.length; P < N; P++) {
                        var R = b[P], J = R.material;
                        w.uniform1f(u, J.alphaTest);
                        w.uniformMatrix4fv(l, !1, R._modelViewMatrix.elements);
                        R.matrixWorld.decompose(F, z, I);
                        V[0] = I.x;
                        V[1] = I.y;
                        R = 0;
                        U.fog && J.fog && (R = L);
                        H !== R && (w.uniform1i(q, R), H = R);
                        null !== J.map ? (w.uniform2f(c, J.map.offset.x, J.map.offset.y), w.uniform2f(d, J.map.repeat.x, J.map.repeat.y)) : (w.uniform2f(c,
                            0, 0), w.uniform2f(d, 1, 1));
                        w.uniform1f(k, J.opacity);
                        w.uniform3f(g, J.color.r, J.color.g, J.color.b);
                        w.uniform1f(e, J.rotation);
                        w.uniform2fv(f, V);
                        a.state.setBlending(J.blending, J.blendEquation, J.blendSrc, J.blendDst);
                        a.state.setDepthTest(J.depthTest);
                        a.state.setDepthWrite(J.depthWrite);
                        J.map && J.map.image && J.map.image.width ? a.setTexture(J.map, 0) : a.setTexture(G, 0);
                        w.drawElements(w.TRIANGLES, 6, w.UNSIGNED_SHORT, 0)
                    }
                    w.enable(w.CULL_FACE);
                    a.resetGLState()
                }
            }
        };
        THREE.GeometryUtils = {
            merge: function (a, b, c) {
                THREE.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                var d;
                b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry);
                a.merge(b, d, c)
            }, center: function (a) {
                THREE.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
                return a.center()
            }
        };
        THREE.ImageUtils = {
            crossOrigin: void 0, loadTexture: function (a, b, c, d) {
                var e = new THREE.ImageLoader;
                e.crossOrigin = this.crossOrigin;
                var f = new THREE.Texture(void 0, b);
                e.load(a, function (a) {
                    f.image = a;
                    f.needsUpdate = !0;
                    c && c(f)
                }, void 0, function (a) {
                    d && d(a)
                });
                f.sourceFile = a;
                return f
            }, loadTextureCube: function (a, b, c, d) {
                var e = new THREE.ImageLoader;
                e.crossOrigin = this.crossOrigin;
                var f = new THREE.CubeTexture([], b);
                f.flipY = !1;
                var g = 0;
                b = function (b) {
                    e.load(a[b], function (a) {
                        f.images[b] = a;
                        g += 1;
                        6 === g && (f.needsUpdate = !0, c &&
                        c(f))
                    }, void 0, d)
                };
                for (var h = 0, k = a.length; h < k; ++h)b(h);
                return f
            }, loadCompressedTexture: function () {
                THREE.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, loadCompressedTextureCube: function () {
                THREE.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }, getNormalMap: function (a, b) {
                var c = function (a) {
                    var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
                    return [a[0] / b, a[1] / b, a[2] / b]
                };
                b |= 1;
                var d = a.width, e = a.height, f = document.createElement("canvas");
                f.width = d;
                f.height = e;
                var g = f.getContext("2d");
                g.drawImage(a, 0, 0);
                for (var h = g.getImageData(0, 0, d, e).data, k = g.createImageData(d, e), l = k.data, p = 0; p < d; p++)for (var q = 0; q < e; q++) {
                    var n = 0 > q - 1 ? 0 : q - 1, t = q + 1 > e - 1 ? e - 1 : q + 1, r = 0 > p - 1 ? 0 : p - 1, s = p + 1 > d - 1 ? d - 1 : p + 1, u = [], v = [0, 0, h[4 * (q * d + p)] / 255 * b];
                    u.push([-1, 0, h[4 * (q * d + r)] / 255 * b]);
                    u.push([-1, -1, h[4 * (n * d + r)] / 255 * b]);
                    u.push([0, -1, h[4 * (n * d + p)] / 255 * b]);
                    u.push([1, -1, h[4 * (n * d + s)] / 255 * b]);
                    u.push([1, 0, h[4 * (q * d + s)] / 255 * b]);
                    u.push([1, 1, h[4 * (t * d + s)] / 255 * b]);
                    u.push([0, 1, h[4 * (t * d + p)] / 255 *
                    b]);
                    u.push([-1, 1, h[4 * (t * d + r)] / 255 * b]);
                    n = [];
                    r = u.length;
                    for (t = 0; t < r; t++) {
                        var s = u[t], x = u[(t + 1) % r], s = [s[0] - v[0], s[1] - v[1], s[2] - v[2]], x = [x[0] - v[0], x[1] - v[1], x[2] - v[2]];
                        n.push(c([s[1] * x[2] - s[2] * x[1], s[2] * x[0] - s[0] * x[2], s[0] * x[1] - s[1] * x[0]]))
                    }
                    u = [0, 0, 0];
                    for (t = 0; t < n.length; t++)u[0] += n[t][0], u[1] += n[t][1], u[2] += n[t][2];
                    u[0] /= n.length;
                    u[1] /= n.length;
                    u[2] /= n.length;
                    v = 4 * (q * d + p);
                    l[v] = (u[0] + 1) / 2 * 255 | 0;
                    l[v + 1] = (u[1] + 1) / 2 * 255 | 0;
                    l[v + 2] = 255 * u[2] | 0;
                    l[v + 3] = 255
                }
                g.putImageData(k, 0, 0);
                return f
            }, generateDataTexture: function (a,
                                              b, c) {
                var d = a * b, e = new Uint8Array(3 * d), f = Math.floor(255 * c.r), g = Math.floor(255 * c.g);
                c = Math.floor(255 * c.b);
                for (var h = 0; h < d; h++)e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;
                a = new THREE.DataTexture(e, a, b, THREE.RGBFormat);
                a.needsUpdate = !0;
                return a
            }
        };
        THREE.SceneUtils = {
            createMultiMaterialObject: function (a, b) {
                for (var c = new THREE.Object3D, d = 0, e = b.length; d < e; d++)c.add(new THREE.Mesh(a, b[d]));
                return c
            }, detach: function (a, b, c) {
                a.applyMatrix(b.matrixWorld);
                b.remove(a);
                c.add(a)
            }, attach: function (a, b, c) {
                var d = new THREE.Matrix4;
                d.getInverse(c.matrixWorld);
                a.applyMatrix(d);
                b.remove(a);
                c.add(a)
            }
        };
        THREE.FontUtils = {
            faces: {}, face: "helvetiker", weight: "normal", style: "normal", size: 150, divisions: 10, getFace: function () {
                try {
                    return this.faces[this.face][this.weight][this.style]
                } catch (a) {
                    throw"The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing.";
                }
            }, loadFace: function (a) {
                var b = a.familyName.toLowerCase();
                this.faces[b] = this.faces[b] || {};
                this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
                this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
                return this.faces[b][a.cssFontWeight][a.cssFontStyle] =
                    a
            }, drawText: function (a) {
                var b = this.getFace(), c = this.size / b.resolution, d = 0, e = String(a).split(""), f = e.length, g = [];
                for (a = 0; a < f; a++) {
                    var h = new THREE.Path, h = this.extractGlyphPoints(e[a], b, c, d, h), d = d + h.offset;
                    g.push(h.path)
                }
                return {paths: g, offset: d / 2}
            }, extractGlyphPoints: function (a, b, c, d, e) {
                var f = [], g, h, k, l, p, q, n, t, r, s, u, v = b.glyphs[a] || b.glyphs["?"];
                if (v) {
                    if (v.o)for (b = v._cachedOutline || (v._cachedOutline = v.o.split(" ")), l = b.length, a = 0; a < l;)switch (k = b[a++], k) {
                        case "m":
                            k = b[a++] * c + d;
                            p = b[a++] * c;
                            e.moveTo(k, p);
                            break;
                        case "l":
                            k = b[a++] * c + d;
                            p = b[a++] * c;
                            e.lineTo(k, p);
                            break;
                        case "q":
                            k = b[a++] * c + d;
                            p = b[a++] * c;
                            t = b[a++] * c + d;
                            r = b[a++] * c;
                            e.quadraticCurveTo(t, r, k, p);
                            if (g = f[f.length - 1])for (q = g.x, n = g.y, g = 1, h = this.divisions; g <= h; g++) {
                                var x = g / h;
                                THREE.Shape.Utils.b2(x, q, t, k);
                                THREE.Shape.Utils.b2(x, n, r, p)
                            }
                            break;
                        case "b":
                            if (k = b[a++] * c + d, p = b[a++] * c, t = b[a++] * c + d, r = b[a++] * c, s = b[a++] * c + d, u = b[a++] * c, e.bezierCurveTo(t, r, s, u, k, p), g = f[f.length - 1])for (q = g.x, n = g.y, g = 1, h = this.divisions; g <= h; g++)x = g / h, THREE.Shape.Utils.b3(x, q, t, s, k), THREE.Shape.Utils.b3(x,
                                n, r, u, p)
                    }
                    return {offset: v.ha * c, path: e}
                }
            }
        };
        THREE.FontUtils.generateShapes = function (a, b) {
            b = b || {};
            var c = void 0 !== b.curveSegments ? b.curveSegments : 4, d = void 0 !== b.font ? b.font : "helvetiker", e = void 0 !== b.weight ? b.weight : "normal", f = void 0 !== b.style ? b.style : "normal";
            THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
            THREE.FontUtils.divisions = c;
            THREE.FontUtils.face = d;
            THREE.FontUtils.weight = e;
            THREE.FontUtils.style = f;
            c = THREE.FontUtils.drawText(a).paths;
            d = [];
            e = 0;
            for (f = c.length; e < f; e++)Array.prototype.push.apply(d, c[e].toShapes());
            return d
        };
        (function (a) {
            var b = function (a) {
                for (var b = a.length, e = 0, f = b - 1, g = 0; g < b; f = g++)e += a[f].x * a[g].y - a[g].x * a[f].y;
                return .5 * e
            };
            a.Triangulate = function (a, d) {
                var e = a.length;
                if (3 > e)return null;
                var f = [], g = [], h = [], k, l, p;
                if (0 < b(a))for (l = 0; l < e; l++)g[l] = l; else for (l = 0; l < e; l++)g[l] = e - 1 - l;
                var q = 2 * e;
                for (l = e - 1; 2 < e;) {
                    if (0 >= q--) {
                        THREE.warn("THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()");
                        break
                    }
                    k = l;
                    e <= k && (k = 0);
                    l = k + 1;
                    e <= l && (l = 0);
                    p = l + 1;
                    e <= p && (p = 0);
                    var n;
                    a:{
                        var t = n = void 0, r = void 0, s = void 0,
                            u = void 0, v = void 0, x = void 0, D = void 0, w = void 0, t = a[g[k]].x, r = a[g[k]].y, s = a[g[l]].x, u = a[g[l]].y, v = a[g[p]].x, x = a[g[p]].y;
                        if (1E-10 > (s - t) * (x - r) - (u - r) * (v - t))n = !1; else {
                            var y = void 0, A = void 0, E = void 0, G = void 0, F = void 0, z = void 0, I = void 0, U = void 0, M = void 0, H = void 0, M = U = I = w = D = void 0, y = v - s, A = x - u, E = t - v, G = r - x, F = s - t, z = u - r;
                            for (n = 0; n < e; n++)if (D = a[g[n]].x, w = a[g[n]].y, !(D === t && w === r || D === s && w === u || D === v && w === x) && (I = D - t, U = w - r, M = D - s, H = w - u, D -= v, w -= x, M = y * H - A * M, I = F * U - z * I, U = E * w - G * D, -1E-10 <= M && -1E-10 <= U && -1E-10 <= I)) {
                                n = !1;
                                break a
                            }
                            n = !0
                        }
                    }
                    if (n) {
                        f.push([a[g[k]], a[g[l]], a[g[p]]]);
                        h.push([g[k], g[l], g[p]]);
                        k = l;
                        for (p = l + 1; p < e; k++, p++)g[k] = g[p];
                        e--;
                        q = 2 * e
                    }
                }
                return d ? h : f
            };
            a.Triangulate.area = b;
            return a
        })(THREE.FontUtils);
        self._typeface_js = {faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace};
        THREE.typeface_js = self._typeface_js;
        THREE.Audio = function (a) {
            THREE.Object3D.call(this);
            this.type = "Audio";
            this.context = a.context;
            this.source = this.context.createBufferSource();
            this.source.onended = this.onEnded.bind(this);
            this.gain = this.context.createGain();
            this.gain.connect(this.context.destination);
            this.panner = this.context.createPanner();
            this.panner.connect(this.gain);
            this.autoplay = !1;
            this.startTime = 0;
            this.isPlaying = !1
        };
        THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Audio.prototype.constructor = THREE.Audio;
        THREE.Audio.prototype.load = function (a) {
            var b = this, c = new XMLHttpRequest;
            c.open("GET", a, !0);
            c.responseType = "arraybuffer";
            c.onload = function (a) {
                b.context.decodeAudioData(this.response, function (a) {
                    b.source.buffer = a;
                    b.autoplay && b.play()
                })
            };
            c.send();
            return this
        };
        THREE.Audio.prototype.play = function () {
            if (!0 === this.isPlaying)THREE.warn("THREE.Audio: Audio is already playing."); else {
                var a = this.context.createBufferSource();
                a.buffer = this.source.buffer;
                a.loop = this.source.loop;
                a.onended = this.source.onended;
                a.connect(this.panner);
                a.start(0, this.startTime);
                this.isPlaying = !0;
                this.source = a
            }
        };
        THREE.Audio.prototype.pause = function () {
            this.source.stop();
            this.startTime = this.context.currentTime
        };
        THREE.Audio.prototype.stop = function () {
            this.source.stop();
            this.startTime = 0
        };
        THREE.Audio.prototype.onEnded = function () {
            this.isPlaying = !1
        };
        THREE.Audio.prototype.setLoop = function (a) {
            this.source.loop = a
        };
        THREE.Audio.prototype.setRefDistance = function (a) {
            this.panner.refDistance = a
        };
        THREE.Audio.prototype.setRolloffFactor = function (a) {
            this.panner.rolloffFactor = a
        };
        THREE.Audio.prototype.setVolume = function (a) {
            this.gain.gain.value = a
        };
        THREE.Audio.prototype.updateMatrixWorld = function () {
            var a = new THREE.Vector3;
            return function (b) {
                THREE.Object3D.prototype.updateMatrixWorld.call(this, b);
                a.setFromMatrixPosition(this.matrixWorld);
                this.panner.setPosition(a.x, a.y, a.z)
            }
        }();
        THREE.AudioListener = function () {
            THREE.Object3D.call(this);
            this.type = "AudioListener";
            this.context = new (window.AudioContext || window.webkitAudioContext)
        };
        THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
        THREE.AudioListener.prototype.constructor = THREE.AudioListener;
        THREE.AudioListener.prototype.updateMatrixWorld = function () {
            var a = new THREE.Vector3, b = new THREE.Quaternion, c = new THREE.Vector3, d = new THREE.Vector3, e = new THREE.Vector3, f = new THREE.Vector3;
            return function (g) {
                THREE.Object3D.prototype.updateMatrixWorld.call(this, g);
                g = this.context.listener;
                var h = this.up;
                this.matrixWorld.decompose(a, b, c);
                d.set(0, 0, -1).applyQuaternion(b);
                e.subVectors(a, f);
                g.setPosition(a.x, a.y, a.z);
                g.setOrientation(d.x, d.y, d.z, h.x, h.y, h.z);
                g.setVelocity(e.x, e.y, e.z);
                f.copy(a)
            }
        }();
        THREE.Curve = function () {
        };
        THREE.Curve.prototype.getPoint = function (a) {
            THREE.warn("THREE.Curve: Warning, getPoint() not implemented!");
            return null
        };
        THREE.Curve.prototype.getPointAt = function (a) {
            a = this.getUtoTmapping(a);
            return this.getPoint(a)
        };
        THREE.Curve.prototype.getPoints = function (a) {
            a || (a = 5);
            var b, c = [];
            for (b = 0; b <= a; b++)c.push(this.getPoint(b / a));
            return c
        };
        THREE.Curve.prototype.getSpacedPoints = function (a) {
            a || (a = 5);
            var b, c = [];
            for (b = 0; b <= a; b++)c.push(this.getPointAt(b / a));
            return c
        };
        THREE.Curve.prototype.getLength = function () {
            var a = this.getLengths();
            return a[a.length - 1]
        };
        THREE.Curve.prototype.getLengths = function (a) {
            a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
            if (this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate)return this.cacheArcLengths;
            this.needsUpdate = !1;
            var b = [], c, d = this.getPoint(0), e, f = 0;
            b.push(0);
            for (e = 1; e <= a; e++)c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;
            return this.cacheArcLengths = b
        };
        THREE.Curve.prototype.updateArcLengths = function () {
            this.needsUpdate = !0;
            this.getLengths()
        };
        THREE.Curve.prototype.getUtoTmapping = function (a, b) {
            var c = this.getLengths(), d = 0, e = c.length, f;
            f = b ? b : a * c[e - 1];
            for (var g = 0, h = e - 1, k; g <= h;)if (d = Math.floor(g + (h - g) / 2), k = c[d] - f, 0 > k)g = d + 1; else if (0 < k)h = d - 1; else {
                h = d;
                break
            }
            d = h;
            if (c[d] == f)return d / (e - 1);
            g = c[d];
            return c = (d + (f - g) / (c[d + 1] - g)) / (e - 1)
        };
        THREE.Curve.prototype.getTangent = function (a) {
            var b = a - 1E-4;
            a += 1E-4;
            0 > b && (b = 0);
            1 < a && (a = 1);
            b = this.getPoint(b);
            return this.getPoint(a).clone().sub(b).normalize()
        };
        THREE.Curve.prototype.getTangentAt = function (a) {
            a = this.getUtoTmapping(a);
            return this.getTangent(a)
        };
        THREE.Curve.Utils = {
            tangentQuadraticBezier: function (a, b, c, d) {
                return 2 * (1 - a) * (c - b) + 2 * a * (d - c)
            }, tangentCubicBezier: function (a, b, c, d, e) {
                return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e
            }, tangentSpline: function (a, b, c, d, e) {
                return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a)
            }, interpolate: function (a, b, c, d, e) {
                a = .5 * (c - a);
                d = .5 * (d - b);
                var f = e * e;
                return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b
            }
        };
        THREE.Curve.create = function (a, b) {
            a.prototype = Object.create(THREE.Curve.prototype);
            a.prototype.constructor = a;
            a.prototype.getPoint = b;
            return a
        };
        THREE.CurvePath = function () {
            this.curves = [];
            this.bends = [];
            this.autoClose = !1
        };
        THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
        THREE.CurvePath.prototype.constructor = THREE.CurvePath;
        THREE.CurvePath.prototype.add = function (a) {
            this.curves.push(a)
        };
        THREE.CurvePath.prototype.checkConnection = function () {
        };
        THREE.CurvePath.prototype.closePath = function () {
            var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
            a.equals(b) || this.curves.push(new THREE.LineCurve(b, a))
        };
        THREE.CurvePath.prototype.getPoint = function (a) {
            var b = a * this.getLength(), c = this.getCurveLengths();
            for (a = 0; a < c.length;) {
                if (c[a] >= b)return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);
                a++
            }
            return null
        };
        THREE.CurvePath.prototype.getLength = function () {
            var a = this.getCurveLengths();
            return a[a.length - 1]
        };
        THREE.CurvePath.prototype.getCurveLengths = function () {
            if (this.cacheLengths && this.cacheLengths.length == this.curves.length)return this.cacheLengths;
            var a = [], b = 0, c, d = this.curves.length;
            for (c = 0; c < d; c++)b += this.curves[c].getLength(), a.push(b);
            return this.cacheLengths = a
        };
        THREE.CurvePath.prototype.getBoundingBox = function () {
            var a = this.getPoints(), b, c, d, e, f, g;
            b = c = Number.NEGATIVE_INFINITY;
            e = f = Number.POSITIVE_INFINITY;
            var h, k, l, p, q = a[0]instanceof THREE.Vector3;
            p = q ? new THREE.Vector3 : new THREE.Vector2;
            k = 0;
            for (l = a.length; k < l; k++)h = a[k], h.x > b ? b = h.x : h.x < e && (e = h.x), h.y > c ? c = h.y : h.y < f && (f = h.y), q && (h.z > d ? d = h.z : h.z < g && (g = h.z)), p.add(h);
            a = {minX: e, minY: f, maxX: b, maxY: c};
            q && (a.maxZ = d, a.minZ = g);
            return a
        };
        THREE.CurvePath.prototype.createPointsGeometry = function (a) {
            a = this.getPoints(a, !0);
            return this.createGeometry(a)
        };
        THREE.CurvePath.prototype.createSpacedPointsGeometry = function (a) {
            a = this.getSpacedPoints(a, !0);
            return this.createGeometry(a)
        };
        THREE.CurvePath.prototype.createGeometry = function (a) {
            for (var b = new THREE.Geometry, c = 0; c < a.length; c++)b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));
            return b
        };
        THREE.CurvePath.prototype.addWrapPath = function (a) {
            this.bends.push(a)
        };
        THREE.CurvePath.prototype.getTransformedPoints = function (a, b) {
            var c = this.getPoints(a), d, e;
            b || (b = this.bends);
            d = 0;
            for (e = b.length; d < e; d++)c = this.getWrapPoints(c, b[d]);
            return c
        };
        THREE.CurvePath.prototype.getTransformedSpacedPoints = function (a, b) {
            var c = this.getSpacedPoints(a), d, e;
            b || (b = this.bends);
            d = 0;
            for (e = b.length; d < e; d++)c = this.getWrapPoints(c, b[d]);
            return c
        };
        THREE.CurvePath.prototype.getWrapPoints = function (a, b) {
            var c = this.getBoundingBox(), d, e, f, g, h, k;
            d = 0;
            for (e = a.length; d < e; d++)f = a[d], g = f.x, h = f.y, k = g / c.maxX, k = b.getUtoTmapping(k, g), g = b.getPoint(k), k = b.getTangent(k), k.set(-k.y, k.x).multiplyScalar(h), f.x = g.x + k.x, f.y = g.y + k.y;
            return a
        };
        THREE.Gyroscope = function () {
            THREE.Object3D.call(this)
        };
        THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
        THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;
        THREE.Gyroscope.prototype.updateMatrixWorld = function () {
            var a = new THREE.Vector3, b = new THREE.Quaternion, c = new THREE.Vector3, d = new THREE.Vector3, e = new THREE.Quaternion, f = new THREE.Vector3;
            return function (g) {
                this.matrixAutoUpdate && this.updateMatrix();
                if (this.matrixWorldNeedsUpdate || g)this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(d, e, f), this.matrix.decompose(a, b, c), this.matrixWorld.compose(d, b, f)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, g = !0;
                for (var h = 0, k = this.children.length; h < k; h++)this.children[h].updateMatrixWorld(g)
            }
        }();
        THREE.Path = function (a) {
            THREE.CurvePath.call(this);
            this.actions = [];
            a && this.fromPoints(a)
        };
        THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
        THREE.Path.prototype.constructor = THREE.Path;
        THREE.PathActions = {
            MOVE_TO: "moveTo",
            LINE_TO: "lineTo",
            QUADRATIC_CURVE_TO: "quadraticCurveTo",
            BEZIER_CURVE_TO: "bezierCurveTo",
            CSPLINE_THRU: "splineThru",
            ARC: "arc",
            ELLIPSE: "ellipse"
        };
        THREE.Path.prototype.fromPoints = function (a) {
            this.moveTo(a[0].x, a[0].y);
            for (var b = 1, c = a.length; b < c; b++)this.lineTo(a[b].x, a[b].y)
        };
        THREE.Path.prototype.moveTo = function (a, b) {
            var c = Array.prototype.slice.call(arguments);
            this.actions.push({action: THREE.PathActions.MOVE_TO, args: c})
        };
        THREE.Path.prototype.lineTo = function (a, b) {
            var c = Array.prototype.slice.call(arguments), d = this.actions[this.actions.length - 1].args, d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));
            this.curves.push(d);
            this.actions.push({action: THREE.PathActions.LINE_TO, args: c})
        };
        THREE.Path.prototype.quadraticCurveTo = function (a, b, c, d) {
            var e = Array.prototype.slice.call(arguments), f = this.actions[this.actions.length - 1].args, f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
            this.curves.push(f);
            this.actions.push({action: THREE.PathActions.QUADRATIC_CURVE_TO, args: e})
        };
        THREE.Path.prototype.bezierCurveTo = function (a, b, c, d, e, f) {
            var g = Array.prototype.slice.call(arguments), h = this.actions[this.actions.length - 1].args, h = new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
            this.curves.push(h);
            this.actions.push({action: THREE.PathActions.BEZIER_CURVE_TO, args: g})
        };
        THREE.Path.prototype.splineThru = function (a) {
            var b = Array.prototype.slice.call(arguments), c = this.actions[this.actions.length - 1].args, c = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])];
            Array.prototype.push.apply(c, a);
            c = new THREE.SplineCurve(c);
            this.curves.push(c);
            this.actions.push({action: THREE.PathActions.CSPLINE_THRU, args: b})
        };
        THREE.Path.prototype.arc = function (a, b, c, d, e, f) {
            var g = this.actions[this.actions.length - 1].args;
            this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f)
        };
        THREE.Path.prototype.absarc = function (a, b, c, d, e, f) {
            this.absellipse(a, b, c, c, d, e, f)
        };
        THREE.Path.prototype.ellipse = function (a, b, c, d, e, f, g) {
            var h = this.actions[this.actions.length - 1].args;
            this.absellipse(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f, g)
        };
        THREE.Path.prototype.absellipse = function (a, b, c, d, e, f, g) {
            var h = Array.prototype.slice.call(arguments), k = new THREE.EllipseCurve(a, b, c, d, e, f, g);
            this.curves.push(k);
            k = k.getPoint(1);
            h.push(k.x);
            h.push(k.y);
            this.actions.push({action: THREE.PathActions.ELLIPSE, args: h})
        };
        THREE.Path.prototype.getSpacedPoints = function (a, b) {
            a || (a = 40);
            for (var c = [], d = 0; d < a; d++)c.push(this.getPoint(d / a));
            return c
        };
        THREE.Path.prototype.getPoints = function (a, b) {
            if (this.useSpacedPoints)return console.log("tata"), this.getSpacedPoints(a, b);
            a = a || 12;
            var c = [], d, e, f, g, h, k, l, p, q, n, t, r, s;
            d = 0;
            for (e = this.actions.length; d < e; d++)switch (f = this.actions[d], g = f.action, f = f.args, g) {
                case THREE.PathActions.MOVE_TO:
                    c.push(new THREE.Vector2(f[0], f[1]));
                    break;
                case THREE.PathActions.LINE_TO:
                    c.push(new THREE.Vector2(f[0], f[1]));
                    break;
                case THREE.PathActions.QUADRATIC_CURVE_TO:
                    h = f[2];
                    k = f[3];
                    q = f[0];
                    n = f[1];
                    0 < c.length ? (g = c[c.length - 1], t = g.x,
                        r = g.y) : (g = this.actions[d - 1].args, t = g[g.length - 2], r = g[g.length - 1]);
                    for (f = 1; f <= a; f++)s = f / a, g = THREE.Shape.Utils.b2(s, t, q, h), s = THREE.Shape.Utils.b2(s, r, n, k), c.push(new THREE.Vector2(g, s));
                    break;
                case THREE.PathActions.BEZIER_CURVE_TO:
                    h = f[4];
                    k = f[5];
                    q = f[0];
                    n = f[1];
                    l = f[2];
                    p = f[3];
                    0 < c.length ? (g = c[c.length - 1], t = g.x, r = g.y) : (g = this.actions[d - 1].args, t = g[g.length - 2], r = g[g.length - 1]);
                    for (f = 1; f <= a; f++)s = f / a, g = THREE.Shape.Utils.b3(s, t, q, l, h), s = THREE.Shape.Utils.b3(s, r, n, p, k), c.push(new THREE.Vector2(g, s));
                    break;
                case THREE.PathActions.CSPLINE_THRU:
                    g =
                        this.actions[d - 1].args;
                    s = [new THREE.Vector2(g[g.length - 2], g[g.length - 1])];
                    g = a * f[0].length;
                    s = s.concat(f[0]);
                    s = new THREE.SplineCurve(s);
                    for (f = 1; f <= g; f++)c.push(s.getPointAt(f / g));
                    break;
                case THREE.PathActions.ARC:
                    h = f[0];
                    k = f[1];
                    n = f[2];
                    l = f[3];
                    g = f[4];
                    q = !!f[5];
                    t = g - l;
                    r = 2 * a;
                    for (f = 1; f <= r; f++)s = f / r, q || (s = 1 - s), s = l + s * t, g = h + n * Math.cos(s), s = k + n * Math.sin(s), c.push(new THREE.Vector2(g, s));
                    break;
                case THREE.PathActions.ELLIPSE:
                    for (h = f[0], k = f[1], n = f[2], p = f[3], l = f[4], g = f[5], q = !!f[6], t = g - l, r = 2 * a, f = 1; f <= r; f++)s = f / r, q ||
                    (s = 1 - s), s = l + s * t, g = h + n * Math.cos(s), s = k + p * Math.sin(s), c.push(new THREE.Vector2(g, s))
            }
            d = c[c.length - 1];
            1E-10 > Math.abs(d.x - c[0].x) && 1E-10 > Math.abs(d.y - c[0].y) && c.splice(c.length - 1, 1);
            b && c.push(c[0]);
            return c
        };
        THREE.Path.prototype.toShapes = function (a, b) {
            function c(a) {
                for (var b = [], c = 0, d = a.length; c < d; c++) {
                    var e = a[c], f = new THREE.Shape;
                    f.actions = e.actions;
                    f.curves = e.curves;
                    b.push(f)
                }
                return b
            }

            function d(a, b) {
                for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
                    var g = b[e], h = b[f], k = h.x - g.x, n = h.y - g.y;
                    if (1E-10 < Math.abs(n)) {
                        if (0 > n && (g = b[f], k = -k, h = b[e], n = -n), !(a.y < g.y || a.y > h.y))if (a.y == g.y) {
                            if (a.x == g.x)return !0
                        } else {
                            e = n * (a.x - g.x) - k * (a.y - g.y);
                            if (0 == e)return !0;
                            0 > e || (d = !d)
                        }
                    } else if (a.y == g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <=
                        h.x))return !0
                }
                return d
            }

            var e = function (a) {
                var b, c, d, e, f = [], g = new THREE.Path;
                b = 0;
                for (c = a.length; b < c; b++)d = a[b], e = d.args, d = d.action, d == THREE.PathActions.MOVE_TO && 0 != g.actions.length && (f.push(g), g = new THREE.Path), g[d].apply(g, e);
                0 != g.actions.length && f.push(g);
                return f
            }(this.actions);
            if (0 == e.length)return [];
            if (!0 === b)return c(e);
            var f, g, h, k = [];
            if (1 == e.length)return g = e[0], h = new THREE.Shape, h.actions = g.actions, h.curves = g.curves, k.push(h), k;
            var l = !THREE.Shape.Utils.isClockWise(e[0].getPoints()), l = a ? !l : l;
            h = [];
            var p = [], q = [], n = 0, t;
            p[n] = void 0;
            q[n] = [];
            var r, s;
            r = 0;
            for (s = e.length; r < s; r++)g = e[r], t = g.getPoints(), f = THREE.Shape.Utils.isClockWise(t), (f = a ? !f : f) ? (!l && p[n] && n++, p[n] = {
                s: new THREE.Shape,
                p: t
            }, p[n].s.actions = g.actions, p[n].s.curves = g.curves, l && n++, q[n] = []) : q[n].push({h: g, p: t[0]});
            if (!p[0])return c(e);
            if (1 < p.length) {
                r = !1;
                s = [];
                g = 0;
                for (e = p.length; g < e; g++)h[g] = [];
                g = 0;
                for (e = p.length; g < e; g++)for (f = q[g], l = 0; l < f.length; l++) {
                    n = f[l];
                    t = !0;
                    for (var u = 0; u < p.length; u++)d(n.p, p[u].p) && (g != u && s.push({
                        froms: g, tos: u,
                        hole: l
                    }), t ? (t = !1, h[u].push(n)) : r = !0);
                    t && h[g].push(n)
                }
                0 < s.length && (r || (q = h))
            }
            r = 0;
            for (s = p.length; r < s; r++)for (h = p[r].s, k.push(h), g = q[r], e = 0, f = g.length; e < f; e++)h.holes.push(g[e].h);
            return k
        };
        THREE.Shape = function () {
            THREE.Path.apply(this, arguments);
            this.holes = []
        };
        THREE.Shape.prototype = Object.create(THREE.Path.prototype);
        THREE.Shape.prototype.constructor = THREE.Shape;
        THREE.Shape.prototype.extrude = function (a) {
            return new THREE.ExtrudeGeometry(this, a)
        };
        THREE.Shape.prototype.makeGeometry = function (a) {
            return new THREE.ShapeGeometry(this, a)
        };
        THREE.Shape.prototype.getPointsHoles = function (a) {
            var b, c = this.holes.length, d = [];
            for (b = 0; b < c; b++)d[b] = this.holes[b].getTransformedPoints(a, this.bends);
            return d
        };
        THREE.Shape.prototype.getSpacedPointsHoles = function (a) {
            var b, c = this.holes.length, d = [];
            for (b = 0; b < c; b++)d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
            return d
        };
        THREE.Shape.prototype.extractAllPoints = function (a) {
            return {shape: this.getTransformedPoints(a), holes: this.getPointsHoles(a)}
        };
        THREE.Shape.prototype.extractPoints = function (a) {
            return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a)
        };
        THREE.Shape.prototype.extractAllSpacedPoints = function (a) {
            return {shape: this.getTransformedSpacedPoints(a), holes: this.getSpacedPointsHoles(a)}
        };
        THREE.Shape.Utils = {
            triangulateShape: function (a, b) {
                function c(a, b, c) {
                    return a.x != b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
                }

                function d(a, b, d, e, f) {
                    var g = b.x - a.x, h = b.y - a.y, k = e.x - d.x, l = e.y - d.y, p = a.x - d.x, q = a.y - d.y, E = h * k - g * l, G = h * p - g * q;
                    if (1E-10 < Math.abs(E)) {
                        if (0 < E) {
                            if (0 > G || G > E)return [];
                            k = l * p - k * q;
                            if (0 > k || k > E)return []
                        } else {
                            if (0 < G || G < E)return [];
                            k = l * p - k * q;
                            if (0 < k || k < E)return []
                        }
                        if (0 == k)return !f || 0 != G && G != E ? [a] : [];
                        if (k == E)return !f || 0 != G && G != E ? [b] : [];
                        if (0 == G)return [d];
                        if (G == E)return [e];
                        f = k / E;
                        return [{x: a.x + f * g, y: a.y + f * h}]
                    }
                    if (0 != G || l * p != k * q)return [];
                    h = 0 == g && 0 == h;
                    k = 0 == k && 0 == l;
                    if (h && k)return a.x != d.x || a.y != d.y ? [] : [a];
                    if (h)return c(d, e, a) ? [a] : [];
                    if (k)return c(a, b, d) ? [d] : [];
                    0 != g ? (a.x < b.x ? (g = a, k = a.x, h = b, a = b.x) : (g = b, k = b.x, h = a, a = a.x), d.x < e.x ? (b = d, E = d.x, l = e, d = e.x) : (b = e, E = e.x, l = d, d = d.x)) : (a.y < b.y ? (g = a, k = a.y, h = b, a = b.y) : (g = b, k = b.y, h = a, a = a.y), d.y < e.y ? (b = d, E = d.y, l = e, d = e.y) : (b = e, E = e.y, l = d, d = d.y));
                    return k <= E ? a < E ? [] : a == E ? f ? [] : [b] : a <= d ? [b, h] : [b, l] : k > d ? [] : k == d ? f ? [] : [g] : a <= d ? [g, h] :
                        [g, l]
                }

                function e(a, b, c, d) {
                    var e = b.x - a.x, f = b.y - a.y;
                    b = c.x - a.x;
                    c = c.y - a.y;
                    var g = d.x - a.x;
                    d = d.y - a.y;
                    a = e * c - f * b;
                    e = e * d - f * g;
                    return 1E-10 < Math.abs(a) ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e
                }

                var f, g, h, k, l, p = {};
                h = a.concat();
                f = 0;
                for (g = b.length; f < g; f++)Array.prototype.push.apply(h, b[f]);
                f = 0;
                for (g = h.length; f < g; f++)l = h[f].x + ":" + h[f].y, void 0 !== p[l] && THREE.warn("THREE.Shape: Duplicate point", l), p[l] = f;
                f = function (a, b) {
                    function c(a, b) {
                        var d = h.length - 1, f = a - 1;
                        0 > f && (f = d);
                        var g = a + 1;
                        g > d && (g = 0);
                        d = e(h[a], h[f], h[g], k[b]);
                        if (!d)return !1;
                        d = k.length - 1;
                        f = b - 1;
                        0 > f && (f = d);
                        g = b + 1;
                        g > d && (g = 0);
                        return (d = e(k[b], k[f], k[g], h[a])) ? !0 : !1
                    }

                    function f(a, b) {
                        var c, e;
                        for (c = 0; c < h.length; c++)if (e = c + 1, e %= h.length, e = d(a, b, h[c], h[e], !0), 0 < e.length)return !0;
                        return !1
                    }

                    function g(a, c) {
                        var e, f, h, k;
                        for (e = 0; e < l.length; e++)for (f = b[l[e]], h = 0; h < f.length; h++)if (k = h + 1, k %= f.length, k = d(a, c, f[h], f[k], !0), 0 < k.length)return !0;
                        return !1
                    }

                    var h = a.concat(), k, l = [], p, q, A, E, G, F = [], z, I, U, M = 0;
                    for (p = b.length; M < p; M++)l.push(M);
                    z = 0;
                    for (var H = 2 * l.length; 0 < l.length;) {
                        H--;
                        if (0 >
                            H) {
                            console.log("Infinite Loop! Holes left:" + l.length + ", Probably Hole outside Shape!");
                            break
                        }
                        for (q = z; q < h.length; q++) {
                            A = h[q];
                            p = -1;
                            for (M = 0; M < l.length; M++)if (E = l[M], G = A.x + ":" + A.y + ":" + E, void 0 === F[G]) {
                                k = b[E];
                                for (I = 0; I < k.length; I++)if (E = k[I], c(q, I) && !f(A, E) && !g(A, E)) {
                                    p = I;
                                    l.splice(M, 1);
                                    z = h.slice(0, q + 1);
                                    E = h.slice(q);
                                    I = k.slice(p);
                                    U = k.slice(0, p + 1);
                                    h = z.concat(I).concat(U).concat(E);
                                    z = q;
                                    break
                                }
                                if (0 <= p)break;
                                F[G] = !0
                            }
                            if (0 <= p)break
                        }
                    }
                    return h
                }(a, b);
                var q = THREE.FontUtils.Triangulate(f, !1);
                f = 0;
                for (g = q.length; f < g; f++)for (k =
                                                       q[f], h = 0; 3 > h; h++)l = k[h].x + ":" + k[h].y, l = p[l], void 0 !== l && (k[h] = l);
                return q.concat()
            }, isClockWise: function (a) {
                return 0 > THREE.FontUtils.Triangulate.area(a)
            }, b2p0: function (a, b) {
                var c = 1 - a;
                return c * c * b
            }, b2p1: function (a, b) {
                return 2 * (1 - a) * a * b
            }, b2p2: function (a, b) {
                return a * a * b
            }, b2: function (a, b, c, d) {
                return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d)
            }, b3p0: function (a, b) {
                var c = 1 - a;
                return c * c * c * b
            }, b3p1: function (a, b) {
                var c = 1 - a;
                return 3 * c * c * a * b
            }, b3p2: function (a, b) {
                return 3 * (1 - a) * a * a * b
            }, b3p3: function (a, b) {
                return a *
                    a * a * b
            }, b3: function (a, b, c, d, e) {
                return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e)
            }
        };
        THREE.LineCurve = function (a, b) {
            this.v1 = a;
            this.v2 = b
        };
        THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
        THREE.LineCurve.prototype.constructor = THREE.LineCurve;
        THREE.LineCurve.prototype.getPoint = function (a) {
            var b = this.v2.clone().sub(this.v1);
            b.multiplyScalar(a).add(this.v1);
            return b
        };
        THREE.LineCurve.prototype.getPointAt = function (a) {
            return this.getPoint(a)
        };
        THREE.LineCurve.prototype.getTangent = function (a) {
            return this.v2.clone().sub(this.v1).normalize()
        };
        THREE.QuadraticBezierCurve = function (a, b, c) {
            this.v0 = a;
            this.v1 = b;
            this.v2 = c
        };
        THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
        THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
        THREE.QuadraticBezierCurve.prototype.getPoint = function (a) {
            var b = new THREE.Vector2;
            b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
            b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
            return b
        };
        THREE.QuadraticBezierCurve.prototype.getTangent = function (a) {
            var b = new THREE.Vector2;
            b.x = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x);
            b.y = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y);
            return b.normalize()
        };
        THREE.CubicBezierCurve = function (a, b, c, d) {
            this.v0 = a;
            this.v1 = b;
            this.v2 = c;
            this.v3 = d
        };
        THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
        THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
        THREE.CubicBezierCurve.prototype.getPoint = function (a) {
            var b;
            b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
            a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
            return new THREE.Vector2(b, a)
        };
        THREE.CubicBezierCurve.prototype.getTangent = function (a) {
            var b;
            b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
            a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
            b = new THREE.Vector2(b, a);
            b.normalize();
            return b
        };
        THREE.SplineCurve = function (a) {
            this.points = void 0 == a ? [] : a
        };
        THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
        THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
        THREE.SplineCurve.prototype.getPoint = function (a) {
            var b = this.points;
            a *= b.length - 1;
            var c = Math.floor(a);
            a -= c;
            var d = b[0 == c ? c : c - 1], e = b[c], f = b[c > b.length - 2 ? b.length - 1 : c + 1], b = b[c > b.length - 3 ? b.length - 1 : c + 2], c = new THREE.Vector2;
            c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a);
            c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a);
            return c
        };
        THREE.EllipseCurve = function (a, b, c, d, e, f, g) {
            this.aX = a;
            this.aY = b;
            this.xRadius = c;
            this.yRadius = d;
            this.aStartAngle = e;
            this.aEndAngle = f;
            this.aClockwise = g
        };
        THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
        THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
        THREE.EllipseCurve.prototype.getPoint = function (a) {
            var b = this.aEndAngle - this.aStartAngle;
            0 > b && (b += 2 * Math.PI);
            b > 2 * Math.PI && (b -= 2 * Math.PI);
            a = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;
            b = new THREE.Vector2;
            b.x = this.aX + this.xRadius * Math.cos(a);
            b.y = this.aY + this.yRadius * Math.sin(a);
            return b
        };
        THREE.ArcCurve = function (a, b, c, d, e, f) {
            THREE.EllipseCurve.call(this, a, b, c, c, d, e, f)
        };
        THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
        THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
        THREE.LineCurve3 = THREE.Curve.create(function (a, b) {
            this.v1 = a;
            this.v2 = b
        }, function (a) {
            var b = new THREE.Vector3;
            b.subVectors(this.v2, this.v1);
            b.multiplyScalar(a);
            b.add(this.v1);
            return b
        });
        THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (a, b, c) {
            this.v0 = a;
            this.v1 = b;
            this.v2 = c
        }, function (a) {
            var b = new THREE.Vector3;
            b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
            b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
            b.z = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z);
            return b
        });
        THREE.CubicBezierCurve3 = THREE.Curve.create(function (a, b, c, d) {
            this.v0 = a;
            this.v1 = b;
            this.v2 = c;
            this.v3 = d
        }, function (a) {
            var b = new THREE.Vector3;
            b.x = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
            b.y = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
            b.z = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
            return b
        });
        THREE.SplineCurve3 = THREE.Curve.create(function (a) {
            this.points = void 0 == a ? [] : a
        }, function (a) {
            var b = this.points;
            a *= b.length - 1;
            var c = Math.floor(a);
            a -= c;
            var d = b[0 == c ? c : c - 1], e = b[c], f = b[c > b.length - 2 ? b.length - 1 : c + 1], b = b[c > b.length - 3 ? b.length - 1 : c + 2], c = new THREE.Vector3;
            c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a);
            c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a);
            c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a);
            return c
        });
        THREE.ClosedSplineCurve3 = THREE.Curve.create(function (a) {
            this.points = void 0 == a ? [] : a
        }, function (a) {
            var b = this.points;
            a *= b.length - 0;
            var c = Math.floor(a);
            a -= c;
            var c = c + (0 < c ? 0 : (Math.floor(Math.abs(c) / b.length) + 1) * b.length), d = b[(c - 1) % b.length], e = b[c % b.length], f = b[(c + 1) % b.length], b = b[(c + 2) % b.length], c = new THREE.Vector3;
            c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a);
            c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a);
            c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a);
            return c
        });
        THREE.AnimationHandler = {
            LINEAR: 0, CATMULLROM: 1, CATMULLROM_FORWARD: 2, add: function () {
                THREE.warn("THREE.AnimationHandler.add() has been deprecated.")
            }, get: function () {
                THREE.warn("THREE.AnimationHandler.get() has been deprecated.")
            }, remove: function () {
                THREE.warn("THREE.AnimationHandler.remove() has been deprecated.")
            }, animations: [], init: function (a) {
                if (!0 === a.initialized)return a;
                for (var b = 0; b < a.hierarchy.length; b++) {
                    for (var c = 0; c < a.hierarchy[b].keys.length; c++)if (0 > a.hierarchy[b].keys[c].time && (a.hierarchy[b].keys[c].time =
                            0), void 0 !== a.hierarchy[b].keys[c].rot && !(a.hierarchy[b].keys[c].rot instanceof THREE.Quaternion)) {
                        var d = a.hierarchy[b].keys[c].rot;
                        a.hierarchy[b].keys[c].rot = (new THREE.Quaternion).fromArray(d)
                    }
                    if (a.hierarchy[b].keys.length && void 0 !== a.hierarchy[b].keys[0].morphTargets) {
                        d = {};
                        for (c = 0; c < a.hierarchy[b].keys.length; c++)for (var e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++) {
                            var f = a.hierarchy[b].keys[c].morphTargets[e];
                            d[f] = -1
                        }
                        a.hierarchy[b].usedMorphTargets = d;
                        for (c = 0; c < a.hierarchy[b].keys.length; c++) {
                            var g =
                            {};
                            for (f in d) {
                                for (e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++)if (a.hierarchy[b].keys[c].morphTargets[e] === f) {
                                    g[f] = a.hierarchy[b].keys[c].morphTargetsInfluences[e];
                                    break
                                }
                                e === a.hierarchy[b].keys[c].morphTargets.length && (g[f] = 0)
                            }
                            a.hierarchy[b].keys[c].morphTargetsInfluences = g
                        }
                    }
                    for (c = 1; c < a.hierarchy[b].keys.length; c++)a.hierarchy[b].keys[c].time === a.hierarchy[b].keys[c - 1].time && (a.hierarchy[b].keys.splice(c, 1), c--);
                    for (c = 0; c < a.hierarchy[b].keys.length; c++)a.hierarchy[b].keys[c].index = c
                }
                a.initialized = !0;
                return a
            }, parse: function (a) {
                var b = function (a, c) {
                    c.push(a);
                    for (var d = 0; d < a.children.length; d++)b(a.children[d], c)
                }, c = [];
                if (a instanceof THREE.SkinnedMesh)for (var d = 0; d < a.skeleton.bones.length; d++)c.push(a.skeleton.bones[d]); else b(a, c);
                return c
            }, play: function (a) {
                -1 === this.animations.indexOf(a) && this.animations.push(a)
            }, stop: function (a) {
                a = this.animations.indexOf(a);
                -1 !== a && this.animations.splice(a, 1)
            }, update: function (a) {
                for (var b = 0; b < this.animations.length; b++)this.animations[b].resetBlendWeights();
                for (b = 0; b < this.animations.length; b++)this.animations[b].update(a)
            }
        };
        THREE.Animation = function (a, b) {
            this.root = a;
            this.data = THREE.AnimationHandler.init(b);
            this.hierarchy = THREE.AnimationHandler.parse(a);
            this.currentTime = 0;
            this.timeScale = 1;
            this.isPlaying = !1;
            this.loop = !0;
            this.weight = 0;
            this.interpolationType = THREE.AnimationHandler.LINEAR
        };
        THREE.Animation.prototype = {
            constructor: THREE.Animation, keyTypes: ["pos", "rot", "scl"], play: function (a, b) {
                this.currentTime = void 0 !== a ? a : 0;
                this.weight = void 0 !== b ? b : 1;
                this.isPlaying = !0;
                this.reset();
                THREE.AnimationHandler.play(this)
            }, stop: function () {
                this.isPlaying = !1;
                THREE.AnimationHandler.stop(this)
            }, reset: function () {
                for (var a = 0, b = this.hierarchy.length; a < b; a++) {
                    var c = this.hierarchy[a];
                    void 0 === c.animationCache && (c.animationCache = {animations: {}, blending: {positionWeight: 0, quaternionWeight: 0, scaleWeight: 0}});
                    var d = this.data.name, e = c.animationCache.animations, f = e[d];
                    void 0 === f && (f = {prevKey: {pos: 0, rot: 0, scl: 0}, nextKey: {pos: 0, rot: 0, scl: 0}, originalMatrix: c.matrix}, e[d] = f);
                    for (c = 0; 3 > c; c++) {
                        for (var d = this.keyTypes[c], e = this.data.hierarchy[a].keys[0], g = this.getNextKeyWith(d, a, 1); g.time < this.currentTime && g.index > e.index;)e = g, g = this.getNextKeyWith(d, a, g.index + 1);
                        f.prevKey[d] = e;
                        f.nextKey[d] = g
                    }
                }
            }, resetBlendWeights: function () {
                for (var a = 0, b = this.hierarchy.length; a < b; a++) {
                    var c = this.hierarchy[a].animationCache;
                    void 0 !==
                    c && (c = c.blending, c.positionWeight = 0, c.quaternionWeight = 0, c.scaleWeight = 0)
                }
            }, update: function () {
                var a = [], b = new THREE.Vector3, c = new THREE.Vector3, d = new THREE.Quaternion, e = function (a, b) {
                    var c = [], d = [], e, q, n, t, r, s;
                    e = (a.length - 1) * b;
                    q = Math.floor(e);
                    e -= q;
                    c[0] = 0 === q ? q : q - 1;
                    c[1] = q;
                    c[2] = q > a.length - 2 ? q : q + 1;
                    c[3] = q > a.length - 3 ? q : q + 2;
                    q = a[c[0]];
                    t = a[c[1]];
                    r = a[c[2]];
                    s = a[c[3]];
                    c = e * e;
                    n = e * c;
                    d[0] = f(q[0], t[0], r[0], s[0], e, c, n);
                    d[1] = f(q[1], t[1], r[1], s[1], e, c, n);
                    d[2] = f(q[2], t[2], r[2], s[2], e, c, n);
                    return d
                }, f = function (a, b, c, d,
                                 e, f, n) {
                    a = .5 * (c - a);
                    d = .5 * (d - b);
                    return (2 * (b - c) + a + d) * n + (-3 * (b - c) - 2 * a - d) * f + a * e + b
                };
                return function (f) {
                    if (!1 !== this.isPlaying && (this.currentTime += f * this.timeScale, 0 !== this.weight)) {
                        f = this.data.length;
                        if (this.currentTime > f || 0 > this.currentTime)this.loop ? (this.currentTime %= f, 0 > this.currentTime && (this.currentTime += f), this.reset()) : this.stop();
                        f = 0;
                        for (var h = this.hierarchy.length; f < h; f++)for (var k = this.hierarchy[f], l = k.animationCache.animations[this.data.name], p = k.animationCache.blending, q = 0; 3 > q; q++) {
                            var n = this.keyTypes[q],
                                t = l.prevKey[n], r = l.nextKey[n];
                            if (0 < this.timeScale && r.time <= this.currentTime || 0 > this.timeScale && t.time >= this.currentTime) {
                                t = this.data.hierarchy[f].keys[0];
                                for (r = this.getNextKeyWith(n, f, 1); r.time < this.currentTime && r.index > t.index;)t = r, r = this.getNextKeyWith(n, f, r.index + 1);
                                l.prevKey[n] = t;
                                l.nextKey[n] = r
                            }
                            var s = (this.currentTime - t.time) / (r.time - t.time), u = t[n], v = r[n];
                            0 > s && (s = 0);
                            1 < s && (s = 1);
                            if ("pos" === n)if (this.interpolationType === THREE.AnimationHandler.LINEAR)c.x = u[0] + (v[0] - u[0]) * s, c.y = u[1] + (v[1] - u[1]) * s,
                                c.z = u[2] + (v[2] - u[2]) * s, t = this.weight / (this.weight + p.positionWeight), k.position.lerp(c, t), p.positionWeight += this.weight; else {
                                if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD)a[0] = this.getPrevKeyWith("pos", f, t.index - 1).pos, a[1] = u, a[2] = v, a[3] = this.getNextKeyWith("pos", f, r.index + 1).pos, s = .33 * s + .33, r = e(a, s), t = this.weight / (this.weight + p.positionWeight), p.positionWeight += this.weight, n = k.position, n.x += (r[0] - n.x) * t, n.y += (r[1] -
                                    n.y) * t, n.z += (r[2] - n.z) * t, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (s = e(a, 1.01 * s), b.set(s[0], s[1], s[2]), b.sub(n), b.y = 0, b.normalize(), s = Math.atan2(b.x, b.z), k.rotation.set(0, s, 0))
                            } else"rot" === n ? (THREE.Quaternion.slerp(u, v, d, s), 0 === p.quaternionWeight ? (k.quaternion.copy(d), p.quaternionWeight = this.weight) : (t = this.weight / (this.weight + p.quaternionWeight), THREE.Quaternion.slerp(k.quaternion, d, k.quaternion, t), p.quaternionWeight += this.weight)) : "scl" === n && (c.x = u[0] + (v[0] - u[0]) * s, c.y =
                                u[1] + (v[1] - u[1]) * s, c.z = u[2] + (v[2] - u[2]) * s, t = this.weight / (this.weight + p.scaleWeight), k.scale.lerp(c, t), p.scaleWeight += this.weight)
                        }
                        return !0
                    }
                }
            }(), getNextKeyWith: function (a, b, c) {
                var d = this.data.hierarchy[b].keys;
                for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++)if (void 0 !== d[c][a])return d[c];
                return this.data.hierarchy[b].keys[0]
            }, getPrevKeyWith: function (a, b, c) {
                var d =
                    this.data.hierarchy[b].keys;
                for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length; 0 <= c; c--)if (void 0 !== d[c][a])return d[c];
                return this.data.hierarchy[b].keys[d.length - 1]
            }
        };
        THREE.KeyFrameAnimation = function (a) {
            this.root = a.node;
            this.data = THREE.AnimationHandler.init(a);
            this.hierarchy = THREE.AnimationHandler.parse(this.root);
            this.currentTime = 0;
            this.timeScale = .001;
            this.isPlaying = !1;
            this.loop = this.isPaused = !0;
            a = 0;
            for (var b = this.hierarchy.length; a < b; a++) {
                var c = this.data.hierarchy[a].sids, d = this.hierarchy[a];
                if (this.data.hierarchy[a].keys.length && c) {
                    for (var e = 0; e < c.length; e++) {
                        var f = c[e], g = this.getNextKeyWith(f, a, 0);
                        g && g.apply(f)
                    }
                    d.matrixAutoUpdate = !1;
                    this.data.hierarchy[a].node.updateMatrix();
                    d.matrixWorldNeedsUpdate = !0
                }
            }
        };
        THREE.KeyFrameAnimation.prototype = {
            constructor: THREE.KeyFrameAnimation, play: function (a) {
                this.currentTime = void 0 !== a ? a : 0;
                if (!1 === this.isPlaying) {
                    this.isPlaying = !0;
                    var b = this.hierarchy.length, c, d;
                    for (a = 0; a < b; a++)c = this.hierarchy[a], d = this.data.hierarchy[a], void 0 === d.animationCache && (d.animationCache = {}, d.animationCache.prevKey = null, d.animationCache.nextKey = null, d.animationCache.originalMatrix = c.matrix), c = this.data.hierarchy[a].keys, c.length && (d.animationCache.prevKey = c[0], d.animationCache.nextKey =
                        c[1], this.startTime = Math.min(c[0].time, this.startTime), this.endTime = Math.max(c[c.length - 1].time, this.endTime));
                    this.update(0)
                }
                this.isPaused = !1;
                THREE.AnimationHandler.play(this)
            }, stop: function () {
                this.isPaused = this.isPlaying = !1;
                THREE.AnimationHandler.stop(this);
                for (var a = 0; a < this.data.hierarchy.length; a++) {
                    var b = this.hierarchy[a], c = this.data.hierarchy[a];
                    if (void 0 !== c.animationCache) {
                        var d = c.animationCache.originalMatrix;
                        d.copy(b.matrix);
                        b.matrix = d;
                        delete c.animationCache
                    }
                }
            }, update: function (a) {
                if (!1 !==
                    this.isPlaying) {
                    this.currentTime += a * this.timeScale;
                    a = this.data.length;
                    !0 === this.loop && this.currentTime > a && (this.currentTime %= a);
                    this.currentTime = Math.min(this.currentTime, a);
                    a = 0;
                    for (var b = this.hierarchy.length; a < b; a++) {
                        var c = this.hierarchy[a], d = this.data.hierarchy[a], e = d.keys, d = d.animationCache;
                        if (e.length) {
                            var f = d.prevKey, g = d.nextKey;
                            if (g.time <= this.currentTime) {
                                for (; g.time < this.currentTime && g.index > f.index;)f = g, g = e[f.index + 1];
                                d.prevKey = f;
                                d.nextKey = g
                            }
                            g.time >= this.currentTime ? f.interpolate(g, this.currentTime) :
                                f.interpolate(g, g.time);
                            this.data.hierarchy[a].node.updateMatrix();
                            c.matrixWorldNeedsUpdate = !0
                        }
                    }
                }
            }, getNextKeyWith: function (a, b, c) {
                b = this.data.hierarchy[b].keys;
                for (c %= b.length; c < b.length; c++)if (b[c].hasTarget(a))return b[c];
                return b[0]
            }, getPrevKeyWith: function (a, b, c) {
                b = this.data.hierarchy[b].keys;
                for (c = 0 <= c ? c : c + b.length; 0 <= c; c--)if (b[c].hasTarget(a))return b[c];
                return b[b.length - 1]
            }
        };
        THREE.MorphAnimation = function (a) {
            this.mesh = a;
            this.frames = a.morphTargetInfluences.length;
            this.currentTime = 0;
            this.duration = 1E3;
            this.loop = !0;
            this.currentFrame = this.lastFrame = 0;
            this.isPlaying = !1
        };
        THREE.MorphAnimation.prototype = {
            constructor: THREE.MorphAnimation, play: function () {
                this.isPlaying = !0
            }, pause: function () {
                this.isPlaying = !1
            }, update: function (a) {
                if (!1 !== this.isPlaying) {
                    this.currentTime += a;
                    !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration);
                    this.currentTime = Math.min(this.currentTime, this.duration);
                    a = this.duration / this.frames;
                    var b = Math.floor(this.currentTime / a), c = this.mesh.morphTargetInfluences;
                    b != this.currentFrame && (c[this.lastFrame] = 0, c[this.currentFrame] =
                        1, c[b] = 0, this.lastFrame = this.currentFrame, this.currentFrame = b);
                    c[b] = this.currentTime % a / a;
                    c[this.lastFrame] = 1 - c[b]
                }
            }
        };
        THREE.BoxGeometry = function (a, b, c, d, e, f) {
            function g(a, b, c, d, e, f, g, s) {
                var u, v = h.widthSegments, x = h.heightSegments, D = e / 2, w = f / 2, y = h.vertices.length;
                if ("x" === a && "y" === b || "y" === a && "x" === b)u = "z"; else if ("x" === a && "z" === b || "z" === a && "x" === b)u = "y", x = h.depthSegments; else if ("z" === a && "y" === b || "y" === a && "z" === b)u = "x", v = h.depthSegments;
                var A = v + 1, E = x + 1, G = e / v, F = f / x, z = new THREE.Vector3;
                z[u] = 0 < g ? 1 : -1;
                for (e = 0; e < E; e++)for (f = 0; f < A; f++) {
                    var I = new THREE.Vector3;
                    I[a] = (f * G - D) * c;
                    I[b] = (e * F - w) * d;
                    I[u] = g;
                    h.vertices.push(I)
                }
                for (e =
                         0; e < x; e++)for (f = 0; f < v; f++)w = f + A * e, a = f + A * (e + 1), b = f + 1 + A * (e + 1), c = f + 1 + A * e, d = new THREE.Vector2(f / v, 1 - e / x), g = new THREE.Vector2(f / v, 1 - (e + 1) / x), u = new THREE.Vector2((f + 1) / v, 1 - (e + 1) / x), D = new THREE.Vector2((f + 1) / v, 1 - e / x), w = new THREE.Face3(w + y, a + y, c + y), w.normal.copy(z), w.vertexNormals.push(z.clone(), z.clone(), z.clone()), w.materialIndex = s, h.faces.push(w), h.faceVertexUvs[0].push([d, g, D]), w = new THREE.Face3(a + y, b + y, c + y), w.normal.copy(z), w.vertexNormals.push(z.clone(), z.clone(), z.clone()), w.materialIndex = s, h.faces.push(w),
                    h.faceVertexUvs[0].push([g.clone(), u, D.clone()])
            }

            THREE.Geometry.call(this);
            this.type = "BoxGeometry";
            this.parameters = {width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f};
            this.widthSegments = d || 1;
            this.heightSegments = e || 1;
            this.depthSegments = f || 1;
            var h = this;
            d = a / 2;
            e = b / 2;
            f = c / 2;
            g("z", "y", -1, -1, c, b, d, 0);
            g("z", "y", 1, -1, c, b, -d, 1);
            g("x", "z", 1, 1, a, c, e, 2);
            g("x", "z", 1, -1, a, c, -e, 3);
            g("x", "y", 1, -1, a, b, f, 4);
            g("x", "y", -1, -1, a, b, -f, 5);
            this.mergeVertices()
        };
        THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
        THREE.CircleGeometry = function (a, b, c, d) {
            THREE.Geometry.call(this);
            this.type = "CircleGeometry";
            this.parameters = {radius: a, segments: b, thetaStart: c, thetaLength: d};
            a = a || 50;
            b = void 0 !== b ? Math.max(3, b) : 8;
            c = void 0 !== c ? c : 0;
            d = void 0 !== d ? d : 2 * Math.PI;
            var e, f = [];
            e = new THREE.Vector3;
            var g = new THREE.Vector2(.5, .5);
            this.vertices.push(e);
            f.push(g);
            for (e = 0; e <= b; e++) {
                var h = new THREE.Vector3, k = c + e / b * d;
                h.x = a * Math.cos(k);
                h.y = a * Math.sin(k);
                this.vertices.push(h);
                f.push(new THREE.Vector2((h.x / a + 1) / 2, (h.y / a + 1) / 2))
            }
            c = new THREE.Vector3(0,
                0, 1);
            for (e = 1; e <= b; e++)this.faces.push(new THREE.Face3(e, e + 1, 0, [c.clone(), c.clone(), c.clone()])), this.faceVertexUvs[0].push([f[e].clone(), f[e + 1].clone(), g.clone()]);
            this.computeFaceNormals();
            this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
        };
        THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
        THREE.CubeGeometry = function (a, b, c, d, e, f) {
            THREE.warn("THREE.CubeGeometry has been renamed to THREE.BoxGeometry.");
            return new THREE.BoxGeometry(a, b, c, d, e, f)
        };
        THREE.CylinderGeometry = function (a, b, c, d, e, f, g, h) {
            THREE.Geometry.call(this);
            this.type = "CylinderGeometry";
            this.parameters = {radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h};
            a = void 0 !== a ? a : 20;
            b = void 0 !== b ? b : 20;
            c = void 0 !== c ? c : 100;
            d = d || 8;
            e = e || 1;
            f = void 0 !== f ? f : !1;
            g = void 0 !== g ? g : 0;
            h = void 0 !== h ? h : 2 * Math.PI;
            var k = c / 2, l, p, q = [], n = [];
            for (p = 0; p <= e; p++) {
                var t = [], r = [], s = p / e, u = s * (b - a) + a;
                for (l = 0; l <= d; l++) {
                    var v = l / d, x = new THREE.Vector3;
                    x.x = u * Math.sin(v * h +
                            g);
                    x.y = -s * c + k;
                    x.z = u * Math.cos(v * h + g);
                    this.vertices.push(x);
                    t.push(this.vertices.length - 1);
                    r.push(new THREE.Vector2(v, 1 - s))
                }
                q.push(t);
                n.push(r)
            }
            c = (b - a) / c;
            for (l = 0; l < d; l++)for (0 !== a ? (g = this.vertices[q[0][l]].clone(), h = this.vertices[q[0][l + 1]].clone()) : (g = this.vertices[q[1][l]].clone(), h = this.vertices[q[1][l + 1]].clone()), g.setY(Math.sqrt(g.x * g.x + g.z * g.z) * c).normalize(), h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * c).normalize(), p = 0; p < e; p++) {
                var t = q[p][l], r = q[p + 1][l], s = q[p + 1][l + 1], u = q[p][l + 1], v = g.clone(), x = g.clone(),
                    D = h.clone(), w = h.clone(), y = n[p][l].clone(), A = n[p + 1][l].clone(), E = n[p + 1][l + 1].clone(), G = n[p][l + 1].clone();
                this.faces.push(new THREE.Face3(t, r, u, [v, x, w]));
                this.faceVertexUvs[0].push([y, A, G]);
                this.faces.push(new THREE.Face3(r, s, u, [x.clone(), D, w.clone()]));
                this.faceVertexUvs[0].push([A.clone(), E, G.clone()])
            }
            if (!1 === f && 0 < a)for (this.vertices.push(new THREE.Vector3(0, k, 0)), l = 0; l < d; l++)t = q[0][l], r = q[0][l + 1], s = this.vertices.length - 1, v = new THREE.Vector3(0, 1, 0), x = new THREE.Vector3(0, 1, 0), D = new THREE.Vector3(0,
                1, 0), y = n[0][l].clone(), A = n[0][l + 1].clone(), E = new THREE.Vector2(A.x, 0), this.faces.push(new THREE.Face3(t, r, s, [v, x, D])), this.faceVertexUvs[0].push([y, A, E]);
            if (!1 === f && 0 < b)for (this.vertices.push(new THREE.Vector3(0, -k, 0)), l = 0; l < d; l++)t = q[e][l + 1], r = q[e][l], s = this.vertices.length - 1, v = new THREE.Vector3(0, -1, 0), x = new THREE.Vector3(0, -1, 0), D = new THREE.Vector3(0, -1, 0), y = n[e][l + 1].clone(), A = n[e][l].clone(), E = new THREE.Vector2(A.x, 1), this.faces.push(new THREE.Face3(t, r, s, [v, x, D])), this.faceVertexUvs[0].push([y,
                A, E]);
            this.computeFaceNormals()
        };
        THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
        THREE.ExtrudeGeometry = function (a, b) {
            "undefined" !== typeof a && (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", a = a instanceof Array ? a : [a], this.addShapeList(a, b), this.computeFaceNormals())
        };
        THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
        THREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {
            for (var c = a.length, d = 0; d < c; d++)this.addShape(a[d], b)
        };
        THREE.ExtrudeGeometry.prototype.addShape = function (a, b) {
            function c(a, b, c) {
                b || THREE.error("THREE.ExtrudeGeometry: vec does not exist");
                return b.clone().multiplyScalar(c).add(a)
            }

            function d(a, b, c) {
                var d = 1, d = a.x - b.x, e = a.y - b.y, f = c.x - a.x, g = c.y - a.y, h = d * d + e * e;
                if (1E-10 < Math.abs(d * g - e * f)) {
                    var k = Math.sqrt(h), l = Math.sqrt(f * f + g * g), h = b.x - e / k;
                    b = b.y + d / k;
                    f = ((c.x - g / l - h) * g - (c.y + f / l - b) * f) / (d * g - e * f);
                    c = h + d * f - a.x;
                    a = b + e * f - a.y;
                    d = c * c + a * a;
                    if (2 >= d)return new THREE.Vector2(c, a);
                    d = Math.sqrt(d / 2)
                } else a = !1, 1E-10 < d ? 1E-10 < f && (a = !0) :
                    -1E-10 > d ? -1E-10 > f && (a = !0) : Math.sign(e) == Math.sign(g) && (a = !0), a ? (c = -e, a = d, d = Math.sqrt(h)) : (c = d, a = e, d = Math.sqrt(h / 2));
                return new THREE.Vector2(c / d, a / d)
            }

            function e(a, b) {
                var c, d;
                for (O = a.length; 0 <= --O;) {
                    c = O;
                    d = O - 1;
                    0 > d && (d = a.length - 1);
                    for (var e = 0, f = t + 2 * p, e = 0; e < f; e++) {
                        var g = oa * e, h = oa * (e + 1), k = b + c + g, g = b + d + g, l = b + d + h, h = b + c + h, k = k + U, g = g + U, l = l + U, h = h + U;
                        I.faces.push(new THREE.Face3(k, g, h, null, null, x));
                        I.faces.push(new THREE.Face3(g, l, h, null, null, x));
                        k = D.generateSideWallUV(I, k, g, l, h);
                        I.faceVertexUvs[0].push([k[0],
                            k[1], k[3]]);
                        I.faceVertexUvs[0].push([k[1], k[2], k[3]])
                    }
                }
            }

            function f(a, b, c) {
                I.vertices.push(new THREE.Vector3(a, b, c))
            }

            function g(a, b, c) {
                a += U;
                b += U;
                c += U;
                I.faces.push(new THREE.Face3(a, b, c, null, null, v));
                a = D.generateTopUV(I, a, b, c);
                I.faceVertexUvs[0].push(a)
            }

            var h = void 0 !== b.amount ? b.amount : 100, k = void 0 !== b.bevelThickness ? b.bevelThickness : 6, l = void 0 !== b.bevelSize ? b.bevelSize : k - 2, p = void 0 !== b.bevelSegments ? b.bevelSegments : 3, q = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, n = void 0 !== b.curveSegments ? b.curveSegments :
                12, t = void 0 !== b.steps ? b.steps : 1, r = b.extrudePath, s, u = !1, v = b.material, x = b.extrudeMaterial, D = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator, w, y, A, E;
            r && (s = r.getSpacedPoints(t), u = !0, q = !1, w = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(r, t, !1), y = new THREE.Vector3, A = new THREE.Vector3, E = new THREE.Vector3);
            q || (l = k = p = 0);
            var G, F, z, I = this, U = this.vertices.length, r = a.extractPoints(n), n = r.shape, M = r.holes;
            if (r = !THREE.Shape.Utils.isClockWise(n)) {
                n = n.reverse();
                F = 0;
                for (z =
                         M.length; F < z; F++)G = M[F], THREE.Shape.Utils.isClockWise(G) && (M[F] = G.reverse());
                r = !1
            }
            var H = THREE.Shape.Utils.triangulateShape(n, M), L = n;
            F = 0;
            for (z = M.length; F < z; F++)G = M[F], n = n.concat(G);
            var P, N, R, V, J, oa = n.length, ja, ha = H.length, r = [], O = 0;
            R = L.length;
            P = R - 1;
            for (N = O + 1; O < R; O++, P++, N++)P === R && (P = 0), N === R && (N = 0), r[O] = d(L[O], L[P], L[N]);
            var ca = [], ba, qa = r.concat();
            F = 0;
            for (z = M.length; F < z; F++) {
                G = M[F];
                ba = [];
                O = 0;
                R = G.length;
                P = R - 1;
                for (N = O + 1; O < R; O++, P++, N++)P === R && (P = 0), N === R && (N = 0), ba[O] = d(G[O], G[P], G[N]);
                ca.push(ba);
                qa =
                    qa.concat(ba)
            }
            for (P = 0; P < p; P++) {
                R = P / p;
                V = k * (1 - R);
                N = l * Math.sin(R * Math.PI / 2);
                O = 0;
                for (R = L.length; O < R; O++)J = c(L[O], r[O], N), f(J.x, J.y, -V);
                F = 0;
                for (z = M.length; F < z; F++)for (G = M[F], ba = ca[F], O = 0, R = G.length; O < R; O++)J = c(G[O], ba[O], N), f(J.x, J.y, -V)
            }
            N = l;
            for (O = 0; O < oa; O++)J = q ? c(n[O], qa[O], N) : n[O], u ? (A.copy(w.normals[0]).multiplyScalar(J.x), y.copy(w.binormals[0]).multiplyScalar(J.y), E.copy(s[0]).add(A).add(y), f(E.x, E.y, E.z)) : f(J.x, J.y, 0);
            for (R = 1; R <= t; R++)for (O = 0; O < oa; O++)J = q ? c(n[O], qa[O], N) : n[O], u ? (A.copy(w.normals[R]).multiplyScalar(J.x),
                y.copy(w.binormals[R]).multiplyScalar(J.y), E.copy(s[R]).add(A).add(y), f(E.x, E.y, E.z)) : f(J.x, J.y, h / t * R);
            for (P = p - 1; 0 <= P; P--) {
                R = P / p;
                V = k * (1 - R);
                N = l * Math.sin(R * Math.PI / 2);
                O = 0;
                for (R = L.length; O < R; O++)J = c(L[O], r[O], N), f(J.x, J.y, h + V);
                F = 0;
                for (z = M.length; F < z; F++)for (G = M[F], ba = ca[F], O = 0, R = G.length; O < R; O++)J = c(G[O], ba[O], N), u ? f(J.x, J.y + s[t - 1].y, s[t - 1].x + V) : f(J.x, J.y, h + V)
            }
            (function () {
                if (q) {
                    var a;
                    a = 0 * oa;
                    for (O = 0; O < ha; O++)ja = H[O], g(ja[2] + a, ja[1] + a, ja[0] + a);
                    a = t + 2 * p;
                    a *= oa;
                    for (O = 0; O < ha; O++)ja = H[O], g(ja[0] + a, ja[1] + a, ja[2] +
                        a)
                } else {
                    for (O = 0; O < ha; O++)ja = H[O], g(ja[2], ja[1], ja[0]);
                    for (O = 0; O < ha; O++)ja = H[O], g(ja[0] + oa * t, ja[1] + oa * t, ja[2] + oa * t)
                }
            })();
            (function () {
                var a = 0;
                e(L, a);
                a += L.length;
                F = 0;
                for (z = M.length; F < z; F++)G = M[F], e(G, a), a += G.length
            })()
        };
        THREE.ExtrudeGeometry.WorldUVGenerator = {
            generateTopUV: function (a, b, c, d) {
                a = a.vertices;
                b = a[b];
                c = a[c];
                d = a[d];
                return [new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y), new THREE.Vector2(d.x, d.y)]
            }, generateSideWallUV: function (a, b, c, d, e) {
                a = a.vertices;
                b = a[b];
                c = a[c];
                d = a[d];
                e = a[e];
                return .01 > Math.abs(b.y - c.y) ? [new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z), new THREE.Vector2(e.x, 1 - e.z)] : [new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y,
                    1 - d.z), new THREE.Vector2(e.y, 1 - e.z)]
            }
        };
        THREE.ShapeGeometry = function (a, b) {
            THREE.Geometry.call(this);
            this.type = "ShapeGeometry";
            !1 === a instanceof Array && (a = [a]);
            this.addShapeList(a, b);
            this.computeFaceNormals()
        };
        THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
        THREE.ShapeGeometry.prototype.addShapeList = function (a, b) {
            for (var c = 0, d = a.length; c < d; c++)this.addShape(a[c], b);
            return this
        };
        THREE.ShapeGeometry.prototype.addShape = function (a, b) {
            void 0 === b && (b = {});
            var c = b.material, d = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, e, f, g, h = this.vertices.length;
            e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
            var k = e.shape, l = e.holes;
            if (!THREE.Shape.Utils.isClockWise(k))for (k = k.reverse(), e = 0, f = l.length; e < f; e++)g = l[e], THREE.Shape.Utils.isClockWise(g) && (l[e] = g.reverse());
            var p = THREE.Shape.Utils.triangulateShape(k, l);
            e = 0;
            for (f = l.length; e < f; e++)g = l[e],
                k = k.concat(g);
            l = k.length;
            f = p.length;
            for (e = 0; e < l; e++)g = k[e], this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
            for (e = 0; e < f; e++)l = p[e], k = l[0] + h, g = l[1] + h, l = l[2] + h, this.faces.push(new THREE.Face3(k, g, l, null, null, c)), this.faceVertexUvs[0].push(d.generateTopUV(this, k, g, l))
        };
        THREE.LatheGeometry = function (a, b, c, d) {
            THREE.Geometry.call(this);
            this.type = "LatheGeometry";
            this.parameters = {points: a, segments: b, phiStart: c, phiLength: d};
            b = b || 12;
            c = c || 0;
            d = d || 2 * Math.PI;
            for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; g <= h; g++)for (var k = c + g * f * d, l = Math.cos(k), p = Math.sin(k), k = 0, q = a.length; k < q; k++) {
                var n = a[k], t = new THREE.Vector3;
                t.x = l * n.x - p * n.y;
                t.y = p * n.x + l * n.y;
                t.z = n.z;
                this.vertices.push(t)
            }
            c = a.length;
            g = 0;
            for (h = b; g < h; g++)for (k = 0, q = a.length - 1; k < q; k++) {
                b = p = k + c * g;
                d = p + c;
                var l = p + 1 + c, p = p + 1, n = g * f, t = k * e, r =
                    n + f, s = t + e;
                this.faces.push(new THREE.Face3(b, d, p));
                this.faceVertexUvs[0].push([new THREE.Vector2(n, t), new THREE.Vector2(r, t), new THREE.Vector2(n, s)]);
                this.faces.push(new THREE.Face3(d, l, p));
                this.faceVertexUvs[0].push([new THREE.Vector2(r, t), new THREE.Vector2(r, s), new THREE.Vector2(n, s)])
            }
            this.mergeVertices();
            this.computeFaceNormals();
            this.computeVertexNormals()
        };
        THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
        THREE.PlaneGeometry = function (a, b, c, d) {
            console.info("THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.");
            THREE.Geometry.call(this);
            this.type = "PlaneGeometry";
            this.parameters = {width: a, height: b, widthSegments: c, heightSegments: d};
            this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, c, d))
        };
        THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
        THREE.PlaneBufferGeometry = function (a, b, c, d) {
            THREE.BufferGeometry.call(this);
            this.type = "PlaneBufferGeometry";
            this.parameters = {width: a, height: b, widthSegments: c, heightSegments: d};
            var e = a / 2, f = b / 2;
            c = c || 1;
            d = d || 1;
            var g = c + 1, h = d + 1, k = a / c, l = b / d;
            b = new Float32Array(g * h * 3);
            a = new Float32Array(g * h * 3);
            for (var p = new Float32Array(g * h * 2), q = 0, n = 0, t = 0; t < h; t++)for (var r = t * l - f, s = 0; s < g; s++)b[q] = s * k - e, b[q + 1] = -r, a[q + 2] = 1, p[n] = s / c, p[n + 1] = 1 - t / d, q += 3, n += 2;
            q = 0;
            e = new (65535 < b.length / 3 ? Uint32Array : Uint16Array)(c * d * 6);
            for (t = 0; t < d; t++)for (s =
                                            0; s < c; s++)f = s + g * (t + 1), h = s + 1 + g * (t + 1), k = s + 1 + g * t, e[q] = s + g * t, e[q + 1] = f, e[q + 2] = k, e[q + 3] = f, e[q + 4] = h, e[q + 5] = k, q += 6;
            this.addAttribute("index", new THREE.BufferAttribute(e, 1));
            this.addAttribute("position", new THREE.BufferAttribute(b, 3));
            this.addAttribute("normal", new THREE.BufferAttribute(a, 3));
            this.addAttribute("uv", new THREE.BufferAttribute(p, 2))
        };
        THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
        THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
        THREE.RingGeometry = function (a, b, c, d, e, f) {
            THREE.Geometry.call(this);
            this.type = "RingGeometry";
            this.parameters = {innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f};
            a = a || 0;
            b = b || 50;
            e = void 0 !== e ? e : 0;
            f = void 0 !== f ? f : 2 * Math.PI;
            c = void 0 !== c ? Math.max(3, c) : 8;
            d = void 0 !== d ? Math.max(1, d) : 8;
            var g, h = [], k = a, l = (b - a) / d;
            for (a = 0; a < d + 1; a++) {
                for (g = 0; g < c + 1; g++) {
                    var p = new THREE.Vector3, q = e + g / c * f;
                    p.x = k * Math.cos(q);
                    p.y = k * Math.sin(q);
                    this.vertices.push(p);
                    h.push(new THREE.Vector2((p.x / b + 1) / 2,
                        (p.y / b + 1) / 2))
                }
                k += l
            }
            b = new THREE.Vector3(0, 0, 1);
            for (a = 0; a < d; a++)for (e = a * (c + 1), g = 0; g < c; g++)f = q = g + e, l = q + c + 1, p = q + c + 2, this.faces.push(new THREE.Face3(f, l, p, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([h[f].clone(), h[l].clone(), h[p].clone()]), f = q, l = q + c + 2, p = q + 1, this.faces.push(new THREE.Face3(f, l, p, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([h[f].clone(), h[l].clone(), h[p].clone()]);
            this.computeFaceNormals();
            this.boundingSphere = new THREE.Sphere(new THREE.Vector3, k)
        };
        THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
        THREE.SphereGeometry = function (a, b, c, d, e, f, g) {
            THREE.Geometry.call(this);
            this.type = "SphereGeometry";
            this.parameters = {radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g};
            a = a || 50;
            b = Math.max(3, Math.floor(b) || 8);
            c = Math.max(2, Math.floor(c) || 6);
            d = void 0 !== d ? d : 0;
            e = void 0 !== e ? e : 2 * Math.PI;
            f = void 0 !== f ? f : 0;
            g = void 0 !== g ? g : Math.PI;
            var h, k, l = [], p = [];
            for (k = 0; k <= c; k++) {
                var q = [], n = [];
                for (h = 0; h <= b; h++) {
                    var t = h / b, r = k / c, s = new THREE.Vector3;
                    s.x = -a * Math.cos(d + t * e) * Math.sin(f + r * g);
                    s.y = a * Math.cos(f + r * g);
                    s.z = a * Math.sin(d + t * e) * Math.sin(f + r * g);
                    this.vertices.push(s);
                    q.push(this.vertices.length - 1);
                    n.push(new THREE.Vector2(t, 1 - r))
                }
                l.push(q);
                p.push(n)
            }
            for (k = 0; k < c; k++)for (h = 0; h < b; h++) {
                d = l[k][h + 1];
                e = l[k][h];
                f = l[k + 1][h];
                g = l[k + 1][h + 1];
                var q = this.vertices[d].clone().normalize(), n = this.vertices[e].clone().normalize(), t = this.vertices[f].clone().normalize(), r = this.vertices[g].clone().normalize(), s = p[k][h + 1].clone(), u = p[k][h].clone(), v = p[k + 1][h].clone(), x = p[k + 1][h + 1].clone();
                Math.abs(this.vertices[d].y) ===
                a ? (s.x = (s.x + u.x) / 2, this.faces.push(new THREE.Face3(d, f, g, [q, t, r])), this.faceVertexUvs[0].push([s, v, x])) : Math.abs(this.vertices[f].y) === a ? (v.x = (v.x + x.x) / 2, this.faces.push(new THREE.Face3(d, e, f, [q, n, t])), this.faceVertexUvs[0].push([s, u, v])) : (this.faces.push(new THREE.Face3(d, e, g, [q, n, r])), this.faceVertexUvs[0].push([s, u, x]), this.faces.push(new THREE.Face3(e, f, g, [n.clone(), t, r.clone()])), this.faceVertexUvs[0].push([u.clone(), v, x.clone()]))
            }
            this.computeFaceNormals();
            this.boundingSphere = new THREE.Sphere(new THREE.Vector3,
                a)
        };
        THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
        THREE.TextGeometry = function (a, b) {
            b = b || {};
            var c = THREE.FontUtils.generateShapes(a, b);
            b.amount = void 0 !== b.height ? b.height : 50;
            void 0 === b.bevelThickness && (b.bevelThickness = 10);
            void 0 === b.bevelSize && (b.bevelSize = 8);
            void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
            THREE.ExtrudeGeometry.call(this, c, b);
            this.type = "TextGeometry"
        };
        THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
        THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
        THREE.TorusGeometry = function (a, b, c, d, e) {
            THREE.Geometry.call(this);
            this.type = "TorusGeometry";
            this.parameters = {radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e};
            a = a || 100;
            b = b || 40;
            c = c || 8;
            d = d || 6;
            e = e || 2 * Math.PI;
            for (var f = new THREE.Vector3, g = [], h = [], k = 0; k <= c; k++)for (var l = 0; l <= d; l++) {
                var p = l / d * e, q = k / c * Math.PI * 2;
                f.x = a * Math.cos(p);
                f.y = a * Math.sin(p);
                var n = new THREE.Vector3;
                n.x = (a + b * Math.cos(q)) * Math.cos(p);
                n.y = (a + b * Math.cos(q)) * Math.sin(p);
                n.z = b * Math.sin(q);
                this.vertices.push(n);
                g.push(new THREE.Vector2(l /
                    d, k / c));
                h.push(n.clone().sub(f).normalize())
            }
            for (k = 1; k <= c; k++)for (l = 1; l <= d; l++)a = (d + 1) * k + l - 1, b = (d + 1) * (k - 1) + l - 1, e = (d + 1) * (k - 1) + l, f = (d + 1) * k + l, p = new THREE.Face3(a, b, f, [h[a].clone(), h[b].clone(), h[f].clone()]), this.faces.push(p), this.faceVertexUvs[0].push([g[a].clone(), g[b].clone(), g[f].clone()]), p = new THREE.Face3(b, e, f, [h[b].clone(), h[e].clone(), h[f].clone()]), this.faces.push(p), this.faceVertexUvs[0].push([g[b].clone(), g[e].clone(), g[f].clone()]);
            this.computeFaceNormals()
        };
        THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
        THREE.TorusKnotGeometry = function (a, b, c, d, e, f, g) {
            function h(a, b, c, d, e) {
                var f = Math.cos(a), g = Math.sin(a);
                a *= b / c;
                b = Math.cos(a);
                f *= d * (2 + b) * .5;
                g = d * (2 + b) * g * .5;
                d = e * d * Math.sin(a) * .5;
                return new THREE.Vector3(f, g, d)
            }

            THREE.Geometry.call(this);
            this.type = "TorusKnotGeometry";
            this.parameters = {radius: a, tube: b, radialSegments: c, tubularSegments: d, p: e, q: f, heightScale: g};
            a = a || 100;
            b = b || 40;
            c = c || 64;
            d = d || 8;
            e = e || 2;
            f = f || 3;
            g = g || 1;
            for (var k = Array(c), l = new THREE.Vector3, p = new THREE.Vector3, q = new THREE.Vector3, n = 0; n < c; ++n) {
                k[n] =
                    Array(d);
                var t = n / c * 2 * e * Math.PI, r = h(t, f, e, a, g), t = h(t + .01, f, e, a, g);
                l.subVectors(t, r);
                p.addVectors(t, r);
                q.crossVectors(l, p);
                p.crossVectors(q, l);
                q.normalize();
                p.normalize();
                for (t = 0; t < d; ++t) {
                    var s = t / d * 2 * Math.PI, u = -b * Math.cos(s), s = b * Math.sin(s), v = new THREE.Vector3;
                    v.x = r.x + u * p.x + s * q.x;
                    v.y = r.y + u * p.y + s * q.y;
                    v.z = r.z + u * p.z + s * q.z;
                    k[n][t] = this.vertices.push(v) - 1
                }
            }
            for (n = 0; n < c; ++n)for (t = 0; t < d; ++t)e = (n + 1) % c, f = (t + 1) % d, a = k[n][t], b = k[e][t], e = k[e][f], f = k[n][f], g = new THREE.Vector2(n / c, t / d), l = new THREE.Vector2((n + 1) / c,
                t / d), p = new THREE.Vector2((n + 1) / c, (t + 1) / d), q = new THREE.Vector2(n / c, (t + 1) / d), this.faces.push(new THREE.Face3(a, b, f)), this.faceVertexUvs[0].push([g, l, q]), this.faces.push(new THREE.Face3(b, e, f)), this.faceVertexUvs[0].push([l.clone(), p, q.clone()]);
            this.computeFaceNormals();
            this.computeVertexNormals()
        };
        THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
        THREE.TubeGeometry = function (a, b, c, d, e, f) {
            THREE.Geometry.call(this);
            this.type = "TubeGeometry";
            this.parameters = {path: a, segments: b, radius: c, radialSegments: d, closed: e};
            b = b || 64;
            c = c || 1;
            d = d || 8;
            e = e || !1;
            f = f || THREE.TubeGeometry.NoTaper;
            var g = [], h, k, l = b + 1, p, q, n, t, r, s = new THREE.Vector3, u, v, x;
            u = new THREE.TubeGeometry.FrenetFrames(a, b, e);
            v = u.normals;
            x = u.binormals;
            this.tangents = u.tangents;
            this.normals = v;
            this.binormals = x;
            for (u = 0; u < l; u++)for (g[u] = [], p = u / (l - 1), r = a.getPointAt(p), h = v[u], k = x[u], n = c * f(p), p = 0; p < d; p++)q =
                p / d * 2 * Math.PI, t = -n * Math.cos(q), q = n * Math.sin(q), s.copy(r), s.x += t * h.x + q * k.x, s.y += t * h.y + q * k.y, s.z += t * h.z + q * k.z, g[u][p] = this.vertices.push(new THREE.Vector3(s.x, s.y, s.z)) - 1;
            for (u = 0; u < b; u++)for (p = 0; p < d; p++)f = e ? (u + 1) % b : u + 1, l = (p + 1) % d, a = g[u][p], c = g[f][p], f = g[f][l], l = g[u][l], s = new THREE.Vector2(u / b, p / d), v = new THREE.Vector2((u + 1) / b, p / d), x = new THREE.Vector2((u + 1) / b, (p + 1) / d), h = new THREE.Vector2(u / b, (p + 1) / d), this.faces.push(new THREE.Face3(a, c, l)), this.faceVertexUvs[0].push([s, v, h]), this.faces.push(new THREE.Face3(c,
                f, l)), this.faceVertexUvs[0].push([v.clone(), x, h.clone()]);
            this.computeFaceNormals();
            this.computeVertexNormals()
        };
        THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
        THREE.TubeGeometry.NoTaper = function (a) {
            return 1
        };
        THREE.TubeGeometry.SinusoidalTaper = function (a) {
            return Math.sin(Math.PI * a)
        };
        THREE.TubeGeometry.FrenetFrames = function (a, b, c) {
            var d = new THREE.Vector3, e = [], f = [], g = [], h = new THREE.Vector3, k = new THREE.Matrix4;
            b += 1;
            var l, p, q;
            this.tangents = e;
            this.normals = f;
            this.binormals = g;
            for (l = 0; l < b; l++)p = l / (b - 1), e[l] = a.getTangentAt(p), e[l].normalize();
            f[0] = new THREE.Vector3;
            g[0] = new THREE.Vector3;
            a = Number.MAX_VALUE;
            l = Math.abs(e[0].x);
            p = Math.abs(e[0].y);
            q = Math.abs(e[0].z);
            l <= a && (a = l, d.set(1, 0, 0));
            p <= a && (a = p, d.set(0, 1, 0));
            q <= a && d.set(0, 0, 1);
            h.crossVectors(e[0], d).normalize();
            f[0].crossVectors(e[0],
                h);
            g[0].crossVectors(e[0], f[0]);
            for (l = 1; l < b; l++)f[l] = f[l - 1].clone(), g[l] = g[l - 1].clone(), h.crossVectors(e[l - 1], e[l]), 1E-4 < h.length() && (h.normalize(), d = Math.acos(THREE.Math.clamp(e[l - 1].dot(e[l]), -1, 1)), f[l].applyMatrix4(k.makeRotationAxis(h, d))), g[l].crossVectors(e[l], f[l]);
            if (c)for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), l = 1; l < b; l++)f[l].applyMatrix4(k.makeRotationAxis(e[l], d * l)), g[l].crossVectors(e[l], f[l])
        };
        THREE.PolyhedronGeometry = function (a, b, c, d) {
            function e(a) {
                var b = a.normalize().clone();
                b.index = k.vertices.push(b) - 1;
                var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5;
                a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5;
                b.uv = new THREE.Vector2(c, 1 - a);
                return b
            }

            function f(a, b, c) {
                var d = new THREE.Face3(a.index, b.index, c.index, [a.clone(), b.clone(), c.clone()]);
                k.faces.push(d);
                u.copy(a).add(b).add(c).divideScalar(3);
                d = Math.atan2(u.z, -u.x);
                k.faceVertexUvs[0].push([h(a.uv, a, d), h(b.uv, b, d), h(c.uv, c, d)])
            }

            function g(a,
                       b) {
                for (var c = Math.pow(2, b), d = e(k.vertices[a.a]), g = e(k.vertices[a.b]), h = e(k.vertices[a.c]), l = [], n = 0; n <= c; n++) {
                    l[n] = [];
                    for (var p = e(d.clone().lerp(h, n / c)), q = e(g.clone().lerp(h, n / c)), s = c - n, r = 0; r <= s; r++)l[n][r] = 0 == r && n == c ? p : e(p.clone().lerp(q, r / s))
                }
                for (n = 0; n < c; n++)for (r = 0; r < 2 * (c - n) - 1; r++)d = Math.floor(r / 2), 0 == r % 2 ? f(l[n][d + 1], l[n + 1][d], l[n][d]) : f(l[n][d + 1], l[n + 1][d + 1], l[n + 1][d])
            }

            function h(a, b, c) {
                0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));
                0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + .5, a.y));
                return a.clone()
            }

            THREE.Geometry.call(this);
            this.type = "PolyhedronGeometry";
            this.parameters = {vertices: a, indices: b, radius: c, detail: d};
            c = c || 1;
            d = d || 0;
            for (var k = this, l = 0, p = a.length; l < p; l += 3)e(new THREE.Vector3(a[l], a[l + 1], a[l + 2]));
            a = this.vertices;
            for (var q = [], n = l = 0, p = b.length; l < p; l += 3, n++) {
                var t = a[b[l]], r = a[b[l + 1]], s = a[b[l + 2]];
                q[n] = new THREE.Face3(t.index, r.index, s.index, [t.clone(), r.clone(), s.clone()])
            }
            for (var u = new THREE.Vector3, l = 0, p = q.length; l < p; l++)g(q[l], d);
            l = 0;
            for (p = this.faceVertexUvs[0].length; l < p; l++)b = this.faceVertexUvs[0][l],
                d = b[0].x, a = b[1].x, q = b[2].x, n = Math.max(d, Math.max(a, q)), t = Math.min(d, Math.min(a, q)), .9 < n && .1 > t && (.2 > d && (b[0].x += 1), .2 > a && (b[1].x += 1), .2 > q && (b[2].x += 1));
            l = 0;
            for (p = this.vertices.length; l < p; l++)this.vertices[l].multiplyScalar(c);
            this.mergeVertices();
            this.computeFaceNormals();
            this.boundingSphere = new THREE.Sphere(new THREE.Vector3, c)
        };
        THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
        THREE.DodecahedronGeometry = function (a, b) {
            this.parameters = {radius: a, detail: b};
            var c = (1 + Math.sqrt(5)) / 2, d = 1 / c;
            THREE.PolyhedronGeometry.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19,
                11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b)
        };
        THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
        THREE.IcosahedronGeometry = function (a, b) {
            var c = (1 + Math.sqrt(5)) / 2;
            THREE.PolyhedronGeometry.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b);
            this.type = "IcosahedronGeometry";
            this.parameters = {radius: a, detail: b}
        };
        THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
        THREE.OctahedronGeometry = function (a, b) {
            this.parameters = {radius: a, detail: b};
            THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);
            this.type = "OctahedronGeometry";
            this.parameters = {radius: a, detail: b}
        };
        THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
        THREE.TetrahedronGeometry = function (a, b) {
            THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);
            this.type = "TetrahedronGeometry";
            this.parameters = {radius: a, detail: b}
        };
        THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
        THREE.ParametricGeometry = function (a, b, c) {
            THREE.Geometry.call(this);
            this.type = "ParametricGeometry";
            this.parameters = {func: a, slices: b, stacks: c};
            var d = this.vertices, e = this.faces, f = this.faceVertexUvs[0], g, h, k, l, p = b + 1;
            for (g = 0; g <= c; g++)for (l = g / c, h = 0; h <= b; h++)k = h / b, k = a(k, l), d.push(k);
            var q, n, t, r;
            for (g = 0; g < c; g++)for (h = 0; h < b; h++)a = g * p + h, d = g * p + h + 1, l = (g + 1) * p + h + 1, k = (g + 1) * p + h, q = new THREE.Vector2(h / b, g / c), n = new THREE.Vector2((h + 1) / b, g / c), t = new THREE.Vector2((h + 1) / b, (g + 1) / c), r = new THREE.Vector2(h / b, (g + 1) / c), e.push(new THREE.Face3(a,
                d, k)), f.push([q, n, r]), e.push(new THREE.Face3(d, l, k)), f.push([n.clone(), t, r.clone()]);
            this.computeFaceNormals();
            this.computeVertexNormals()
        };
        THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
        THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
        THREE.AxisHelper = function (a) {
            a = a || 1;
            var b = new Float32Array([0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]), c = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
            a = new THREE.BufferGeometry;
            a.addAttribute("position", new THREE.BufferAttribute(b, 3));
            a.addAttribute("color", new THREE.BufferAttribute(c, 3));
            b = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
            THREE.Line.call(this, a, b, THREE.LinePieces)
        };
        THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
        THREE.ArrowHelper = function () {
            var a = new THREE.Geometry;
            a.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
            var b = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
            b.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0));
            return function (c, d, e, f, g, h) {
                THREE.Object3D.call(this);
                void 0 === f && (f = 16776960);
                void 0 === e && (e = 1);
                void 0 === g && (g = .2 * e);
                void 0 === h && (h = .2 * g);
                this.position.copy(d);
                this.line = new THREE.Line(a, new THREE.LineBasicMaterial({color: f}));
                this.line.matrixAutoUpdate = !1;
                this.add(this.line);
                this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({color: f}));
                this.cone.matrixAutoUpdate = !1;
                this.add(this.cone);
                this.setDirection(c);
                this.setLength(e, g, h)
            }
        }();
        THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
        THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
        THREE.ArrowHelper.prototype.setDirection = function () {
            var a = new THREE.Vector3, b;
            return function (c) {
                .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b))
            }
        }();
        THREE.ArrowHelper.prototype.setLength = function (a, b, c) {
            void 0 === b && (b = .2 * a);
            void 0 === c && (c = .2 * b);
            this.line.scale.set(1, a - b, 1);
            this.line.updateMatrix();
            this.cone.scale.set(c, b, c);
            this.cone.position.y = a;
            this.cone.updateMatrix()
        };
        THREE.ArrowHelper.prototype.setColor = function (a) {
            this.line.material.color.set(a);
            this.cone.material.color.set(a)
        };
        THREE.BoxHelper = function (a) {
            var b = new THREE.BufferGeometry;
            b.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3));
            THREE.Line.call(this, b, new THREE.LineBasicMaterial({color: 16776960}), THREE.LinePieces);
            void 0 !== a && this.update(a)
        };
        THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
        THREE.BoxHelper.prototype.update = function (a) {
            var b = a.geometry;
            null === b.boundingBox && b.computeBoundingBox();
            var c = b.boundingBox.min, b = b.boundingBox.max, d = this.geometry.attributes.position.array;
            d[0] = b.x;
            d[1] = b.y;
            d[2] = b.z;
            d[3] = c.x;
            d[4] = b.y;
            d[5] = b.z;
            d[6] = c.x;
            d[7] = b.y;
            d[8] = b.z;
            d[9] = c.x;
            d[10] = c.y;
            d[11] = b.z;
            d[12] = c.x;
            d[13] = c.y;
            d[14] = b.z;
            d[15] = b.x;
            d[16] = c.y;
            d[17] = b.z;
            d[18] = b.x;
            d[19] = c.y;
            d[20] = b.z;
            d[21] = b.x;
            d[22] = b.y;
            d[23] = b.z;
            d[24] = b.x;
            d[25] = b.y;
            d[26] = c.z;
            d[27] = c.x;
            d[28] = b.y;
            d[29] = c.z;
            d[30] = c.x;
            d[31] = b.y;
            d[32] = c.z;
            d[33] = c.x;
            d[34] = c.y;
            d[35] = c.z;
            d[36] = c.x;
            d[37] = c.y;
            d[38] = c.z;
            d[39] = b.x;
            d[40] = c.y;
            d[41] = c.z;
            d[42] = b.x;
            d[43] = c.y;
            d[44] = c.z;
            d[45] = b.x;
            d[46] = b.y;
            d[47] = c.z;
            d[48] = b.x;
            d[49] = b.y;
            d[50] = b.z;
            d[51] = b.x;
            d[52] = b.y;
            d[53] = c.z;
            d[54] = c.x;
            d[55] = b.y;
            d[56] = b.z;
            d[57] = c.x;
            d[58] = b.y;
            d[59] = c.z;
            d[60] = c.x;
            d[61] = c.y;
            d[62] = b.z;
            d[63] = c.x;
            d[64] = c.y;
            d[65] = c.z;
            d[66] = b.x;
            d[67] = c.y;
            d[68] = b.z;
            d[69] = b.x;
            d[70] = c.y;
            d[71] = c.z;
            this.geometry.attributes.position.needsUpdate = !0;
            this.geometry.computeBoundingSphere();
            this.matrix = a.matrixWorld;
            this.matrixAutoUpdate = !1
        };
        THREE.BoundingBoxHelper = function (a, b) {
            var c = void 0 !== b ? b : 8947848;
            this.object = a;
            this.box = new THREE.Box3;
            THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({color: c, wireframe: !0}))
        };
        THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
        THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
        THREE.BoundingBoxHelper.prototype.update = function () {
            this.box.setFromObject(this.object);
            this.box.size(this.scale);
            this.box.center(this.position)
        };
        THREE.CameraHelper = function (a) {
            function b(a, b, d) {
                c(a, d);
                c(b, d)
            }

            function c(a, b) {
                d.vertices.push(new THREE.Vector3);
                d.colors.push(new THREE.Color(b));
                void 0 === f[a] && (f[a] = []);
                f[a].push(d.vertices.length - 1)
            }

            var d = new THREE.Geometry, e = new THREE.LineBasicMaterial({color: 16777215, vertexColors: THREE.FaceColors}), f = {};
            b("n1", "n2", 16755200);
            b("n2", "n4", 16755200);
            b("n4", "n3", 16755200);
            b("n3", "n1", 16755200);
            b("f1", "f2", 16755200);
            b("f2", "f4", 16755200);
            b("f4", "f3", 16755200);
            b("f3", "f1", 16755200);
            b("n1", "f1", 16755200);
            b("n2", "f2", 16755200);
            b("n3", "f3", 16755200);
            b("n4", "f4", 16755200);
            b("p", "n1", 16711680);
            b("p", "n2", 16711680);
            b("p", "n3", 16711680);
            b("p", "n4", 16711680);
            b("u1", "u2", 43775);
            b("u2", "u3", 43775);
            b("u3", "u1", 43775);
            b("c", "t", 16777215);
            b("p", "c", 3355443);
            b("cn1", "cn2", 3355443);
            b("cn3", "cn4", 3355443);
            b("cf1", "cf2", 3355443);
            b("cf3", "cf4", 3355443);
            THREE.Line.call(this, d, e, THREE.LinePieces);
            this.camera = a;
            this.matrix = a.matrixWorld;
            this.matrixAutoUpdate = !1;
            this.pointMap = f;
            this.update()
        };
        THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
        THREE.CameraHelper.prototype.update = function () {
            var a, b, c = new THREE.Vector3, d = new THREE.Camera, e = function (e, g, h, k) {
                c.set(g, h, k).unproject(d);
                e = b[e];
                if (void 0 !== e)for (g = 0, h = e.length; g < h; g++)a.vertices[e[g]].copy(c)
            };
            return function () {
                a = this.geometry;
                b = this.pointMap;
                d.projectionMatrix.copy(this.camera.projectionMatrix);
                e("c", 0, 0, -1);
                e("t", 0, 0, 1);
                e("n1", -1, -1, -1);
                e("n2", 1, -1, -1);
                e("n3", -1, 1, -1);
                e("n4", 1, 1, -1);
                e("f1", -1, -1, 1);
                e("f2", 1, -1, 1);
                e("f3", -1, 1, 1);
                e("f4", 1, 1, 1);
                e("u1", .7, 1.1, -1);
                e("u2", -.7, 1.1,
                    -1);
                e("u3", 0, 2, -1);
                e("cf1", -1, 0, 1);
                e("cf2", 1, 0, 1);
                e("cf3", 0, -1, 1);
                e("cf4", 0, 1, 1);
                e("cn1", -1, 0, -1);
                e("cn2", 1, 0, -1);
                e("cn3", 0, -1, -1);
                e("cn4", 0, 1, -1);
                a.verticesNeedUpdate = !0
            }
        }();
        THREE.DirectionalLightHelper = function (a, b) {
            THREE.Object3D.call(this);
            this.light = a;
            this.light.updateMatrixWorld();
            this.matrix = a.matrixWorld;
            this.matrixAutoUpdate = !1;
            b = b || 1;
            var c = new THREE.Geometry;
            c.vertices.push(new THREE.Vector3(-b, b, 0), new THREE.Vector3(b, b, 0), new THREE.Vector3(b, -b, 0), new THREE.Vector3(-b, -b, 0), new THREE.Vector3(-b, b, 0));
            var d = new THREE.LineBasicMaterial({fog: !1});
            d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            this.lightPlane = new THREE.Line(c, d);
            this.add(this.lightPlane);
            c = new THREE.Geometry;
            c.vertices.push(new THREE.Vector3, new THREE.Vector3);
            d = new THREE.LineBasicMaterial({fog: !1});
            d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            this.targetLine = new THREE.Line(c, d);
            this.add(this.targetLine);
            this.update()
        };
        THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
        THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
        THREE.DirectionalLightHelper.prototype.dispose = function () {
            this.lightPlane.geometry.dispose();
            this.lightPlane.material.dispose();
            this.targetLine.geometry.dispose();
            this.targetLine.material.dispose()
        };
        THREE.DirectionalLightHelper.prototype.update = function () {
            var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3;
            return function () {
                a.setFromMatrixPosition(this.light.matrixWorld);
                b.setFromMatrixPosition(this.light.target.matrixWorld);
                c.subVectors(b, a);
                this.lightPlane.lookAt(c);
                this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                this.targetLine.geometry.vertices[1].copy(c);
                this.targetLine.geometry.verticesNeedUpdate = !0;
                this.targetLine.material.color.copy(this.lightPlane.material.color)
            }
        }();
        THREE.EdgesHelper = function (a, b, c) {
            b = void 0 !== b ? b : 16777215;
            c = Math.cos(THREE.Math.degToRad(void 0 !== c ? c : 1));
            var d = [0, 0], e = {}, f = function (a, b) {
                return a - b
            }, g = ["a", "b", "c"], h = new THREE.BufferGeometry, k;
            a.geometry instanceof THREE.BufferGeometry ? (k = new THREE.Geometry, k.fromBufferGeometry(a.geometry)) : k = a.geometry.clone();
            k.mergeVertices();
            k.computeFaceNormals();
            var l = k.vertices;
            k = k.faces;
            for (var p = 0, q = 0, n = k.length; q < n; q++)for (var t = k[q], r = 0; 3 > r; r++) {
                d[0] = t[g[r]];
                d[1] = t[g[(r + 1) % 3]];
                d.sort(f);
                var s = d.toString();
                void 0 === e[s] ? (e[s] = {vert1: d[0], vert2: d[1], face1: q, face2: void 0}, p++) : e[s].face2 = q
            }
            d = new Float32Array(6 * p);
            f = 0;
            for (s in e)if (g = e[s], void 0 === g.face2 || k[g.face1].normal.dot(k[g.face2].normal) <= c)p = l[g.vert1], d[f++] = p.x, d[f++] = p.y, d[f++] = p.z, p = l[g.vert2], d[f++] = p.x, d[f++] = p.y, d[f++] = p.z;
            h.addAttribute("position", new THREE.BufferAttribute(d, 3));
            THREE.Line.call(this, h, new THREE.LineBasicMaterial({color: b}), THREE.LinePieces);
            this.matrix = a.matrixWorld;
            this.matrixAutoUpdate = !1
        };
        THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
        THREE.FaceNormalsHelper = function (a, b, c, d) {
            this.object = a;
            this.size = void 0 !== b ? b : 1;
            a = void 0 !== c ? c : 16776960;
            d = void 0 !== d ? d : 1;
            b = new THREE.Geometry;
            c = 0;
            for (var e = this.object.geometry.faces.length; c < e; c++)b.vertices.push(new THREE.Vector3, new THREE.Vector3);
            THREE.Line.call(this, b, new THREE.LineBasicMaterial({color: a, linewidth: d}), THREE.LinePieces);
            this.matrixAutoUpdate = !1;
            this.normalMatrix = new THREE.Matrix3;
            this.update()
        };
        THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
        THREE.FaceNormalsHelper.prototype.update = function () {
            var a = this.geometry.vertices, b = this.object, c = b.geometry.vertices, d = b.geometry.faces, e = b.matrixWorld;
            b.updateMatrixWorld(!0);
            this.normalMatrix.getNormalMatrix(e);
            for (var f = b = 0, g = d.length; b < g; b++, f += 2) {
                var h = d[b];
                a[f].copy(c[h.a]).add(c[h.b]).add(c[h.c]).divideScalar(3).applyMatrix4(e);
                a[f + 1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(a[f])
            }
            this.geometry.verticesNeedUpdate = !0;
            return this
        };
        THREE.GridHelper = function (a, b) {
            var c = new THREE.Geometry, d = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
            this.color1 = new THREE.Color(4473924);
            this.color2 = new THREE.Color(8947848);
            for (var e = -a; e <= a; e += b) {
                c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
                var f = 0 === e ? this.color1 : this.color2;
                c.colors.push(f, f, f, f)
            }
            THREE.Line.call(this, c, d, THREE.LinePieces)
        };
        THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.GridHelper.prototype.constructor = THREE.GridHelper;
        THREE.GridHelper.prototype.setColors = function (a, b) {
            this.color1.set(a);
            this.color2.set(b);
            this.geometry.colorsNeedUpdate = !0
        };
        THREE.HemisphereLightHelper = function (a, b) {
            THREE.Object3D.call(this);
            this.light = a;
            this.light.updateMatrixWorld();
            this.matrix = a.matrixWorld;
            this.matrixAutoUpdate = !1;
            this.colors = [new THREE.Color, new THREE.Color];
            var c = new THREE.SphereGeometry(b, 4, 2);
            c.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
            for (var d = 0; 8 > d; d++)c.faces[d].color = this.colors[4 > d ? 0 : 1];
            d = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors, wireframe: !0});
            this.lightSphere = new THREE.Mesh(c, d);
            this.add(this.lightSphere);
            this.update()
        };
        THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
        THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
        THREE.HemisphereLightHelper.prototype.dispose = function () {
            this.lightSphere.geometry.dispose();
            this.lightSphere.material.dispose()
        };
        THREE.HemisphereLightHelper.prototype.update = function () {
            var a = new THREE.Vector3;
            return function () {
                this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
                this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
                this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
                this.lightSphere.geometry.colorsNeedUpdate = !0
            }
        }();
        THREE.PointLightHelper = function (a, b) {
            this.light = a;
            this.light.updateMatrixWorld();
            var c = new THREE.SphereGeometry(b, 4, 2), d = new THREE.MeshBasicMaterial({wireframe: !0, fog: !1});
            d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            THREE.Mesh.call(this, c, d);
            this.matrix = this.light.matrixWorld;
            this.matrixAutoUpdate = !1
        };
        THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
        THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
        THREE.PointLightHelper.prototype.dispose = function () {
            this.geometry.dispose();
            this.material.dispose()
        };
        THREE.PointLightHelper.prototype.update = function () {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        };
        THREE.SkeletonHelper = function (a) {
            this.bones = this.getBoneList(a);
            for (var b = new THREE.Geometry, c = 0; c < this.bones.length; c++)this.bones[c].parent instanceof THREE.Bone && (b.vertices.push(new THREE.Vector3), b.vertices.push(new THREE.Vector3), b.colors.push(new THREE.Color(0, 0, 1)), b.colors.push(new THREE.Color(0, 1, 0)));
            c = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors, depthTest: !1, depthWrite: !1, transparent: !0});
            THREE.Line.call(this, b, c, THREE.LinePieces);
            this.root = a;
            this.matrix = a.matrixWorld;
            this.matrixAutoUpdate = !1;
            this.update()
        };
        THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
        THREE.SkeletonHelper.prototype.getBoneList = function (a) {
            var b = [];
            a instanceof THREE.Bone && b.push(a);
            for (var c = 0; c < a.children.length; c++)b.push.apply(b, this.getBoneList(a.children[c]));
            return b
        };
        THREE.SkeletonHelper.prototype.update = function () {
            for (var a = this.geometry, b = (new THREE.Matrix4).getInverse(this.root.matrixWorld), c = new THREE.Matrix4, d = 0, e = 0; e < this.bones.length; e++) {
                var f = this.bones[e];
                f.parent instanceof THREE.Bone && (c.multiplyMatrices(b, f.matrixWorld), a.vertices[d].setFromMatrixPosition(c), c.multiplyMatrices(b, f.parent.matrixWorld), a.vertices[d + 1].setFromMatrixPosition(c), d += 2)
            }
            a.verticesNeedUpdate = !0;
            a.computeBoundingSphere()
        };
        THREE.SpotLightHelper = function (a) {
            THREE.Object3D.call(this);
            this.light = a;
            this.light.updateMatrixWorld();
            this.matrix = a.matrixWorld;
            this.matrixAutoUpdate = !1;
            a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
            a.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0));
            a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
            var b = new THREE.MeshBasicMaterial({wireframe: !0, fog: !1});
            this.cone = new THREE.Mesh(a, b);
            this.add(this.cone);
            this.update()
        };
        THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
        THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
        THREE.SpotLightHelper.prototype.dispose = function () {
            this.cone.geometry.dispose();
            this.cone.material.dispose()
        };
        THREE.SpotLightHelper.prototype.update = function () {
            var a = new THREE.Vector3, b = new THREE.Vector3;
            return function () {
                var c = this.light.distance ? this.light.distance : 1E4, d = c * Math.tan(this.light.angle);
                this.cone.scale.set(d, d, c);
                a.setFromMatrixPosition(this.light.matrixWorld);
                b.setFromMatrixPosition(this.light.target.matrixWorld);
                this.cone.lookAt(b.sub(a));
                this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
            }
        }();
        THREE.VertexNormalsHelper = function (a, b, c, d) {
            this.object = a;
            this.size = void 0 !== b ? b : 1;
            b = void 0 !== c ? c : 16711680;
            d = void 0 !== d ? d : 1;
            c = new THREE.Geometry;
            a = a.geometry.faces;
            for (var e = 0, f = a.length; e < f; e++)for (var g = 0, h = a[e].vertexNormals.length; g < h; g++)c.vertices.push(new THREE.Vector3, new THREE.Vector3);
            THREE.Line.call(this, c, new THREE.LineBasicMaterial({color: b, linewidth: d}), THREE.LinePieces);
            this.matrixAutoUpdate = !1;
            this.normalMatrix = new THREE.Matrix3;
            this.update()
        };
        THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
        THREE.VertexNormalsHelper.prototype.update = function (a) {
            var b = new THREE.Vector3;
            return function (a) {
                a = ["a", "b", "c", "d"];
                this.object.updateMatrixWorld(!0);
                this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
                for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++)for (var p = f[k], q = 0, n = p.vertexNormals.length; q < n; q++) {
                    var t = p.vertexNormals[q];
                    d[h].copy(e[p[a[q]]]).applyMatrix4(g);
                    b.copy(t).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
                    b.add(d[h]);
                    h += 1;
                    d[h].copy(b);
                    h += 1
                }
                this.geometry.verticesNeedUpdate = !0;
                return this
            }
        }();
        THREE.VertexTangentsHelper = function (a, b, c, d) {
            this.object = a;
            this.size = void 0 !== b ? b : 1;
            b = void 0 !== c ? c : 255;
            d = void 0 !== d ? d : 1;
            c = new THREE.Geometry;
            a = a.geometry.faces;
            for (var e = 0, f = a.length; e < f; e++)for (var g = 0, h = a[e].vertexTangents.length; g < h; g++)c.vertices.push(new THREE.Vector3), c.vertices.push(new THREE.Vector3);
            THREE.Line.call(this, c, new THREE.LineBasicMaterial({color: b, linewidth: d}), THREE.LinePieces);
            this.matrixAutoUpdate = !1;
            this.update()
        };
        THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;
        THREE.VertexTangentsHelper.prototype.update = function (a) {
            var b = new THREE.Vector3;
            return function (a) {
                a = ["a", "b", "c", "d"];
                this.object.updateMatrixWorld(!0);
                for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++)for (var p = f[k], q = 0, n = p.vertexTangents.length; q < n; q++) {
                    var t = p.vertexTangents[q];
                    d[h].copy(e[p[a[q]]]).applyMatrix4(g);
                    b.copy(t).transformDirection(g).multiplyScalar(this.size);
                    b.add(d[h]);
                    h += 1;
                    d[h].copy(b);
                    h += 1
                }
                this.geometry.verticesNeedUpdate = !0;
                return this
            }
        }();
        THREE.WireframeHelper = function (a, b) {
            var c = void 0 !== b ? b : 16777215, d = [0, 0], e = {}, f = function (a, b) {
                return a - b
            }, g = ["a", "b", "c"], h = new THREE.BufferGeometry;
            if (a.geometry instanceof THREE.Geometry) {
                for (var k = a.geometry.vertices, l = a.geometry.faces, p = 0, q = new Uint32Array(6 * l.length), n = 0, t = l.length; n < t; n++)for (var r = l[n], s = 0; 3 > s; s++) {
                    d[0] = r[g[s]];
                    d[1] = r[g[(s + 1) % 3]];
                    d.sort(f);
                    var u = d.toString();
                    void 0 === e[u] && (q[2 * p] = d[0], q[2 * p + 1] = d[1], e[u] = !0, p++)
                }
                d = new Float32Array(6 * p);
                n = 0;
                for (t = p; n < t; n++)for (s = 0; 2 > s; s++)p =
                    k[q[2 * n + s]], g = 6 * n + 3 * s, d[g + 0] = p.x, d[g + 1] = p.y, d[g + 2] = p.z;
                h.addAttribute("position", new THREE.BufferAttribute(d, 3))
            } else if (a.geometry instanceof THREE.BufferGeometry) {
                if (void 0 !== a.geometry.attributes.index) {
                    k = a.geometry.attributes.position.array;
                    t = a.geometry.attributes.index.array;
                    l = a.geometry.drawcalls;
                    p = 0;
                    0 === l.length && (l = [{count: t.length, index: 0, start: 0}]);
                    for (var q = new Uint32Array(2 * t.length), r = 0, v = l.length; r < v; ++r)for (var s = l[r].start, u = l[r].count, g = l[r].index, n = s, x = s + u; n < x; n += 3)for (s = 0; 3 > s; s++)d[0] =
                        g + t[n + s], d[1] = g + t[n + (s + 1) % 3], d.sort(f), u = d.toString(), void 0 === e[u] && (q[2 * p] = d[0], q[2 * p + 1] = d[1], e[u] = !0, p++);
                    d = new Float32Array(6 * p);
                    n = 0;
                    for (t = p; n < t; n++)for (s = 0; 2 > s; s++)g = 6 * n + 3 * s, p = 3 * q[2 * n + s], d[g + 0] = k[p], d[g + 1] = k[p + 1], d[g + 2] = k[p + 2]
                } else for (k = a.geometry.attributes.position.array, p = k.length / 3, q = p / 3, d = new Float32Array(6 * p), n = 0, t = q; n < t; n++)for (s = 0; 3 > s; s++)g = 18 * n + 6 * s, q = 9 * n + 3 * s, d[g + 0] = k[q], d[g + 1] = k[q + 1], d[g + 2] = k[q + 2], p = 9 * n + (s + 1) % 3 * 3, d[g + 3] = k[p], d[g + 4] = k[p + 1], d[g + 5] = k[p + 2];
                h.addAttribute("position", new THREE.BufferAttribute(d,
                    3))
            }
            THREE.Line.call(this, h, new THREE.LineBasicMaterial({color: c}), THREE.LinePieces);
            this.matrix = a.matrixWorld;
            this.matrixAutoUpdate = !1
        };
        THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
        THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
        THREE.ImmediateRenderObject = function () {
            THREE.Object3D.call(this);
            this.render = function (a) {
            }
        };
        THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
        THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
        THREE.MorphBlendMesh = function (a, b) {
            THREE.Mesh.call(this, a, b);
            this.animationsMap = {};
            this.animationsList = [];
            var c = this.geometry.morphTargets.length;
            this.createAnimation("__default", 0, c - 1, c / 1);
            this.setAnimationWeight("__default", 1)
        };
        THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
        THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
        THREE.MorphBlendMesh.prototype.createAnimation = function (a, b, c, d) {
            b = {
                startFrame: b,
                endFrame: c,
                length: c - b + 1,
                fps: d,
                duration: (c - b) / d,
                lastFrame: 0,
                currentFrame: 0,
                active: !1,
                time: 0,
                direction: 1,
                weight: 1,
                directionBackwards: !1,
                mirroredLoop: !1
            };
            this.animationsMap[a] = b;
            this.animationsList.push(b)
        };
        THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (a) {
            for (var b = /([a-z]+)_?(\d+)/, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
                var h = e.morphTargets[f].name.match(b);
                if (h && 1 < h.length) {
                    var k = h[1];
                    d[k] || (d[k] = {start: Infinity, end: -Infinity});
                    h = d[k];
                    f < h.start && (h.start = f);
                    f > h.end && (h.end = f);
                    c || (c = k)
                }
            }
            for (k in d)h = d[k], this.createAnimation(k, h.start, h.end, a);
            this.firstAnimation = c
        };
        THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (a) {
            if (a = this.animationsMap[a])a.direction = 1, a.directionBackwards = !1
        };
        THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (a) {
            if (a = this.animationsMap[a])a.direction = -1, a.directionBackwards = !0
        };
        THREE.MorphBlendMesh.prototype.setAnimationFPS = function (a, b) {
            var c = this.animationsMap[a];
            c && (c.fps = b, c.duration = (c.end - c.start) / c.fps)
        };
        THREE.MorphBlendMesh.prototype.setAnimationDuration = function (a, b) {
            var c = this.animationsMap[a];
            c && (c.duration = b, c.fps = (c.end - c.start) / c.duration)
        };
        THREE.MorphBlendMesh.prototype.setAnimationWeight = function (a, b) {
            var c = this.animationsMap[a];
            c && (c.weight = b)
        };
        THREE.MorphBlendMesh.prototype.setAnimationTime = function (a, b) {
            var c = this.animationsMap[a];
            c && (c.time = b)
        };
        THREE.MorphBlendMesh.prototype.getAnimationTime = function (a) {
            var b = 0;
            if (a = this.animationsMap[a])b = a.time;
            return b
        };
        THREE.MorphBlendMesh.prototype.getAnimationDuration = function (a) {
            var b = -1;
            if (a = this.animationsMap[a])b = a.duration;
            return b
        };
        THREE.MorphBlendMesh.prototype.playAnimation = function (a) {
            var b = this.animationsMap[a];
            b ? (b.time = 0, b.active = !0) : THREE.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()")
        };
        THREE.MorphBlendMesh.prototype.stopAnimation = function (a) {
            if (a = this.animationsMap[a])a.active = !1
        };
        THREE.MorphBlendMesh.prototype.update = function (a) {
            for (var b = 0, c = this.animationsList.length; b < c; b++) {
                var d = this.animationsList[b];
                if (d.active) {
                    var e = d.duration / d.length;
                    d.time += d.direction * a;
                    if (d.mirroredLoop) {
                        if (d.time > d.duration || 0 > d.time)d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1)
                    } else d.time %= d.duration, 0 > d.time && (d.time += d.duration);
                    var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1), g = d.weight;
                    f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
                    e = d.time % e / e;
                    d.directionBackwards && (e = 1 - e);
                    this.morphTargetInfluences[d.currentFrame] = e * g;
                    this.morphTargetInfluences[d.lastFrame] = (1 - e) * g
                }
            }
        };
    }, {}],
    7: [function (require, module, exports) {
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
        (function () {
            function n(n) {
                function t(t, r, e, u, i, o) {
                    for (; i >= 0 && o > i; i += n) {
                        var a = u ? u[i] : i;
                        e = r(e, t[a], a, t)
                    }
                    return e
                }

                return function (r, e, u, i) {
                    e = b(e, i, 4);
                    var o = !k(r) && m.keys(r), a = (o || r).length, c = n > 0 ? 0 : a - 1;
                    return arguments.length < 3 && (u = r[o ? o[c] : c], c += n), t(r, e, u, o, c, a)
                }
            }

            function t(n) {
                return function (t, r, e) {
                    r = x(r, e);
                    for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n)if (r(t[i], i, t))return i;
                    return -1
                }
            }

            function r(n, t, r) {
                return function (e, u, i) {
                    var o = 0, a = O(e);
                    if ("number" == typeof i)n > 0 ? o = i >= 0 ? i : Math.max(i + a, o) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1; else if (r && i && a)return i = r(e, u), e[i] === u ? i : -1;
                    if (u !== u)return i = t(l.call(e, o, a), m.isNaN), i >= 0 ? i + o : -1;
                    for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n)if (e[i] === u)return i;
                    return -1
                }
            }

            function e(n, t) {
                var r = I.length, e = n.constructor, u = m.isFunction(e) && e.prototype || a, i = "constructor";
                for (m.has(n, i) && !m.contains(t, i) && t.push(i); r--;)i = I[r], i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i)
            }

            var u = this, i = u._, o = Array.prototype, a = Object.prototype, c = Function.prototype, f = o.push, l = o.slice, s = a.toString, p = a.hasOwnProperty, h = Array.isArray, v = Object.keys, g = c.bind, y = Object.create, d = function () {
            }, m = function (n) {
                return n instanceof m ? n : this instanceof m ? void(this._wrapped = n) : new m(n)
            };
            "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = m), exports._ = m) : u._ = m, m.VERSION = "1.8.3";
            var b = function (n, t, r) {
                if (t === void 0)return n;
                switch (null == r ? 3 : r) {
                    case 1:
                        return function (r) {
                            return n.call(t, r)
                        };
                    case 2:
                        return function (r, e) {
                            return n.call(t, r, e)
                        };
                    case 3:
                        return function (r, e, u) {
                            return n.call(t, r, e, u)
                        };
                    case 4:
                        return function (r, e, u, i) {
                            return n.call(t, r, e, u, i)
                        }
                }
                return function () {
                    return n.apply(t, arguments)
                }
            }, x = function (n, t, r) {
                return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n)
            };
            m.iteratee = function (n, t) {
                return x(n, t, 1 / 0)
            };
            var _ = function (n, t) {
                return function (r) {
                    var e = arguments.length;
                    if (2 > e || null == r)return r;
                    for (var u = 1; e > u; u++)for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) {
                        var f = o[c];
                        t && r[f] !== void 0 || (r[f] = i[f])
                    }
                    return r
                }
            }, j = function (n) {
                if (!m.isObject(n))return {};
                if (y)return y(n);
                d.prototype = n;
                var t = new d;
                return d.prototype = null, t
            }, w = function (n) {
                return function (t) {
                    return null == t ? void 0 : t[n]
                }
            }, A = Math.pow(2, 53) - 1, O = w("length"), k = function (n) {
                var t = O(n);
                return "number" == typeof t && t >= 0 && A >= t
            };
            m.each = m.forEach = function (n, t, r) {
                t = b(t, r);
                var e, u;
                if (k(n))for (e = 0, u = n.length; u > e; e++)t(n[e], e, n); else {
                    var i = m.keys(n);
                    for (e = 0, u = i.length; u > e; e++)t(n[i[e]], i[e], n)
                }
                return n
            }, m.map = m.collect = function (n, t, r) {
                t = x(t, r);
                for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) {
                    var a = e ? e[o] : o;
                    i[o] = t(n[a], a, n)
                }
                return i
            }, m.reduce = m.foldl = m.inject = n(1), m.reduceRight = m.foldr = n(-1), m.find = m.detect = function (n, t, r) {
                var e;
                return e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r), e !== void 0 && e !== -1 ? n[e] : void 0
            }, m.filter = m.select = function (n, t, r) {
                var e = [];
                return t = x(t, r), m.each(n, function (n, r, u) {
                    t(n, r, u) && e.push(n)
                }), e
            }, m.reject = function (n, t, r) {
                return m.filter(n, m.negate(x(t)), r)
            }, m.every = m.all = function (n, t, r) {
                t = x(t, r);
                for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
                    var o = e ? e[i] : i;
                    if (!t(n[o], o, n))return !1
                }
                return !0
            }, m.some = m.any = function (n, t, r) {
                t = x(t, r);
                for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
                    var o = e ? e[i] : i;
                    if (t(n[o], o, n))return !0
                }
                return !1
            }, m.contains = m.includes = m.include = function (n, t, r, e) {
                return k(n) || (n = m.values(n)), ("number" != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0
            }, m.invoke = function (n, t) {
                var r = l.call(arguments, 2), e = m.isFunction(t);
                return m.map(n, function (n) {
                    var u = e ? t : n[t];
                    return null == u ? u : u.apply(n, r)
                })
            }, m.pluck = function (n, t) {
                return m.map(n, m.property(t))
            }, m.where = function (n, t) {
                return m.filter(n, m.matcher(t))
            }, m.findWhere = function (n, t) {
                return m.find(n, m.matcher(t))
            }, m.max = function (n, t, r) {
                var e, u, i = -1 / 0, o = -1 / 0;
                if (null == t && null != n) {
                    n = k(n) ? n : m.values(n);
                    for (var a = 0, c = n.length; c > a; a++)e = n[a], e > i && (i = e)
                } else t = x(t, r), m.each(n, function (n, r, e) {
                    u = t(n, r, e), (u > o || u === -1 / 0 && i === -1 / 0) && (i = n, o = u)
                });
                return i
            }, m.min = function (n, t, r) {
                var e, u, i = 1 / 0, o = 1 / 0;
                if (null == t && null != n) {
                    n = k(n) ? n : m.values(n);
                    for (var a = 0, c = n.length; c > a; a++)e = n[a], i > e && (i = e)
                } else t = x(t, r), m.each(n, function (n, r, e) {
                    u = t(n, r, e), (o > u || 1 / 0 === u && 1 / 0 === i) && (i = n, o = u)
                });
                return i
            }, m.shuffle = function (n) {
                for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++)t = m.random(0, i), t !== i && (u[i] = u[t]), u[t] = r[i];
                return u
            }, m.sample = function (n, t, r) {
                return null == t || r ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)]) : m.shuffle(n).slice(0, Math.max(0, t))
            }, m.sortBy = function (n, t, r) {
                return t = x(t, r), m.pluck(m.map(n, function (n, r, e) {
                    return {value: n, index: r, criteria: t(n, r, e)}
                }).sort(function (n, t) {
                    var r = n.criteria, e = t.criteria;
                    if (r !== e) {
                        if (r > e || r === void 0)return 1;
                        if (e > r || e === void 0)return -1
                    }
                    return n.index - t.index
                }), "value")
            };
            var F = function (n) {
                return function (t, r, e) {
                    var u = {};
                    return r = x(r, e), m.each(t, function (e, i) {
                        var o = r(e, i, t);
                        n(u, e, o)
                    }), u
                }
            };
            m.groupBy = F(function (n, t, r) {
                m.has(n, r) ? n[r].push(t) : n[r] = [t]
            }), m.indexBy = F(function (n, t, r) {
                n[r] = t
            }), m.countBy = F(function (n, t, r) {
                m.has(n, r) ? n[r]++ : n[r] = 1
            }), m.toArray = function (n) {
                return n ? m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n) : []
            }, m.size = function (n) {
                return null == n ? 0 : k(n) ? n.length : m.keys(n).length
            }, m.partition = function (n, t, r) {
                t = x(t, r);
                var e = [], u = [];
                return m.each(n, function (n, r, i) {
                    (t(n, r, i) ? e : u).push(n)
                }), [e, u]
            }, m.first = m.head = m.take = function (n, t, r) {
                return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t)
            }, m.initial = function (n, t, r) {
                return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t)))
            }, m.last = function (n, t, r) {
                return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t))
            }, m.rest = m.tail = m.drop = function (n, t, r) {
                return l.call(n, null == t || r ? 1 : t)
            }, m.compact = function (n) {
                return m.filter(n, m.identity)
            };
            var S = function (n, t, r, e) {
                for (var u = [], i = 0, o = e || 0, a = O(n); a > o; o++) {
                    var c = n[o];
                    if (k(c) && (m.isArray(c) || m.isArguments(c))) {
                        t || (c = S(c, t, r));
                        var f = 0, l = c.length;
                        for (u.length += l; l > f;)u[i++] = c[f++]
                    } else r || (u[i++] = c)
                }
                return u
            };
            m.flatten = function (n, t) {
                return S(n, t, !1)
            }, m.without = function (n) {
                return m.difference(n, l.call(arguments, 1))
            }, m.uniq = m.unique = function (n, t, r, e) {
                m.isBoolean(t) || (e = r, r = t, t = !1), null != r && (r = x(r, e));
                for (var u = [], i = [], o = 0, a = O(n); a > o; o++) {
                    var c = n[o], f = r ? r(c, o, n) : c;
                    t ? (o && i === f || u.push(c), i = f) : r ? m.contains(i, f) || (i.push(f), u.push(c)) : m.contains(u, c) || u.push(c)
                }
                return u
            }, m.union = function () {
                return m.uniq(S(arguments, !0, !0))
            }, m.intersection = function (n) {
                for (var t = [], r = arguments.length, e = 0, u = O(n); u > e; e++) {
                    var i = n[e];
                    if (!m.contains(t, i)) {
                        for (var o = 1; r > o && m.contains(arguments[o], i); o++);
                        o === r && t.push(i)
                    }
                }
                return t
            }, m.difference = function (n) {
                var t = S(arguments, !0, !0, 1);
                return m.filter(n, function (n) {
                    return !m.contains(t, n)
                })
            }, m.zip = function () {
                return m.unzip(arguments)
            }, m.unzip = function (n) {
                for (var t = n && m.max(n, O).length || 0, r = Array(t), e = 0; t > e; e++)r[e] = m.pluck(n, e);
                return r
            }, m.object = function (n, t) {
                for (var r = {}, e = 0, u = O(n); u > e; e++)t ? r[n[e]] = t[e] : r[n[e][0]] = n[e][1];
                return r
            }, m.findIndex = t(1), m.findLastIndex = t(-1), m.sortedIndex = function (n, t, r, e) {
                r = x(r, e, 1);
                for (var u = r(t), i = 0, o = O(n); o > i;) {
                    var a = Math.floor((i + o) / 2);
                    r(n[a]) < u ? i = a + 1 : o = a
                }
                return i
            }, m.indexOf = r(1, m.findIndex, m.sortedIndex), m.lastIndexOf = r(-1, m.findLastIndex), m.range = function (n, t, r) {
                null == t && (t = n || 0, n = 0), r = r || 1;
                for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++, n += r)u[i] = n;
                return u
            };
            var E = function (n, t, r, e, u) {
                if (!(e instanceof t))return n.apply(r, u);
                var i = j(n.prototype), o = n.apply(i, u);
                return m.isObject(o) ? o : i
            };
            m.bind = function (n, t) {
                if (g && n.bind === g)return g.apply(n, l.call(arguments, 1));
                if (!m.isFunction(n))throw new TypeError("Bind must be called on a function");
                var r = l.call(arguments, 2), e = function () {
                    return E(n, e, t, this, r.concat(l.call(arguments)))
                };
                return e
            }, m.partial = function (n) {
                var t = l.call(arguments, 1), r = function () {
                    for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++)i[o] = t[o] === m ? arguments[e++] : t[o];
                    for (; e < arguments.length;)i.push(arguments[e++]);
                    return E(n, r, this, this, i)
                };
                return r
            }, m.bindAll = function (n) {
                var t, r, e = arguments.length;
                if (1 >= e)throw new Error("bindAll must be passed function names");
                for (t = 1; e > t; t++)r = arguments[t], n[r] = m.bind(n[r], n);
                return n
            }, m.memoize = function (n, t) {
                var r = function (e) {
                    var u = r.cache, i = "" + (t ? t.apply(this, arguments) : e);
                    return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i]
                };
                return r.cache = {}, r
            }, m.delay = function (n, t) {
                var r = l.call(arguments, 2);
                return setTimeout(function () {
                    return n.apply(null, r)
                }, t)
            }, m.defer = m.partial(m.delay, m, 1), m.throttle = function (n, t, r) {
                var e, u, i, o = null, a = 0;
                r || (r = {});
                var c = function () {
                    a = r.leading === !1 ? 0 : m.now(), o = null, i = n.apply(e, u), o || (e = u = null)
                };
                return function () {
                    var f = m.now();
                    a || r.leading !== !1 || (a = f);
                    var l = t - (f - a);
                    return e = this, u = arguments, 0 >= l || l > t ? (o && (clearTimeout(o), o = null), a = f, i = n.apply(e, u), o || (e = u = null)) : o || r.trailing === !1 || (o = setTimeout(c, l)), i
                }
            }, m.debounce = function (n, t, r) {
                var e, u, i, o, a, c = function () {
                    var f = m.now() - o;
                    t > f && f >= 0 ? e = setTimeout(c, t - f) : (e = null, r || (a = n.apply(i, u), e || (i = u = null)))
                };
                return function () {
                    i = this, u = arguments, o = m.now();
                    var f = r && !e;
                    return e || (e = setTimeout(c, t)), f && (a = n.apply(i, u), i = u = null), a
                }
            }, m.wrap = function (n, t) {
                return m.partial(t, n)
            }, m.negate = function (n) {
                return function () {
                    return !n.apply(this, arguments)
                }
            }, m.compose = function () {
                var n = arguments, t = n.length - 1;
                return function () {
                    for (var r = t, e = n[t].apply(this, arguments); r--;)e = n[r].call(this, e);
                    return e
                }
            }, m.after = function (n, t) {
                return function () {
                    return --n < 1 ? t.apply(this, arguments) : void 0
                }
            }, m.before = function (n, t) {
                var r;
                return function () {
                    return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r
                }
            }, m.once = m.partial(m.before, 2);
            var M = !{toString: null}.propertyIsEnumerable("toString"), I = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
            m.keys = function (n) {
                if (!m.isObject(n))return [];
                if (v)return v(n);
                var t = [];
                for (var r in n)m.has(n, r) && t.push(r);
                return M && e(n, t), t
            }, m.allKeys = function (n) {
                if (!m.isObject(n))return [];
                var t = [];
                for (var r in n)t.push(r);
                return M && e(n, t), t
            }, m.values = function (n) {
                for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++)e[u] = n[t[u]];
                return e
            }, m.mapObject = function (n, t, r) {
                t = x(t, r);
                for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++)e = u[a], o[e] = t(n[e], e, n);
                return o
            }, m.pairs = function (n) {
                for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++)e[u] = [t[u], n[t[u]]];
                return e
            }, m.invert = function (n) {
                for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++)t[n[r[e]]] = r[e];
                return t
            }, m.functions = m.methods = function (n) {
                var t = [];
                for (var r in n)m.isFunction(n[r]) && t.push(r);
                return t.sort()
            }, m.extend = _(m.allKeys), m.extendOwn = m.assign = _(m.keys), m.findKey = function (n, t, r) {
                t = x(t, r);
                for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++)if (e = u[i], t(n[e], e, n))return e
            }, m.pick = function (n, t, r) {
                var e, u, i = {}, o = n;
                if (null == o)return i;
                m.isFunction(t) ? (u = m.allKeys(o), e = b(t, r)) : (u = S(arguments, !1, !1, 1), e = function (n, t, r) {
                    return t in r
                }, o = Object(o));
                for (var a = 0, c = u.length; c > a; a++) {
                    var f = u[a], l = o[f];
                    e(l, f, o) && (i[f] = l)
                }
                return i
            }, m.omit = function (n, t, r) {
                if (m.isFunction(t))t = m.negate(t); else {
                    var e = m.map(S(arguments, !1, !1, 1), String);
                    t = function (n, t) {
                        return !m.contains(e, t)
                    }
                }
                return m.pick(n, t, r)
            }, m.defaults = _(m.allKeys, !0), m.create = function (n, t) {
                var r = j(n);
                return t && m.extendOwn(r, t), r
            }, m.clone = function (n) {
                return m.isObject(n) ? m.isArray(n) ? n.slice() : m.extend({}, n) : n
            }, m.tap = function (n, t) {
                return t(n), n
            }, m.isMatch = function (n, t) {
                var r = m.keys(t), e = r.length;
                if (null == n)return !e;
                for (var u = Object(n), i = 0; e > i; i++) {
                    var o = r[i];
                    if (t[o] !== u[o] || !(o in u))return !1
                }
                return !0
            };
            var N = function (n, t, r, e) {
                if (n === t)return 0 !== n || 1 / n === 1 / t;
                if (null == n || null == t)return n === t;
                n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped);
                var u = s.call(n);
                if (u !== s.call(t))return !1;
                switch (u) {
                    case"[object RegExp]":
                    case"[object String]":
                        return "" + n == "" + t;
                    case"[object Number]":
                        return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t;
                    case"[object Date]":
                    case"[object Boolean]":
                        return +n === +t
                }
                var i = "[object Array]" === u;
                if (!i) {
                    if ("object" != typeof n || "object" != typeof t)return !1;
                    var o = n.constructor, a = t.constructor;
                    if (o !== a && !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) && "constructor"in n && "constructor"in t)return !1
                }
                r = r || [], e = e || [];
                for (var c = r.length; c--;)if (r[c] === n)return e[c] === t;
                if (r.push(n), e.push(t), i) {
                    if (c = n.length, c !== t.length)return !1;
                    for (; c--;)if (!N(n[c], t[c], r, e))return !1
                } else {
                    var f, l = m.keys(n);
                    if (c = l.length, m.keys(t).length !== c)return !1;
                    for (; c--;)if (f = l[c], !m.has(t, f) || !N(n[f], t[f], r, e))return !1
                }
                return r.pop(), e.pop(), !0
            };
            m.isEqual = function (n, t) {
                return N(n, t)
            }, m.isEmpty = function (n) {
                return null == n ? !0 : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n)) ? 0 === n.length : 0 === m.keys(n).length
            }, m.isElement = function (n) {
                return !(!n || 1 !== n.nodeType)
            }, m.isArray = h || function (n) {
                    return "[object Array]" === s.call(n)
                }, m.isObject = function (n) {
                var t = typeof n;
                return "function" === t || "object" === t && !!n
            }, m.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function (n) {
                m["is" + n] = function (t) {
                    return s.call(t) === "[object " + n + "]"
                }
            }), m.isArguments(arguments) || (m.isArguments = function (n) {
                return m.has(n, "callee")
            }), "function" != typeof/./ && "object" != typeof Int8Array && (m.isFunction = function (n) {
                return "function" == typeof n || !1
            }), m.isFinite = function (n) {
                return isFinite(n) && !isNaN(parseFloat(n))
            }, m.isNaN = function (n) {
                return m.isNumber(n) && n !== +n
            }, m.isBoolean = function (n) {
                return n === !0 || n === !1 || "[object Boolean]" === s.call(n)
            }, m.isNull = function (n) {
                return null === n
            }, m.isUndefined = function (n) {
                return n === void 0
            }, m.has = function (n, t) {
                return null != n && p.call(n, t)
            }, m.noConflict = function () {
                return u._ = i, this
            }, m.identity = function (n) {
                return n
            }, m.constant = function (n) {
                return function () {
                    return n
                }
            }, m.noop = function () {
            }, m.property = w, m.propertyOf = function (n) {
                return null == n ? function () {
                } : function (t) {
                    return n[t]
                }
            }, m.matcher = m.matches = function (n) {
                return n = m.extendOwn({}, n), function (t) {
                    return m.isMatch(t, n)
                }
            }, m.times = function (n, t, r) {
                var e = Array(Math.max(0, n));
                t = b(t, r, 1);
                for (var u = 0; n > u; u++)e[u] = t(u);
                return e
            }, m.random = function (n, t) {
                return null == t && (t = n, n = 0), n + Math.floor(Math.random() * (t - n + 1))
            }, m.now = Date.now || function () {
                    return (new Date).getTime()
                };
            var B = {"&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;"}, T = m.invert(B), R = function (n) {
                var t = function (t) {
                    return n[t]
                }, r = "(?:" + m.keys(n).join("|") + ")", e = RegExp(r), u = RegExp(r, "g");
                return function (n) {
                    return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, t) : n
                }
            };
            m.escape = R(B), m.unescape = R(T), m.result = function (n, t, r) {
                var e = null == n ? void 0 : n[t];
                return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e
            };
            var q = 0;
            m.uniqueId = function (n) {
                var t = ++q + "";
                return n ? n + t : t
            }, m.templateSettings = {evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g};
            var K = /(.)^/, z = {"'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029"}, D = /\\|'|\r|\n|\u2028|\u2029/g, L = function (n) {
                return "\\" + z[n]
            };
            m.template = function (n, t, r) {
                !t && r && (t = r), t = m.defaults({}, t, m.templateSettings);
                var e = RegExp([(t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source].join("|") + "|$", "g"), u = 0, i = "__p+='";
                n.replace(e, function (t, r, e, o, a) {
                    return i += n.slice(u, a).replace(D, L), u = a + t.length, r ? i += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : e ? i += "'+\n((__t=(" + e + "))==null?'':__t)+\n'" : o && (i += "';\n" + o + "\n__p+='"), t
                }), i += "';\n", t.variable || (i = "with(obj||{}){\n" + i + "}\n"), i = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + i + "return __p;\n";
                try {
                    var o = new Function(t.variable || "obj", "_", i)
                } catch (a) {
                    throw a.source = i, a
                }
                var c = function (n) {
                    return o.call(this, n, m)
                }, f = t.variable || "obj";
                return c.source = "function(" + f + "){\n" + i + "}", c
            }, m.chain = function (n) {
                var t = m(n);
                return t._chain = !0, t
            };
            var P = function (n, t) {
                return n._chain ? m(t).chain() : t
            };
            m.mixin = function (n) {
                m.each(m.functions(n), function (t) {
                    var r = m[t] = n[t];
                    m.prototype[t] = function () {
                        var n = [this._wrapped];
                        return f.apply(n, arguments), P(this, r.apply(m, n))
                    }
                })
            }, m.mixin(m), m.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (n) {
                var t = o[n];
                m.prototype[n] = function () {
                    var r = this._wrapped;
                    return t.apply(r, arguments), "shift" !== n && "splice" !== n || 0 !== r.length || delete r[0], P(this, r)
                }
            }), m.each(["concat", "join", "slice"], function (n) {
                var t = o[n];
                m.prototype[n] = function () {
                    return P(this, t.apply(this._wrapped, arguments))
                }
            }), m.prototype.value = function () {
                return this._wrapped
            }, m.prototype.valueOf = m.prototype.toJSON = m.prototype.value, m.prototype.toString = function () {
                return "" + this._wrapped
            }, "function" == typeof define && define.amd && define("underscore", [], function () {
                return m
            })
        }).call(this);

    }, {}],
    8: [function (require, module, exports) {
        /**
         * The Main singleton object.
         * Created by Henry on 6/27/2015.
         */
        var $ = require("./lib/jquery.js");
        var _ = require("./lib/underscore.js");
        var THREE = require("./lib/three.js");
        var World = require("./world.js");
        var Input = require("./input.js");
        var Renderer = require("./renderer.js");
        var OrbitControls = require("./lib/orbitcontrols.js");

        var Main = new function () {

            /**
             * The self instance
             * @type {Main}
             */
            var self = this;

            self.keyMap = {
                SHIFT: 16
            };

            /**
             * Called when the Main singleton is initialized.
             */
            self.init = function () {
                /**
                 * Create Camera
                 * @type {THREE.PerspectiveCamera}
                 */
                self.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
                self.camera.position.set(500, 800, 1300);
                self.camera.lookAt(new THREE.Vector3());

                self.scene = new THREE.Scene();

                // roll-over helpers
                var rollOverGeo = new THREE.BoxGeometry(50, 50, 50);
                self.rollOverMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, opacity: 0.5, transparent: true});
                self.rollOverMesh = new THREE.Mesh(rollOverGeo, self.rollOverMaterial);
                self.scene.add(self.rollOverMesh);

                // cubes
                self.cubeGeo = new THREE.BoxGeometry(50, 50, 50);
                self.cubeMaterial = new THREE.MeshLambertMaterial({color: 0xfeb74c, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture("textures/square-outline-textured.png")});

                // Draw grid
                var size = 500, step = 50;

                var geometry = new THREE.Geometry();

                for (var i = -size; i <= size; i += step) {
                    geometry.vertices.push(new THREE.Vector3(-size, 0, i));
                    geometry.vertices.push(new THREE.Vector3(size, 0, i));

                    geometry.vertices.push(new THREE.Vector3(i, 0, -size));
                    geometry.vertices.push(new THREE.Vector3(i, 0, size));
                }

                var material = new THREE.LineBasicMaterial({color: 0x000000, opacity: 0.2, transparent: true});

                var line = new THREE.Line(geometry, material, THREE.LinePieces);
                self.scene.add(line);

                self.raycaster = new THREE.Raycaster();
                self.mouse = new THREE.Vector2();

                var geometry = new THREE.PlaneBufferGeometry(1000, 1000);
                geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));

                self.plane = new THREE.Mesh(geometry);
                self.plane.visible = false;
                self.scene.add(self.plane);

                World.entities.push(self.plane);

                // Lights
                var ambientLight = new THREE.AmbientLight(0x606060);
                self.scene.add(ambientLight);

                var directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(1, 0.75, 0.5).normalize();
                self.scene.add(directionalLight);

                //Controls
                self.controls = new OrbitControls(self.camera, Renderer.renderer.domElement);

                $(document).bind("mousemove", self.onMouseMove);
                $(document).bind("mousedown", self.onMouseDown);
                $(document).bind("mouseup", self.onMouseUp);
                $(window).bind("resize", self.onWindowResize);

                Renderer.renderWorld();
            };

            self.onWindowResize = function () {
                self.camera.aspect = window.innerWidth / window.innerHeight;
                self.camera.updateProjectionMatrix();

                Renderer.renderer.setSize(window.innerWidth, window.innerHeight);
            };

            self.onMouseMove = function (event) {
                event.preventDefault();

                self.mouse.set(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1);

                if (!self.isMiddleMouseDown) {
                    self.camera.lookAt(new THREE.Vector3());
                    self.raycaster.setFromCamera(self.mouse, self.camera);

                    var intersects = self.raycaster.intersectObjects(World.entities);

                    if (intersects.length > 0) {
                        var intersect = intersects[0];
                        self.rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
                        self.rollOverMesh.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
                    }
                }

                Renderer.renderWorld();
            };

            self.onMouseDown = function (event) {
                event.preventDefault();

                self.mouse.set(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1);

                if (event.which == 2) {
                    self.isMiddleMouseDown = true;
                }
                else {
                    self.raycaster.setFromCamera(self.mouse, self.camera);
                    var intersects = self.raycaster.intersectObjects(World.entities);

                    if (intersects.length > 0) {
                        var intersect = intersects[0];

                        if (_.contains(Input.pressed, self.keyMap.SHIFT)) {
                            // delete cube
                            if (intersect.object != self.plane) {
                                self.scene.remove(intersect.object);
                                World.entities.splice(World.entities.indexOf(intersect.object), 1);
                            }
                        } else {
                            // create cube
                            var voxel = new THREE.Mesh(self.cubeGeo, self.cubeMaterial);
                            voxel.position.copy(intersect.point).add(intersect.face.normal);
                            voxel.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
                            self.scene.add(voxel);

                            World.entities.push(voxel);

                        }

                        Renderer.renderWorld();
                    }
                }
            };

            self.onMouseUp = function (e) {
                if (e.which == 2) {
                    self.isMiddleMouseDown = false;
                }
            };
        };

        module.exports = Main;
    }, {"./input.js": 2, "./lib/jquery.js": 4, "./lib/orbitcontrols.js": 5, "./lib/three.js": 6, "./lib/underscore.js": 7, "./renderer.js": 9, "./world.js": 10}],
    9: [function (require, module, exports) {
        /**
         * The UI and World renderer
         * Created by Henry on 6/28/2015.
         */
        var $ = require("./lib/jquery.js");
        var THREE = require("./lib/three.js");
        var Main = require("./main.js");

        var Renderer = new function () {
            var self = this;

            self.container = $("<div>").appendTo(document.body);

            /**
             * WebGL Renderer
             */
            self.renderer = new THREE.WebGLRenderer({antialias: true});
            self.renderer.setClearColor(0xf0f0f0);
            self.renderer.setPixelRatio(window.devicePixelRatio);
            self.renderer.setSize(window.innerWidth, window.innerHeight);
            self.container.append(self.renderer.domElement);

            /**
             * Renders the user interface.
             */
            self.renderUI = function () {
                $("<div>")
                    .addClass("ui")
                    .addClass("header")
                    .append(
                    $("<h1>")
                        .html("Voxel Modeler")
                )
                    .appendTo(self.container);

                $("<div>")
                    .addClass("ui")
                    .addClass("panel")
                    .append(
                    $("<div>")
                        .append($("<h4>").html("Input Control"))
                        .append($("<p>").html("Middle - Rotate"))
                )
                    .append(
                    $("<button>")
                        .attr("type", "button")
                        .addClass("btn")
                        .addClass("btn-default")
                        .append(
                        $("<span>")
                            .addClass("glyphicon")
                            .addClass("glyphicon-plus")
                    )
                    //.bind("click", Main.)
                ).append(
                    $("<button>")
                        .attr("type", "button")
                        .addClass("btn")
                        .addClass("btn-default")
                        .append(
                        $("<span>")
                            .addClass("glyphicon")
                            .addClass("glyphicon-pencil")
                    )
                )
                    .appendTo(self.container);
            };

            /**
             * Renders the world.
             */
            self.renderWorld = function () {
                Main = require("./main.js");
                self.renderer.render(Main.scene, Main.camera);
            };
        };

        Renderer.renderUI();

        module.exports = Renderer;
    }, {"./lib/jquery.js": 4, "./lib/three.js": 6, "./main.js": 8}],
    10: [function (require, module, exports) {
        /**
         * The World singleton object that defines the world space
         * Created by Henry on 6/27/2015.
         */
        var THREE = require("./lib/three.js");

        var World = new function () {
            var self = this;

            self.scene = new THREE.Scene();

            /**
             * An array of objects in the world.
             * @type {Entity}
             */
            self.entities = [];

            /**
             * Adds an entity to the world
             * @param The entity to add
             */
            self.add = function (entity) {
                self.entities.push(entity);
            };
        };

        module.exports = World;
    }, {"./lib/three.js": 6}]
}, {}, [1])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJwdWJsaWMvamF2YXNjcmlwdHMvZW50cnkuanMiLCJwdWJsaWMvamF2YXNjcmlwdHMvaW5wdXQuanMiLCJwdWJsaWMvamF2YXNjcmlwdHMvbGliL2RldGVjdG9yLmpzIiwicHVibGljL2phdmFzY3JpcHRzL2xpYi9qcXVlcnkuanMiLCJwdWJsaWMvamF2YXNjcmlwdHMvbGliL29yYml0Y29udHJvbHMuanMiLCJwdWJsaWMvamF2YXNjcmlwdHMvbGliL3RocmVlLmpzIiwicHVibGljL2phdmFzY3JpcHRzL2xpYi91bmRlcnNjb3JlLmpzIiwicHVibGljL2phdmFzY3JpcHRzL21haW4uanMiLCJwdWJsaWMvamF2YXNjcmlwdHMvcmVuZGVyZXIuanMiLCJwdWJsaWMvamF2YXNjcmlwdHMvd29ybGQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0c0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIFRoZSBtYWluIEpTIGVudHJ5IHBvaW50IHRvIHJ1biB0aGUgYXBwbGljYXRpb25cbiAqIENyZWF0ZWQgYnkgSGVucnkgb24gNi8yNy8yMDE1LlxuICovXG52YXIgRGV0ZWN0b3IgPSByZXF1aXJlKFwiLi9saWIvZGV0ZWN0b3IuanNcIik7XG52YXIgTWFpbiA9IHJlcXVpcmUoXCIuL21haW4uanNcIik7XG5cbmlmICghRGV0ZWN0b3Iud2ViZ2wpIERldGVjdG9yLmFkZEdldFdlYkdMTWVzc2FnZSgpO1xuTWFpbi5pbml0KCk7IiwiLyoqXG4gKiBTdGF0aWMgc2luZ2xldG9uIGNsYXNzIHRoYXQgaGFuZGxlIGlucHV0c1xuICogQ3JlYXRlZCBieSBIZW5yeSBvbiA2LzI3LzIwMTUuXG4gKi9cblxudmFyICQgPSByZXF1aXJlKFwiLi9saWIvanF1ZXJ5LmpzXCIpO1xudmFyIF8gPSByZXF1aXJlKFwiLi9saWIvdW5kZXJzY29yZS5qc1wiKTtcbnZhciBNYWluID0gcmVxdWlyZShcIi4vbWFpbi5qc1wiKTtcblxudmFyIElucHV0ID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzZWxlY3RlZCBvYmplY3RcbiAgICAgKiBAdHlwZSB7Qm94fVxuICAgICAqL1xuICAgIHNlbGYuc2VsZWN0ZWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcHJlc3NlZCBrZXljb2Rlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBzZWxmLnByZXNzZWQgPSBbXTtcblxuICAgIC8vQmluZCBrZXlzXG4gICAgJChkb2N1bWVudCkuYmluZChcImtleWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNlbGYucHJlc3NlZC5wdXNoKGV2ZW50LmtleUNvZGUpO1xuICAgIH0pO1xuXG4gICAgJChkb2N1bWVudCkuYmluZChcImtleXVwXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzZWxmLnByZXNzZWQgPSBfLndpdGhvdXQoc2VsZi5wcmVzc2VkLCBldmVudC5rZXlDb2RlKTtcbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogRG9lcyBhIHJheXRyYWNlIHRvIGZpbmQgdGhlIG9iamVjdCBjdXJyZW50bHkgaGl0XG4gICAgICogQHJldHVybnMge0VudGl0eX0gVGhlIGhpdCBlbnRpdHlcbiAgICAgKi9cbiAgICBzZWxmLmdldEhpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTWFpbi5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzZWxmLm1vdXNlLCBzZWxmLmNhbWVyYSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3RzID0gc2VsZi5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0cyh3b3JsZC5lbnRpdGllcyk7XG5cbiAgICAgICAgaWYgKGludGVyc2VjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdHNbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0OyIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG52YXIgRGV0ZWN0b3IgPSB7XG4gICAgY2FudmFzOiAhIXdpbmRvdy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgd2ViZ2w6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICByZXR1cm4gISEoIHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgKCBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykgKSApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KSgpLFxuICAgIHdvcmtlcnM6ICEhd2luZG93LldvcmtlcixcbiAgICBmaWxlYXBpOiB3aW5kb3cuRmlsZSAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZUxpc3QgJiYgd2luZG93LkJsb2IsXG5cbiAgICBnZXRXZWJHTEVycm9yTWVzc2FnZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGVsZW1lbnQuaWQgPSAnd2ViZ2wtZXJyb3ItbWVzc2FnZSc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZm9udEZhbWlseSA9ICdtb25vc3BhY2UnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmZvbnRTaXplID0gJzEzcHgnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmZvbnRXZWlnaHQgPSAnbm9ybWFsJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kID0gJyNmZmYnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmNvbG9yID0gJyMwMDAnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmcgPSAnMS41ZW0nO1xuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gJzQwMHB4JztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5tYXJnaW4gPSAnNWVtIGF1dG8gMCc7XG5cbiAgICAgICAgaWYgKCF0aGlzLndlYmdsKSB7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCA/IFtcbiAgICAgICAgICAgICAgICAnWW91ciBncmFwaGljcyBjYXJkIGRvZXMgbm90IHNlZW0gdG8gc3VwcG9ydCA8YSBocmVmPVwiaHR0cDovL2tocm9ub3Mub3JnL3dlYmdsL3dpa2kvR2V0dGluZ19hX1dlYkdMX0ltcGxlbWVudGF0aW9uXCIgc3R5bGU9XCJjb2xvcjojMDAwXCI+V2ViR0w8L2E+LjxiciAvPicsXG4gICAgICAgICAgICAgICAgJ0ZpbmQgb3V0IGhvdyB0byBnZXQgaXQgPGEgaHJlZj1cImh0dHA6Ly9nZXQud2ViZ2wub3JnL1wiIHN0eWxlPVwiY29sb3I6IzAwMFwiPmhlcmU8L2E+LidcbiAgICAgICAgICAgIF0uam9pbignXFxuJykgOiBbXG4gICAgICAgICAgICAgICAgJ1lvdXIgYnJvd3NlciBkb2VzIG5vdCBzZWVtIHRvIHN1cHBvcnQgPGEgaHJlZj1cImh0dHA6Ly9raHJvbm9zLm9yZy93ZWJnbC93aWtpL0dldHRpbmdfYV9XZWJHTF9JbXBsZW1lbnRhdGlvblwiIHN0eWxlPVwiY29sb3I6IzAwMFwiPldlYkdMPC9hPi48YnIvPicsXG4gICAgICAgICAgICAgICAgJ0ZpbmQgb3V0IGhvdyB0byBnZXQgaXQgPGEgaHJlZj1cImh0dHA6Ly9nZXQud2ViZ2wub3JnL1wiIHN0eWxlPVwiY29sb3I6IzAwMFwiPmhlcmU8L2E+LidcbiAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuXG4gICAgfSxcblxuICAgIGFkZEdldFdlYkdMTWVzc2FnZTogZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcblxuICAgICAgICB2YXIgcGFyZW50LCBpZCwgZWxlbWVudDtcblxuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICAgICAgICBwYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wYXJlbnQgOiBkb2N1bWVudC5ib2R5O1xuICAgICAgICBpZCA9IHBhcmFtZXRlcnMuaWQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaWQgOiAnb2xkaWUnO1xuXG4gICAgICAgIGVsZW1lbnQgPSBEZXRlY3Rvci5nZXRXZWJHTEVycm9yTWVzc2FnZSgpO1xuICAgICAgICBlbGVtZW50LmlkID0gaWQ7XG5cbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXRlY3RvcjsiLCIvKiEgalF1ZXJ5IHYyLjEuNCB8IChjKSAyMDA1LCAyMDE1IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXG4hZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9YS5kb2N1bWVudD9iKGEsITApOmZ1bmN0aW9uKGEpe2lmKCFhLmRvY3VtZW50KXRocm93IG5ldyBFcnJvcihcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIik7cmV0dXJuIGIoYSl9OmIoYSl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnRoaXMsZnVuY3Rpb24oYSxiKXt2YXIgYz1bXSxkPWMuc2xpY2UsZT1jLmNvbmNhdCxmPWMucHVzaCxnPWMuaW5kZXhPZixoPXt9LGk9aC50b1N0cmluZyxqPWguaGFzT3duUHJvcGVydHksaz17fSxsPWEuZG9jdW1lbnQsbT1cIjIuMS40XCIsbj1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgbi5mbi5pbml0KGEsYil9LG89L15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLHA9L14tbXMtLyxxPS8tKFtcXGRhLXpdKS9naSxyPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudG9VcHBlckNhc2UoKX07bi5mbj1uLnByb3RvdHlwZT17anF1ZXJ5Om0sY29uc3RydWN0b3I6bixzZWxlY3RvcjpcIlwiLGxlbmd0aDowLHRvQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gZC5jYWxsKHRoaXMpfSxnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/MD5hP3RoaXNbYSt0aGlzLmxlbmd0aF06dGhpc1thXTpkLmNhbGwodGhpcyl9LHB1c2hTdGFjazpmdW5jdGlvbihhKXt2YXIgYj1uLm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSxhKTtyZXR1cm4gYi5wcmV2T2JqZWN0PXRoaXMsYi5jb250ZXh0PXRoaXMuY29udGV4dCxifSxlYWNoOmZ1bmN0aW9uKGEsYil7cmV0dXJuIG4uZWFjaCh0aGlzLGEsYil9LG1hcDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2sobi5tYXAodGhpcyxmdW5jdGlvbihiLGMpe3JldHVybiBhLmNhbGwoYixjLGIpfSkpfSxzbGljZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFjayhkLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9LGZpcnN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoMCl9LGxhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcSgtMSl9LGVxOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGVuZ3RoLGM9K2ErKDA+YT9iOjApO3JldHVybiB0aGlzLnB1c2hTdGFjayhjPj0wJiZiPmM/W3RoaXNbY11dOltdKX0sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJldk9iamVjdHx8dGhpcy5jb25zdHJ1Y3RvcihudWxsKX0scHVzaDpmLHNvcnQ6Yy5zb3J0LHNwbGljZTpjLnNwbGljZX0sbi5leHRlbmQ9bi5mbi5leHRlbmQ9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZz1hcmd1bWVudHNbMF18fHt9LGg9MSxpPWFyZ3VtZW50cy5sZW5ndGgsaj0hMTtmb3IoXCJib29sZWFuXCI9PXR5cGVvZiBnJiYoaj1nLGc9YXJndW1lbnRzW2hdfHx7fSxoKyspLFwib2JqZWN0XCI9PXR5cGVvZiBnfHxuLmlzRnVuY3Rpb24oZyl8fChnPXt9KSxoPT09aSYmKGc9dGhpcyxoLS0pO2k+aDtoKyspaWYobnVsbCE9KGE9YXJndW1lbnRzW2hdKSlmb3IoYiBpbiBhKWM9Z1tiXSxkPWFbYl0sZyE9PWQmJihqJiZkJiYobi5pc1BsYWluT2JqZWN0KGQpfHwoZT1uLmlzQXJyYXkoZCkpKT8oZT8oZT0hMSxmPWMmJm4uaXNBcnJheShjKT9jOltdKTpmPWMmJm4uaXNQbGFpbk9iamVjdChjKT9jOnt9LGdbYl09bi5leHRlbmQoaixmLGQpKTp2b2lkIDAhPT1kJiYoZ1tiXT1kKSk7cmV0dXJuIGd9LG4uZXh0ZW5kKHtleHBhbmRvOlwialF1ZXJ5XCIrKG0rTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csXCJcIiksaXNSZWFkeTohMCxlcnJvcjpmdW5jdGlvbihhKXt0aHJvdyBuZXcgRXJyb3IoYSl9LG5vb3A6ZnVuY3Rpb24oKXt9LGlzRnVuY3Rpb246ZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT09bi50eXBlKGEpfSxpc0FycmF5OkFycmF5LmlzQXJyYXksaXNXaW5kb3c6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJmE9PT1hLndpbmRvd30saXNOdW1lcmljOmZ1bmN0aW9uKGEpe3JldHVybiFuLmlzQXJyYXkoYSkmJmEtcGFyc2VGbG9hdChhKSsxPj0wfSxpc1BsYWluT2JqZWN0OmZ1bmN0aW9uKGEpe3JldHVyblwib2JqZWN0XCIhPT1uLnR5cGUoYSl8fGEubm9kZVR5cGV8fG4uaXNXaW5kb3coYSk/ITE6YS5jb25zdHJ1Y3RvciYmIWouY2FsbChhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxcImlzUHJvdG90eXBlT2ZcIik/ITE6ITB9LGlzRW1wdHlPYmplY3Q6ZnVuY3Rpb24oYSl7dmFyIGI7Zm9yKGIgaW4gYSlyZXR1cm4hMTtyZXR1cm4hMH0sdHlwZTpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YT9hK1wiXCI6XCJvYmplY3RcIj09dHlwZW9mIGF8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGE/aFtpLmNhbGwoYSldfHxcIm9iamVjdFwiOnR5cGVvZiBhfSxnbG9iYWxFdmFsOmZ1bmN0aW9uKGEpe3ZhciBiLGM9ZXZhbDthPW4udHJpbShhKSxhJiYoMT09PWEuaW5kZXhPZihcInVzZSBzdHJpY3RcIik/KGI9bC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLGIudGV4dD1hLGwuaGVhZC5hcHBlbmRDaGlsZChiKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpKTpjKGEpKX0sY2FtZWxDYXNlOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UocCxcIm1zLVwiKS5yZXBsYWNlKHEscil9LG5vZGVOYW1lOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PWIudG9Mb3dlckNhc2UoKX0sZWFjaDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZT0wLGY9YS5sZW5ndGgsZz1zKGEpO2lmKGMpe2lmKGcpe2Zvcig7Zj5lO2UrKylpZihkPWIuYXBwbHkoYVtlXSxjKSxkPT09ITEpYnJlYWt9ZWxzZSBmb3IoZSBpbiBhKWlmKGQ9Yi5hcHBseShhW2VdLGMpLGQ9PT0hMSlicmVha31lbHNlIGlmKGcpe2Zvcig7Zj5lO2UrKylpZihkPWIuY2FsbChhW2VdLGUsYVtlXSksZD09PSExKWJyZWFrfWVsc2UgZm9yKGUgaW4gYSlpZihkPWIuY2FsbChhW2VdLGUsYVtlXSksZD09PSExKWJyZWFrO3JldHVybiBhfSx0cmltOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP1wiXCI6KGErXCJcIikucmVwbGFjZShvLFwiXCIpfSxtYWtlQXJyYXk6ZnVuY3Rpb24oYSxiKXt2YXIgYz1ifHxbXTtyZXR1cm4gbnVsbCE9YSYmKHMoT2JqZWN0KGEpKT9uLm1lcmdlKGMsXCJzdHJpbmdcIj09dHlwZW9mIGE/W2FdOmEpOmYuY2FsbChjLGEpKSxjfSxpbkFycmF5OmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbnVsbD09Yj8tMTpnLmNhbGwoYixhLGMpfSxtZXJnZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0rYi5sZW5ndGgsZD0wLGU9YS5sZW5ndGg7Yz5kO2QrKylhW2UrK109YltkXTtyZXR1cm4gYS5sZW5ndGg9ZSxhfSxncmVwOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQsZT1bXSxmPTAsZz1hLmxlbmd0aCxoPSFjO2c+ZjtmKyspZD0hYihhW2ZdLGYpLGQhPT1oJiZlLnB1c2goYVtmXSk7cmV0dXJuIGV9LG1hcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZj0wLGc9YS5sZW5ndGgsaD1zKGEpLGk9W107aWYoaClmb3IoO2c+ZjtmKyspZD1iKGFbZl0sZixjKSxudWxsIT1kJiZpLnB1c2goZCk7ZWxzZSBmb3IoZiBpbiBhKWQ9YihhW2ZdLGYsYyksbnVsbCE9ZCYmaS5wdXNoKGQpO3JldHVybiBlLmFwcGx5KFtdLGkpfSxndWlkOjEscHJveHk6ZnVuY3Rpb24oYSxiKXt2YXIgYyxlLGY7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGImJihjPWFbYl0sYj1hLGE9Yyksbi5pc0Z1bmN0aW9uKGEpPyhlPWQuY2FsbChhcmd1bWVudHMsMiksZj1mdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGJ8fHRoaXMsZS5jb25jYXQoZC5jYWxsKGFyZ3VtZW50cykpKX0sZi5ndWlkPWEuZ3VpZD1hLmd1aWR8fG4uZ3VpZCsrLGYpOnZvaWQgMH0sbm93OkRhdGUubm93LHN1cHBvcnQ6a30pLG4uZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oYSxiKXtoW1wiW29iamVjdCBcIitiK1wiXVwiXT1iLnRvTG93ZXJDYXNlKCl9KTtmdW5jdGlvbiBzKGEpe3ZhciBiPVwibGVuZ3RoXCJpbiBhJiZhLmxlbmd0aCxjPW4udHlwZShhKTtyZXR1cm5cImZ1bmN0aW9uXCI9PT1jfHxuLmlzV2luZG93KGEpPyExOjE9PT1hLm5vZGVUeXBlJiZiPyEwOlwiYXJyYXlcIj09PWN8fDA9PT1ifHxcIm51bWJlclwiPT10eXBlb2YgYiYmYj4wJiZiLTEgaW4gYX12YXIgdD1mdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaCxpLGosayxsLG0sbixvLHAscSxyLHMsdCx1PVwic2l6emxlXCIrMSpuZXcgRGF0ZSx2PWEuZG9jdW1lbnQsdz0wLHg9MCx5PWhhKCksej1oYSgpLEE9aGEoKSxCPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9PT1iJiYobD0hMCksMH0sQz0xPDwzMSxEPXt9Lmhhc093blByb3BlcnR5LEU9W10sRj1FLnBvcCxHPUUucHVzaCxIPUUucHVzaCxJPUUuc2xpY2UsSj1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGg7ZD5jO2MrKylpZihhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sSz1cImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsTD1cIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsTT1cIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLE49TS5yZXBsYWNlKFwid1wiLFwidyNcIiksTz1cIlxcXFxbXCIrTCtcIiooXCIrTStcIikoPzpcIitMK1wiKihbKl4kfCF+XT89KVwiK0wrXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIitOK1wiKSl8KVwiK0wrXCIqXFxcXF1cIixQPVwiOihcIitNK1wiKSg/OlxcXFwoKCgnKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIitPK1wiKSopfC4qKVxcXFwpfClcIixRPW5ldyBSZWdFeHAoTCtcIitcIixcImdcIiksUj1uZXcgUmVnRXhwKFwiXlwiK0wrXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiK0wrXCIrJFwiLFwiZ1wiKSxTPW5ldyBSZWdFeHAoXCJeXCIrTCtcIiosXCIrTCtcIipcIiksVD1uZXcgUmVnRXhwKFwiXlwiK0wrXCIqKFs+K35dfFwiK0wrXCIpXCIrTCtcIipcIiksVT1uZXcgUmVnRXhwKFwiPVwiK0wrXCIqKFteXFxcXF0nXFxcIl0qPylcIitMK1wiKlxcXFxdXCIsXCJnXCIpLFY9bmV3IFJlZ0V4cChQKSxXPW5ldyBSZWdFeHAoXCJeXCIrTitcIiRcIiksWD17SUQ6bmV3IFJlZ0V4cChcIl4jKFwiK00rXCIpXCIpLENMQVNTOm5ldyBSZWdFeHAoXCJeXFxcXC4oXCIrTStcIilcIiksVEFHOm5ldyBSZWdFeHAoXCJeKFwiK00ucmVwbGFjZShcIndcIixcIncqXCIpK1wiKVwiKSxBVFRSOm5ldyBSZWdFeHAoXCJeXCIrTyksUFNFVURPOm5ldyBSZWdFeHAoXCJeXCIrUCksQ0hJTEQ6bmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIrTCtcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiK0wrXCIqKD86KFsrLV18KVwiK0wrXCIqKFxcXFxkKyl8KSlcIitMK1wiKlxcXFwpfClcIixcImlcIiksYm9vbDpuZXcgUmVnRXhwKFwiXig/OlwiK0srXCIpJFwiLFwiaVwiKSxuZWVkc0NvbnRleHQ6bmV3IFJlZ0V4cChcIl5cIitMK1wiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIitMK1wiKigoPzotXFxcXGQpP1xcXFxkKilcIitMK1wiKlxcXFwpfCkoPz1bXi1dfCQpXCIsXCJpXCIpfSxZPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksWj0vXmhcXGQkL2ksJD0vXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLF89L14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sYWE9L1srfl0vLGJhPS8nfFxcXFwvZyxjYT1uZXcgUmVnRXhwKFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIrTCtcIj98KFwiK0wrXCIpfC4pXCIsXCJpZ1wiKSxkYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9XCIweFwiK2ItNjU1MzY7cmV0dXJuIGQhPT1kfHxjP2I6MD5kP1N0cmluZy5mcm9tQ2hhckNvZGUoZCs2NTUzNik6U3RyaW5nLmZyb21DaGFyQ29kZShkPj4xMHw1NTI5NiwxMDIzJmR8NTYzMjApfSxlYT1mdW5jdGlvbigpe20oKX07dHJ5e0guYXBwbHkoRT1JLmNhbGwodi5jaGlsZE5vZGVzKSx2LmNoaWxkTm9kZXMpLEVbdi5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGV9Y2F0Y2goZmEpe0g9e2FwcGx5OkUubGVuZ3RoP2Z1bmN0aW9uKGEsYil7Ry5hcHBseShhLEkuY2FsbChiKSl9OmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5sZW5ndGgsZD0wO3doaWxlKGFbYysrXT1iW2QrK10pO2EubGVuZ3RoPWMtMX19fWZ1bmN0aW9uIGdhKGEsYixkLGUpe3ZhciBmLGgsaixrLGwsbyxyLHMsdyx4O2lmKChiP2Iub3duZXJEb2N1bWVudHx8Yjp2KSE9PW4mJm0oYiksYj1ifHxuLGQ9ZHx8W10saz1iLm5vZGVUeXBlLFwic3RyaW5nXCIhPXR5cGVvZiBhfHwhYXx8MSE9PWsmJjkhPT1rJiYxMSE9PWspcmV0dXJuIGQ7aWYoIWUmJnApe2lmKDExIT09ayYmKGY9Xy5leGVjKGEpKSlpZihqPWZbMV0pe2lmKDk9PT1rKXtpZihoPWIuZ2V0RWxlbWVudEJ5SWQoaiksIWh8fCFoLnBhcmVudE5vZGUpcmV0dXJuIGQ7aWYoaC5pZD09PWopcmV0dXJuIGQucHVzaChoKSxkfWVsc2UgaWYoYi5vd25lckRvY3VtZW50JiYoaD1iLm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaikpJiZ0KGIsaCkmJmguaWQ9PT1qKXJldHVybiBkLnB1c2goaCksZH1lbHNle2lmKGZbMl0pcmV0dXJuIEguYXBwbHkoZCxiLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpKSxkO2lmKChqPWZbM10pJiZjLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpcmV0dXJuIEguYXBwbHkoZCxiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaikpLGR9aWYoYy5xc2EmJighcXx8IXEudGVzdChhKSkpe2lmKHM9cj11LHc9Yix4PTEhPT1rJiZhLDE9PT1rJiZcIm9iamVjdFwiIT09Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXtvPWcoYSksKHI9Yi5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk/cz1yLnJlcGxhY2UoYmEsXCJcXFxcJCZcIik6Yi5zZXRBdHRyaWJ1dGUoXCJpZFwiLHMpLHM9XCJbaWQ9J1wiK3MrXCInXSBcIixsPW8ubGVuZ3RoO3doaWxlKGwtLSlvW2xdPXMrcmEob1tsXSk7dz1hYS50ZXN0KGEpJiZwYShiLnBhcmVudE5vZGUpfHxiLHg9by5qb2luKFwiLFwiKX1pZih4KXRyeXtyZXR1cm4gSC5hcHBseShkLHcucXVlcnlTZWxlY3RvckFsbCh4KSksZH1jYXRjaCh5KXt9ZmluYWxseXtyfHxiLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpfX19cmV0dXJuIGkoYS5yZXBsYWNlKFIsXCIkMVwiKSxiLGQsZSl9ZnVuY3Rpb24gaGEoKXt2YXIgYT1bXTtmdW5jdGlvbiBiKGMsZSl7cmV0dXJuIGEucHVzaChjK1wiIFwiKT5kLmNhY2hlTGVuZ3RoJiZkZWxldGUgYlthLnNoaWZ0KCldLGJbYytcIiBcIl09ZX1yZXR1cm4gYn1mdW5jdGlvbiBpYShhKXtyZXR1cm4gYVt1XT0hMCxhfWZ1bmN0aW9uIGphKGEpe3ZhciBiPW4uY3JlYXRlRWxlbWVudChcImRpdlwiKTt0cnl7cmV0dXJuISFhKGIpfWNhdGNoKGMpe3JldHVybiExfWZpbmFsbHl7Yi5wYXJlbnROb2RlJiZiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYiksYj1udWxsfX1mdW5jdGlvbiBrYShhLGIpe3ZhciBjPWEuc3BsaXQoXCJ8XCIpLGU9YS5sZW5ndGg7d2hpbGUoZS0tKWQuYXR0ckhhbmRsZVtjW2VdXT1ifWZ1bmN0aW9uIGxhKGEsYil7dmFyIGM9YiYmYSxkPWMmJjE9PT1hLm5vZGVUeXBlJiYxPT09Yi5ub2RlVHlwZSYmKH5iLnNvdXJjZUluZGV4fHxDKS0ofmEuc291cmNlSW5kZXh8fEMpO2lmKGQpcmV0dXJuIGQ7aWYoYyl3aGlsZShjPWMubmV4dFNpYmxpbmcpaWYoYz09PWIpcmV0dXJuLTE7cmV0dXJuIGE/MTotMX1mdW5jdGlvbiBtYShhKXtyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGM9Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWMmJmIudHlwZT09PWF9fWZ1bmN0aW9uIG5hKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuKFwiaW5wdXRcIj09PWN8fFwiYnV0dG9uXCI9PT1jKSYmYi50eXBlPT09YX19ZnVuY3Rpb24gb2EoYSl7cmV0dXJuIGlhKGZ1bmN0aW9uKGIpe3JldHVybiBiPStiLGlhKGZ1bmN0aW9uKGMsZCl7dmFyIGUsZj1hKFtdLGMubGVuZ3RoLGIpLGc9Zi5sZW5ndGg7d2hpbGUoZy0tKWNbZT1mW2ddXSYmKGNbZV09IShkW2VdPWNbZV0pKX0pfSl9ZnVuY3Rpb24gcGEoYSl7cmV0dXJuIGEmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmdldEVsZW1lbnRzQnlUYWdOYW1lJiZhfWM9Z2Euc3VwcG9ydD17fSxmPWdhLmlzWE1MPWZ1bmN0aW9uKGEpe3ZhciBiPWEmJihhLm93bmVyRG9jdW1lbnR8fGEpLmRvY3VtZW50RWxlbWVudDtyZXR1cm4gYj9cIkhUTUxcIiE9PWIubm9kZU5hbWU6ITF9LG09Z2Euc2V0RG9jdW1lbnQ9ZnVuY3Rpb24oYSl7dmFyIGIsZSxnPWE/YS5vd25lckRvY3VtZW50fHxhOnY7cmV0dXJuIGchPT1uJiY5PT09Zy5ub2RlVHlwZSYmZy5kb2N1bWVudEVsZW1lbnQ/KG49ZyxvPWcuZG9jdW1lbnRFbGVtZW50LGU9Zy5kZWZhdWx0VmlldyxlJiZlIT09ZS50b3AmJihlLmFkZEV2ZW50TGlzdGVuZXI/ZS5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsZWEsITEpOmUuYXR0YWNoRXZlbnQmJmUuYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLGVhKSkscD0hZihnKSxjLmF0dHJpYnV0ZXM9amEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuY2xhc3NOYW1lPVwiaVwiLCFhLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKX0pLGMuZ2V0RWxlbWVudHNCeVRhZ05hbWU9amEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuYXBwZW5kQ2hpbGQoZy5jcmVhdGVDb21tZW50KFwiXCIpKSwhYS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RofSksYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lPSQudGVzdChnLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLGMuZ2V0QnlJZD1qYShmdW5jdGlvbihhKXtyZXR1cm4gby5hcHBlbmRDaGlsZChhKS5pZD11LCFnLmdldEVsZW1lbnRzQnlOYW1lfHwhZy5nZXRFbGVtZW50c0J5TmFtZSh1KS5sZW5ndGh9KSxjLmdldEJ5SWQ/KGQuZmluZC5JRD1mdW5jdGlvbihhLGIpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBiLmdldEVsZW1lbnRCeUlkJiZwKXt2YXIgYz1iLmdldEVsZW1lbnRCeUlkKGEpO3JldHVybiBjJiZjLnBhcmVudE5vZGU/W2NdOltdfX0sZC5maWx0ZXIuSUQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKGNhLGRhKTtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGEuZ2V0QXR0cmlidXRlKFwiaWRcIik9PT1ifX0pOihkZWxldGUgZC5maW5kLklELGQuZmlsdGVyLklEPWZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShjYSxkYSk7cmV0dXJuIGZ1bmN0aW9uKGEpe3ZhciBjPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmdldEF0dHJpYnV0ZU5vZGUmJmEuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO3JldHVybiBjJiZjLnZhbHVlPT09Yn19KSxkLmZpbmQuVEFHPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWU/ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgYi5nZXRFbGVtZW50c0J5VGFnTmFtZT9iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpOmMucXNhP2IucXVlcnlTZWxlY3RvckFsbChhKTp2b2lkIDB9OmZ1bmN0aW9uKGEsYil7dmFyIGMsZD1bXSxlPTAsZj1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpO2lmKFwiKlwiPT09YSl7d2hpbGUoYz1mW2UrK10pMT09PWMubm9kZVR5cGUmJmQucHVzaChjKTtyZXR1cm4gZH1yZXR1cm4gZn0sZC5maW5kLkNMQVNTPWMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmZnVuY3Rpb24oYSxiKXtyZXR1cm4gcD9iLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYSk6dm9pZCAwfSxyPVtdLHE9W10sKGMucXNhPSQudGVzdChnLnF1ZXJ5U2VsZWN0b3JBbGwpKSYmKGphKGZ1bmN0aW9uKGEpe28uYXBwZW5kQ2hpbGQoYSkuaW5uZXJIVE1MPVwiPGEgaWQ9J1wiK3UrXCInPjwvYT48c2VsZWN0IGlkPSdcIit1K1wiLVxcZl0nIG1zYWxsb3djYXB0dXJlPScnPjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCIsYS5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoJiZxLnB1c2goXCJbKl4kXT1cIitMK1wiKig/OicnfFxcXCJcXFwiKVwiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aHx8cS5wdXNoKFwiXFxcXFtcIitMK1wiKig/OnZhbHVlfFwiK0srXCIpXCIpLGEucXVlcnlTZWxlY3RvckFsbChcIltpZH49XCIrdStcIi1dXCIpLmxlbmd0aHx8cS5wdXNoKFwifj1cIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RofHxxLnB1c2goXCI6Y2hlY2tlZFwiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhI1wiK3UrXCIrKlwiKS5sZW5ndGh8fHEucHVzaChcIi4jLitbK35dXCIpfSksamEoZnVuY3Rpb24oYSl7dmFyIGI9Zy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7Yi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJoaWRkZW5cIiksYS5hcHBlbmRDaGlsZChiKS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJEXCIpLGEucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCYmcS5wdXNoKFwibmFtZVwiK0wrXCIqWypeJHwhfl0/PVwiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGh8fHEucHVzaChcIjplbmFibGVkXCIsXCI6ZGlzYWJsZWRcIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKSxxLnB1c2goXCIsLio6XCIpfSkpLChjLm1hdGNoZXNTZWxlY3Rvcj0kLnRlc3Qocz1vLm1hdGNoZXN8fG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHxvLm1vek1hdGNoZXNTZWxlY3Rvcnx8by5vTWF0Y2hlc1NlbGVjdG9yfHxvLm1zTWF0Y2hlc1NlbGVjdG9yKSkmJmphKGZ1bmN0aW9uKGEpe2MuZGlzY29ubmVjdGVkTWF0Y2g9cy5jYWxsKGEsXCJkaXZcIikscy5jYWxsKGEsXCJbcyE9JyddOnhcIiksci5wdXNoKFwiIT1cIixQKX0pLHE9cS5sZW5ndGgmJm5ldyBSZWdFeHAocS5qb2luKFwifFwiKSkscj1yLmxlbmd0aCYmbmV3IFJlZ0V4cChyLmpvaW4oXCJ8XCIpKSxiPSQudGVzdChvLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSx0PWJ8fCQudGVzdChvLmNvbnRhaW5zKT9mdW5jdGlvbihhLGIpe3ZhciBjPTk9PT1hLm5vZGVUeXBlP2EuZG9jdW1lbnRFbGVtZW50OmEsZD1iJiZiLnBhcmVudE5vZGU7cmV0dXJuIGE9PT1kfHwhKCFkfHwxIT09ZC5ub2RlVHlwZXx8IShjLmNvbnRhaW5zP2MuY29udGFpbnMoZCk6YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmMTYmYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkKSkpfTpmdW5jdGlvbihhLGIpe2lmKGIpd2hpbGUoYj1iLnBhcmVudE5vZGUpaWYoYj09PWEpcmV0dXJuITA7cmV0dXJuITF9LEI9Yj9mdW5jdGlvbihhLGIpe2lmKGE9PT1iKXJldHVybiBsPSEwLDA7dmFyIGQ9IWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24tIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247cmV0dXJuIGQ/ZDooZD0oYS5vd25lckRvY3VtZW50fHxhKT09PShiLm93bmVyRG9jdW1lbnR8fGIpP2EuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYik6MSwxJmR8fCFjLnNvcnREZXRhY2hlZCYmYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhKT09PWQ/YT09PWd8fGEub3duZXJEb2N1bWVudD09PXYmJnQodixhKT8tMTpiPT09Z3x8Yi5vd25lckRvY3VtZW50PT09diYmdCh2LGIpPzE6az9KKGssYSktSihrLGIpOjA6NCZkPy0xOjEpfTpmdW5jdGlvbihhLGIpe2lmKGE9PT1iKXJldHVybiBsPSEwLDA7dmFyIGMsZD0wLGU9YS5wYXJlbnROb2RlLGY9Yi5wYXJlbnROb2RlLGg9W2FdLGk9W2JdO2lmKCFlfHwhZilyZXR1cm4gYT09PWc/LTE6Yj09PWc/MTplPy0xOmY/MTprP0ooayxhKS1KKGssYik6MDtpZihlPT09ZilyZXR1cm4gbGEoYSxiKTtjPWE7d2hpbGUoYz1jLnBhcmVudE5vZGUpaC51bnNoaWZ0KGMpO2M9Yjt3aGlsZShjPWMucGFyZW50Tm9kZSlpLnVuc2hpZnQoYyk7d2hpbGUoaFtkXT09PWlbZF0pZCsrO3JldHVybiBkP2xhKGhbZF0saVtkXSk6aFtkXT09PXY/LTE6aVtkXT09PXY/MTowfSxnKTpufSxnYS5tYXRjaGVzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGdhKGEsbnVsbCxudWxsLGIpfSxnYS5tYXRjaGVzU2VsZWN0b3I9ZnVuY3Rpb24oYSxiKXtpZigoYS5vd25lckRvY3VtZW50fHxhKSE9PW4mJm0oYSksYj1iLnJlcGxhY2UoVSxcIj0nJDEnXVwiKSwhKCFjLm1hdGNoZXNTZWxlY3Rvcnx8IXB8fHImJnIudGVzdChiKXx8cSYmcS50ZXN0KGIpKSl0cnl7dmFyIGQ9cy5jYWxsKGEsYik7aWYoZHx8Yy5kaXNjb25uZWN0ZWRNYXRjaHx8YS5kb2N1bWVudCYmMTEhPT1hLmRvY3VtZW50Lm5vZGVUeXBlKXJldHVybiBkfWNhdGNoKGUpe31yZXR1cm4gZ2EoYixuLG51bGwsW2FdKS5sZW5ndGg+MH0sZ2EuY29udGFpbnM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYS5vd25lckRvY3VtZW50fHxhKSE9PW4mJm0oYSksdChhLGIpfSxnYS5hdHRyPWZ1bmN0aW9uKGEsYil7KGEub3duZXJEb2N1bWVudHx8YSkhPT1uJiZtKGEpO3ZhciBlPWQuYXR0ckhhbmRsZVtiLnRvTG93ZXJDYXNlKCldLGY9ZSYmRC5jYWxsKGQuYXR0ckhhbmRsZSxiLnRvTG93ZXJDYXNlKCkpP2UoYSxiLCFwKTp2b2lkIDA7cmV0dXJuIHZvaWQgMCE9PWY/ZjpjLmF0dHJpYnV0ZXN8fCFwP2EuZ2V0QXR0cmlidXRlKGIpOihmPWEuZ2V0QXR0cmlidXRlTm9kZShiKSkmJmYuc3BlY2lmaWVkP2YudmFsdWU6bnVsbH0sZ2EuZXJyb3I9ZnVuY3Rpb24oYSl7dGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIrYSl9LGdhLnVuaXF1ZVNvcnQ9ZnVuY3Rpb24oYSl7dmFyIGIsZD1bXSxlPTAsZj0wO2lmKGw9IWMuZGV0ZWN0RHVwbGljYXRlcyxrPSFjLnNvcnRTdGFibGUmJmEuc2xpY2UoMCksYS5zb3J0KEIpLGwpe3doaWxlKGI9YVtmKytdKWI9PT1hW2ZdJiYoZT1kLnB1c2goZikpO3doaWxlKGUtLSlhLnNwbGljZShkW2VdLDEpfXJldHVybiBrPW51bGwsYX0sZT1nYS5nZXRUZXh0PWZ1bmN0aW9uKGEpe3ZhciBiLGM9XCJcIixkPTAsZj1hLm5vZGVUeXBlO2lmKGYpe2lmKDE9PT1mfHw5PT09Znx8MTE9PT1mKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYS50ZXh0Q29udGVudClyZXR1cm4gYS50ZXh0Q29udGVudDtmb3IoYT1hLmZpcnN0Q2hpbGQ7YTthPWEubmV4dFNpYmxpbmcpYys9ZShhKX1lbHNlIGlmKDM9PT1mfHw0PT09ZilyZXR1cm4gYS5ub2RlVmFsdWV9ZWxzZSB3aGlsZShiPWFbZCsrXSljKz1lKGIpO3JldHVybiBjfSxkPWdhLnNlbGVjdG9ycz17Y2FjaGVMZW5ndGg6NTAsY3JlYXRlUHNldWRvOmlhLG1hdGNoOlgsYXR0ckhhbmRsZTp7fSxmaW5kOnt9LHJlbGF0aXZlOntcIj5cIjp7ZGlyOlwicGFyZW50Tm9kZVwiLGZpcnN0OiEwfSxcIiBcIjp7ZGlyOlwicGFyZW50Tm9kZVwifSxcIitcIjp7ZGlyOlwicHJldmlvdXNTaWJsaW5nXCIsZmlyc3Q6ITB9LFwiflwiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIn19LHByZUZpbHRlcjp7QVRUUjpmdW5jdGlvbihhKXtyZXR1cm4gYVsxXT1hWzFdLnJlcGxhY2UoY2EsZGEpLGFbM109KGFbM118fGFbNF18fGFbNV18fFwiXCIpLnJlcGxhY2UoY2EsZGEpLFwifj1cIj09PWFbMl0mJihhWzNdPVwiIFwiK2FbM10rXCIgXCIpLGEuc2xpY2UoMCw0KX0sQ0hJTEQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGFbMV09YVsxXS50b0xvd2VyQ2FzZSgpLFwibnRoXCI9PT1hWzFdLnNsaWNlKDAsMyk/KGFbM118fGdhLmVycm9yKGFbMF0pLGFbNF09KyhhWzRdP2FbNV0rKGFbNl18fDEpOjIqKFwiZXZlblwiPT09YVszXXx8XCJvZGRcIj09PWFbM10pKSxhWzVdPSsoYVs3XSthWzhdfHxcIm9kZFwiPT09YVszXSkpOmFbM10mJmdhLmVycm9yKGFbMF0pLGF9LFBTRVVETzpmdW5jdGlvbihhKXt2YXIgYixjPSFhWzZdJiZhWzJdO3JldHVybiBYLkNISUxELnRlc3QoYVswXSk/bnVsbDooYVszXT9hWzJdPWFbNF18fGFbNV18fFwiXCI6YyYmVi50ZXN0KGMpJiYoYj1nKGMsITApKSYmKGI9Yy5pbmRleE9mKFwiKVwiLGMubGVuZ3RoLWIpLWMubGVuZ3RoKSYmKGFbMF09YVswXS5zbGljZSgwLGIpLGFbMl09Yy5zbGljZSgwLGIpKSxhLnNsaWNlKDAsMykpfX0sZmlsdGVyOntUQUc6ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKGNhLGRhKS50b0xvd2VyQ2FzZSgpO3JldHVyblwiKlwiPT09YT9mdW5jdGlvbigpe3JldHVybiEwfTpmdW5jdGlvbihhKXtyZXR1cm4gYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09Yn19LENMQVNTOmZ1bmN0aW9uKGEpe3ZhciBiPXlbYStcIiBcIl07cmV0dXJuIGJ8fChiPW5ldyBSZWdFeHAoXCIoXnxcIitMK1wiKVwiK2ErXCIoXCIrTCtcInwkKVwiKSkmJnkoYSxmdW5jdGlvbihhKXtyZXR1cm4gYi50ZXN0KFwic3RyaW5nXCI9PXR5cGVvZiBhLmNsYXNzTmFtZSYmYS5jbGFzc05hbWV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmdldEF0dHJpYnV0ZSYmYS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIil9KX0sQVRUUjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGZ1bmN0aW9uKGQpe3ZhciBlPWdhLmF0dHIoZCxhKTtyZXR1cm4gbnVsbD09ZT9cIiE9XCI9PT1iOmI/KGUrPVwiXCIsXCI9XCI9PT1iP2U9PT1jOlwiIT1cIj09PWI/ZSE9PWM6XCJePVwiPT09Yj9jJiYwPT09ZS5pbmRleE9mKGMpOlwiKj1cIj09PWI/YyYmZS5pbmRleE9mKGMpPi0xOlwiJD1cIj09PWI/YyYmZS5zbGljZSgtYy5sZW5ndGgpPT09YzpcIn49XCI9PT1iPyhcIiBcIitlLnJlcGxhY2UoUSxcIiBcIikrXCIgXCIpLmluZGV4T2YoYyk+LTE6XCJ8PVwiPT09Yj9lPT09Y3x8ZS5zbGljZSgwLGMubGVuZ3RoKzEpPT09YytcIi1cIjohMSk6ITB9fSxDSElMRDpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPVwibnRoXCIhPT1hLnNsaWNlKDAsMyksZz1cImxhc3RcIiE9PWEuc2xpY2UoLTQpLGg9XCJvZi10eXBlXCI9PT1iO3JldHVybiAxPT09ZCYmMD09PWU/ZnVuY3Rpb24oYSl7cmV0dXJuISFhLnBhcmVudE5vZGV9OmZ1bmN0aW9uKGIsYyxpKXt2YXIgaixrLGwsbSxuLG8scD1mIT09Zz9cIm5leHRTaWJsaW5nXCI6XCJwcmV2aW91c1NpYmxpbmdcIixxPWIucGFyZW50Tm9kZSxyPWgmJmIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxzPSFpJiYhaDtpZihxKXtpZihmKXt3aGlsZShwKXtsPWI7d2hpbGUobD1sW3BdKWlmKGg/bC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09cjoxPT09bC5ub2RlVHlwZSlyZXR1cm4hMTtvPXA9XCJvbmx5XCI9PT1hJiYhbyYmXCJuZXh0U2libGluZ1wifXJldHVybiEwfWlmKG89W2c/cS5maXJzdENoaWxkOnEubGFzdENoaWxkXSxnJiZzKXtrPXFbdV18fChxW3VdPXt9KSxqPWtbYV18fFtdLG49alswXT09PXcmJmpbMV0sbT1qWzBdPT09dyYmalsyXSxsPW4mJnEuY2hpbGROb2Rlc1tuXTt3aGlsZShsPSsrbiYmbCYmbFtwXXx8KG09bj0wKXx8by5wb3AoKSlpZigxPT09bC5ub2RlVHlwZSYmKyttJiZsPT09Yil7a1thXT1bdyxuLG1dO2JyZWFrfX1lbHNlIGlmKHMmJihqPShiW3VdfHwoYlt1XT17fSkpW2FdKSYmalswXT09PXcpbT1qWzFdO2Vsc2Ugd2hpbGUobD0rK24mJmwmJmxbcF18fChtPW49MCl8fG8ucG9wKCkpaWYoKGg/bC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09cjoxPT09bC5ub2RlVHlwZSkmJisrbSYmKHMmJigobFt1XXx8KGxbdV09e30pKVthXT1bdyxtXSksbD09PWIpKWJyZWFrO3JldHVybiBtLT1lLG09PT1kfHxtJWQ9PT0wJiZtL2Q+PTB9fX0sUFNFVURPOmZ1bmN0aW9uKGEsYil7dmFyIGMsZT1kLnBzZXVkb3NbYV18fGQuc2V0RmlsdGVyc1thLnRvTG93ZXJDYXNlKCldfHxnYS5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIrYSk7cmV0dXJuIGVbdV0/ZShiKTplLmxlbmd0aD4xPyhjPVthLGEsXCJcIixiXSxkLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoYS50b0xvd2VyQ2FzZSgpKT9pYShmdW5jdGlvbihhLGMpe3ZhciBkLGY9ZShhLGIpLGc9Zi5sZW5ndGg7d2hpbGUoZy0tKWQ9SihhLGZbZ10pLGFbZF09IShjW2RdPWZbZ10pfSk6ZnVuY3Rpb24oYSl7cmV0dXJuIGUoYSwwLGMpfSk6ZX19LHBzZXVkb3M6e25vdDppYShmdW5jdGlvbihhKXt2YXIgYj1bXSxjPVtdLGQ9aChhLnJlcGxhY2UoUixcIiQxXCIpKTtyZXR1cm4gZFt1XT9pYShmdW5jdGlvbihhLGIsYyxlKXt2YXIgZixnPWQoYSxudWxsLGUsW10pLGg9YS5sZW5ndGg7d2hpbGUoaC0tKShmPWdbaF0pJiYoYVtoXT0hKGJbaF09ZikpfSk6ZnVuY3Rpb24oYSxlLGYpe3JldHVybiBiWzBdPWEsZChiLG51bGwsZixjKSxiWzBdPW51bGwsIWMucG9wKCl9fSksaGFzOmlhKGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gZ2EoYSxiKS5sZW5ndGg+MH19KSxjb250YWluczppYShmdW5jdGlvbihhKXtyZXR1cm4gYT1hLnJlcGxhY2UoY2EsZGEpLGZ1bmN0aW9uKGIpe3JldHVybihiLnRleHRDb250ZW50fHxiLmlubmVyVGV4dHx8ZShiKSkuaW5kZXhPZihhKT4tMX19KSxsYW5nOmlhKGZ1bmN0aW9uKGEpe3JldHVybiBXLnRlc3QoYXx8XCJcIil8fGdhLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIrYSksYT1hLnJlcGxhY2UoY2EsZGEpLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oYil7dmFyIGM7ZG8gaWYoYz1wP2IubGFuZzpiLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpfHxiLmdldEF0dHJpYnV0ZShcImxhbmdcIikpcmV0dXJuIGM9Yy50b0xvd2VyQ2FzZSgpLGM9PT1hfHwwPT09Yy5pbmRleE9mKGErXCItXCIpO3doaWxlKChiPWIucGFyZW50Tm9kZSkmJjE9PT1iLm5vZGVUeXBlKTtyZXR1cm4hMX19KSx0YXJnZXQ6ZnVuY3Rpb24oYil7dmFyIGM9YS5sb2NhdGlvbiYmYS5sb2NhdGlvbi5oYXNoO3JldHVybiBjJiZjLnNsaWNlKDEpPT09Yi5pZH0scm9vdDpmdW5jdGlvbihhKXtyZXR1cm4gYT09PW99LGZvY3VzOmZ1bmN0aW9uKGEpe3JldHVybiBhPT09bi5hY3RpdmVFbGVtZW50JiYoIW4uaGFzRm9jdXN8fG4uaGFzRm9jdXMoKSkmJiEhKGEudHlwZXx8YS5ocmVmfHx+YS50YWJJbmRleCl9LGVuYWJsZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGlzYWJsZWQ9PT0hMX0sZGlzYWJsZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGlzYWJsZWQ9PT0hMH0sY2hlY2tlZDpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09YiYmISFhLmNoZWNrZWR8fFwib3B0aW9uXCI9PT1iJiYhIWEuc2VsZWN0ZWR9LHNlbGVjdGVkOmZ1bmN0aW9uKGEpe3JldHVybiBhLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LGEuc2VsZWN0ZWQ9PT0hMH0sZW1wdHk6ZnVuY3Rpb24oYSl7Zm9yKGE9YS5maXJzdENoaWxkO2E7YT1hLm5leHRTaWJsaW5nKWlmKGEubm9kZVR5cGU8NilyZXR1cm4hMTtyZXR1cm4hMH0scGFyZW50OmZ1bmN0aW9uKGEpe3JldHVybiFkLnBzZXVkb3MuZW1wdHkoYSl9LGhlYWRlcjpmdW5jdGlvbihhKXtyZXR1cm4gWi50ZXN0KGEubm9kZU5hbWUpfSxpbnB1dDpmdW5jdGlvbihhKXtyZXR1cm4gWS50ZXN0KGEubm9kZU5hbWUpfSxidXR0b246ZnVuY3Rpb24oYSl7dmFyIGI9YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWImJlwiYnV0dG9uXCI9PT1hLnR5cGV8fFwiYnV0dG9uXCI9PT1ifSx0ZXh0OmZ1bmN0aW9uKGEpe3ZhciBiO3JldHVyblwiaW5wdXRcIj09PWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmXCJ0ZXh0XCI9PT1hLnR5cGUmJihudWxsPT0oYj1hLmdldEF0dHJpYnV0ZShcInR5cGVcIikpfHxcInRleHRcIj09PWIudG9Mb3dlckNhc2UoKSl9LGZpcnN0Om9hKGZ1bmN0aW9uKCl7cmV0dXJuWzBdfSksbGFzdDpvYShmdW5jdGlvbihhLGIpe3JldHVybltiLTFdfSksZXE6b2EoZnVuY3Rpb24oYSxiLGMpe3JldHVyblswPmM/YytiOmNdfSksZXZlbjpvYShmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2I+YztjKz0yKWEucHVzaChjKTtyZXR1cm4gYX0pLG9kZDpvYShmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0xO2I+YztjKz0yKWEucHVzaChjKTtyZXR1cm4gYX0pLGx0Om9hKGZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9MD5jP2MrYjpjOy0tZD49MDspYS5wdXNoKGQpO3JldHVybiBhfSksZ3Q6b2EoZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0wPmM/YytiOmM7KytkPGI7KWEucHVzaChkKTtyZXR1cm4gYX0pfX0sZC5wc2V1ZG9zLm50aD1kLnBzZXVkb3MuZXE7Zm9yKGIgaW57cmFkaW86ITAsY2hlY2tib3g6ITAsZmlsZTohMCxwYXNzd29yZDohMCxpbWFnZTohMH0pZC5wc2V1ZG9zW2JdPW1hKGIpO2ZvcihiIGlue3N1Ym1pdDohMCxyZXNldDohMH0pZC5wc2V1ZG9zW2JdPW5hKGIpO2Z1bmN0aW9uIHFhKCl7fXFhLnByb3RvdHlwZT1kLmZpbHRlcnM9ZC5wc2V1ZG9zLGQuc2V0RmlsdGVycz1uZXcgcWEsZz1nYS50b2tlbml6ZT1mdW5jdGlvbihhLGIpe3ZhciBjLGUsZixnLGgsaSxqLGs9elthK1wiIFwiXTtpZihrKXJldHVybiBiPzA6ay5zbGljZSgwKTtoPWEsaT1bXSxqPWQucHJlRmlsdGVyO3doaWxlKGgpeyghY3x8KGU9Uy5leGVjKGgpKSkmJihlJiYoaD1oLnNsaWNlKGVbMF0ubGVuZ3RoKXx8aCksaS5wdXNoKGY9W10pKSxjPSExLChlPVQuZXhlYyhoKSkmJihjPWUuc2hpZnQoKSxmLnB1c2goe3ZhbHVlOmMsdHlwZTplWzBdLnJlcGxhY2UoUixcIiBcIil9KSxoPWguc2xpY2UoYy5sZW5ndGgpKTtmb3IoZyBpbiBkLmZpbHRlcikhKGU9WFtnXS5leGVjKGgpKXx8altnXSYmIShlPWpbZ10oZSkpfHwoYz1lLnNoaWZ0KCksZi5wdXNoKHt2YWx1ZTpjLHR5cGU6ZyxtYXRjaGVzOmV9KSxoPWguc2xpY2UoYy5sZW5ndGgpKTtpZighYylicmVha31yZXR1cm4gYj9oLmxlbmd0aDpoP2dhLmVycm9yKGEpOnooYSxpKS5zbGljZSgwKX07ZnVuY3Rpb24gcmEoYSl7Zm9yKHZhciBiPTAsYz1hLmxlbmd0aCxkPVwiXCI7Yz5iO2IrKylkKz1hW2JdLnZhbHVlO3JldHVybiBkfWZ1bmN0aW9uIHNhKGEsYixjKXt2YXIgZD1iLmRpcixlPWMmJlwicGFyZW50Tm9kZVwiPT09ZCxmPXgrKztyZXR1cm4gYi5maXJzdD9mdW5jdGlvbihiLGMsZil7d2hpbGUoYj1iW2RdKWlmKDE9PT1iLm5vZGVUeXBlfHxlKXJldHVybiBhKGIsYyxmKX06ZnVuY3Rpb24oYixjLGcpe3ZhciBoLGksaj1bdyxmXTtpZihnKXt3aGlsZShiPWJbZF0paWYoKDE9PT1iLm5vZGVUeXBlfHxlKSYmYShiLGMsZykpcmV0dXJuITB9ZWxzZSB3aGlsZShiPWJbZF0paWYoMT09PWIubm9kZVR5cGV8fGUpe2lmKGk9Ylt1XXx8KGJbdV09e30pLChoPWlbZF0pJiZoWzBdPT09dyYmaFsxXT09PWYpcmV0dXJuIGpbMl09aFsyXTtpZihpW2RdPWosalsyXT1hKGIsYyxnKSlyZXR1cm4hMH19fWZ1bmN0aW9uIHRhKGEpe3JldHVybiBhLmxlbmd0aD4xP2Z1bmN0aW9uKGIsYyxkKXt2YXIgZT1hLmxlbmd0aDt3aGlsZShlLS0paWYoIWFbZV0oYixjLGQpKXJldHVybiExO3JldHVybiEwfTphWzBdfWZ1bmN0aW9uIHVhKGEsYixjKXtmb3IodmFyIGQ9MCxlPWIubGVuZ3RoO2U+ZDtkKyspZ2EoYSxiW2RdLGMpO3JldHVybiBjfWZ1bmN0aW9uIHZhKGEsYixjLGQsZSl7Zm9yKHZhciBmLGc9W10saD0wLGk9YS5sZW5ndGgsaj1udWxsIT1iO2k+aDtoKyspKGY9YVtoXSkmJighY3x8YyhmLGQsZSkpJiYoZy5wdXNoKGYpLGomJmIucHVzaChoKSk7cmV0dXJuIGd9ZnVuY3Rpb24gd2EoYSxiLGMsZCxlLGYpe3JldHVybiBkJiYhZFt1XSYmKGQ9d2EoZCkpLGUmJiFlW3VdJiYoZT13YShlLGYpKSxpYShmdW5jdGlvbihmLGcsaCxpKXt2YXIgaixrLGwsbT1bXSxuPVtdLG89Zy5sZW5ndGgscD1mfHx1YShifHxcIipcIixoLm5vZGVUeXBlP1toXTpoLFtdKSxxPSFhfHwhZiYmYj9wOnZhKHAsbSxhLGgsaSkscj1jP2V8fChmP2E6b3x8ZCk/W106ZzpxO2lmKGMmJmMocSxyLGgsaSksZCl7aj12YShyLG4pLGQoaixbXSxoLGkpLGs9ai5sZW5ndGg7d2hpbGUoay0tKShsPWpba10pJiYocltuW2tdXT0hKHFbbltrXV09bCkpfWlmKGYpe2lmKGV8fGEpe2lmKGUpe2o9W10saz1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJmoucHVzaChxW2tdPWwpO2UobnVsbCxyPVtdLGosaSl9az1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJihqPWU/SihmLGwpOm1ba10pPi0xJiYoZltqXT0hKGdbal09bCkpfX1lbHNlIHI9dmEocj09PWc/ci5zcGxpY2UobyxyLmxlbmd0aCk6ciksZT9lKG51bGwsZyxyLGkpOkguYXBwbHkoZyxyKX0pfWZ1bmN0aW9uIHhhKGEpe2Zvcih2YXIgYixjLGUsZj1hLmxlbmd0aCxnPWQucmVsYXRpdmVbYVswXS50eXBlXSxoPWd8fGQucmVsYXRpdmVbXCIgXCJdLGk9Zz8xOjAsaz1zYShmdW5jdGlvbihhKXtyZXR1cm4gYT09PWJ9LGgsITApLGw9c2EoZnVuY3Rpb24oYSl7cmV0dXJuIEooYixhKT4tMX0saCwhMCksbT1bZnVuY3Rpb24oYSxjLGQpe3ZhciBlPSFnJiYoZHx8YyE9PWopfHwoKGI9Yykubm9kZVR5cGU/ayhhLGMsZCk6bChhLGMsZCkpO3JldHVybiBiPW51bGwsZX1dO2Y+aTtpKyspaWYoYz1kLnJlbGF0aXZlW2FbaV0udHlwZV0pbT1bc2EodGEobSksYyldO2Vsc2V7aWYoYz1kLmZpbHRlclthW2ldLnR5cGVdLmFwcGx5KG51bGwsYVtpXS5tYXRjaGVzKSxjW3VdKXtmb3IoZT0rK2k7Zj5lO2UrKylpZihkLnJlbGF0aXZlW2FbZV0udHlwZV0pYnJlYWs7cmV0dXJuIHdhKGk+MSYmdGEobSksaT4xJiZyYShhLnNsaWNlKDAsaS0xKS5jb25jYXQoe3ZhbHVlOlwiIFwiPT09YVtpLTJdLnR5cGU/XCIqXCI6XCJcIn0pKS5yZXBsYWNlKFIsXCIkMVwiKSxjLGU+aSYmeGEoYS5zbGljZShpLGUpKSxmPmUmJnhhKGE9YS5zbGljZShlKSksZj5lJiZyYShhKSl9bS5wdXNoKGMpfXJldHVybiB0YShtKX1mdW5jdGlvbiB5YShhLGIpe3ZhciBjPWIubGVuZ3RoPjAsZT1hLmxlbmd0aD4wLGY9ZnVuY3Rpb24oZixnLGgsaSxrKXt2YXIgbCxtLG8scD0wLHE9XCIwXCIscj1mJiZbXSxzPVtdLHQ9aix1PWZ8fGUmJmQuZmluZC5UQUcoXCIqXCIsayksdj13Kz1udWxsPT10PzE6TWF0aC5yYW5kb20oKXx8LjEseD11Lmxlbmd0aDtmb3IoayYmKGo9ZyE9PW4mJmcpO3EhPT14JiZudWxsIT0obD11W3FdKTtxKyspe2lmKGUmJmwpe209MDt3aGlsZShvPWFbbSsrXSlpZihvKGwsZyxoKSl7aS5wdXNoKGwpO2JyZWFrfWsmJih3PXYpfWMmJigobD0hbyYmbCkmJnAtLSxmJiZyLnB1c2gobCkpfWlmKHArPXEsYyYmcSE9PXApe209MDt3aGlsZShvPWJbbSsrXSlvKHIscyxnLGgpO2lmKGYpe2lmKHA+MCl3aGlsZShxLS0pcltxXXx8c1txXXx8KHNbcV09Ri5jYWxsKGkpKTtzPXZhKHMpfUguYXBwbHkoaSxzKSxrJiYhZiYmcy5sZW5ndGg+MCYmcCtiLmxlbmd0aD4xJiZnYS51bmlxdWVTb3J0KGkpfXJldHVybiBrJiYodz12LGo9dCkscn07cmV0dXJuIGM/aWEoZik6Zn1yZXR1cm4gaD1nYS5jb21waWxlPWZ1bmN0aW9uKGEsYil7dmFyIGMsZD1bXSxlPVtdLGY9QVthK1wiIFwiXTtpZighZil7Ynx8KGI9ZyhhKSksYz1iLmxlbmd0aDt3aGlsZShjLS0pZj14YShiW2NdKSxmW3VdP2QucHVzaChmKTplLnB1c2goZik7Zj1BKGEseWEoZSxkKSksZi5zZWxlY3Rvcj1hfXJldHVybiBmfSxpPWdhLnNlbGVjdD1mdW5jdGlvbihhLGIsZSxmKXt2YXIgaSxqLGssbCxtLG49XCJmdW5jdGlvblwiPT10eXBlb2YgYSYmYSxvPSFmJiZnKGE9bi5zZWxlY3Rvcnx8YSk7aWYoZT1lfHxbXSwxPT09by5sZW5ndGgpe2lmKGo9b1swXT1vWzBdLnNsaWNlKDApLGoubGVuZ3RoPjImJlwiSURcIj09PShrPWpbMF0pLnR5cGUmJmMuZ2V0QnlJZCYmOT09PWIubm9kZVR5cGUmJnAmJmQucmVsYXRpdmVbalsxXS50eXBlXSl7aWYoYj0oZC5maW5kLklEKGsubWF0Y2hlc1swXS5yZXBsYWNlKGNhLGRhKSxiKXx8W10pWzBdLCFiKXJldHVybiBlO24mJihiPWIucGFyZW50Tm9kZSksYT1hLnNsaWNlKGouc2hpZnQoKS52YWx1ZS5sZW5ndGgpfWk9WC5uZWVkc0NvbnRleHQudGVzdChhKT8wOmoubGVuZ3RoO3doaWxlKGktLSl7aWYoaz1qW2ldLGQucmVsYXRpdmVbbD1rLnR5cGVdKWJyZWFrO2lmKChtPWQuZmluZFtsXSkmJihmPW0oay5tYXRjaGVzWzBdLnJlcGxhY2UoY2EsZGEpLGFhLnRlc3QoalswXS50eXBlKSYmcGEoYi5wYXJlbnROb2RlKXx8YikpKXtpZihqLnNwbGljZShpLDEpLGE9Zi5sZW5ndGgmJnJhKGopLCFhKXJldHVybiBILmFwcGx5KGUsZiksZTticmVha319fXJldHVybihufHxoKGEsbykpKGYsYiwhcCxlLGFhLnRlc3QoYSkmJnBhKGIucGFyZW50Tm9kZSl8fGIpLGV9LGMuc29ydFN0YWJsZT11LnNwbGl0KFwiXCIpLnNvcnQoQikuam9pbihcIlwiKT09PXUsYy5kZXRlY3REdXBsaWNhdGVzPSEhbCxtKCksYy5zb3J0RGV0YWNoZWQ9amEoZnVuY3Rpb24oYSl7cmV0dXJuIDEmYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpfSksamEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5uZXJIVE1MPVwiPGEgaHJlZj0nIyc+PC9hPlwiLFwiI1wiPT09YS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIil9KXx8a2EoXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjP3ZvaWQgMDphLmdldEF0dHJpYnV0ZShiLFwidHlwZVwiPT09Yi50b0xvd2VyQ2FzZSgpPzE6Mil9KSxjLmF0dHJpYnV0ZXMmJmphKGZ1bmN0aW9uKGEpe3JldHVybiBhLmlubmVySFRNTD1cIjxpbnB1dC8+XCIsYS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIiksXCJcIj09PWEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKX0pfHxrYShcInZhbHVlXCIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjfHxcImlucHV0XCIhPT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk/dm9pZCAwOmEuZGVmYXVsdFZhbHVlfSksamEoZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWEuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIil9KXx8a2EoSyxmdW5jdGlvbihhLGIsYyl7dmFyIGQ7cmV0dXJuIGM/dm9pZCAwOmFbYl09PT0hMD9iLnRvTG93ZXJDYXNlKCk6KGQ9YS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSYmZC5zcGVjaWZpZWQ/ZC52YWx1ZTpudWxsfSksZ2F9KGEpO24uZmluZD10LG4uZXhwcj10LnNlbGVjdG9ycyxuLmV4cHJbXCI6XCJdPW4uZXhwci5wc2V1ZG9zLG4udW5pcXVlPXQudW5pcXVlU29ydCxuLnRleHQ9dC5nZXRUZXh0LG4uaXNYTUxEb2M9dC5pc1hNTCxuLmNvbnRhaW5zPXQuY29udGFpbnM7dmFyIHU9bi5leHByLm1hdGNoLm5lZWRzQ29udGV4dCx2PS9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyx3PS9eLlteOiNcXFtcXC4sXSokLztmdW5jdGlvbiB4KGEsYixjKXtpZihuLmlzRnVuY3Rpb24oYikpcmV0dXJuIG4uZ3JlcChhLGZ1bmN0aW9uKGEsZCl7cmV0dXJuISFiLmNhbGwoYSxkLGEpIT09Y30pO2lmKGIubm9kZVR5cGUpcmV0dXJuIG4uZ3JlcChhLGZ1bmN0aW9uKGEpe3JldHVybiBhPT09YiE9PWN9KTtpZihcInN0cmluZ1wiPT10eXBlb2YgYil7aWYody50ZXN0KGIpKXJldHVybiBuLmZpbHRlcihiLGEsYyk7Yj1uLmZpbHRlcihiLGEpfXJldHVybiBuLmdyZXAoYSxmdW5jdGlvbihhKXtyZXR1cm4gZy5jYWxsKGIsYSk+PTAhPT1jfSl9bi5maWx0ZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWJbMF07cmV0dXJuIGMmJihhPVwiOm5vdChcIithK1wiKVwiKSwxPT09Yi5sZW5ndGgmJjE9PT1kLm5vZGVUeXBlP24uZmluZC5tYXRjaGVzU2VsZWN0b3IoZCxhKT9bZF06W106bi5maW5kLm1hdGNoZXMoYSxuLmdyZXAoYixmdW5jdGlvbihhKXtyZXR1cm4gMT09PWEubm9kZVR5cGV9KSl9LG4uZm4uZXh0ZW5kKHtmaW5kOmZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcy5sZW5ndGgsZD1bXSxlPXRoaXM7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGEpcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4oYSkuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKGI9MDtjPmI7YisrKWlmKG4uY29udGFpbnMoZVtiXSx0aGlzKSlyZXR1cm4hMH0pKTtmb3IoYj0wO2M+YjtiKyspbi5maW5kKGEsZVtiXSxkKTtyZXR1cm4gZD10aGlzLnB1c2hTdGFjayhjPjE/bi51bmlxdWUoZCk6ZCksZC5zZWxlY3Rvcj10aGlzLnNlbGVjdG9yP3RoaXMuc2VsZWN0b3IrXCIgXCIrYTphLGR9LGZpbHRlcjpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soeCh0aGlzLGF8fFtdLCExKSl9LG5vdDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soeCh0aGlzLGF8fFtdLCEwKSl9LGlzOmZ1bmN0aW9uKGEpe3JldHVybiEheCh0aGlzLFwic3RyaW5nXCI9PXR5cGVvZiBhJiZ1LnRlc3QoYSk/bihhKTphfHxbXSwhMSkubGVuZ3RofX0pO3ZhciB5LHo9L14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sQT1uLmZuLmluaXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkO2lmKCFhKXJldHVybiB0aGlzO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXtpZihjPVwiPFwiPT09YVswXSYmXCI+XCI9PT1hW2EubGVuZ3RoLTFdJiZhLmxlbmd0aD49Mz9bbnVsbCxhLG51bGxdOnouZXhlYyhhKSwhY3x8IWNbMV0mJmIpcmV0dXJuIWJ8fGIuanF1ZXJ5PyhifHx5KS5maW5kKGEpOnRoaXMuY29uc3RydWN0b3IoYikuZmluZChhKTtpZihjWzFdKXtpZihiPWIgaW5zdGFuY2VvZiBuP2JbMF06YixuLm1lcmdlKHRoaXMsbi5wYXJzZUhUTUwoY1sxXSxiJiZiLm5vZGVUeXBlP2Iub3duZXJEb2N1bWVudHx8YjpsLCEwKSksdi50ZXN0KGNbMV0pJiZuLmlzUGxhaW5PYmplY3QoYikpZm9yKGMgaW4gYiluLmlzRnVuY3Rpb24odGhpc1tjXSk/dGhpc1tjXShiW2NdKTp0aGlzLmF0dHIoYyxiW2NdKTtyZXR1cm4gdGhpc31yZXR1cm4gZD1sLmdldEVsZW1lbnRCeUlkKGNbMl0pLGQmJmQucGFyZW50Tm9kZSYmKHRoaXMubGVuZ3RoPTEsdGhpc1swXT1kKSx0aGlzLmNvbnRleHQ9bCx0aGlzLnNlbGVjdG9yPWEsdGhpc31yZXR1cm4gYS5ub2RlVHlwZT8odGhpcy5jb250ZXh0PXRoaXNbMF09YSx0aGlzLmxlbmd0aD0xLHRoaXMpOm4uaXNGdW5jdGlvbihhKT9cInVuZGVmaW5lZFwiIT10eXBlb2YgeS5yZWFkeT95LnJlYWR5KGEpOmEobik6KHZvaWQgMCE9PWEuc2VsZWN0b3ImJih0aGlzLnNlbGVjdG9yPWEuc2VsZWN0b3IsdGhpcy5jb250ZXh0PWEuY29udGV4dCksbi5tYWtlQXJyYXkoYSx0aGlzKSl9O0EucHJvdG90eXBlPW4uZm4seT1uKGwpO3ZhciBCPS9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLEM9e2NoaWxkcmVuOiEwLGNvbnRlbnRzOiEwLG5leHQ6ITAscHJldjohMH07bi5leHRlbmQoe2RpcjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9W10sZT12b2lkIDAhPT1jO3doaWxlKChhPWFbYl0pJiY5IT09YS5ub2RlVHlwZSlpZigxPT09YS5ub2RlVHlwZSl7aWYoZSYmbihhKS5pcyhjKSlicmVhaztkLnB1c2goYSl9cmV0dXJuIGR9LHNpYmxpbmc6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W107YTthPWEubmV4dFNpYmxpbmcpMT09PWEubm9kZVR5cGUmJmEhPT1iJiZjLnB1c2goYSk7cmV0dXJuIGN9fSksbi5mbi5leHRlbmQoe2hhczpmdW5jdGlvbihhKXt2YXIgYj1uKGEsdGhpcyksYz1iLmxlbmd0aDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKXtmb3IodmFyIGE9MDtjPmE7YSsrKWlmKG4uY29udGFpbnModGhpcyxiW2FdKSlyZXR1cm4hMH0pfSxjbG9zZXN0OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjLGQ9MCxlPXRoaXMubGVuZ3RoLGY9W10sZz11LnRlc3QoYSl8fFwic3RyaW5nXCIhPXR5cGVvZiBhP24oYSxifHx0aGlzLmNvbnRleHQpOjA7ZT5kO2QrKylmb3IoYz10aGlzW2RdO2MmJmMhPT1iO2M9Yy5wYXJlbnROb2RlKWlmKGMubm9kZVR5cGU8MTEmJihnP2cuaW5kZXgoYyk+LTE6MT09PWMubm9kZVR5cGUmJm4uZmluZC5tYXRjaGVzU2VsZWN0b3IoYyxhKSkpe2YucHVzaChjKTticmVha31yZXR1cm4gdGhpcy5wdXNoU3RhY2soZi5sZW5ndGg+MT9uLnVuaXF1ZShmKTpmKX0saW5kZXg6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/XCJzdHJpbmdcIj09dHlwZW9mIGE/Zy5jYWxsKG4oYSksdGhpc1swXSk6Zy5jYWxsKHRoaXMsYS5qcXVlcnk/YVswXTphKTp0aGlzWzBdJiZ0aGlzWzBdLnBhcmVudE5vZGU/dGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGg6LTF9LGFkZDpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnB1c2hTdGFjayhuLnVuaXF1ZShuLm1lcmdlKHRoaXMuZ2V0KCksbihhLGIpKSkpfSxhZGRCYWNrOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmFkZChudWxsPT1hP3RoaXMucHJldk9iamVjdDp0aGlzLnByZXZPYmplY3QuZmlsdGVyKGEpKX19KTtmdW5jdGlvbiBEKGEsYil7d2hpbGUoKGE9YVtiXSkmJjEhPT1hLm5vZGVUeXBlKTtyZXR1cm4gYX1uLmVhY2goe3BhcmVudDpmdW5jdGlvbihhKXt2YXIgYj1hLnBhcmVudE5vZGU7cmV0dXJuIGImJjExIT09Yi5ub2RlVHlwZT9iOm51bGx9LHBhcmVudHM6ZnVuY3Rpb24oYSl7cmV0dXJuIG4uZGlyKGEsXCJwYXJlbnROb2RlXCIpfSxwYXJlbnRzVW50aWw6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuLmRpcihhLFwicGFyZW50Tm9kZVwiLGMpfSxuZXh0OmZ1bmN0aW9uKGEpe3JldHVybiBEKGEsXCJuZXh0U2libGluZ1wiKX0scHJldjpmdW5jdGlvbihhKXtyZXR1cm4gRChhLFwicHJldmlvdXNTaWJsaW5nXCIpfSxuZXh0QWxsOmZ1bmN0aW9uKGEpe3JldHVybiBuLmRpcihhLFwibmV4dFNpYmxpbmdcIil9LHByZXZBbGw6ZnVuY3Rpb24oYSl7cmV0dXJuIG4uZGlyKGEsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRVbnRpbDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG4uZGlyKGEsXCJuZXh0U2libGluZ1wiLGMpfSxwcmV2VW50aWw6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuLmRpcihhLFwicHJldmlvdXNTaWJsaW5nXCIsYyl9LHNpYmxpbmdzOmZ1bmN0aW9uKGEpe3JldHVybiBuLnNpYmxpbmcoKGEucGFyZW50Tm9kZXx8e30pLmZpcnN0Q2hpbGQsYSl9LGNoaWxkcmVuOmZ1bmN0aW9uKGEpe3JldHVybiBuLnNpYmxpbmcoYS5maXJzdENoaWxkKX0sY29udGVudHM6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuY29udGVudERvY3VtZW50fHxuLm1lcmdlKFtdLGEuY2hpbGROb2Rlcyl9fSxmdW5jdGlvbihhLGIpe24uZm5bYV09ZnVuY3Rpb24oYyxkKXt2YXIgZT1uLm1hcCh0aGlzLGIsYyk7cmV0dXJuXCJVbnRpbFwiIT09YS5zbGljZSgtNSkmJihkPWMpLGQmJlwic3RyaW5nXCI9PXR5cGVvZiBkJiYoZT1uLmZpbHRlcihkLGUpKSx0aGlzLmxlbmd0aD4xJiYoQ1thXXx8bi51bmlxdWUoZSksQi50ZXN0KGEpJiZlLnJldmVyc2UoKSksdGhpcy5wdXNoU3RhY2soZSl9fSk7dmFyIEU9L1xcUysvZyxGPXt9O2Z1bmN0aW9uIEcoYSl7dmFyIGI9RlthXT17fTtyZXR1cm4gbi5lYWNoKGEubWF0Y2goRSl8fFtdLGZ1bmN0aW9uKGEsYyl7YltjXT0hMH0pLGJ9bi5DYWxsYmFja3M9ZnVuY3Rpb24oYSl7YT1cInN0cmluZ1wiPT10eXBlb2YgYT9GW2FdfHxHKGEpOm4uZXh0ZW5kKHt9LGEpO3ZhciBiLGMsZCxlLGYsZyxoPVtdLGk9IWEub25jZSYmW10saj1mdW5jdGlvbihsKXtmb3IoYj1hLm1lbW9yeSYmbCxjPSEwLGc9ZXx8MCxlPTAsZj1oLmxlbmd0aCxkPSEwO2gmJmY+ZztnKyspaWYoaFtnXS5hcHBseShsWzBdLGxbMV0pPT09ITEmJmEuc3RvcE9uRmFsc2Upe2I9ITE7YnJlYWt9ZD0hMSxoJiYoaT9pLmxlbmd0aCYmaihpLnNoaWZ0KCkpOmI/aD1bXTprLmRpc2FibGUoKSl9LGs9e2FkZDpmdW5jdGlvbigpe2lmKGgpe3ZhciBjPWgubGVuZ3RoOyFmdW5jdGlvbiBnKGIpe24uZWFjaChiLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9bi50eXBlKGMpO1wiZnVuY3Rpb25cIj09PWQ/YS51bmlxdWUmJmsuaGFzKGMpfHxoLnB1c2goYyk6YyYmYy5sZW5ndGgmJlwic3RyaW5nXCIhPT1kJiZnKGMpfSl9KGFyZ3VtZW50cyksZD9mPWgubGVuZ3RoOmImJihlPWMsaihiKSl9cmV0dXJuIHRoaXN9LHJlbW92ZTpmdW5jdGlvbigpe3JldHVybiBoJiZuLmVhY2goYXJndW1lbnRzLGZ1bmN0aW9uKGEsYil7dmFyIGM7d2hpbGUoKGM9bi5pbkFycmF5KGIsaCxjKSk+LTEpaC5zcGxpY2UoYywxKSxkJiYoZj49YyYmZi0tLGc+PWMmJmctLSl9KSx0aGlzfSxoYXM6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/bi5pbkFycmF5KGEsaCk+LTE6ISghaHx8IWgubGVuZ3RoKX0sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gaD1bXSxmPTAsdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiBoPWk9Yj12b2lkIDAsdGhpc30sZGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4haH0sbG9jazpmdW5jdGlvbigpe3JldHVybiBpPXZvaWQgMCxifHxrLmRpc2FibGUoKSx0aGlzfSxsb2NrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4haX0sZmlyZVdpdGg6ZnVuY3Rpb24oYSxiKXtyZXR1cm4haHx8YyYmIWl8fChiPWJ8fFtdLGI9W2EsYi5zbGljZT9iLnNsaWNlKCk6Yl0sZD9pLnB1c2goYik6aihiKSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBrLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhY319O3JldHVybiBrfSxuLmV4dGVuZCh7RGVmZXJyZWQ6ZnVuY3Rpb24oYSl7dmFyIGI9W1tcInJlc29sdmVcIixcImRvbmVcIixuLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFwicmVzb2x2ZWRcIl0sW1wicmVqZWN0XCIsXCJmYWlsXCIsbi5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcInJlamVjdGVkXCJdLFtcIm5vdGlmeVwiLFwicHJvZ3Jlc3NcIixuLkNhbGxiYWNrcyhcIm1lbW9yeVwiKV1dLGM9XCJwZW5kaW5nXCIsZD17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gY30sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIGUuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSx0aGVuOmZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzO3JldHVybiBuLkRlZmVycmVkKGZ1bmN0aW9uKGMpe24uZWFjaChiLGZ1bmN0aW9uKGIsZil7dmFyIGc9bi5pc0Z1bmN0aW9uKGFbYl0pJiZhW2JdO2VbZlsxXV0oZnVuY3Rpb24oKXt2YXIgYT1nJiZnLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthJiZuLmlzRnVuY3Rpb24oYS5wcm9taXNlKT9hLnByb21pc2UoKS5kb25lKGMucmVzb2x2ZSkuZmFpbChjLnJlamVjdCkucHJvZ3Jlc3MoYy5ub3RpZnkpOmNbZlswXStcIldpdGhcIl0odGhpcz09PWQ/Yy5wcm9taXNlKCk6dGhpcyxnP1thXTphcmd1bWVudHMpfSl9KSxhPW51bGx9KS5wcm9taXNlKCl9LHByb21pc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/bi5leHRlbmQoYSxkKTpkfX0sZT17fTtyZXR1cm4gZC5waXBlPWQudGhlbixuLmVhY2goYixmdW5jdGlvbihhLGYpe3ZhciBnPWZbMl0saD1mWzNdO2RbZlsxXV09Zy5hZGQsaCYmZy5hZGQoZnVuY3Rpb24oKXtjPWh9LGJbMV5hXVsyXS5kaXNhYmxlLGJbMl1bMl0ubG9jayksZVtmWzBdXT1mdW5jdGlvbigpe3JldHVybiBlW2ZbMF0rXCJXaXRoXCJdKHRoaXM9PT1lP2Q6dGhpcyxhcmd1bWVudHMpLHRoaXN9LGVbZlswXStcIldpdGhcIl09Zy5maXJlV2l0aH0pLGQucHJvbWlzZShlKSxhJiZhLmNhbGwoZSxlKSxlfSx3aGVuOmZ1bmN0aW9uKGEpe3ZhciBiPTAsYz1kLmNhbGwoYXJndW1lbnRzKSxlPWMubGVuZ3RoLGY9MSE9PWV8fGEmJm4uaXNGdW5jdGlvbihhLnByb21pc2UpP2U6MCxnPTE9PT1mP2E6bi5EZWZlcnJlZCgpLGg9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBmdW5jdGlvbihlKXtiW2FdPXRoaXMsY1thXT1hcmd1bWVudHMubGVuZ3RoPjE/ZC5jYWxsKGFyZ3VtZW50cyk6ZSxjPT09aT9nLm5vdGlmeVdpdGgoYixjKTotLWZ8fGcucmVzb2x2ZVdpdGgoYixjKX19LGksaixrO2lmKGU+MSlmb3IoaT1uZXcgQXJyYXkoZSksaj1uZXcgQXJyYXkoZSksaz1uZXcgQXJyYXkoZSk7ZT5iO2IrKyljW2JdJiZuLmlzRnVuY3Rpb24oY1tiXS5wcm9taXNlKT9jW2JdLnByb21pc2UoKS5kb25lKGgoYixrLGMpKS5mYWlsKGcucmVqZWN0KS5wcm9ncmVzcyhoKGIsaixpKSk6LS1mO3JldHVybiBmfHxnLnJlc29sdmVXaXRoKGssYyksZy5wcm9taXNlKCl9fSk7dmFyIEg7bi5mbi5yZWFkeT1mdW5jdGlvbihhKXtyZXR1cm4gbi5yZWFkeS5wcm9taXNlKCkuZG9uZShhKSx0aGlzfSxuLmV4dGVuZCh7aXNSZWFkeTohMSxyZWFkeVdhaXQ6MSxob2xkUmVhZHk6ZnVuY3Rpb24oYSl7YT9uLnJlYWR5V2FpdCsrOm4ucmVhZHkoITApfSxyZWFkeTpmdW5jdGlvbihhKXsoYT09PSEwPy0tbi5yZWFkeVdhaXQ6bi5pc1JlYWR5KXx8KG4uaXNSZWFkeT0hMCxhIT09ITAmJi0tbi5yZWFkeVdhaXQ+MHx8KEgucmVzb2x2ZVdpdGgobCxbbl0pLG4uZm4udHJpZ2dlckhhbmRsZXImJihuKGwpLnRyaWdnZXJIYW5kbGVyKFwicmVhZHlcIiksbihsKS5vZmYoXCJyZWFkeVwiKSkpKX19KTtmdW5jdGlvbiBJKCl7bC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLEksITEpLGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIixJLCExKSxuLnJlYWR5KCl9bi5yZWFkeS5wcm9taXNlPWZ1bmN0aW9uKGIpe3JldHVybiBIfHwoSD1uLkRlZmVycmVkKCksXCJjb21wbGV0ZVwiPT09bC5yZWFkeVN0YXRlP3NldFRpbWVvdXQobi5yZWFkeSk6KGwuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixJLCExKSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsSSwhMSkpKSxILnByb21pc2UoYil9LG4ucmVhZHkucHJvbWlzZSgpO3ZhciBKPW4uYWNjZXNzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe3ZhciBoPTAsaT1hLmxlbmd0aCxqPW51bGw9PWM7aWYoXCJvYmplY3RcIj09PW4udHlwZShjKSl7ZT0hMDtmb3IoaCBpbiBjKW4uYWNjZXNzKGEsYixoLGNbaF0sITAsZixnKX1lbHNlIGlmKHZvaWQgMCE9PWQmJihlPSEwLG4uaXNGdW5jdGlvbihkKXx8KGc9ITApLGomJihnPyhiLmNhbGwoYSxkKSxiPW51bGwpOihqPWIsYj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGouY2FsbChuKGEpLGMpfSkpLGIpKWZvcig7aT5oO2grKyliKGFbaF0sYyxnP2Q6ZC5jYWxsKGFbaF0saCxiKGFbaF0sYykpKTtyZXR1cm4gZT9hOmo/Yi5jYWxsKGEpOmk/YihhWzBdLGMpOmZ9O24uYWNjZXB0RGF0YT1mdW5jdGlvbihhKXtyZXR1cm4gMT09PWEubm9kZVR5cGV8fDk9PT1hLm5vZGVUeXBlfHwhK2Eubm9kZVR5cGV9O2Z1bmN0aW9uIEsoKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5jYWNoZT17fSwwLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm57fX19KSx0aGlzLmV4cGFuZG89bi5leHBhbmRvK0sudWlkKyt9Sy51aWQ9MSxLLmFjY2VwdHM9bi5hY2NlcHREYXRhLEsucHJvdG90eXBlPXtrZXk6ZnVuY3Rpb24oYSl7aWYoIUsuYWNjZXB0cyhhKSlyZXR1cm4gMDt2YXIgYj17fSxjPWFbdGhpcy5leHBhbmRvXTtpZighYyl7Yz1LLnVpZCsrO3RyeXtiW3RoaXMuZXhwYW5kb109e3ZhbHVlOmN9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGEsYil9Y2F0Y2goZCl7Ylt0aGlzLmV4cGFuZG9dPWMsbi5leHRlbmQoYSxiKX19cmV0dXJuIHRoaXMuY2FjaGVbY118fCh0aGlzLmNhY2hlW2NdPXt9KSxjfSxzZXQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU9dGhpcy5rZXkoYSksZj10aGlzLmNhY2hlW2VdO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiKWZbYl09YztlbHNlIGlmKG4uaXNFbXB0eU9iamVjdChmKSluLmV4dGVuZCh0aGlzLmNhY2hlW2VdLGIpO2Vsc2UgZm9yKGQgaW4gYilmW2RdPWJbZF07cmV0dXJuIGZ9LGdldDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY2FjaGVbdGhpcy5rZXkoYSldO3JldHVybiB2b2lkIDA9PT1iP2M6Y1tiXX0sYWNjZXNzOmZ1bmN0aW9uKGEsYixjKXt2YXIgZDtyZXR1cm4gdm9pZCAwPT09Ynx8YiYmXCJzdHJpbmdcIj09dHlwZW9mIGImJnZvaWQgMD09PWM/KGQ9dGhpcy5nZXQoYSxiKSx2b2lkIDAhPT1kP2Q6dGhpcy5nZXQoYSxuLmNhbWVsQ2FzZShiKSkpOih0aGlzLnNldChhLGIsYyksdm9pZCAwIT09Yz9jOmIpfSxyZW1vdmU6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZj10aGlzLmtleShhKSxnPXRoaXMuY2FjaGVbZl07aWYodm9pZCAwPT09Yil0aGlzLmNhY2hlW2ZdPXt9O2Vsc2V7bi5pc0FycmF5KGIpP2Q9Yi5jb25jYXQoYi5tYXAobi5jYW1lbENhc2UpKTooZT1uLmNhbWVsQ2FzZShiKSxiIGluIGc/ZD1bYixlXTooZD1lLGQ9ZCBpbiBnP1tkXTpkLm1hdGNoKEUpfHxbXSkpLGM9ZC5sZW5ndGg7d2hpbGUoYy0tKWRlbGV0ZSBnW2RbY11dfX0saGFzRGF0YTpmdW5jdGlvbihhKXtyZXR1cm4hbi5pc0VtcHR5T2JqZWN0KHRoaXMuY2FjaGVbYVt0aGlzLmV4cGFuZG9dXXx8e30pfSxkaXNjYXJkOmZ1bmN0aW9uKGEpe2FbdGhpcy5leHBhbmRvXSYmZGVsZXRlIHRoaXMuY2FjaGVbYVt0aGlzLmV4cGFuZG9dXX19O3ZhciBMPW5ldyBLLE09bmV3IEssTj0vXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sTz0vKFtBLVpdKS9nO2Z1bmN0aW9uIFAoYSxiLGMpe3ZhciBkO2lmKHZvaWQgMD09PWMmJjE9PT1hLm5vZGVUeXBlKWlmKGQ9XCJkYXRhLVwiK2IucmVwbGFjZShPLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCksYz1hLmdldEF0dHJpYnV0ZShkKSxcInN0cmluZ1wiPT10eXBlb2YgYyl7dHJ5e2M9XCJ0cnVlXCI9PT1jPyEwOlwiZmFsc2VcIj09PWM/ITE6XCJudWxsXCI9PT1jP251bGw6K2MrXCJcIj09PWM/K2M6Ti50ZXN0KGMpP24ucGFyc2VKU09OKGMpOmN9Y2F0Y2goZSl7fU0uc2V0KGEsYixjKX1lbHNlIGM9dm9pZCAwO3JldHVybiBjfW4uZXh0ZW5kKHtoYXNEYXRhOmZ1bmN0aW9uKGEpe3JldHVybiBNLmhhc0RhdGEoYSl8fEwuaGFzRGF0YShhKX0sZGF0YTpmdW5jdGlvbihhLGIsYyl7XG5yZXR1cm4gTS5hY2Nlc3MoYSxiLGMpfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGEsYil7TS5yZW1vdmUoYSxiKX0sX2RhdGE6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBMLmFjY2VzcyhhLGIsYyl9LF9yZW1vdmVEYXRhOmZ1bmN0aW9uKGEsYil7TC5yZW1vdmUoYSxiKX19KSxuLmZuLmV4dGVuZCh7ZGF0YTpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPXRoaXNbMF0sZz1mJiZmLmF0dHJpYnV0ZXM7aWYodm9pZCAwPT09YSl7aWYodGhpcy5sZW5ndGgmJihlPU0uZ2V0KGYpLDE9PT1mLm5vZGVUeXBlJiYhTC5nZXQoZixcImhhc0RhdGFBdHRyc1wiKSkpe2M9Zy5sZW5ndGg7d2hpbGUoYy0tKWdbY10mJihkPWdbY10ubmFtZSwwPT09ZC5pbmRleE9mKFwiZGF0YS1cIikmJihkPW4uY2FtZWxDYXNlKGQuc2xpY2UoNSkpLFAoZixkLGVbZF0pKSk7TC5zZXQoZixcImhhc0RhdGFBdHRyc1wiLCEwKX1yZXR1cm4gZX1yZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgYT90aGlzLmVhY2goZnVuY3Rpb24oKXtNLnNldCh0aGlzLGEpfSk6Sih0aGlzLGZ1bmN0aW9uKGIpe3ZhciBjLGQ9bi5jYW1lbENhc2UoYSk7aWYoZiYmdm9pZCAwPT09Yil7aWYoYz1NLmdldChmLGEpLHZvaWQgMCE9PWMpcmV0dXJuIGM7aWYoYz1NLmdldChmLGQpLHZvaWQgMCE9PWMpcmV0dXJuIGM7aWYoYz1QKGYsZCx2b2lkIDApLHZvaWQgMCE9PWMpcmV0dXJuIGN9ZWxzZSB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1NLmdldCh0aGlzLGQpO00uc2V0KHRoaXMsZCxiKSwtMSE9PWEuaW5kZXhPZihcIi1cIikmJnZvaWQgMCE9PWMmJk0uc2V0KHRoaXMsYSxiKX0pfSxudWxsLGIsYXJndW1lbnRzLmxlbmd0aD4xLG51bGwsITApfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtNLnJlbW92ZSh0aGlzLGEpfSl9fSksbi5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZDtyZXR1cm4gYT8oYj0oYnx8XCJmeFwiKStcInF1ZXVlXCIsZD1MLmdldChhLGIpLGMmJighZHx8bi5pc0FycmF5KGMpP2Q9TC5hY2Nlc3MoYSxiLG4ubWFrZUFycmF5KGMpKTpkLnB1c2goYykpLGR8fFtdKTp2b2lkIDB9LGRlcXVldWU6ZnVuY3Rpb24oYSxiKXtiPWJ8fFwiZnhcIjt2YXIgYz1uLnF1ZXVlKGEsYiksZD1jLmxlbmd0aCxlPWMuc2hpZnQoKSxmPW4uX3F1ZXVlSG9va3MoYSxiKSxnPWZ1bmN0aW9uKCl7bi5kZXF1ZXVlKGEsYil9O1wiaW5wcm9ncmVzc1wiPT09ZSYmKGU9Yy5zaGlmdCgpLGQtLSksZSYmKFwiZnhcIj09PWImJmMudW5zaGlmdChcImlucHJvZ3Jlc3NcIiksZGVsZXRlIGYuc3RvcCxlLmNhbGwoYSxnLGYpKSwhZCYmZiYmZi5lbXB0eS5maXJlKCl9LF9xdWV1ZUhvb2tzOmZ1bmN0aW9uKGEsYil7dmFyIGM9YitcInF1ZXVlSG9va3NcIjtyZXR1cm4gTC5nZXQoYSxjKXx8TC5hY2Nlc3MoYSxjLHtlbXB0eTpuLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpe0wucmVtb3ZlKGEsW2IrXCJxdWV1ZVwiLGNdKX0pfSl9fSksbi5mbi5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9MjtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgYSYmKGI9YSxhPVwiZnhcIixjLS0pLGFyZ3VtZW50cy5sZW5ndGg8Yz9uLnF1ZXVlKHRoaXNbMF0sYSk6dm9pZCAwPT09Yj90aGlzOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPW4ucXVldWUodGhpcyxhLGIpO24uX3F1ZXVlSG9va3ModGhpcyxhKSxcImZ4XCI9PT1hJiZcImlucHJvZ3Jlc3NcIiE9PWNbMF0mJm4uZGVxdWV1ZSh0aGlzLGEpfSl9LGRlcXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe24uZGVxdWV1ZSh0aGlzLGEpfSl9LGNsZWFyUXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucXVldWUoYXx8XCJmeFwiLFtdKX0scHJvbWlzZTpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9MSxlPW4uRGVmZXJyZWQoKSxmPXRoaXMsZz10aGlzLmxlbmd0aCxoPWZ1bmN0aW9uKCl7LS1kfHxlLnJlc29sdmVXaXRoKGYsW2ZdKX07XCJzdHJpbmdcIiE9dHlwZW9mIGEmJihiPWEsYT12b2lkIDApLGE9YXx8XCJmeFwiO3doaWxlKGctLSljPUwuZ2V0KGZbZ10sYStcInF1ZXVlSG9va3NcIiksYyYmYy5lbXB0eSYmKGQrKyxjLmVtcHR5LmFkZChoKSk7cmV0dXJuIGgoKSxlLnByb21pc2UoYil9fSk7dmFyIFE9L1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlLFI9W1wiVG9wXCIsXCJSaWdodFwiLFwiQm90dG9tXCIsXCJMZWZ0XCJdLFM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT1ifHxhLFwibm9uZVwiPT09bi5jc3MoYSxcImRpc3BsYXlcIil8fCFuLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKX0sVD0vXig/OmNoZWNrYm94fHJhZGlvKSQvaTshZnVuY3Rpb24oKXt2YXIgYT1sLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxiPWEuYXBwZW5kQ2hpbGQobC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxjPWwuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO2Muc2V0QXR0cmlidXRlKFwidHlwZVwiLFwicmFkaW9cIiksYy5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsXCJjaGVja2VkXCIpLGMuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwidFwiKSxiLmFwcGVuZENoaWxkKGMpLGsuY2hlY2tDbG9uZT1iLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCxiLmlubmVySFRNTD1cIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIixrLm5vQ2xvbmVDaGVja2VkPSEhYi5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWV9KCk7dmFyIFU9XCJ1bmRlZmluZWRcIjtrLmZvY3VzaW5CdWJibGVzPVwib25mb2N1c2luXCJpbiBhO3ZhciBWPS9ea2V5LyxXPS9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudSl8Y2xpY2svLFg9L14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFk9L14oW14uXSopKD86XFwuKC4rKXwpJC87ZnVuY3Rpb24gWigpe3JldHVybiEwfWZ1bmN0aW9uICQoKXtyZXR1cm4hMX1mdW5jdGlvbiBfKCl7dHJ5e3JldHVybiBsLmFjdGl2ZUVsZW1lbnR9Y2F0Y2goYSl7fX1uLmV2ZW50PXtnbG9iYWw6e30sYWRkOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZyxoLGksaixrLGwsbSxvLHAscSxyPUwuZ2V0KGEpO2lmKHIpe2MuaGFuZGxlciYmKGY9YyxjPWYuaGFuZGxlcixlPWYuc2VsZWN0b3IpLGMuZ3VpZHx8KGMuZ3VpZD1uLmd1aWQrKyksKGk9ci5ldmVudHMpfHwoaT1yLmV2ZW50cz17fSksKGc9ci5oYW5kbGUpfHwoZz1yLmhhbmRsZT1mdW5jdGlvbihiKXtyZXR1cm4gdHlwZW9mIG4hPT1VJiZuLmV2ZW50LnRyaWdnZXJlZCE9PWIudHlwZT9uLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGEsYXJndW1lbnRzKTp2b2lkIDB9KSxiPShifHxcIlwiKS5tYXRjaChFKXx8W1wiXCJdLGo9Yi5sZW5ndGg7d2hpbGUoai0tKWg9WS5leGVjKGJbal0pfHxbXSxvPXE9aFsxXSxwPShoWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLG8mJihsPW4uZXZlbnQuc3BlY2lhbFtvXXx8e30sbz0oZT9sLmRlbGVnYXRlVHlwZTpsLmJpbmRUeXBlKXx8byxsPW4uZXZlbnQuc3BlY2lhbFtvXXx8e30saz1uLmV4dGVuZCh7dHlwZTpvLG9yaWdUeXBlOnEsZGF0YTpkLGhhbmRsZXI6YyxndWlkOmMuZ3VpZCxzZWxlY3RvcjplLG5lZWRzQ29udGV4dDplJiZuLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoZSksbmFtZXNwYWNlOnAuam9pbihcIi5cIil9LGYpLChtPWlbb10pfHwobT1pW29dPVtdLG0uZGVsZWdhdGVDb3VudD0wLGwuc2V0dXAmJmwuc2V0dXAuY2FsbChhLGQscCxnKSE9PSExfHxhLmFkZEV2ZW50TGlzdGVuZXImJmEuYWRkRXZlbnRMaXN0ZW5lcihvLGcsITEpKSxsLmFkZCYmKGwuYWRkLmNhbGwoYSxrKSxrLmhhbmRsZXIuZ3VpZHx8KGsuaGFuZGxlci5ndWlkPWMuZ3VpZCkpLGU/bS5zcGxpY2UobS5kZWxlZ2F0ZUNvdW50KyssMCxrKTptLnB1c2goayksbi5ldmVudC5nbG9iYWxbb109ITApfX0scmVtb3ZlOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZyxoLGksaixrLGwsbSxvLHAscSxyPUwuaGFzRGF0YShhKSYmTC5nZXQoYSk7aWYociYmKGk9ci5ldmVudHMpKXtiPShifHxcIlwiKS5tYXRjaChFKXx8W1wiXCJdLGo9Yi5sZW5ndGg7d2hpbGUoai0tKWlmKGg9WS5leGVjKGJbal0pfHxbXSxvPXE9aFsxXSxwPShoWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLG8pe2w9bi5ldmVudC5zcGVjaWFsW29dfHx7fSxvPShkP2wuZGVsZWdhdGVUeXBlOmwuYmluZFR5cGUpfHxvLG09aVtvXXx8W10saD1oWzJdJiZuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIrcC5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikrXCIoXFxcXC58JClcIiksZz1mPW0ubGVuZ3RoO3doaWxlKGYtLSlrPW1bZl0sIWUmJnEhPT1rLm9yaWdUeXBlfHxjJiZjLmd1aWQhPT1rLmd1aWR8fGgmJiFoLnRlc3Qoay5uYW1lc3BhY2UpfHxkJiZkIT09ay5zZWxlY3RvciYmKFwiKipcIiE9PWR8fCFrLnNlbGVjdG9yKXx8KG0uc3BsaWNlKGYsMSksay5zZWxlY3RvciYmbS5kZWxlZ2F0ZUNvdW50LS0sbC5yZW1vdmUmJmwucmVtb3ZlLmNhbGwoYSxrKSk7ZyYmIW0ubGVuZ3RoJiYobC50ZWFyZG93biYmbC50ZWFyZG93bi5jYWxsKGEscCxyLmhhbmRsZSkhPT0hMXx8bi5yZW1vdmVFdmVudChhLG8sci5oYW5kbGUpLGRlbGV0ZSBpW29dKX1lbHNlIGZvcihvIGluIGkpbi5ldmVudC5yZW1vdmUoYSxvK2Jbal0sYyxkLCEwKTtuLmlzRW1wdHlPYmplY3QoaSkmJihkZWxldGUgci5oYW5kbGUsTC5yZW1vdmUoYSxcImV2ZW50c1wiKSl9fSx0cmlnZ2VyOmZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmLGcsaCxpLGssbSxvLHA9W2R8fGxdLHE9ai5jYWxsKGIsXCJ0eXBlXCIpP2IudHlwZTpiLHI9ai5jYWxsKGIsXCJuYW1lc3BhY2VcIik/Yi5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpOltdO2lmKGc9aD1kPWR8fGwsMyE9PWQubm9kZVR5cGUmJjghPT1kLm5vZGVUeXBlJiYhWC50ZXN0KHErbi5ldmVudC50cmlnZ2VyZWQpJiYocS5pbmRleE9mKFwiLlwiKT49MCYmKHI9cS5zcGxpdChcIi5cIikscT1yLnNoaWZ0KCksci5zb3J0KCkpLGs9cS5pbmRleE9mKFwiOlwiKTwwJiZcIm9uXCIrcSxiPWJbbi5leHBhbmRvXT9iOm5ldyBuLkV2ZW50KHEsXCJvYmplY3RcIj09dHlwZW9mIGImJmIpLGIuaXNUcmlnZ2VyPWU/MjozLGIubmFtZXNwYWNlPXIuam9pbihcIi5cIiksYi5uYW1lc3BhY2VfcmU9Yi5uYW1lc3BhY2U/bmV3IFJlZ0V4cChcIihefFxcXFwuKVwiK3Iuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpOm51bGwsYi5yZXN1bHQ9dm9pZCAwLGIudGFyZ2V0fHwoYi50YXJnZXQ9ZCksYz1udWxsPT1jP1tiXTpuLm1ha2VBcnJheShjLFtiXSksbz1uLmV2ZW50LnNwZWNpYWxbcV18fHt9LGV8fCFvLnRyaWdnZXJ8fG8udHJpZ2dlci5hcHBseShkLGMpIT09ITEpKXtpZighZSYmIW8ubm9CdWJibGUmJiFuLmlzV2luZG93KGQpKXtmb3IoaT1vLmRlbGVnYXRlVHlwZXx8cSxYLnRlc3QoaStxKXx8KGc9Zy5wYXJlbnROb2RlKTtnO2c9Zy5wYXJlbnROb2RlKXAucHVzaChnKSxoPWc7aD09PShkLm93bmVyRG9jdW1lbnR8fGwpJiZwLnB1c2goaC5kZWZhdWx0Vmlld3x8aC5wYXJlbnRXaW5kb3d8fGEpfWY9MDt3aGlsZSgoZz1wW2YrK10pJiYhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWIudHlwZT1mPjE/aTpvLmJpbmRUeXBlfHxxLG09KEwuZ2V0KGcsXCJldmVudHNcIil8fHt9KVtiLnR5cGVdJiZMLmdldChnLFwiaGFuZGxlXCIpLG0mJm0uYXBwbHkoZyxjKSxtPWsmJmdba10sbSYmbS5hcHBseSYmbi5hY2NlcHREYXRhKGcpJiYoYi5yZXN1bHQ9bS5hcHBseShnLGMpLGIucmVzdWx0PT09ITEmJmIucHJldmVudERlZmF1bHQoKSk7cmV0dXJuIGIudHlwZT1xLGV8fGIuaXNEZWZhdWx0UHJldmVudGVkKCl8fG8uX2RlZmF1bHQmJm8uX2RlZmF1bHQuYXBwbHkocC5wb3AoKSxjKSE9PSExfHwhbi5hY2NlcHREYXRhKGQpfHxrJiZuLmlzRnVuY3Rpb24oZFtxXSkmJiFuLmlzV2luZG93KGQpJiYoaD1kW2tdLGgmJihkW2tdPW51bGwpLG4uZXZlbnQudHJpZ2dlcmVkPXEsZFtxXSgpLG4uZXZlbnQudHJpZ2dlcmVkPXZvaWQgMCxoJiYoZFtrXT1oKSksYi5yZXN1bHR9fSxkaXNwYXRjaDpmdW5jdGlvbihhKXthPW4uZXZlbnQuZml4KGEpO3ZhciBiLGMsZSxmLGcsaD1bXSxpPWQuY2FsbChhcmd1bWVudHMpLGo9KEwuZ2V0KHRoaXMsXCJldmVudHNcIil8fHt9KVthLnR5cGVdfHxbXSxrPW4uZXZlbnQuc3BlY2lhbFthLnR5cGVdfHx7fTtpZihpWzBdPWEsYS5kZWxlZ2F0ZVRhcmdldD10aGlzLCFrLnByZURpc3BhdGNofHxrLnByZURpc3BhdGNoLmNhbGwodGhpcyxhKSE9PSExKXtoPW4uZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLGEsaiksYj0wO3doaWxlKChmPWhbYisrXSkmJiFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpe2EuY3VycmVudFRhcmdldD1mLmVsZW0sYz0wO3doaWxlKChnPWYuaGFuZGxlcnNbYysrXSkmJiFhLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpKCFhLm5hbWVzcGFjZV9yZXx8YS5uYW1lc3BhY2VfcmUudGVzdChnLm5hbWVzcGFjZSkpJiYoYS5oYW5kbGVPYmo9ZyxhLmRhdGE9Zy5kYXRhLGU9KChuLmV2ZW50LnNwZWNpYWxbZy5vcmlnVHlwZV18fHt9KS5oYW5kbGV8fGcuaGFuZGxlcikuYXBwbHkoZi5lbGVtLGkpLHZvaWQgMCE9PWUmJihhLnJlc3VsdD1lKT09PSExJiYoYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCkpKX1yZXR1cm4gay5wb3N0RGlzcGF0Y2gmJmsucG9zdERpc3BhdGNoLmNhbGwodGhpcyxhKSxhLnJlc3VsdH19LGhhbmRsZXJzOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZz1bXSxoPWIuZGVsZWdhdGVDb3VudCxpPWEudGFyZ2V0O2lmKGgmJmkubm9kZVR5cGUmJighYS5idXR0b258fFwiY2xpY2tcIiE9PWEudHlwZSkpZm9yKDtpIT09dGhpcztpPWkucGFyZW50Tm9kZXx8dGhpcylpZihpLmRpc2FibGVkIT09ITB8fFwiY2xpY2tcIiE9PWEudHlwZSl7Zm9yKGQ9W10sYz0wO2g+YztjKyspZj1iW2NdLGU9Zi5zZWxlY3RvcitcIiBcIix2b2lkIDA9PT1kW2VdJiYoZFtlXT1mLm5lZWRzQ29udGV4dD9uKGUsdGhpcykuaW5kZXgoaSk+PTA6bi5maW5kKGUsdGhpcyxudWxsLFtpXSkubGVuZ3RoKSxkW2VdJiZkLnB1c2goZik7ZC5sZW5ndGgmJmcucHVzaCh7ZWxlbTppLGhhbmRsZXJzOmR9KX1yZXR1cm4gaDxiLmxlbmd0aCYmZy5wdXNoKHtlbGVtOnRoaXMsaGFuZGxlcnM6Yi5zbGljZShoKX0pLGd9LHByb3BzOlwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLGZpeEhvb2tzOnt9LGtleUhvb2tzOntwcm9wczpcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksZmlsdGVyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGw9PWEud2hpY2gmJihhLndoaWNoPW51bGwhPWIuY2hhckNvZGU/Yi5jaGFyQ29kZTpiLmtleUNvZGUpLGF9fSxtb3VzZUhvb2tzOntwcm9wczpcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFwiLnNwbGl0KFwiIFwiKSxmaWx0ZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZj1iLmJ1dHRvbjtyZXR1cm4gbnVsbD09YS5wYWdlWCYmbnVsbCE9Yi5jbGllbnRYJiYoYz1hLnRhcmdldC5vd25lckRvY3VtZW50fHxsLGQ9Yy5kb2N1bWVudEVsZW1lbnQsZT1jLmJvZHksYS5wYWdlWD1iLmNsaWVudFgrKGQmJmQuc2Nyb2xsTGVmdHx8ZSYmZS5zY3JvbGxMZWZ0fHwwKS0oZCYmZC5jbGllbnRMZWZ0fHxlJiZlLmNsaWVudExlZnR8fDApLGEucGFnZVk9Yi5jbGllbnRZKyhkJiZkLnNjcm9sbFRvcHx8ZSYmZS5zY3JvbGxUb3B8fDApLShkJiZkLmNsaWVudFRvcHx8ZSYmZS5jbGllbnRUb3B8fDApKSxhLndoaWNofHx2b2lkIDA9PT1mfHwoYS53aGljaD0xJmY/MToyJmY/Mzo0JmY/MjowKSxhfX0sZml4OmZ1bmN0aW9uKGEpe2lmKGFbbi5leHBhbmRvXSlyZXR1cm4gYTt2YXIgYixjLGQsZT1hLnR5cGUsZj1hLGc9dGhpcy5maXhIb29rc1tlXTtnfHwodGhpcy5maXhIb29rc1tlXT1nPVcudGVzdChlKT90aGlzLm1vdXNlSG9va3M6Vi50ZXN0KGUpP3RoaXMua2V5SG9va3M6e30pLGQ9Zy5wcm9wcz90aGlzLnByb3BzLmNvbmNhdChnLnByb3BzKTp0aGlzLnByb3BzLGE9bmV3IG4uRXZlbnQoZiksYj1kLmxlbmd0aDt3aGlsZShiLS0pYz1kW2JdLGFbY109ZltjXTtyZXR1cm4gYS50YXJnZXR8fChhLnRhcmdldD1sKSwzPT09YS50YXJnZXQubm9kZVR5cGUmJihhLnRhcmdldD1hLnRhcmdldC5wYXJlbnROb2RlKSxnLmZpbHRlcj9nLmZpbHRlcihhLGYpOmF9LHNwZWNpYWw6e2xvYWQ6e25vQnViYmxlOiEwfSxmb2N1czp7dHJpZ2dlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzIT09XygpJiZ0aGlzLmZvY3VzPyh0aGlzLmZvY3VzKCksITEpOnZvaWQgMH0sZGVsZWdhdGVUeXBlOlwiZm9jdXNpblwifSxibHVyOnt0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXM9PT1fKCkmJnRoaXMuYmx1cj8odGhpcy5ibHVyKCksITEpOnZvaWQgMH0sZGVsZWdhdGVUeXBlOlwiZm9jdXNvdXRcIn0sY2xpY2s6e3RyaWdnZXI6ZnVuY3Rpb24oKXtyZXR1cm5cImNoZWNrYm94XCI9PT10aGlzLnR5cGUmJnRoaXMuY2xpY2smJm4ubm9kZU5hbWUodGhpcyxcImlucHV0XCIpPyh0aGlzLmNsaWNrKCksITEpOnZvaWQgMH0sX2RlZmF1bHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG4ubm9kZU5hbWUoYS50YXJnZXQsXCJhXCIpfX0sYmVmb3JldW5sb2FkOntwb3N0RGlzcGF0Y2g6ZnVuY3Rpb24oYSl7dm9pZCAwIT09YS5yZXN1bHQmJmEub3JpZ2luYWxFdmVudCYmKGEub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZT1hLnJlc3VsdCl9fX0sc2ltdWxhdGU6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bi5leHRlbmQobmV3IG4uRXZlbnQsYyx7dHlwZTphLGlzU2ltdWxhdGVkOiEwLG9yaWdpbmFsRXZlbnQ6e319KTtkP24uZXZlbnQudHJpZ2dlcihlLG51bGwsYik6bi5ldmVudC5kaXNwYXRjaC5jYWxsKGIsZSksZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmYy5wcmV2ZW50RGVmYXVsdCgpfX0sbi5yZW1vdmVFdmVudD1mdW5jdGlvbihhLGIsYyl7YS5yZW1vdmVFdmVudExpc3RlbmVyJiZhLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLCExKX0sbi5FdmVudD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzIGluc3RhbmNlb2Ygbi5FdmVudD8oYSYmYS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9YSx0aGlzLnR5cGU9YS50eXBlLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWEuZGVmYXVsdFByZXZlbnRlZHx8dm9pZCAwPT09YS5kZWZhdWx0UHJldmVudGVkJiZhLnJldHVyblZhbHVlPT09ITE/WjokKTp0aGlzLnR5cGU9YSxiJiZuLmV4dGVuZCh0aGlzLGIpLHRoaXMudGltZVN0YW1wPWEmJmEudGltZVN0YW1wfHxuLm5vdygpLHZvaWQodGhpc1tuLmV4cGFuZG9dPSEwKSk6bmV3IG4uRXZlbnQoYSxiKX0sbi5FdmVudC5wcm90b3R5cGU9e2lzRGVmYXVsdFByZXZlbnRlZDokLGlzUHJvcGFnYXRpb25TdG9wcGVkOiQsaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6JCxwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1aLGEmJmEucHJldmVudERlZmF1bHQmJmEucHJldmVudERlZmF1bHQoKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9WixhJiZhLnN0b3BQcm9wYWdhdGlvbiYmYS5zdG9wUHJvcGFnYXRpb24oKX0sc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9WixhJiZhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiYmYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSx0aGlzLnN0b3BQcm9wYWdhdGlvbigpfX0sbi5lYWNoKHttb3VzZWVudGVyOlwibW91c2VvdmVyXCIsbW91c2VsZWF2ZTpcIm1vdXNlb3V0XCIscG9pbnRlcmVudGVyOlwicG9pbnRlcm92ZXJcIixwb2ludGVybGVhdmU6XCJwb2ludGVyb3V0XCJ9LGZ1bmN0aW9uKGEsYil7bi5ldmVudC5zcGVjaWFsW2FdPXtkZWxlZ2F0ZVR5cGU6YixiaW5kVHlwZTpiLGhhbmRsZTpmdW5jdGlvbihhKXt2YXIgYyxkPXRoaXMsZT1hLnJlbGF0ZWRUYXJnZXQsZj1hLmhhbmRsZU9iajtyZXR1cm4oIWV8fGUhPT1kJiYhbi5jb250YWlucyhkLGUpKSYmKGEudHlwZT1mLm9yaWdUeXBlLGM9Zi5oYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxhLnR5cGU9YiksY319fSksay5mb2N1c2luQnViYmxlc3x8bi5lYWNoKHtmb2N1czpcImZvY3VzaW5cIixibHVyOlwiZm9jdXNvdXRcIn0sZnVuY3Rpb24oYSxiKXt2YXIgYz1mdW5jdGlvbihhKXtuLmV2ZW50LnNpbXVsYXRlKGIsYS50YXJnZXQsbi5ldmVudC5maXgoYSksITApfTtuLmV2ZW50LnNwZWNpYWxbYl09e3NldHVwOmZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5vd25lckRvY3VtZW50fHx0aGlzLGU9TC5hY2Nlc3MoZCxiKTtlfHxkLmFkZEV2ZW50TGlzdGVuZXIoYSxjLCEwKSxMLmFjY2VzcyhkLGIsKGV8fDApKzEpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3ZhciBkPXRoaXMub3duZXJEb2N1bWVudHx8dGhpcyxlPUwuYWNjZXNzKGQsYiktMTtlP0wuYWNjZXNzKGQsYixlKTooZC5yZW1vdmVFdmVudExpc3RlbmVyKGEsYywhMCksTC5yZW1vdmUoZCxiKSl9fX0pLG4uZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmLGc7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEpe1wic3RyaW5nXCIhPXR5cGVvZiBiJiYoYz1jfHxiLGI9dm9pZCAwKTtmb3IoZyBpbiBhKXRoaXMub24oZyxiLGMsYVtnXSxlKTtyZXR1cm4gdGhpc31pZihudWxsPT1jJiZudWxsPT1kPyhkPWIsYz1iPXZvaWQgMCk6bnVsbD09ZCYmKFwic3RyaW5nXCI9PXR5cGVvZiBiPyhkPWMsYz12b2lkIDApOihkPWMsYz1iLGI9dm9pZCAwKSksZD09PSExKWQ9JDtlbHNlIGlmKCFkKXJldHVybiB0aGlzO3JldHVybiAxPT09ZSYmKGY9ZCxkPWZ1bmN0aW9uKGEpe3JldHVybiBuKCkub2ZmKGEpLGYuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxkLmd1aWQ9Zi5ndWlkfHwoZi5ndWlkPW4uZ3VpZCsrKSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7bi5ldmVudC5hZGQodGhpcyxhLGQsYyxiKX0pfSxvbmU6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMub24oYSxiLGMsZCwxKX0sb2ZmOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlO2lmKGEmJmEucHJldmVudERlZmF1bHQmJmEuaGFuZGxlT2JqKXJldHVybiBkPWEuaGFuZGxlT2JqLG4oYS5kZWxlZ2F0ZVRhcmdldCkub2ZmKGQubmFtZXNwYWNlP2Qub3JpZ1R5cGUrXCIuXCIrZC5uYW1lc3BhY2U6ZC5vcmlnVHlwZSxkLnNlbGVjdG9yLGQuaGFuZGxlciksdGhpcztpZihcIm9iamVjdFwiPT10eXBlb2YgYSl7Zm9yKGUgaW4gYSl0aGlzLm9mZihlLGIsYVtlXSk7cmV0dXJuIHRoaXN9cmV0dXJuKGI9PT0hMXx8XCJmdW5jdGlvblwiPT10eXBlb2YgYikmJihjPWIsYj12b2lkIDApLGM9PT0hMSYmKGM9JCksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7bi5ldmVudC5yZW1vdmUodGhpcyxhLGMsYil9KX0sdHJpZ2dlcjpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtuLmV2ZW50LnRyaWdnZXIoYSxiLHRoaXMpfSl9LHRyaWdnZXJIYW5kbGVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpc1swXTtyZXR1cm4gYz9uLmV2ZW50LnRyaWdnZXIoYSxiLGMsITApOnZvaWQgMH19KTt2YXIgYWE9LzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2dpLGJhPS88KFtcXHc6XSspLyxjYT0vPHwmIz9cXHcrOy8sZGE9LzwoPzpzY3JpcHR8c3R5bGV8bGluaykvaSxlYT0vY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLGZhPS9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksZ2E9L150cnVlXFwvKC4qKS8saGE9L15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nLGlhPXtvcHRpb246WzEsXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsXCI8L3NlbGVjdD5cIl0sdGhlYWQ6WzEsXCI8dGFibGU+XCIsXCI8L3RhYmxlPlwiXSxjb2w6WzIsXCI8dGFibGU+PGNvbGdyb3VwPlwiLFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSx0cjpbMixcIjx0YWJsZT48dGJvZHk+XCIsXCI8L3Rib2R5PjwvdGFibGU+XCJdLHRkOlszLFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sX2RlZmF1bHQ6WzAsXCJcIixcIlwiXX07aWEub3B0Z3JvdXA9aWEub3B0aW9uLGlhLnRib2R5PWlhLnRmb290PWlhLmNvbGdyb3VwPWlhLmNhcHRpb249aWEudGhlYWQsaWEudGg9aWEudGQ7ZnVuY3Rpb24gamEoYSxiKXtyZXR1cm4gbi5ub2RlTmFtZShhLFwidGFibGVcIikmJm4ubm9kZU5hbWUoMTEhPT1iLm5vZGVUeXBlP2I6Yi5maXJzdENoaWxkLFwidHJcIik/YS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdfHxhLmFwcGVuZENoaWxkKGEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikpOmF9ZnVuY3Rpb24ga2EoYSl7cmV0dXJuIGEudHlwZT0obnVsbCE9PWEuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkrXCIvXCIrYS50eXBlLGF9ZnVuY3Rpb24gbGEoYSl7dmFyIGI9Z2EuZXhlYyhhLnR5cGUpO3JldHVybiBiP2EudHlwZT1iWzFdOmEucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKSxhfWZ1bmN0aW9uIG1hKGEsYil7Zm9yKHZhciBjPTAsZD1hLmxlbmd0aDtkPmM7YysrKUwuc2V0KGFbY10sXCJnbG9iYWxFdmFsXCIsIWJ8fEwuZ2V0KGJbY10sXCJnbG9iYWxFdmFsXCIpKX1mdW5jdGlvbiBuYShhLGIpe3ZhciBjLGQsZSxmLGcsaCxpLGo7aWYoMT09PWIubm9kZVR5cGUpe2lmKEwuaGFzRGF0YShhKSYmKGY9TC5hY2Nlc3MoYSksZz1MLnNldChiLGYpLGo9Zi5ldmVudHMpKXtkZWxldGUgZy5oYW5kbGUsZy5ldmVudHM9e307Zm9yKGUgaW4gailmb3IoYz0wLGQ9altlXS5sZW5ndGg7ZD5jO2MrKyluLmV2ZW50LmFkZChiLGUsaltlXVtjXSl9TS5oYXNEYXRhKGEpJiYoaD1NLmFjY2VzcyhhKSxpPW4uZXh0ZW5kKHt9LGgpLE0uc2V0KGIsaSkpfX1mdW5jdGlvbiBvYShhLGIpe3ZhciBjPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWU/YS5nZXRFbGVtZW50c0J5VGFnTmFtZShifHxcIipcIik6YS5xdWVyeVNlbGVjdG9yQWxsP2EucXVlcnlTZWxlY3RvckFsbChifHxcIipcIik6W107cmV0dXJuIHZvaWQgMD09PWJ8fGImJm4ubm9kZU5hbWUoYSxiKT9uLm1lcmdlKFthXSxjKTpjfWZ1bmN0aW9uIHBhKGEsYil7dmFyIGM9Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1wiaW5wdXRcIj09PWMmJlQudGVzdChhLnR5cGUpP2IuY2hlY2tlZD1hLmNoZWNrZWQ6KFwiaW5wdXRcIj09PWN8fFwidGV4dGFyZWFcIj09PWMpJiYoYi5kZWZhdWx0VmFsdWU9YS5kZWZhdWx0VmFsdWUpfW4uZXh0ZW5kKHtjbG9uZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGcsaD1hLmNsb25lTm9kZSghMCksaT1uLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKTtpZighKGsubm9DbG9uZUNoZWNrZWR8fDEhPT1hLm5vZGVUeXBlJiYxMSE9PWEubm9kZVR5cGV8fG4uaXNYTUxEb2MoYSkpKWZvcihnPW9hKGgpLGY9b2EoYSksZD0wLGU9Zi5sZW5ndGg7ZT5kO2QrKylwYShmW2RdLGdbZF0pO2lmKGIpaWYoYylmb3IoZj1mfHxvYShhKSxnPWd8fG9hKGgpLGQ9MCxlPWYubGVuZ3RoO2U+ZDtkKyspbmEoZltkXSxnW2RdKTtlbHNlIG5hKGEsaCk7cmV0dXJuIGc9b2EoaCxcInNjcmlwdFwiKSxnLmxlbmd0aD4wJiZtYShnLCFpJiZvYShhLFwic2NyaXB0XCIpKSxofSxidWlsZEZyYWdtZW50OmZ1bmN0aW9uKGEsYixjLGQpe2Zvcih2YXIgZSxmLGcsaCxpLGosaz1iLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxsPVtdLG09MCxvPWEubGVuZ3RoO28+bTttKyspaWYoZT1hW21dLGV8fDA9PT1lKWlmKFwib2JqZWN0XCI9PT1uLnR5cGUoZSkpbi5tZXJnZShsLGUubm9kZVR5cGU/W2VdOmUpO2Vsc2UgaWYoY2EudGVzdChlKSl7Zj1mfHxrLmFwcGVuZENoaWxkKGIuY3JlYXRlRWxlbWVudChcImRpdlwiKSksZz0oYmEuZXhlYyhlKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCksaD1pYVtnXXx8aWEuX2RlZmF1bHQsZi5pbm5lckhUTUw9aFsxXStlLnJlcGxhY2UoYWEsXCI8JDE+PC8kMj5cIikraFsyXSxqPWhbMF07d2hpbGUoai0tKWY9Zi5sYXN0Q2hpbGQ7bi5tZXJnZShsLGYuY2hpbGROb2RlcyksZj1rLmZpcnN0Q2hpbGQsZi50ZXh0Q29udGVudD1cIlwifWVsc2UgbC5wdXNoKGIuY3JlYXRlVGV4dE5vZGUoZSkpO2sudGV4dENvbnRlbnQ9XCJcIixtPTA7d2hpbGUoZT1sW20rK10paWYoKCFkfHwtMT09PW4uaW5BcnJheShlLGQpKSYmKGk9bi5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsZSksZj1vYShrLmFwcGVuZENoaWxkKGUpLFwic2NyaXB0XCIpLGkmJm1hKGYpLGMpKXtqPTA7d2hpbGUoZT1mW2orK10pZmEudGVzdChlLnR5cGV8fFwiXCIpJiZjLnB1c2goZSl9cmV0dXJuIGt9LGNsZWFuRGF0YTpmdW5jdGlvbihhKXtmb3IodmFyIGIsYyxkLGUsZj1uLmV2ZW50LnNwZWNpYWwsZz0wO3ZvaWQgMCE9PShjPWFbZ10pO2crKyl7aWYobi5hY2NlcHREYXRhKGMpJiYoZT1jW0wuZXhwYW5kb10sZSYmKGI9TC5jYWNoZVtlXSkpKXtpZihiLmV2ZW50cylmb3IoZCBpbiBiLmV2ZW50cylmW2RdP24uZXZlbnQucmVtb3ZlKGMsZCk6bi5yZW1vdmVFdmVudChjLGQsYi5oYW5kbGUpO0wuY2FjaGVbZV0mJmRlbGV0ZSBMLmNhY2hlW2VdfWRlbGV0ZSBNLmNhY2hlW2NbTS5leHBhbmRvXV19fX0pLG4uZm4uZXh0ZW5kKHt0ZXh0OmZ1bmN0aW9uKGEpe3JldHVybiBKKHRoaXMsZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMD09PWE/bi50ZXh0KHRoaXMpOnRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCl7KDE9PT10aGlzLm5vZGVUeXBlfHwxMT09PXRoaXMubm9kZVR5cGV8fDk9PT10aGlzLm5vZGVUeXBlKSYmKHRoaXMudGV4dENvbnRlbnQ9YSl9KX0sbnVsbCxhLGFyZ3VtZW50cy5sZW5ndGgpfSxhcHBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsZnVuY3Rpb24oYSl7aWYoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpe3ZhciBiPWphKHRoaXMsYSk7Yi5hcHBlbmRDaGlsZChhKX19KX0scHJlcGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihhKXtpZigxPT09dGhpcy5ub2RlVHlwZXx8MTE9PT10aGlzLm5vZGVUeXBlfHw5PT09dGhpcy5ub2RlVHlwZSl7dmFyIGI9amEodGhpcyxhKTtiLmluc2VydEJlZm9yZShhLGIuZmlyc3RDaGlsZCl9fSl9LGJlZm9yZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihhKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSx0aGlzKX0pfSxhZnRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihhKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSx0aGlzLm5leHRTaWJsaW5nKX0pfSxyZW1vdmU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZD1hP24uZmlsdGVyKGEsdGhpcyk6dGhpcyxlPTA7bnVsbCE9KGM9ZFtlXSk7ZSsrKWJ8fDEhPT1jLm5vZGVUeXBlfHxuLmNsZWFuRGF0YShvYShjKSksYy5wYXJlbnROb2RlJiYoYiYmbi5jb250YWlucyhjLm93bmVyRG9jdW1lbnQsYykmJm1hKG9hKGMsXCJzY3JpcHRcIikpLGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSk7cmV0dXJuIHRoaXN9LGVtcHR5OmZ1bmN0aW9uKCl7Zm9yKHZhciBhLGI9MDtudWxsIT0oYT10aGlzW2JdKTtiKyspMT09PWEubm9kZVR5cGUmJihuLmNsZWFuRGF0YShvYShhLCExKSksYS50ZXh0Q29udGVudD1cIlwiKTtyZXR1cm4gdGhpc30sY2xvbmU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT1udWxsPT1hPyExOmEsYj1udWxsPT1iP2E6Yix0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiBuLmNsb25lKHRoaXMsYSxiKX0pfSxodG1sOmZ1bmN0aW9uKGEpe3JldHVybiBKKHRoaXMsZnVuY3Rpb24oYSl7dmFyIGI9dGhpc1swXXx8e30sYz0wLGQ9dGhpcy5sZW5ndGg7aWYodm9pZCAwPT09YSYmMT09PWIubm9kZVR5cGUpcmV0dXJuIGIuaW5uZXJIVE1MO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhJiYhZGEudGVzdChhKSYmIWlhWyhiYS5leGVjKGEpfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pe2E9YS5yZXBsYWNlKGFhLFwiPCQxPjwvJDI+XCIpO3RyeXtmb3IoO2Q+YztjKyspYj10aGlzW2NdfHx7fSwxPT09Yi5ub2RlVHlwZSYmKG4uY2xlYW5EYXRhKG9hKGIsITEpKSxiLmlubmVySFRNTD1hKTtiPTB9Y2F0Y2goZSl7fX1iJiZ0aGlzLmVtcHR5KCkuYXBwZW5kKGEpfSxudWxsLGEsYXJndW1lbnRzLmxlbmd0aCl9LHJlcGxhY2VXaXRoOmZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihiKXthPXRoaXMucGFyZW50Tm9kZSxuLmNsZWFuRGF0YShvYSh0aGlzKSksYSYmYS5yZXBsYWNlQ2hpbGQoYix0aGlzKX0pLGEmJihhLmxlbmd0aHx8YS5ub2RlVHlwZSk/dGhpczp0aGlzLnJlbW92ZSgpfSxkZXRhY2g6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucmVtb3ZlKGEsITApfSxkb21NYW5pcDpmdW5jdGlvbihhLGIpe2E9ZS5hcHBseShbXSxhKTt2YXIgYyxkLGYsZyxoLGksaj0wLGw9dGhpcy5sZW5ndGgsbT10aGlzLG89bC0xLHA9YVswXSxxPW4uaXNGdW5jdGlvbihwKTtpZihxfHxsPjEmJlwic3RyaW5nXCI9PXR5cGVvZiBwJiYhay5jaGVja0Nsb25lJiZlYS50ZXN0KHApKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYyl7dmFyIGQ9bS5lcShjKTtxJiYoYVswXT1wLmNhbGwodGhpcyxjLGQuaHRtbCgpKSksZC5kb21NYW5pcChhLGIpfSk7aWYobCYmKGM9bi5idWlsZEZyYWdtZW50KGEsdGhpc1swXS5vd25lckRvY3VtZW50LCExLHRoaXMpLGQ9Yy5maXJzdENoaWxkLDE9PT1jLmNoaWxkTm9kZXMubGVuZ3RoJiYoYz1kKSxkKSl7Zm9yKGY9bi5tYXAob2EoYyxcInNjcmlwdFwiKSxrYSksZz1mLmxlbmd0aDtsPmo7aisrKWg9YyxqIT09byYmKGg9bi5jbG9uZShoLCEwLCEwKSxnJiZuLm1lcmdlKGYsb2EoaCxcInNjcmlwdFwiKSkpLGIuY2FsbCh0aGlzW2pdLGgsaik7aWYoZylmb3IoaT1mW2YubGVuZ3RoLTFdLm93bmVyRG9jdW1lbnQsbi5tYXAoZixsYSksaj0wO2c+ajtqKyspaD1mW2pdLGZhLnRlc3QoaC50eXBlfHxcIlwiKSYmIUwuYWNjZXNzKGgsXCJnbG9iYWxFdmFsXCIpJiZuLmNvbnRhaW5zKGksaCkmJihoLnNyYz9uLl9ldmFsVXJsJiZuLl9ldmFsVXJsKGguc3JjKTpuLmdsb2JhbEV2YWwoaC50ZXh0Q29udGVudC5yZXBsYWNlKGhhLFwiXCIpKSl9cmV0dXJuIHRoaXN9fSksbi5lYWNoKHthcHBlbmRUbzpcImFwcGVuZFwiLHByZXBlbmRUbzpcInByZXBlbmRcIixpbnNlcnRCZWZvcmU6XCJiZWZvcmVcIixpbnNlcnRBZnRlcjpcImFmdGVyXCIscmVwbGFjZUFsbDpcInJlcGxhY2VXaXRoXCJ9LGZ1bmN0aW9uKGEsYil7bi5mblthXT1mdW5jdGlvbihhKXtmb3IodmFyIGMsZD1bXSxlPW4oYSksZz1lLmxlbmd0aC0xLGg9MDtnPj1oO2grKyljPWg9PT1nP3RoaXM6dGhpcy5jbG9uZSghMCksbihlW2hdKVtiXShjKSxmLmFwcGx5KGQsYy5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGQpfX0pO3ZhciBxYSxyYT17fTtmdW5jdGlvbiBzYShiLGMpe3ZhciBkLGU9bihjLmNyZWF0ZUVsZW1lbnQoYikpLmFwcGVuZFRvKGMuYm9keSksZj1hLmdldERlZmF1bHRDb21wdXRlZFN0eWxlJiYoZD1hLmdldERlZmF1bHRDb21wdXRlZFN0eWxlKGVbMF0pKT9kLmRpc3BsYXk6bi5jc3MoZVswXSxcImRpc3BsYXlcIik7cmV0dXJuIGUuZGV0YWNoKCksZn1mdW5jdGlvbiB0YShhKXt2YXIgYj1sLGM9cmFbYV07cmV0dXJuIGN8fChjPXNhKGEsYiksXCJub25lXCIhPT1jJiZjfHwocWE9KHFhfHxuKFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiKSkuYXBwZW5kVG8oYi5kb2N1bWVudEVsZW1lbnQpLGI9cWFbMF0uY29udGVudERvY3VtZW50LGIud3JpdGUoKSxiLmNsb3NlKCksYz1zYShhLGIpLHFhLmRldGFjaCgpKSxyYVthXT1jKSxjfXZhciB1YT0vXm1hcmdpbi8sdmE9bmV3IFJlZ0V4cChcIl4oXCIrUStcIikoPyFweClbYS16JV0rJFwiLFwiaVwiKSx3YT1mdW5jdGlvbihiKXtyZXR1cm4gYi5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lm9wZW5lcj9iLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShiLG51bGwpOmEuZ2V0Q29tcHV0ZWRTdHlsZShiLG51bGwpfTtmdW5jdGlvbiB4YShhLGIsYyl7dmFyIGQsZSxmLGcsaD1hLnN0eWxlO3JldHVybiBjPWN8fHdhKGEpLGMmJihnPWMuZ2V0UHJvcGVydHlWYWx1ZShiKXx8Y1tiXSksYyYmKFwiXCIhPT1nfHxuLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKXx8KGc9bi5zdHlsZShhLGIpKSx2YS50ZXN0KGcpJiZ1YS50ZXN0KGIpJiYoZD1oLndpZHRoLGU9aC5taW5XaWR0aCxmPWgubWF4V2lkdGgsaC5taW5XaWR0aD1oLm1heFdpZHRoPWgud2lkdGg9ZyxnPWMud2lkdGgsaC53aWR0aD1kLGgubWluV2lkdGg9ZSxoLm1heFdpZHRoPWYpKSx2b2lkIDAhPT1nP2crXCJcIjpnfWZ1bmN0aW9uIHlhKGEsYil7cmV0dXJue2dldDpmdW5jdGlvbigpe3JldHVybiBhKCk/dm9pZCBkZWxldGUgdGhpcy5nZXQ6KHRoaXMuZ2V0PWIpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19fSFmdW5jdGlvbigpe3ZhciBiLGMsZD1sLmRvY3VtZW50RWxlbWVudCxlPWwuY3JlYXRlRWxlbWVudChcImRpdlwiKSxmPWwuY3JlYXRlRWxlbWVudChcImRpdlwiKTtpZihmLnN0eWxlKXtmLnN0eWxlLmJhY2tncm91bmRDbGlwPVwiY29udGVudC1ib3hcIixmLmNsb25lTm9kZSghMCkuc3R5bGUuYmFja2dyb3VuZENsaXA9XCJcIixrLmNsZWFyQ2xvbmVTdHlsZT1cImNvbnRlbnQtYm94XCI9PT1mLnN0eWxlLmJhY2tncm91bmRDbGlwLGUuc3R5bGUuY3NzVGV4dD1cImJvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCIsZS5hcHBlbmRDaGlsZChmKTtmdW5jdGlvbiBnKCl7Zi5zdHlsZS5jc3NUZXh0PVwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDoxJTt0b3A6MSU7Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo0cHg7cG9zaXRpb246YWJzb2x1dGVcIixmLmlubmVySFRNTD1cIlwiLGQuYXBwZW5kQ2hpbGQoZSk7dmFyIGc9YS5nZXRDb21wdXRlZFN0eWxlKGYsbnVsbCk7Yj1cIjElXCIhPT1nLnRvcCxjPVwiNHB4XCI9PT1nLndpZHRoLGQucmVtb3ZlQ2hpbGQoZSl9YS5nZXRDb21wdXRlZFN0eWxlJiZuLmV4dGVuZChrLHtwaXhlbFBvc2l0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGcoKSxifSxib3hTaXppbmdSZWxpYWJsZTpmdW5jdGlvbigpe3JldHVybiBudWxsPT1jJiZnKCksY30scmVsaWFibGVNYXJnaW5SaWdodDpmdW5jdGlvbigpe3ZhciBiLGM9Zi5hcHBlbmRDaGlsZChsLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO3JldHVybiBjLnN0eWxlLmNzc1RleHQ9Zi5zdHlsZS5jc3NUZXh0PVwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXCIsYy5zdHlsZS5tYXJnaW5SaWdodD1jLnN0eWxlLndpZHRoPVwiMFwiLGYuc3R5bGUud2lkdGg9XCIxcHhcIixkLmFwcGVuZENoaWxkKGUpLGI9IXBhcnNlRmxvYXQoYS5nZXRDb21wdXRlZFN0eWxlKGMsbnVsbCkubWFyZ2luUmlnaHQpLGQucmVtb3ZlQ2hpbGQoZSksZi5yZW1vdmVDaGlsZChjKSxifX0pfX0oKSxuLnN3YXA9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixnPXt9O2ZvcihmIGluIGIpZ1tmXT1hLnN0eWxlW2ZdLGEuc3R5bGVbZl09YltmXTtlPWMuYXBwbHkoYSxkfHxbXSk7Zm9yKGYgaW4gYilhLnN0eWxlW2ZdPWdbZl07cmV0dXJuIGV9O3ZhciB6YT0vXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sQWE9bmV3IFJlZ0V4cChcIl4oXCIrUStcIikoLiopJFwiLFwiaVwiKSxCYT1uZXcgUmVnRXhwKFwiXihbKy1dKT0oXCIrUStcIilcIixcImlcIiksQ2E9e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix2aXNpYmlsaXR5OlwiaGlkZGVuXCIsZGlzcGxheTpcImJsb2NrXCJ9LERhPXtsZXR0ZXJTcGFjaW5nOlwiMFwiLGZvbnRXZWlnaHQ6XCI0MDBcIn0sRWE9W1wiV2Via2l0XCIsXCJPXCIsXCJNb3pcIixcIm1zXCJdO2Z1bmN0aW9uIEZhKGEsYil7aWYoYiBpbiBhKXJldHVybiBiO3ZhciBjPWJbMF0udG9VcHBlckNhc2UoKStiLnNsaWNlKDEpLGQ9YixlPUVhLmxlbmd0aDt3aGlsZShlLS0paWYoYj1FYVtlXStjLGIgaW4gYSlyZXR1cm4gYjtyZXR1cm4gZH1mdW5jdGlvbiBHYShhLGIsYyl7dmFyIGQ9QWEuZXhlYyhiKTtyZXR1cm4gZD9NYXRoLm1heCgwLGRbMV0tKGN8fDApKSsoZFsyXXx8XCJweFwiKTpifWZ1bmN0aW9uIEhhKGEsYixjLGQsZSl7Zm9yKHZhciBmPWM9PT0oZD9cImJvcmRlclwiOlwiY29udGVudFwiKT80Olwid2lkdGhcIj09PWI/MTowLGc9MDs0PmY7Zis9MilcIm1hcmdpblwiPT09YyYmKGcrPW4uY3NzKGEsYytSW2ZdLCEwLGUpKSxkPyhcImNvbnRlbnRcIj09PWMmJihnLT1uLmNzcyhhLFwicGFkZGluZ1wiK1JbZl0sITAsZSkpLFwibWFyZ2luXCIhPT1jJiYoZy09bi5jc3MoYSxcImJvcmRlclwiK1JbZl0rXCJXaWR0aFwiLCEwLGUpKSk6KGcrPW4uY3NzKGEsXCJwYWRkaW5nXCIrUltmXSwhMCxlKSxcInBhZGRpbmdcIiE9PWMmJihnKz1uLmNzcyhhLFwiYm9yZGVyXCIrUltmXStcIldpZHRoXCIsITAsZSkpKTtyZXR1cm4gZ31mdW5jdGlvbiBJYShhLGIsYyl7dmFyIGQ9ITAsZT1cIndpZHRoXCI9PT1iP2Eub2Zmc2V0V2lkdGg6YS5vZmZzZXRIZWlnaHQsZj13YShhKSxnPVwiYm9yZGVyLWJveFwiPT09bi5jc3MoYSxcImJveFNpemluZ1wiLCExLGYpO2lmKDA+PWV8fG51bGw9PWUpe2lmKGU9eGEoYSxiLGYpLCgwPmV8fG51bGw9PWUpJiYoZT1hLnN0eWxlW2JdKSx2YS50ZXN0KGUpKXJldHVybiBlO2Q9ZyYmKGsuYm94U2l6aW5nUmVsaWFibGUoKXx8ZT09PWEuc3R5bGVbYl0pLGU9cGFyc2VGbG9hdChlKXx8MH1yZXR1cm4gZStIYShhLGIsY3x8KGc/XCJib3JkZXJcIjpcImNvbnRlbnRcIiksZCxmKStcInB4XCJ9ZnVuY3Rpb24gSmEoYSxiKXtmb3IodmFyIGMsZCxlLGY9W10sZz0wLGg9YS5sZW5ndGg7aD5nO2crKylkPWFbZ10sZC5zdHlsZSYmKGZbZ109TC5nZXQoZCxcIm9sZGRpc3BsYXlcIiksYz1kLnN0eWxlLmRpc3BsYXksYj8oZltnXXx8XCJub25lXCIhPT1jfHwoZC5zdHlsZS5kaXNwbGF5PVwiXCIpLFwiXCI9PT1kLnN0eWxlLmRpc3BsYXkmJlMoZCkmJihmW2ddPUwuYWNjZXNzKGQsXCJvbGRkaXNwbGF5XCIsdGEoZC5ub2RlTmFtZSkpKSk6KGU9UyhkKSxcIm5vbmVcIj09PWMmJmV8fEwuc2V0KGQsXCJvbGRkaXNwbGF5XCIsZT9jOm4uY3NzKGQsXCJkaXNwbGF5XCIpKSkpO2ZvcihnPTA7aD5nO2crKylkPWFbZ10sZC5zdHlsZSYmKGImJlwibm9uZVwiIT09ZC5zdHlsZS5kaXNwbGF5JiZcIlwiIT09ZC5zdHlsZS5kaXNwbGF5fHwoZC5zdHlsZS5kaXNwbGF5PWI/ZltnXXx8XCJcIjpcIm5vbmVcIikpO3JldHVybiBhfW4uZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1bmN0aW9uKGEsYil7aWYoYil7dmFyIGM9eGEoYSxcIm9wYWNpdHlcIik7cmV0dXJuXCJcIj09PWM/XCIxXCI6Y319fX0sY3NzTnVtYmVyOntjb2x1bW5Db3VudDohMCxmaWxsT3BhY2l0eTohMCxmbGV4R3JvdzohMCxmbGV4U2hyaW5rOiEwLGZvbnRXZWlnaHQ6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwfSxjc3NQcm9wczp7XCJmbG9hdFwiOlwiY3NzRmxvYXRcIn0sc3R5bGU6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoYSYmMyE9PWEubm9kZVR5cGUmJjghPT1hLm5vZGVUeXBlJiZhLnN0eWxlKXt2YXIgZSxmLGcsaD1uLmNhbWVsQ2FzZShiKSxpPWEuc3R5bGU7cmV0dXJuIGI9bi5jc3NQcm9wc1toXXx8KG4uY3NzUHJvcHNbaF09RmEoaSxoKSksZz1uLmNzc0hvb2tzW2JdfHxuLmNzc0hvb2tzW2hdLHZvaWQgMD09PWM/ZyYmXCJnZXRcImluIGcmJnZvaWQgMCE9PShlPWcuZ2V0KGEsITEsZCkpP2U6aVtiXTooZj10eXBlb2YgYyxcInN0cmluZ1wiPT09ZiYmKGU9QmEuZXhlYyhjKSkmJihjPShlWzFdKzEpKmVbMl0rcGFyc2VGbG9hdChuLmNzcyhhLGIpKSxmPVwibnVtYmVyXCIpLG51bGwhPWMmJmM9PT1jJiYoXCJudW1iZXJcIiE9PWZ8fG4uY3NzTnVtYmVyW2hdfHwoYys9XCJweFwiKSxrLmNsZWFyQ2xvbmVTdHlsZXx8XCJcIiE9PWN8fDAhPT1iLmluZGV4T2YoXCJiYWNrZ3JvdW5kXCIpfHwoaVtiXT1cImluaGVyaXRcIiksZyYmXCJzZXRcImluIGcmJnZvaWQgMD09PShjPWcuc2V0KGEsYyxkKSl8fChpW2JdPWMpKSx2b2lkIDApfX0sY3NzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlLGYsZyxoPW4uY2FtZWxDYXNlKGIpO3JldHVybiBiPW4uY3NzUHJvcHNbaF18fChuLmNzc1Byb3BzW2hdPUZhKGEuc3R5bGUsaCkpLGc9bi5jc3NIb29rc1tiXXx8bi5jc3NIb29rc1toXSxnJiZcImdldFwiaW4gZyYmKGU9Zy5nZXQoYSwhMCxjKSksdm9pZCAwPT09ZSYmKGU9eGEoYSxiLGQpKSxcIm5vcm1hbFwiPT09ZSYmYiBpbiBEYSYmKGU9RGFbYl0pLFwiXCI9PT1jfHxjPyhmPXBhcnNlRmxvYXQoZSksYz09PSEwfHxuLmlzTnVtZXJpYyhmKT9mfHwwOmUpOmV9fSksbi5lYWNoKFtcImhlaWdodFwiLFwid2lkdGhcIl0sZnVuY3Rpb24oYSxiKXtuLmNzc0hvb2tzW2JdPXtnZXQ6ZnVuY3Rpb24oYSxjLGQpe3JldHVybiBjP3phLnRlc3Qobi5jc3MoYSxcImRpc3BsYXlcIikpJiYwPT09YS5vZmZzZXRXaWR0aD9uLnN3YXAoYSxDYSxmdW5jdGlvbigpe3JldHVybiBJYShhLGIsZCl9KTpJYShhLGIsZCk6dm9pZCAwfSxzZXQ6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlPWQmJndhKGEpO3JldHVybiBHYShhLGMsZD9IYShhLGIsZCxcImJvcmRlci1ib3hcIj09PW4uY3NzKGEsXCJib3hTaXppbmdcIiwhMSxlKSxlKTowKX19fSksbi5jc3NIb29rcy5tYXJnaW5SaWdodD15YShrLnJlbGlhYmxlTWFyZ2luUmlnaHQsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYj9uLnN3YXAoYSx7ZGlzcGxheTpcImlubGluZS1ibG9ja1wifSx4YSxbYSxcIm1hcmdpblJpZ2h0XCJdKTp2b2lkIDB9KSxuLmVhY2goe21hcmdpbjpcIlwiLHBhZGRpbmc6XCJcIixib3JkZXI6XCJXaWR0aFwifSxmdW5jdGlvbihhLGIpe24uY3NzSG9va3NbYStiXT17ZXhwYW5kOmZ1bmN0aW9uKGMpe2Zvcih2YXIgZD0wLGU9e30sZj1cInN0cmluZ1wiPT10eXBlb2YgYz9jLnNwbGl0KFwiIFwiKTpbY107ND5kO2QrKyllW2ErUltkXStiXT1mW2RdfHxmW2QtMl18fGZbMF07cmV0dXJuIGV9fSx1YS50ZXN0KGEpfHwobi5jc3NIb29rc1thK2JdLnNldD1HYSl9KSxuLmZuLmV4dGVuZCh7Y3NzOmZ1bmN0aW9uKGEsYil7cmV0dXJuIEoodGhpcyxmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPXt9LGc9MDtpZihuLmlzQXJyYXkoYikpe2ZvcihkPXdhKGEpLGU9Yi5sZW5ndGg7ZT5nO2crKylmW2JbZ11dPW4uY3NzKGEsYltnXSwhMSxkKTtyZXR1cm4gZn1yZXR1cm4gdm9pZCAwIT09Yz9uLnN0eWxlKGEsYixjKTpuLmNzcyhhLGIpfSxhLGIsYXJndW1lbnRzLmxlbmd0aD4xKX0sc2hvdzpmdW5jdGlvbigpe3JldHVybiBKYSh0aGlzLCEwKX0saGlkZTpmdW5jdGlvbigpe3JldHVybiBKYSh0aGlzKX0sdG9nZ2xlOmZ1bmN0aW9uKGEpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgYT9hP3RoaXMuc2hvdygpOnRoaXMuaGlkZSgpOnRoaXMuZWFjaChmdW5jdGlvbigpe1ModGhpcyk/bih0aGlzKS5zaG93KCk6bih0aGlzKS5oaWRlKCl9KX19KTtmdW5jdGlvbiBLYShhLGIsYyxkLGUpe3JldHVybiBuZXcgS2EucHJvdG90eXBlLmluaXQoYSxiLGMsZCxlKX1uLlR3ZWVuPUthLEthLnByb3RvdHlwZT17Y29uc3RydWN0b3I6S2EsaW5pdDpmdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5lbGVtPWEsdGhpcy5wcm9wPWMsdGhpcy5lYXNpbmc9ZXx8XCJzd2luZ1wiLHRoaXMub3B0aW9ucz1iLHRoaXMuc3RhcnQ9dGhpcy5ub3c9dGhpcy5jdXIoKSx0aGlzLmVuZD1kLHRoaXMudW5pdD1mfHwobi5jc3NOdW1iZXJbY10/XCJcIjpcInB4XCIpfSxjdXI6ZnVuY3Rpb24oKXt2YXIgYT1LYS5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gYSYmYS5nZXQ/YS5nZXQodGhpcyk6S2EucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKX0scnVuOmZ1bmN0aW9uKGEpe3ZhciBiLGM9S2EucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbj90aGlzLnBvcz1iPW4uZWFzaW5nW3RoaXMuZWFzaW5nXShhLHRoaXMub3B0aW9ucy5kdXJhdGlvbiphLDAsMSx0aGlzLm9wdGlvbnMuZHVyYXRpb24pOnRoaXMucG9zPWI9YSx0aGlzLm5vdz0odGhpcy5lbmQtdGhpcy5zdGFydCkqYit0aGlzLnN0YXJ0LHRoaXMub3B0aW9ucy5zdGVwJiZ0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSx0aGlzLm5vdyx0aGlzKSxjJiZjLnNldD9jLnNldCh0aGlzKTpLYS5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLHRoaXN9fSxLYS5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGU9S2EucHJvdG90eXBlLEthLnByb3BIb29rcz17X2RlZmF1bHQ6e2dldDpmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gbnVsbD09YS5lbGVtW2EucHJvcF18fGEuZWxlbS5zdHlsZSYmbnVsbCE9YS5lbGVtLnN0eWxlW2EucHJvcF0/KGI9bi5jc3MoYS5lbGVtLGEucHJvcCxcIlwiKSxiJiZcImF1dG9cIiE9PWI/YjowKTphLmVsZW1bYS5wcm9wXX0sc2V0OmZ1bmN0aW9uKGEpe24uZnguc3RlcFthLnByb3BdP24uZnguc3RlcFthLnByb3BdKGEpOmEuZWxlbS5zdHlsZSYmKG51bGwhPWEuZWxlbS5zdHlsZVtuLmNzc1Byb3BzW2EucHJvcF1dfHxuLmNzc0hvb2tzW2EucHJvcF0pP24uc3R5bGUoYS5lbGVtLGEucHJvcCxhLm5vdythLnVuaXQpOmEuZWxlbVthLnByb3BdPWEubm93fX19LEthLnByb3BIb29rcy5zY3JvbGxUb3A9S2EucHJvcEhvb2tzLnNjcm9sbExlZnQ9e3NldDpmdW5jdGlvbihhKXthLmVsZW0ubm9kZVR5cGUmJmEuZWxlbS5wYXJlbnROb2RlJiYoYS5lbGVtW2EucHJvcF09YS5ub3cpfX0sbi5lYXNpbmc9e2xpbmVhcjpmdW5jdGlvbihhKXtyZXR1cm4gYX0sc3dpbmc6ZnVuY3Rpb24oYSl7cmV0dXJuLjUtTWF0aC5jb3MoYSpNYXRoLlBJKS8yfX0sbi5meD1LYS5wcm90b3R5cGUuaW5pdCxuLmZ4LnN0ZXA9e307dmFyIExhLE1hLE5hPS9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxPYT1uZXcgUmVnRXhwKFwiXig/OihbKy1dKT18KShcIitRK1wiKShbYS16JV0qKSRcIixcImlcIiksUGE9L3F1ZXVlSG9va3MkLyxRYT1bVmFdLFJhPXtcIipcIjpbZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNyZWF0ZVR3ZWVuKGEsYiksZD1jLmN1cigpLGU9T2EuZXhlYyhiKSxmPWUmJmVbM118fChuLmNzc051bWJlclthXT9cIlwiOlwicHhcIiksZz0obi5jc3NOdW1iZXJbYV18fFwicHhcIiE9PWYmJitkKSYmT2EuZXhlYyhuLmNzcyhjLmVsZW0sYSkpLGg9MSxpPTIwO2lmKGcmJmdbM10hPT1mKXtmPWZ8fGdbM10sZT1lfHxbXSxnPStkfHwxO2RvIGg9aHx8XCIuNVwiLGcvPWgsbi5zdHlsZShjLmVsZW0sYSxnK2YpO3doaWxlKGghPT0oaD1jLmN1cigpL2QpJiYxIT09aCYmLS1pKX1yZXR1cm4gZSYmKGc9Yy5zdGFydD0rZ3x8K2R8fDAsYy51bml0PWYsYy5lbmQ9ZVsxXT9nKyhlWzFdKzEpKmVbMl06K2VbMl0pLGN9XX07ZnVuY3Rpb24gU2EoKXtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe0xhPXZvaWQgMH0pLExhPW4ubm93KCl9ZnVuY3Rpb24gVGEoYSxiKXt2YXIgYyxkPTAsZT17aGVpZ2h0OmF9O2ZvcihiPWI/MTowOzQ+ZDtkKz0yLWIpYz1SW2RdLGVbXCJtYXJnaW5cIitjXT1lW1wicGFkZGluZ1wiK2NdPWE7cmV0dXJuIGImJihlLm9wYWNpdHk9ZS53aWR0aD1hKSxlfWZ1bmN0aW9uIFVhKGEsYixjKXtmb3IodmFyIGQsZT0oUmFbYl18fFtdKS5jb25jYXQoUmFbXCIqXCJdKSxmPTAsZz1lLmxlbmd0aDtnPmY7ZisrKWlmKGQ9ZVtmXS5jYWxsKGMsYixhKSlyZXR1cm4gZH1mdW5jdGlvbiBWYShhLGIsYyl7dmFyIGQsZSxmLGcsaCxpLGosayxsPXRoaXMsbT17fSxvPWEuc3R5bGUscD1hLm5vZGVUeXBlJiZTKGEpLHE9TC5nZXQoYSxcImZ4c2hvd1wiKTtjLnF1ZXVlfHwoaD1uLl9xdWV1ZUhvb2tzKGEsXCJmeFwiKSxudWxsPT1oLnVucXVldWVkJiYoaC51bnF1ZXVlZD0wLGk9aC5lbXB0eS5maXJlLGguZW1wdHkuZmlyZT1mdW5jdGlvbigpe2gudW5xdWV1ZWR8fGkoKX0pLGgudW5xdWV1ZWQrKyxsLmFsd2F5cyhmdW5jdGlvbigpe2wuYWx3YXlzKGZ1bmN0aW9uKCl7aC51bnF1ZXVlZC0tLG4ucXVldWUoYSxcImZ4XCIpLmxlbmd0aHx8aC5lbXB0eS5maXJlKCl9KX0pKSwxPT09YS5ub2RlVHlwZSYmKFwiaGVpZ2h0XCJpbiBifHxcIndpZHRoXCJpbiBiKSYmKGMub3ZlcmZsb3c9W28ub3ZlcmZsb3csby5vdmVyZmxvd1gsby5vdmVyZmxvd1ldLGo9bi5jc3MoYSxcImRpc3BsYXlcIiksaz1cIm5vbmVcIj09PWo/TC5nZXQoYSxcIm9sZGRpc3BsYXlcIil8fHRhKGEubm9kZU5hbWUpOmosXCJpbmxpbmVcIj09PWsmJlwibm9uZVwiPT09bi5jc3MoYSxcImZsb2F0XCIpJiYoby5kaXNwbGF5PVwiaW5saW5lLWJsb2NrXCIpKSxjLm92ZXJmbG93JiYoby5vdmVyZmxvdz1cImhpZGRlblwiLGwuYWx3YXlzKGZ1bmN0aW9uKCl7by5vdmVyZmxvdz1jLm92ZXJmbG93WzBdLG8ub3ZlcmZsb3dYPWMub3ZlcmZsb3dbMV0sby5vdmVyZmxvd1k9Yy5vdmVyZmxvd1syXX0pKTtmb3IoZCBpbiBiKWlmKGU9YltkXSxOYS5leGVjKGUpKXtpZihkZWxldGUgYltkXSxmPWZ8fFwidG9nZ2xlXCI9PT1lLGU9PT0ocD9cImhpZGVcIjpcInNob3dcIikpe2lmKFwic2hvd1wiIT09ZXx8IXF8fHZvaWQgMD09PXFbZF0pY29udGludWU7cD0hMH1tW2RdPXEmJnFbZF18fG4uc3R5bGUoYSxkKX1lbHNlIGo9dm9pZCAwO2lmKG4uaXNFbXB0eU9iamVjdChtKSlcImlubGluZVwiPT09KFwibm9uZVwiPT09aj90YShhLm5vZGVOYW1lKTpqKSYmKG8uZGlzcGxheT1qKTtlbHNle3E/XCJoaWRkZW5cImluIHEmJihwPXEuaGlkZGVuKTpxPUwuYWNjZXNzKGEsXCJmeHNob3dcIix7fSksZiYmKHEuaGlkZGVuPSFwKSxwP24oYSkuc2hvdygpOmwuZG9uZShmdW5jdGlvbigpe24oYSkuaGlkZSgpfSksbC5kb25lKGZ1bmN0aW9uKCl7dmFyIGI7TC5yZW1vdmUoYSxcImZ4c2hvd1wiKTtmb3IoYiBpbiBtKW4uc3R5bGUoYSxiLG1bYl0pfSk7Zm9yKGQgaW4gbSlnPVVhKHA/cVtkXTowLGQsbCksZCBpbiBxfHwocVtkXT1nLnN0YXJ0LHAmJihnLmVuZD1nLnN0YXJ0LGcuc3RhcnQ9XCJ3aWR0aFwiPT09ZHx8XCJoZWlnaHRcIj09PWQ/MTowKSl9fWZ1bmN0aW9uIFdhKGEsYil7dmFyIGMsZCxlLGYsZztmb3IoYyBpbiBhKWlmKGQ9bi5jYW1lbENhc2UoYyksZT1iW2RdLGY9YVtjXSxuLmlzQXJyYXkoZikmJihlPWZbMV0sZj1hW2NdPWZbMF0pLGMhPT1kJiYoYVtkXT1mLGRlbGV0ZSBhW2NdKSxnPW4uY3NzSG9va3NbZF0sZyYmXCJleHBhbmRcImluIGcpe2Y9Zy5leHBhbmQoZiksZGVsZXRlIGFbZF07Zm9yKGMgaW4gZiljIGluIGF8fChhW2NdPWZbY10sYltjXT1lKX1lbHNlIGJbZF09ZX1mdW5jdGlvbiBYYShhLGIsYyl7dmFyIGQsZSxmPTAsZz1RYS5sZW5ndGgsaD1uLkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uKCl7ZGVsZXRlIGkuZWxlbX0pLGk9ZnVuY3Rpb24oKXtpZihlKXJldHVybiExO2Zvcih2YXIgYj1MYXx8U2EoKSxjPU1hdGgubWF4KDAsai5zdGFydFRpbWUrai5kdXJhdGlvbi1iKSxkPWMvai5kdXJhdGlvbnx8MCxmPTEtZCxnPTAsaT1qLnR3ZWVucy5sZW5ndGg7aT5nO2crKylqLnR3ZWVuc1tnXS5ydW4oZik7cmV0dXJuIGgubm90aWZ5V2l0aChhLFtqLGYsY10pLDE+ZiYmaT9jOihoLnJlc29sdmVXaXRoKGEsW2pdKSwhMSl9LGo9aC5wcm9taXNlKHtlbGVtOmEscHJvcHM6bi5leHRlbmQoe30sYiksb3B0czpuLmV4dGVuZCghMCx7c3BlY2lhbEVhc2luZzp7fX0sYyksb3JpZ2luYWxQcm9wZXJ0aWVzOmIsb3JpZ2luYWxPcHRpb25zOmMsc3RhcnRUaW1lOkxhfHxTYSgpLGR1cmF0aW9uOmMuZHVyYXRpb24sdHdlZW5zOltdLGNyZWF0ZVR3ZWVuOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9bi5Ud2VlbihhLGoub3B0cyxiLGMsai5vcHRzLnNwZWNpYWxFYXNpbmdbYl18fGoub3B0cy5lYXNpbmcpO3JldHVybiBqLnR3ZWVucy5wdXNoKGQpLGR9LHN0b3A6ZnVuY3Rpb24oYil7dmFyIGM9MCxkPWI/ai50d2VlbnMubGVuZ3RoOjA7aWYoZSlyZXR1cm4gdGhpcztmb3IoZT0hMDtkPmM7YysrKWoudHdlZW5zW2NdLnJ1bigxKTtyZXR1cm4gYj9oLnJlc29sdmVXaXRoKGEsW2osYl0pOmgucmVqZWN0V2l0aChhLFtqLGJdKSx0aGlzfX0pLGs9ai5wcm9wcztmb3IoV2EoayxqLm9wdHMuc3BlY2lhbEVhc2luZyk7Zz5mO2YrKylpZihkPVFhW2ZdLmNhbGwoaixhLGssai5vcHRzKSlyZXR1cm4gZDtyZXR1cm4gbi5tYXAoayxVYSxqKSxuLmlzRnVuY3Rpb24oai5vcHRzLnN0YXJ0KSYmai5vcHRzLnN0YXJ0LmNhbGwoYSxqKSxuLmZ4LnRpbWVyKG4uZXh0ZW5kKGkse2VsZW06YSxhbmltOmoscXVldWU6ai5vcHRzLnF1ZXVlfSkpLGoucHJvZ3Jlc3Moai5vcHRzLnByb2dyZXNzKS5kb25lKGoub3B0cy5kb25lLGoub3B0cy5jb21wbGV0ZSkuZmFpbChqLm9wdHMuZmFpbCkuYWx3YXlzKGoub3B0cy5hbHdheXMpfW4uQW5pbWF0aW9uPW4uZXh0ZW5kKFhhLHt0d2VlbmVyOmZ1bmN0aW9uKGEsYil7bi5pc0Z1bmN0aW9uKGEpPyhiPWEsYT1bXCIqXCJdKTphPWEuc3BsaXQoXCIgXCIpO2Zvcih2YXIgYyxkPTAsZT1hLmxlbmd0aDtlPmQ7ZCsrKWM9YVtkXSxSYVtjXT1SYVtjXXx8W10sUmFbY10udW5zaGlmdChiKX0scHJlZmlsdGVyOmZ1bmN0aW9uKGEsYil7Yj9RYS51bnNoaWZ0KGEpOlFhLnB1c2goYSl9fSksbi5zcGVlZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YSYmXCJvYmplY3RcIj09dHlwZW9mIGE/bi5leHRlbmQoe30sYSk6e2NvbXBsZXRlOmN8fCFjJiZifHxuLmlzRnVuY3Rpb24oYSkmJmEsZHVyYXRpb246YSxlYXNpbmc6YyYmYnx8YiYmIW4uaXNGdW5jdGlvbihiKSYmYn07cmV0dXJuIGQuZHVyYXRpb249bi5meC5vZmY/MDpcIm51bWJlclwiPT10eXBlb2YgZC5kdXJhdGlvbj9kLmR1cmF0aW9uOmQuZHVyYXRpb24gaW4gbi5meC5zcGVlZHM/bi5meC5zcGVlZHNbZC5kdXJhdGlvbl06bi5meC5zcGVlZHMuX2RlZmF1bHQsKG51bGw9PWQucXVldWV8fGQucXVldWU9PT0hMCkmJihkLnF1ZXVlPVwiZnhcIiksZC5vbGQ9ZC5jb21wbGV0ZSxkLmNvbXBsZXRlPWZ1bmN0aW9uKCl7bi5pc0Z1bmN0aW9uKGQub2xkKSYmZC5vbGQuY2FsbCh0aGlzKSxkLnF1ZXVlJiZuLmRlcXVldWUodGhpcyxkLnF1ZXVlKX0sZH0sbi5mbi5leHRlbmQoe2ZhZGVUbzpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5maWx0ZXIoUykuY3NzKFwib3BhY2l0eVwiLDApLnNob3coKS5lbmQoKS5hbmltYXRlKHtvcGFjaXR5OmJ9LGEsYyxkKX0sYW5pbWF0ZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uLmlzRW1wdHlPYmplY3QoYSksZj1uLnNwZWVkKGIsYyxkKSxnPWZ1bmN0aW9uKCl7dmFyIGI9WGEodGhpcyxuLmV4dGVuZCh7fSxhKSxmKTsoZXx8TC5nZXQodGhpcyxcImZpbmlzaFwiKSkmJmIuc3RvcCghMCl9O3JldHVybiBnLmZpbmlzaD1nLGV8fGYucXVldWU9PT0hMT90aGlzLmVhY2goZyk6dGhpcy5xdWV1ZShmLnF1ZXVlLGcpfSxzdG9wOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1mdW5jdGlvbihhKXt2YXIgYj1hLnN0b3A7ZGVsZXRlIGEuc3RvcCxiKGMpfTtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgYSYmKGM9YixiPWEsYT12b2lkIDApLGImJmEhPT0hMSYmdGhpcy5xdWV1ZShhfHxcImZ4XCIsW10pLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPSEwLGU9bnVsbCE9YSYmYStcInF1ZXVlSG9va3NcIixmPW4udGltZXJzLGc9TC5nZXQodGhpcyk7aWYoZSlnW2VdJiZnW2VdLnN0b3AmJmQoZ1tlXSk7ZWxzZSBmb3IoZSBpbiBnKWdbZV0mJmdbZV0uc3RvcCYmUGEudGVzdChlKSYmZChnW2VdKTtmb3IoZT1mLmxlbmd0aDtlLS07KWZbZV0uZWxlbSE9PXRoaXN8fG51bGwhPWEmJmZbZV0ucXVldWUhPT1hfHwoZltlXS5hbmltLnN0b3AoYyksYj0hMSxmLnNwbGljZShlLDEpKTsoYnx8IWMpJiZuLmRlcXVldWUodGhpcyxhKX0pfSxmaW5pc2g6ZnVuY3Rpb24oYSl7cmV0dXJuIGEhPT0hMSYmKGE9YXx8XCJmeFwiKSx0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYixjPUwuZ2V0KHRoaXMpLGQ9Y1thK1wicXVldWVcIl0sZT1jW2ErXCJxdWV1ZUhvb2tzXCJdLGY9bi50aW1lcnMsZz1kP2QubGVuZ3RoOjA7Zm9yKGMuZmluaXNoPSEwLG4ucXVldWUodGhpcyxhLFtdKSxlJiZlLnN0b3AmJmUuc3RvcC5jYWxsKHRoaXMsITApLGI9Zi5sZW5ndGg7Yi0tOylmW2JdLmVsZW09PT10aGlzJiZmW2JdLnF1ZXVlPT09YSYmKGZbYl0uYW5pbS5zdG9wKCEwKSxmLnNwbGljZShiLDEpKTtmb3IoYj0wO2c+YjtiKyspZFtiXSYmZFtiXS5maW5pc2gmJmRbYl0uZmluaXNoLmNhbGwodGhpcyk7ZGVsZXRlIGMuZmluaXNofSl9fSksbi5lYWNoKFtcInRvZ2dsZVwiLFwic2hvd1wiLFwiaGlkZVwiXSxmdW5jdGlvbihhLGIpe3ZhciBjPW4uZm5bYl07bi5mbltiXT1mdW5jdGlvbihhLGQsZSl7cmV0dXJuIG51bGw9PWF8fFwiYm9vbGVhblwiPT10eXBlb2YgYT9jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUoVGEoYiwhMCksYSxkLGUpfX0pLG4uZWFjaCh7c2xpZGVEb3duOlRhKFwic2hvd1wiKSxzbGlkZVVwOlRhKFwiaGlkZVwiKSxzbGlkZVRvZ2dsZTpUYShcInRvZ2dsZVwiKSxmYWRlSW46e29wYWNpdHk6XCJzaG93XCJ9LGZhZGVPdXQ6e29wYWNpdHk6XCJoaWRlXCJ9LGZhZGVUb2dnbGU6e29wYWNpdHk6XCJ0b2dnbGVcIn19LGZ1bmN0aW9uKGEsYil7bi5mblthXT1mdW5jdGlvbihhLGMsZCl7cmV0dXJuIHRoaXMuYW5pbWF0ZShiLGEsYyxkKX19KSxuLnRpbWVycz1bXSxuLmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgYSxiPTAsYz1uLnRpbWVycztmb3IoTGE9bi5ub3coKTtiPGMubGVuZ3RoO2IrKylhPWNbYl0sYSgpfHxjW2JdIT09YXx8Yy5zcGxpY2UoYi0tLDEpO2MubGVuZ3RofHxuLmZ4LnN0b3AoKSxMYT12b2lkIDB9LG4uZngudGltZXI9ZnVuY3Rpb24oYSl7bi50aW1lcnMucHVzaChhKSxhKCk/bi5meC5zdGFydCgpOm4udGltZXJzLnBvcCgpfSxuLmZ4LmludGVydmFsPTEzLG4uZnguc3RhcnQ9ZnVuY3Rpb24oKXtNYXx8KE1hPXNldEludGVydmFsKG4uZngudGljayxuLmZ4LmludGVydmFsKSl9LG4uZnguc3RvcD1mdW5jdGlvbigpe2NsZWFySW50ZXJ2YWwoTWEpLE1hPW51bGx9LG4uZnguc3BlZWRzPXtzbG93OjYwMCxmYXN0OjIwMCxfZGVmYXVsdDo0MDB9LG4uZm4uZGVsYXk9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT1uLmZ4P24uZnguc3BlZWRzW2FdfHxhOmEsYj1ifHxcImZ4XCIsdGhpcy5xdWV1ZShiLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9c2V0VGltZW91dChiLGEpO2Muc3RvcD1mdW5jdGlvbigpe2NsZWFyVGltZW91dChkKX19KX0sZnVuY3Rpb24oKXt2YXIgYT1sLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxiPWwuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKSxjPWIuYXBwZW5kQ2hpbGQobC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKTthLnR5cGU9XCJjaGVja2JveFwiLGsuY2hlY2tPbj1cIlwiIT09YS52YWx1ZSxrLm9wdFNlbGVjdGVkPWMuc2VsZWN0ZWQsYi5kaXNhYmxlZD0hMCxrLm9wdERpc2FibGVkPSFjLmRpc2FibGVkLGE9bC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYS52YWx1ZT1cInRcIixhLnR5cGU9XCJyYWRpb1wiLGsucmFkaW9WYWx1ZT1cInRcIj09PWEudmFsdWV9KCk7dmFyIFlhLFphLCRhPW4uZXhwci5hdHRySGFuZGxlO24uZm4uZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIEoodGhpcyxuLmF0dHIsYSxiLGFyZ3VtZW50cy5sZW5ndGg+MSl9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe24ucmVtb3ZlQXR0cih0aGlzLGEpfSl9fSksbi5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZj1hLm5vZGVUeXBlO2lmKGEmJjMhPT1mJiY4IT09ZiYmMiE9PWYpcmV0dXJuIHR5cGVvZiBhLmdldEF0dHJpYnV0ZT09PVU/bi5wcm9wKGEsYixjKTooMT09PWYmJm4uaXNYTUxEb2MoYSl8fChiPWIudG9Mb3dlckNhc2UoKSxkPW4uYXR0ckhvb2tzW2JdfHwobi5leHByLm1hdGNoLmJvb2wudGVzdChiKT9aYTpZYSkpLFxudm9pZCAwPT09Yz9kJiZcImdldFwiaW4gZCYmbnVsbCE9PShlPWQuZ2V0KGEsYikpP2U6KGU9bi5maW5kLmF0dHIoYSxiKSxudWxsPT1lP3ZvaWQgMDplKTpudWxsIT09Yz9kJiZcInNldFwiaW4gZCYmdm9pZCAwIT09KGU9ZC5zZXQoYSxjLGIpKT9lOihhLnNldEF0dHJpYnV0ZShiLGMrXCJcIiksYyk6dm9pZCBuLnJlbW92ZUF0dHIoYSxiKSl9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU9MCxmPWImJmIubWF0Y2goRSk7aWYoZiYmMT09PWEubm9kZVR5cGUpd2hpbGUoYz1mW2UrK10pZD1uLnByb3BGaXhbY118fGMsbi5leHByLm1hdGNoLmJvb2wudGVzdChjKSYmKGFbZF09ITEpLGEucmVtb3ZlQXR0cmlidXRlKGMpfSxhdHRySG9va3M6e3R5cGU6e3NldDpmdW5jdGlvbihhLGIpe2lmKCFrLnJhZGlvVmFsdWUmJlwicmFkaW9cIj09PWImJm4ubm9kZU5hbWUoYSxcImlucHV0XCIpKXt2YXIgYz1hLnZhbHVlO3JldHVybiBhLnNldEF0dHJpYnV0ZShcInR5cGVcIixiKSxjJiYoYS52YWx1ZT1jKSxifX19fX0pLFphPXtzZXQ6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBiPT09ITE/bi5yZW1vdmVBdHRyKGEsYyk6YS5zZXRBdHRyaWJ1dGUoYyxjKSxjfX0sbi5lYWNoKG4uZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSxmdW5jdGlvbihhLGIpe3ZhciBjPSRhW2JdfHxuLmZpbmQuYXR0cjskYVtiXT1mdW5jdGlvbihhLGIsZCl7dmFyIGUsZjtyZXR1cm4gZHx8KGY9JGFbYl0sJGFbYl09ZSxlPW51bGwhPWMoYSxiLGQpP2IudG9Mb3dlckNhc2UoKTpudWxsLCRhW2JdPWYpLGV9fSk7dmFyIF9hPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2k7bi5mbi5leHRlbmQoe3Byb3A6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gSih0aGlzLG4ucHJvcCxhLGIsYXJndW1lbnRzLmxlbmd0aD4xKX0scmVtb3ZlUHJvcDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7ZGVsZXRlIHRoaXNbbi5wcm9wRml4W2FdfHxhXX0pfX0pLG4uZXh0ZW5kKHtwcm9wRml4OntcImZvclwiOlwiaHRtbEZvclwiLFwiY2xhc3NcIjpcImNsYXNzTmFtZVwifSxwcm9wOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZz1hLm5vZGVUeXBlO2lmKGEmJjMhPT1nJiY4IT09ZyYmMiE9PWcpcmV0dXJuIGY9MSE9PWd8fCFuLmlzWE1MRG9jKGEpLGYmJihiPW4ucHJvcEZpeFtiXXx8YixlPW4ucHJvcEhvb2tzW2JdKSx2b2lkIDAhPT1jP2UmJlwic2V0XCJpbiBlJiZ2b2lkIDAhPT0oZD1lLnNldChhLGMsYikpP2Q6YVtiXT1jOmUmJlwiZ2V0XCJpbiBlJiZudWxsIT09KGQ9ZS5nZXQoYSxiKSk/ZDphW2JdfSxwcm9wSG9va3M6e3RhYkluZGV4OntnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuaGFzQXR0cmlidXRlKFwidGFiaW5kZXhcIil8fF9hLnRlc3QoYS5ub2RlTmFtZSl8fGEuaHJlZj9hLnRhYkluZGV4Oi0xfX19fSksay5vcHRTZWxlY3RlZHx8KG4ucHJvcEhvb2tzLnNlbGVjdGVkPXtnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO3JldHVybiBiJiZiLnBhcmVudE5vZGUmJmIucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LG51bGx9fSksbi5lYWNoKFtcInRhYkluZGV4XCIsXCJyZWFkT25seVwiLFwibWF4TGVuZ3RoXCIsXCJjZWxsU3BhY2luZ1wiLFwiY2VsbFBhZGRpbmdcIixcInJvd1NwYW5cIixcImNvbFNwYW5cIixcInVzZU1hcFwiLFwiZnJhbWVCb3JkZXJcIixcImNvbnRlbnRFZGl0YWJsZVwiXSxmdW5jdGlvbigpe24ucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldPXRoaXN9KTt2YXIgYWI9L1tcXHRcXHJcXG5cXGZdL2c7bi5mbi5leHRlbmQoe2FkZENsYXNzOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoPVwic3RyaW5nXCI9PXR5cGVvZiBhJiZhLGk9MCxqPXRoaXMubGVuZ3RoO2lmKG4uaXNGdW5jdGlvbihhKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGIpe24odGhpcykuYWRkQ2xhc3MoYS5jYWxsKHRoaXMsYix0aGlzLmNsYXNzTmFtZSkpfSk7aWYoaClmb3IoYj0oYXx8XCJcIikubWF0Y2goRSl8fFtdO2o+aTtpKyspaWYoYz10aGlzW2ldLGQ9MT09PWMubm9kZVR5cGUmJihjLmNsYXNzTmFtZT8oXCIgXCIrYy5jbGFzc05hbWUrXCIgXCIpLnJlcGxhY2UoYWIsXCIgXCIpOlwiIFwiKSl7Zj0wO3doaWxlKGU9YltmKytdKWQuaW5kZXhPZihcIiBcIitlK1wiIFwiKTwwJiYoZCs9ZStcIiBcIik7Zz1uLnRyaW0oZCksYy5jbGFzc05hbWUhPT1nJiYoYy5jbGFzc05hbWU9Zyl9cmV0dXJuIHRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoPTA9PT1hcmd1bWVudHMubGVuZ3RofHxcInN0cmluZ1wiPT10eXBlb2YgYSYmYSxpPTAsaj10aGlzLmxlbmd0aDtpZihuLmlzRnVuY3Rpb24oYSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKXtuKHRoaXMpLnJlbW92ZUNsYXNzKGEuY2FsbCh0aGlzLGIsdGhpcy5jbGFzc05hbWUpKX0pO2lmKGgpZm9yKGI9KGF8fFwiXCIpLm1hdGNoKEUpfHxbXTtqPmk7aSsrKWlmKGM9dGhpc1tpXSxkPTE9PT1jLm5vZGVUeXBlJiYoYy5jbGFzc05hbWU/KFwiIFwiK2MuY2xhc3NOYW1lK1wiIFwiKS5yZXBsYWNlKGFiLFwiIFwiKTpcIlwiKSl7Zj0wO3doaWxlKGU9YltmKytdKXdoaWxlKGQuaW5kZXhPZihcIiBcIitlK1wiIFwiKT49MClkPWQucmVwbGFjZShcIiBcIitlK1wiIFwiLFwiIFwiKTtnPWE/bi50cmltKGQpOlwiXCIsYy5jbGFzc05hbWUhPT1nJiYoYy5jbGFzc05hbWU9Zyl9cmV0dXJuIHRoaXN9LHRvZ2dsZUNsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGM9dHlwZW9mIGE7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBiJiZcInN0cmluZ1wiPT09Yz9iP3RoaXMuYWRkQ2xhc3MoYSk6dGhpcy5yZW1vdmVDbGFzcyhhKTp0aGlzLmVhY2gobi5pc0Z1bmN0aW9uKGEpP2Z1bmN0aW9uKGMpe24odGhpcykudG9nZ2xlQ2xhc3MoYS5jYWxsKHRoaXMsYyx0aGlzLmNsYXNzTmFtZSxiKSxiKX06ZnVuY3Rpb24oKXtpZihcInN0cmluZ1wiPT09Yyl7dmFyIGIsZD0wLGU9bih0aGlzKSxmPWEubWF0Y2goRSl8fFtdO3doaWxlKGI9ZltkKytdKWUuaGFzQ2xhc3MoYik/ZS5yZW1vdmVDbGFzcyhiKTplLmFkZENsYXNzKGIpfWVsc2UoYz09PVV8fFwiYm9vbGVhblwiPT09YykmJih0aGlzLmNsYXNzTmFtZSYmTC5zZXQodGhpcyxcIl9fY2xhc3NOYW1lX19cIix0aGlzLmNsYXNzTmFtZSksdGhpcy5jbGFzc05hbWU9dGhpcy5jbGFzc05hbWV8fGE9PT0hMT9cIlwiOkwuZ2V0KHRoaXMsXCJfX2NsYXNzTmFtZV9fXCIpfHxcIlwiKX0pfSxoYXNDbGFzczpmdW5jdGlvbihhKXtmb3IodmFyIGI9XCIgXCIrYStcIiBcIixjPTAsZD10aGlzLmxlbmd0aDtkPmM7YysrKWlmKDE9PT10aGlzW2NdLm5vZGVUeXBlJiYoXCIgXCIrdGhpc1tjXS5jbGFzc05hbWUrXCIgXCIpLnJlcGxhY2UoYWIsXCIgXCIpLmluZGV4T2YoYik+PTApcmV0dXJuITA7cmV0dXJuITF9fSk7dmFyIGJiPS9cXHIvZztuLmZuLmV4dGVuZCh7dmFsOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPXRoaXNbMF07e2lmKGFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGQ9bi5pc0Z1bmN0aW9uKGEpLHRoaXMuZWFjaChmdW5jdGlvbihjKXt2YXIgZTsxPT09dGhpcy5ub2RlVHlwZSYmKGU9ZD9hLmNhbGwodGhpcyxjLG4odGhpcykudmFsKCkpOmEsbnVsbD09ZT9lPVwiXCI6XCJudW1iZXJcIj09dHlwZW9mIGU/ZSs9XCJcIjpuLmlzQXJyYXkoZSkmJihlPW4ubWFwKGUsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/XCJcIjphK1wiXCJ9KSksYj1uLnZhbEhvb2tzW3RoaXMudHlwZV18fG4udmFsSG9va3NbdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSxiJiZcInNldFwiaW4gYiYmdm9pZCAwIT09Yi5zZXQodGhpcyxlLFwidmFsdWVcIil8fCh0aGlzLnZhbHVlPWUpKX0pO2lmKGUpcmV0dXJuIGI9bi52YWxIb29rc1tlLnR5cGVdfHxuLnZhbEhvb2tzW2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sYiYmXCJnZXRcImluIGImJnZvaWQgMCE9PShjPWIuZ2V0KGUsXCJ2YWx1ZVwiKSk/YzooYz1lLnZhbHVlLFwic3RyaW5nXCI9PXR5cGVvZiBjP2MucmVwbGFjZShiYixcIlwiKTpudWxsPT1jP1wiXCI6Yyl9fX0pLG4uZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9bi5maW5kLmF0dHIoYSxcInZhbHVlXCIpO3JldHVybiBudWxsIT1iP2I6bi50cmltKG4udGV4dChhKSl9fSxzZWxlY3Q6e2dldDpmdW5jdGlvbihhKXtmb3IodmFyIGIsYyxkPWEub3B0aW9ucyxlPWEuc2VsZWN0ZWRJbmRleCxmPVwic2VsZWN0LW9uZVwiPT09YS50eXBlfHwwPmUsZz1mP251bGw6W10saD1mP2UrMTpkLmxlbmd0aCxpPTA+ZT9oOmY/ZTowO2g+aTtpKyspaWYoYz1kW2ldLCEoIWMuc2VsZWN0ZWQmJmkhPT1lfHwoay5vcHREaXNhYmxlZD9jLmRpc2FibGVkOm51bGwhPT1jLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpKXx8Yy5wYXJlbnROb2RlLmRpc2FibGVkJiZuLm5vZGVOYW1lKGMucGFyZW50Tm9kZSxcIm9wdGdyb3VwXCIpKSl7aWYoYj1uKGMpLnZhbCgpLGYpcmV0dXJuIGI7Zy5wdXNoKGIpfXJldHVybiBnfSxzZXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU9YS5vcHRpb25zLGY9bi5tYWtlQXJyYXkoYiksZz1lLmxlbmd0aDt3aGlsZShnLS0pZD1lW2ddLChkLnNlbGVjdGVkPW4uaW5BcnJheShkLnZhbHVlLGYpPj0wKSYmKGM9ITApO3JldHVybiBjfHwoYS5zZWxlY3RlZEluZGV4PS0xKSxmfX19fSksbi5lYWNoKFtcInJhZGlvXCIsXCJjaGVja2JveFwiXSxmdW5jdGlvbigpe24udmFsSG9va3NbdGhpc109e3NldDpmdW5jdGlvbihhLGIpe3JldHVybiBuLmlzQXJyYXkoYik/YS5jaGVja2VkPW4uaW5BcnJheShuKGEpLnZhbCgpLGIpPj0wOnZvaWQgMH19LGsuY2hlY2tPbnx8KG4udmFsSG9va3NbdGhpc10uZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT09YS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKT9cIm9uXCI6YS52YWx1ZX0pfSksbi5lYWNoKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhLGIpe24uZm5bYl09ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD4wP3RoaXMub24oYixudWxsLGEsYyk6dGhpcy50cmlnZ2VyKGIpfX0pLG4uZm4uZXh0ZW5kKHtob3ZlcjpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm1vdXNlZW50ZXIoYSkubW91c2VsZWF2ZShifHxhKX0sYmluZDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMub24oYSxudWxsLGIsYyl9LHVuYmluZDpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm9mZihhLG51bGwsYil9LGRlbGVnYXRlOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLm9uKGIsYSxjLGQpfSx1bmRlbGVnYXRlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5vZmYoYSxcIioqXCIpOnRoaXMub2ZmKGIsYXx8XCIqKlwiLGMpfX0pO3ZhciBjYj1uLm5vdygpLGRiPS9cXD8vO24ucGFyc2VKU09OPWZ1bmN0aW9uKGEpe3JldHVybiBKU09OLnBhcnNlKGErXCJcIil9LG4ucGFyc2VYTUw9ZnVuY3Rpb24oYSl7dmFyIGIsYztpZighYXx8XCJzdHJpbmdcIiE9dHlwZW9mIGEpcmV0dXJuIG51bGw7dHJ5e2M9bmV3IERPTVBhcnNlcixiPWMucGFyc2VGcm9tU3RyaW5nKGEsXCJ0ZXh0L3htbFwiKX1jYXRjaChkKXtiPXZvaWQgMH1yZXR1cm4oIWJ8fGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKS5sZW5ndGgpJiZuLmVycm9yKFwiSW52YWxpZCBYTUw6IFwiK2EpLGJ9O3ZhciBlYj0vIy4qJC8sZmI9LyhbPyZdKV89W14mXSovLGdiPS9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvZ20saGI9L14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8saWI9L14oPzpHRVR8SEVBRCkkLyxqYj0vXlxcL1xcLy8sa2I9L14oW1xcdy4rLV0rOikoPzpcXC9cXC8oPzpbXlxcLz8jXSpAfCkoW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sbGI9e30sbWI9e30sbmI9XCIqL1wiLmNvbmNhdChcIipcIiksb2I9YS5sb2NhdGlvbi5ocmVmLHBiPWtiLmV4ZWMob2IudG9Mb3dlckNhc2UoKSl8fFtdO2Z1bmN0aW9uIHFiKGEpe3JldHVybiBmdW5jdGlvbihiLGMpe1wic3RyaW5nXCIhPXR5cGVvZiBiJiYoYz1iLGI9XCIqXCIpO3ZhciBkLGU9MCxmPWIudG9Mb3dlckNhc2UoKS5tYXRjaChFKXx8W107aWYobi5pc0Z1bmN0aW9uKGMpKXdoaWxlKGQ9ZltlKytdKVwiK1wiPT09ZFswXT8oZD1kLnNsaWNlKDEpfHxcIipcIiwoYVtkXT1hW2RdfHxbXSkudW5zaGlmdChjKSk6KGFbZF09YVtkXXx8W10pLnB1c2goYyl9fWZ1bmN0aW9uIHJiKGEsYixjLGQpe3ZhciBlPXt9LGY9YT09PW1iO2Z1bmN0aW9uIGcoaCl7dmFyIGk7cmV0dXJuIGVbaF09ITAsbi5lYWNoKGFbaF18fFtdLGZ1bmN0aW9uKGEsaCl7dmFyIGo9aChiLGMsZCk7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGp8fGZ8fGVbal0/Zj8hKGk9aik6dm9pZCAwOihiLmRhdGFUeXBlcy51bnNoaWZ0KGopLGcoaiksITEpfSksaX1yZXR1cm4gZyhiLmRhdGFUeXBlc1swXSl8fCFlW1wiKlwiXSYmZyhcIipcIil9ZnVuY3Rpb24gc2IoYSxiKXt2YXIgYyxkLGU9bi5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnN8fHt9O2ZvcihjIGluIGIpdm9pZCAwIT09YltjXSYmKChlW2NdP2E6ZHx8KGQ9e30pKVtjXT1iW2NdKTtyZXR1cm4gZCYmbi5leHRlbmQoITAsYSxkKSxhfWZ1bmN0aW9uIHRiKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuY29udGVudHMsaT1hLmRhdGFUeXBlczt3aGlsZShcIipcIj09PWlbMF0paS5zaGlmdCgpLHZvaWQgMD09PWQmJihkPWEubWltZVR5cGV8fGIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpO2lmKGQpZm9yKGUgaW4gaClpZihoW2VdJiZoW2VdLnRlc3QoZCkpe2kudW5zaGlmdChlKTticmVha31pZihpWzBdaW4gYylmPWlbMF07ZWxzZXtmb3IoZSBpbiBjKXtpZighaVswXXx8YS5jb252ZXJ0ZXJzW2UrXCIgXCIraVswXV0pe2Y9ZTticmVha31nfHwoZz1lKX1mPWZ8fGd9cmV0dXJuIGY/KGYhPT1pWzBdJiZpLnVuc2hpZnQoZiksY1tmXSk6dm9pZCAwfWZ1bmN0aW9uIHViKGEsYixjLGQpe3ZhciBlLGYsZyxoLGksaj17fSxrPWEuZGF0YVR5cGVzLnNsaWNlKCk7aWYoa1sxXSlmb3IoZyBpbiBhLmNvbnZlcnRlcnMpaltnLnRvTG93ZXJDYXNlKCldPWEuY29udmVydGVyc1tnXTtmPWsuc2hpZnQoKTt3aGlsZShmKWlmKGEucmVzcG9uc2VGaWVsZHNbZl0mJihjW2EucmVzcG9uc2VGaWVsZHNbZl1dPWIpLCFpJiZkJiZhLmRhdGFGaWx0ZXImJihiPWEuZGF0YUZpbHRlcihiLGEuZGF0YVR5cGUpKSxpPWYsZj1rLnNoaWZ0KCkpaWYoXCIqXCI9PT1mKWY9aTtlbHNlIGlmKFwiKlwiIT09aSYmaSE9PWYpe2lmKGc9altpK1wiIFwiK2ZdfHxqW1wiKiBcIitmXSwhZylmb3IoZSBpbiBqKWlmKGg9ZS5zcGxpdChcIiBcIiksaFsxXT09PWYmJihnPWpbaStcIiBcIitoWzBdXXx8altcIiogXCIraFswXV0pKXtnPT09ITA/Zz1qW2VdOmpbZV0hPT0hMCYmKGY9aFswXSxrLnVuc2hpZnQoaFsxXSkpO2JyZWFrfWlmKGchPT0hMClpZihnJiZhW1widGhyb3dzXCJdKWI9ZyhiKTtlbHNlIHRyeXtiPWcoYil9Y2F0Y2gobCl7cmV0dXJue3N0YXRlOlwicGFyc2VyZXJyb3JcIixlcnJvcjpnP2w6XCJObyBjb252ZXJzaW9uIGZyb20gXCIraStcIiB0byBcIitmfX19cmV0dXJue3N0YXRlOlwic3VjY2Vzc1wiLGRhdGE6Yn19bi5leHRlbmQoe2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9LGFqYXhTZXR0aW5nczp7dXJsOm9iLHR5cGU6XCJHRVRcIixpc0xvY2FsOmhiLnRlc3QocGJbMV0pLGdsb2JhbDohMCxwcm9jZXNzRGF0YTohMCxhc3luYzohMCxjb250ZW50VHlwZTpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLGFjY2VwdHM6e1wiKlwiOm5iLHRleHQ6XCJ0ZXh0L3BsYWluXCIsaHRtbDpcInRleHQvaHRtbFwiLHhtbDpcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixqc29uOlwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJ9LGNvbnRlbnRzOnt4bWw6L3htbC8saHRtbDovaHRtbC8sanNvbjovanNvbi99LHJlc3BvbnNlRmllbGRzOnt4bWw6XCJyZXNwb25zZVhNTFwiLHRleHQ6XCJyZXNwb25zZVRleHRcIixqc29uOlwicmVzcG9uc2VKU09OXCJ9LGNvbnZlcnRlcnM6e1wiKiB0ZXh0XCI6U3RyaW5nLFwidGV4dCBodG1sXCI6ITAsXCJ0ZXh0IGpzb25cIjpuLnBhcnNlSlNPTixcInRleHQgeG1sXCI6bi5wYXJzZVhNTH0sZmxhdE9wdGlvbnM6e3VybDohMCxjb250ZXh0OiEwfX0sYWpheFNldHVwOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGI/c2Ioc2IoYSxuLmFqYXhTZXR0aW5ncyksYik6c2Iobi5hamF4U2V0dGluZ3MsYSl9LGFqYXhQcmVmaWx0ZXI6cWIobGIpLGFqYXhUcmFuc3BvcnQ6cWIobWIpLGFqYXg6ZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiPT10eXBlb2YgYSYmKGI9YSxhPXZvaWQgMCksYj1ifHx7fTt2YXIgYyxkLGUsZixnLGgsaSxqLGs9bi5hamF4U2V0dXAoe30sYiksbD1rLmNvbnRleHR8fGssbT1rLmNvbnRleHQmJihsLm5vZGVUeXBlfHxsLmpxdWVyeSk/bihsKTpuLmV2ZW50LG89bi5EZWZlcnJlZCgpLHA9bi5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxxPWsuc3RhdHVzQ29kZXx8e30scj17fSxzPXt9LHQ9MCx1PVwiY2FuY2VsZWRcIix2PXtyZWFkeVN0YXRlOjAsZ2V0UmVzcG9uc2VIZWFkZXI6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoMj09PXQpe2lmKCFmKXtmPXt9O3doaWxlKGI9Z2IuZXhlYyhlKSlmW2JbMV0udG9Mb3dlckNhc2UoKV09YlsyXX1iPWZbYS50b0xvd2VyQ2FzZSgpXX1yZXR1cm4gbnVsbD09Yj9udWxsOmJ9LGdldEFsbFJlc3BvbnNlSGVhZGVyczpmdW5jdGlvbigpe3JldHVybiAyPT09dD9lOm51bGx9LHNldFJlcXVlc3RIZWFkZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHR8fChhPXNbY109c1tjXXx8YSxyW2FdPWIpLHRoaXN9LG92ZXJyaWRlTWltZVR5cGU6ZnVuY3Rpb24oYSl7cmV0dXJuIHR8fChrLm1pbWVUeXBlPWEpLHRoaXN9LHN0YXR1c0NvZGU6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoYSlpZigyPnQpZm9yKGIgaW4gYSlxW2JdPVtxW2JdLGFbYl1dO2Vsc2Ugdi5hbHdheXMoYVt2LnN0YXR1c10pO3JldHVybiB0aGlzfSxhYm9ydDpmdW5jdGlvbihhKXt2YXIgYj1hfHx1O3JldHVybiBjJiZjLmFib3J0KGIpLHgoMCxiKSx0aGlzfX07aWYoby5wcm9taXNlKHYpLmNvbXBsZXRlPXAuYWRkLHYuc3VjY2Vzcz12LmRvbmUsdi5lcnJvcj12LmZhaWwsay51cmw9KChhfHxrLnVybHx8b2IpK1wiXCIpLnJlcGxhY2UoZWIsXCJcIikucmVwbGFjZShqYixwYlsxXStcIi8vXCIpLGsudHlwZT1iLm1ldGhvZHx8Yi50eXBlfHxrLm1ldGhvZHx8ay50eXBlLGsuZGF0YVR5cGVzPW4udHJpbShrLmRhdGFUeXBlfHxcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChFKXx8W1wiXCJdLG51bGw9PWsuY3Jvc3NEb21haW4mJihoPWtiLmV4ZWMoay51cmwudG9Mb3dlckNhc2UoKSksay5jcm9zc0RvbWFpbj0hKCFofHxoWzFdPT09cGJbMV0mJmhbMl09PT1wYlsyXSYmKGhbM118fChcImh0dHA6XCI9PT1oWzFdP1wiODBcIjpcIjQ0M1wiKSk9PT0ocGJbM118fChcImh0dHA6XCI9PT1wYlsxXT9cIjgwXCI6XCI0NDNcIikpKSksay5kYXRhJiZrLnByb2Nlc3NEYXRhJiZcInN0cmluZ1wiIT10eXBlb2Ygay5kYXRhJiYoay5kYXRhPW4ucGFyYW0oay5kYXRhLGsudHJhZGl0aW9uYWwpKSxyYihsYixrLGIsdiksMj09PXQpcmV0dXJuIHY7aT1uLmV2ZW50JiZrLmdsb2JhbCxpJiYwPT09bi5hY3RpdmUrKyYmbi5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLGsudHlwZT1rLnR5cGUudG9VcHBlckNhc2UoKSxrLmhhc0NvbnRlbnQ9IWliLnRlc3Qoay50eXBlKSxkPWsudXJsLGsuaGFzQ29udGVudHx8KGsuZGF0YSYmKGQ9ay51cmwrPShkYi50ZXN0KGQpP1wiJlwiOlwiP1wiKStrLmRhdGEsZGVsZXRlIGsuZGF0YSksay5jYWNoZT09PSExJiYoay51cmw9ZmIudGVzdChkKT9kLnJlcGxhY2UoZmIsXCIkMV89XCIrY2IrKyk6ZCsoZGIudGVzdChkKT9cIiZcIjpcIj9cIikrXCJfPVwiK2NiKyspKSxrLmlmTW9kaWZpZWQmJihuLmxhc3RNb2RpZmllZFtkXSYmdi5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIixuLmxhc3RNb2RpZmllZFtkXSksbi5ldGFnW2RdJiZ2LnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Ob25lLU1hdGNoXCIsbi5ldGFnW2RdKSksKGsuZGF0YSYmay5oYXNDb250ZW50JiZrLmNvbnRlbnRUeXBlIT09ITF8fGIuY29udGVudFR5cGUpJiZ2LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixrLmNvbnRlbnRUeXBlKSx2LnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIixrLmRhdGFUeXBlc1swXSYmay5hY2NlcHRzW2suZGF0YVR5cGVzWzBdXT9rLmFjY2VwdHNbay5kYXRhVHlwZXNbMF1dKyhcIipcIiE9PWsuZGF0YVR5cGVzWzBdP1wiLCBcIituYitcIjsgcT0wLjAxXCI6XCJcIik6ay5hY2NlcHRzW1wiKlwiXSk7Zm9yKGogaW4gay5oZWFkZXJzKXYuc2V0UmVxdWVzdEhlYWRlcihqLGsuaGVhZGVyc1tqXSk7aWYoay5iZWZvcmVTZW5kJiYoay5iZWZvcmVTZW5kLmNhbGwobCx2LGspPT09ITF8fDI9PT10KSlyZXR1cm4gdi5hYm9ydCgpO3U9XCJhYm9ydFwiO2ZvcihqIGlue3N1Y2Nlc3M6MSxlcnJvcjoxLGNvbXBsZXRlOjF9KXZbal0oa1tqXSk7aWYoYz1yYihtYixrLGIsdikpe3YucmVhZHlTdGF0ZT0xLGkmJm0udHJpZ2dlcihcImFqYXhTZW5kXCIsW3Ysa10pLGsuYXN5bmMmJmsudGltZW91dD4wJiYoZz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7di5hYm9ydChcInRpbWVvdXRcIil9LGsudGltZW91dCkpO3RyeXt0PTEsYy5zZW5kKHIseCl9Y2F0Y2godyl7aWYoISgyPnQpKXRocm93IHc7eCgtMSx3KX19ZWxzZSB4KC0xLFwiTm8gVHJhbnNwb3J0XCIpO2Z1bmN0aW9uIHgoYSxiLGYsaCl7dmFyIGoscixzLHUsdyx4PWI7MiE9PXQmJih0PTIsZyYmY2xlYXJUaW1lb3V0KGcpLGM9dm9pZCAwLGU9aHx8XCJcIix2LnJlYWR5U3RhdGU9YT4wPzQ6MCxqPWE+PTIwMCYmMzAwPmF8fDMwND09PWEsZiYmKHU9dGIoayx2LGYpKSx1PXViKGssdSx2LGopLGo/KGsuaWZNb2RpZmllZCYmKHc9di5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIiksdyYmKG4ubGFzdE1vZGlmaWVkW2RdPXcpLHc9di5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIiksdyYmKG4uZXRhZ1tkXT13KSksMjA0PT09YXx8XCJIRUFEXCI9PT1rLnR5cGU/eD1cIm5vY29udGVudFwiOjMwND09PWE/eD1cIm5vdG1vZGlmaWVkXCI6KHg9dS5zdGF0ZSxyPXUuZGF0YSxzPXUuZXJyb3Isaj0hcykpOihzPXgsKGF8fCF4KSYmKHg9XCJlcnJvclwiLDA+YSYmKGE9MCkpKSx2LnN0YXR1cz1hLHYuc3RhdHVzVGV4dD0oYnx8eCkrXCJcIixqP28ucmVzb2x2ZVdpdGgobCxbcix4LHZdKTpvLnJlamVjdFdpdGgobCxbdix4LHNdKSx2LnN0YXR1c0NvZGUocSkscT12b2lkIDAsaSYmbS50cmlnZ2VyKGo/XCJhamF4U3VjY2Vzc1wiOlwiYWpheEVycm9yXCIsW3YsayxqP3I6c10pLHAuZmlyZVdpdGgobCxbdix4XSksaSYmKG0udHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLFt2LGtdKSwtLW4uYWN0aXZlfHxuLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpfXJldHVybiB2fSxnZXRKU09OOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbi5nZXQoYSxiLGMsXCJqc29uXCIpfSxnZXRTY3JpcHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbi5nZXQoYSx2b2lkIDAsYixcInNjcmlwdFwiKX19KSxuLmVhY2goW1wiZ2V0XCIsXCJwb3N0XCJdLGZ1bmN0aW9uKGEsYil7bltiXT1mdW5jdGlvbihhLGMsZCxlKXtyZXR1cm4gbi5pc0Z1bmN0aW9uKGMpJiYoZT1lfHxkLGQ9YyxjPXZvaWQgMCksbi5hamF4KHt1cmw6YSx0eXBlOmIsZGF0YVR5cGU6ZSxkYXRhOmMsc3VjY2VzczpkfSl9fSksbi5fZXZhbFVybD1mdW5jdGlvbihhKXtyZXR1cm4gbi5hamF4KHt1cmw6YSx0eXBlOlwiR0VUXCIsZGF0YVR5cGU6XCJzY3JpcHRcIixhc3luYzohMSxnbG9iYWw6ITEsXCJ0aHJvd3NcIjohMH0pfSxuLmZuLmV4dGVuZCh7d3JhcEFsbDpmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gbi5pc0Z1bmN0aW9uKGEpP3RoaXMuZWFjaChmdW5jdGlvbihiKXtuKHRoaXMpLndyYXBBbGwoYS5jYWxsKHRoaXMsYikpfSk6KHRoaXNbMF0mJihiPW4oYSx0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSx0aGlzWzBdLnBhcmVudE5vZGUmJmIuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLGIubWFwKGZ1bmN0aW9uKCl7dmFyIGE9dGhpczt3aGlsZShhLmZpcnN0RWxlbWVudENoaWxkKWE9YS5maXJzdEVsZW1lbnRDaGlsZDtyZXR1cm4gYX0pLmFwcGVuZCh0aGlzKSksdGhpcyl9LHdyYXBJbm5lcjpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKG4uaXNGdW5jdGlvbihhKT9mdW5jdGlvbihiKXtuKHRoaXMpLndyYXBJbm5lcihhLmNhbGwodGhpcyxiKSl9OmZ1bmN0aW9uKCl7dmFyIGI9bih0aGlzKSxjPWIuY29udGVudHMoKTtjLmxlbmd0aD9jLndyYXBBbGwoYSk6Yi5hcHBlbmQoYSl9KX0sd3JhcDpmdW5jdGlvbihhKXt2YXIgYj1uLmlzRnVuY3Rpb24oYSk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjKXtuKHRoaXMpLndyYXBBbGwoYj9hLmNhbGwodGhpcyxjKTphKX0pfSx1bndyYXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCl7bi5ub2RlTmFtZSh0aGlzLFwiYm9keVwiKXx8bih0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpfSkuZW5kKCl9fSksbi5leHByLmZpbHRlcnMuaGlkZGVuPWZ1bmN0aW9uKGEpe3JldHVybiBhLm9mZnNldFdpZHRoPD0wJiZhLm9mZnNldEhlaWdodDw9MH0sbi5leHByLmZpbHRlcnMudmlzaWJsZT1mdW5jdGlvbihhKXtyZXR1cm4hbi5leHByLmZpbHRlcnMuaGlkZGVuKGEpfTt2YXIgdmI9LyUyMC9nLHdiPS9cXFtcXF0kLyx4Yj0vXFxyP1xcbi9nLHliPS9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSx6Yj0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7ZnVuY3Rpb24gQWIoYSxiLGMsZCl7dmFyIGU7aWYobi5pc0FycmF5KGIpKW4uZWFjaChiLGZ1bmN0aW9uKGIsZSl7Y3x8d2IudGVzdChhKT9kKGEsZSk6QWIoYStcIltcIisoXCJvYmplY3RcIj09dHlwZW9mIGU/YjpcIlwiKStcIl1cIixlLGMsZCl9KTtlbHNlIGlmKGN8fFwib2JqZWN0XCIhPT1uLnR5cGUoYikpZChhLGIpO2Vsc2UgZm9yKGUgaW4gYilBYihhK1wiW1wiK2UrXCJdXCIsYltlXSxjLGQpfW4ucGFyYW09ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPVtdLGU9ZnVuY3Rpb24oYSxiKXtiPW4uaXNGdW5jdGlvbihiKT9iKCk6bnVsbD09Yj9cIlwiOmIsZFtkLmxlbmd0aF09ZW5jb2RlVVJJQ29tcG9uZW50KGEpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChiKX07aWYodm9pZCAwPT09YiYmKGI9bi5hamF4U2V0dGluZ3MmJm4uYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKSxuLmlzQXJyYXkoYSl8fGEuanF1ZXJ5JiYhbi5pc1BsYWluT2JqZWN0KGEpKW4uZWFjaChhLGZ1bmN0aW9uKCl7ZSh0aGlzLm5hbWUsdGhpcy52YWx1ZSl9KTtlbHNlIGZvcihjIGluIGEpQWIoYyxhW2NdLGIsZSk7cmV0dXJuIGQuam9pbihcIiZcIikucmVwbGFjZSh2YixcIitcIil9LG4uZm4uZXh0ZW5kKHtzZXJpYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbi5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpfSxzZXJpYWxpemVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPW4ucHJvcCh0aGlzLFwiZWxlbWVudHNcIik7cmV0dXJuIGE/bi5tYWtlQXJyYXkoYSk6dGhpc30pLmZpbHRlcihmdW5jdGlvbigpe3ZhciBhPXRoaXMudHlwZTtyZXR1cm4gdGhpcy5uYW1lJiYhbih0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSYmemIudGVzdCh0aGlzLm5vZGVOYW1lKSYmIXliLnRlc3QoYSkmJih0aGlzLmNoZWNrZWR8fCFULnRlc3QoYSkpfSkubWFwKGZ1bmN0aW9uKGEsYil7dmFyIGM9bih0aGlzKS52YWwoKTtyZXR1cm4gbnVsbD09Yz9udWxsOm4uaXNBcnJheShjKT9uLm1hcChjLGZ1bmN0aW9uKGEpe3JldHVybntuYW1lOmIubmFtZSx2YWx1ZTphLnJlcGxhY2UoeGIsXCJcXHJcXG5cIil9fSk6e25hbWU6Yi5uYW1lLHZhbHVlOmMucmVwbGFjZSh4YixcIlxcclxcblwiKX19KS5nZXQoKX19KSxuLmFqYXhTZXR0aW5ncy54aHI9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdH1jYXRjaChhKXt9fTt2YXIgQmI9MCxDYj17fSxEYj17MDoyMDAsMTIyMzoyMDR9LEViPW4uYWpheFNldHRpbmdzLnhocigpO2EuYXR0YWNoRXZlbnQmJmEuYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLGZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIENiKUNiW2FdKCl9KSxrLmNvcnM9ISFFYiYmXCJ3aXRoQ3JlZGVudGlhbHNcImluIEViLGsuYWpheD1FYj0hIUViLG4uYWpheFRyYW5zcG9ydChmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gay5jb3JzfHxFYiYmIWEuY3Jvc3NEb21haW4/e3NlbmQ6ZnVuY3Rpb24oYyxkKXt2YXIgZSxmPWEueGhyKCksZz0rK0JiO2lmKGYub3BlbihhLnR5cGUsYS51cmwsYS5hc3luYyxhLnVzZXJuYW1lLGEucGFzc3dvcmQpLGEueGhyRmllbGRzKWZvcihlIGluIGEueGhyRmllbGRzKWZbZV09YS54aHJGaWVsZHNbZV07YS5taW1lVHlwZSYmZi5vdmVycmlkZU1pbWVUeXBlJiZmLm92ZXJyaWRlTWltZVR5cGUoYS5taW1lVHlwZSksYS5jcm9zc0RvbWFpbnx8Y1tcIlgtUmVxdWVzdGVkLVdpdGhcIl18fChjW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXT1cIlhNTEh0dHBSZXF1ZXN0XCIpO2ZvcihlIGluIGMpZi5zZXRSZXF1ZXN0SGVhZGVyKGUsY1tlXSk7Yj1mdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oKXtiJiYoZGVsZXRlIENiW2ddLGI9Zi5vbmxvYWQ9Zi5vbmVycm9yPW51bGwsXCJhYm9ydFwiPT09YT9mLmFib3J0KCk6XCJlcnJvclwiPT09YT9kKGYuc3RhdHVzLGYuc3RhdHVzVGV4dCk6ZChEYltmLnN0YXR1c118fGYuc3RhdHVzLGYuc3RhdHVzVGV4dCxcInN0cmluZ1wiPT10eXBlb2YgZi5yZXNwb25zZVRleHQ/e3RleHQ6Zi5yZXNwb25zZVRleHR9OnZvaWQgMCxmLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSl9fSxmLm9ubG9hZD1iKCksZi5vbmVycm9yPWIoXCJlcnJvclwiKSxiPUNiW2ddPWIoXCJhYm9ydFwiKTt0cnl7Zi5zZW5kKGEuaGFzQ29udGVudCYmYS5kYXRhfHxudWxsKX1jYXRjaChoKXtpZihiKXRocm93IGh9fSxhYm9ydDpmdW5jdGlvbigpe2ImJmIoKX19OnZvaWQgMH0pLG4uYWpheFNldHVwKHthY2NlcHRzOntzY3JpcHQ6XCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwifSxjb250ZW50czp7c2NyaXB0Oi8oPzpqYXZhfGVjbWEpc2NyaXB0L30sY29udmVydGVyczp7XCJ0ZXh0IHNjcmlwdFwiOmZ1bmN0aW9uKGEpe3JldHVybiBuLmdsb2JhbEV2YWwoYSksYX19fSksbi5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsZnVuY3Rpb24oYSl7dm9pZCAwPT09YS5jYWNoZSYmKGEuY2FjaGU9ITEpLGEuY3Jvc3NEb21haW4mJihhLnR5cGU9XCJHRVRcIil9KSxuLmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIixmdW5jdGlvbihhKXtpZihhLmNyb3NzRG9tYWluKXt2YXIgYixjO3JldHVybntzZW5kOmZ1bmN0aW9uKGQsZSl7Yj1uKFwiPHNjcmlwdD5cIikucHJvcCh7YXN5bmM6ITAsY2hhcnNldDphLnNjcmlwdENoYXJzZXQsc3JjOmEudXJsfSkub24oXCJsb2FkIGVycm9yXCIsYz1mdW5jdGlvbihhKXtiLnJlbW92ZSgpLGM9bnVsbCxhJiZlKFwiZXJyb3JcIj09PWEudHlwZT80MDQ6MjAwLGEudHlwZSl9KSxsLmhlYWQuYXBwZW5kQ2hpbGQoYlswXSl9LGFib3J0OmZ1bmN0aW9uKCl7YyYmYygpfX19fSk7dmFyIEZiPVtdLEdiPS8oPSlcXD8oPz0mfCQpfFxcP1xcPy87bi5hamF4U2V0dXAoe2pzb25wOlwiY2FsbGJhY2tcIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGE9RmIucG9wKCl8fG4uZXhwYW5kbytcIl9cIitjYisrO3JldHVybiB0aGlzW2FdPSEwLGF9fSksbi5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLGZ1bmN0aW9uKGIsYyxkKXt2YXIgZSxmLGcsaD1iLmpzb25wIT09ITEmJihHYi50ZXN0KGIudXJsKT9cInVybFwiOlwic3RyaW5nXCI9PXR5cGVvZiBiLmRhdGEmJiEoYi5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmR2IudGVzdChiLmRhdGEpJiZcImRhdGFcIik7cmV0dXJuIGh8fFwianNvbnBcIj09PWIuZGF0YVR5cGVzWzBdPyhlPWIuanNvbnBDYWxsYmFjaz1uLmlzRnVuY3Rpb24oYi5qc29ucENhbGxiYWNrKT9iLmpzb25wQ2FsbGJhY2soKTpiLmpzb25wQ2FsbGJhY2ssaD9iW2hdPWJbaF0ucmVwbGFjZShHYixcIiQxXCIrZSk6Yi5qc29ucCE9PSExJiYoYi51cmwrPShkYi50ZXN0KGIudXJsKT9cIiZcIjpcIj9cIikrYi5qc29ucCtcIj1cIitlKSxiLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXT1mdW5jdGlvbigpe3JldHVybiBnfHxuLmVycm9yKGUrXCIgd2FzIG5vdCBjYWxsZWRcIiksZ1swXX0sYi5kYXRhVHlwZXNbMF09XCJqc29uXCIsZj1hW2VdLGFbZV09ZnVuY3Rpb24oKXtnPWFyZ3VtZW50c30sZC5hbHdheXMoZnVuY3Rpb24oKXthW2VdPWYsYltlXSYmKGIuanNvbnBDYWxsYmFjaz1jLmpzb25wQ2FsbGJhY2ssRmIucHVzaChlKSksZyYmbi5pc0Z1bmN0aW9uKGYpJiZmKGdbMF0pLGc9Zj12b2lkIDB9KSxcInNjcmlwdFwiKTp2b2lkIDB9KSxuLnBhcnNlSFRNTD1mdW5jdGlvbihhLGIsYyl7aWYoIWF8fFwic3RyaW5nXCIhPXR5cGVvZiBhKXJldHVybiBudWxsO1wiYm9vbGVhblwiPT10eXBlb2YgYiYmKGM9YixiPSExKSxiPWJ8fGw7dmFyIGQ9di5leGVjKGEpLGU9IWMmJltdO3JldHVybiBkP1tiLmNyZWF0ZUVsZW1lbnQoZFsxXSldOihkPW4uYnVpbGRGcmFnbWVudChbYV0sYixlKSxlJiZlLmxlbmd0aCYmbihlKS5yZW1vdmUoKSxuLm1lcmdlKFtdLGQuY2hpbGROb2RlcykpfTt2YXIgSGI9bi5mbi5sb2FkO24uZm4ubG9hZD1mdW5jdGlvbihhLGIsYyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGEmJkhiKXJldHVybiBIYi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGQsZSxmLGc9dGhpcyxoPWEuaW5kZXhPZihcIiBcIik7cmV0dXJuIGg+PTAmJihkPW4udHJpbShhLnNsaWNlKGgpKSxhPWEuc2xpY2UoMCxoKSksbi5pc0Z1bmN0aW9uKGIpPyhjPWIsYj12b2lkIDApOmImJlwib2JqZWN0XCI9PXR5cGVvZiBiJiYoZT1cIlBPU1RcIiksZy5sZW5ndGg+MCYmbi5hamF4KHt1cmw6YSx0eXBlOmUsZGF0YVR5cGU6XCJodG1sXCIsZGF0YTpifSkuZG9uZShmdW5jdGlvbihhKXtmPWFyZ3VtZW50cyxnLmh0bWwoZD9uKFwiPGRpdj5cIikuYXBwZW5kKG4ucGFyc2VIVE1MKGEpKS5maW5kKGQpOmEpfSkuY29tcGxldGUoYyYmZnVuY3Rpb24oYSxiKXtnLmVhY2goYyxmfHxbYS5yZXNwb25zZVRleHQsYixhXSl9KSx0aGlzfSxuLmVhY2goW1wiYWpheFN0YXJ0XCIsXCJhamF4U3RvcFwiLFwiYWpheENvbXBsZXRlXCIsXCJhamF4RXJyb3JcIixcImFqYXhTdWNjZXNzXCIsXCJhamF4U2VuZFwiXSxmdW5jdGlvbihhLGIpe24uZm5bYl09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMub24oYixhKX19KSxuLmV4cHIuZmlsdGVycy5hbmltYXRlZD1mdW5jdGlvbihhKXtyZXR1cm4gbi5ncmVwKG4udGltZXJzLGZ1bmN0aW9uKGIpe3JldHVybiBhPT09Yi5lbGVtfSkubGVuZ3RofTt2YXIgSWI9YS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7ZnVuY3Rpb24gSmIoYSl7cmV0dXJuIG4uaXNXaW5kb3coYSk/YTo5PT09YS5ub2RlVHlwZSYmYS5kZWZhdWx0Vmlld31uLm9mZnNldD17c2V0T2Zmc2V0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoLGksaixrPW4uY3NzKGEsXCJwb3NpdGlvblwiKSxsPW4oYSksbT17fTtcInN0YXRpY1wiPT09ayYmKGEuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiKSxoPWwub2Zmc2V0KCksZj1uLmNzcyhhLFwidG9wXCIpLGk9bi5jc3MoYSxcImxlZnRcIiksaj0oXCJhYnNvbHV0ZVwiPT09a3x8XCJmaXhlZFwiPT09aykmJihmK2kpLmluZGV4T2YoXCJhdXRvXCIpPi0xLGo/KGQ9bC5wb3NpdGlvbigpLGc9ZC50b3AsZT1kLmxlZnQpOihnPXBhcnNlRmxvYXQoZil8fDAsZT1wYXJzZUZsb2F0KGkpfHwwKSxuLmlzRnVuY3Rpb24oYikmJihiPWIuY2FsbChhLGMsaCkpLG51bGwhPWIudG9wJiYobS50b3A9Yi50b3AtaC50b3ArZyksbnVsbCE9Yi5sZWZ0JiYobS5sZWZ0PWIubGVmdC1oLmxlZnQrZSksXCJ1c2luZ1wiaW4gYj9iLnVzaW5nLmNhbGwoYSxtKTpsLmNzcyhtKX19LG4uZm4uZXh0ZW5kKHtvZmZzZXQ6ZnVuY3Rpb24oYSl7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdm9pZCAwPT09YT90aGlzOnRoaXMuZWFjaChmdW5jdGlvbihiKXtuLm9mZnNldC5zZXRPZmZzZXQodGhpcyxhLGIpfSk7dmFyIGIsYyxkPXRoaXNbMF0sZT17dG9wOjAsbGVmdDowfSxmPWQmJmQub3duZXJEb2N1bWVudDtpZihmKXJldHVybiBiPWYuZG9jdW1lbnRFbGVtZW50LG4uY29udGFpbnMoYixkKT8odHlwZW9mIGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0IT09VSYmKGU9ZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksYz1KYihmKSx7dG9wOmUudG9wK2MucGFnZVlPZmZzZXQtYi5jbGllbnRUb3AsbGVmdDplLmxlZnQrYy5wYWdlWE9mZnNldC1iLmNsaWVudExlZnR9KTplfSxwb3NpdGlvbjpmdW5jdGlvbigpe2lmKHRoaXNbMF0pe3ZhciBhLGIsYz10aGlzWzBdLGQ9e3RvcDowLGxlZnQ6MH07cmV0dXJuXCJmaXhlZFwiPT09bi5jc3MoYyxcInBvc2l0aW9uXCIpP2I9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTooYT10aGlzLm9mZnNldFBhcmVudCgpLGI9dGhpcy5vZmZzZXQoKSxuLm5vZGVOYW1lKGFbMF0sXCJodG1sXCIpfHwoZD1hLm9mZnNldCgpKSxkLnRvcCs9bi5jc3MoYVswXSxcImJvcmRlclRvcFdpZHRoXCIsITApLGQubGVmdCs9bi5jc3MoYVswXSxcImJvcmRlckxlZnRXaWR0aFwiLCEwKSkse3RvcDpiLnRvcC1kLnRvcC1uLmNzcyhjLFwibWFyZ2luVG9wXCIsITApLGxlZnQ6Yi5sZWZ0LWQubGVmdC1uLmNzcyhjLFwibWFyZ2luTGVmdFwiLCEwKX19fSxvZmZzZXRQYXJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9mZnNldFBhcmVudHx8SWI7d2hpbGUoYSYmIW4ubm9kZU5hbWUoYSxcImh0bWxcIikmJlwic3RhdGljXCI9PT1uLmNzcyhhLFwicG9zaXRpb25cIikpYT1hLm9mZnNldFBhcmVudDtyZXR1cm4gYXx8SWJ9KX19KSxuLmVhY2goe3Njcm9sbExlZnQ6XCJwYWdlWE9mZnNldFwiLHNjcm9sbFRvcDpcInBhZ2VZT2Zmc2V0XCJ9LGZ1bmN0aW9uKGIsYyl7dmFyIGQ9XCJwYWdlWU9mZnNldFwiPT09YztuLmZuW2JdPWZ1bmN0aW9uKGUpe3JldHVybiBKKHRoaXMsZnVuY3Rpb24oYixlLGYpe3ZhciBnPUpiKGIpO3JldHVybiB2b2lkIDA9PT1mP2c/Z1tjXTpiW2VdOnZvaWQoZz9nLnNjcm9sbFRvKGQ/YS5wYWdlWE9mZnNldDpmLGQ/ZjphLnBhZ2VZT2Zmc2V0KTpiW2VdPWYpfSxiLGUsYXJndW1lbnRzLmxlbmd0aCxudWxsKX19KSxuLmVhY2goW1widG9wXCIsXCJsZWZ0XCJdLGZ1bmN0aW9uKGEsYil7bi5jc3NIb29rc1tiXT15YShrLnBpeGVsUG9zaXRpb24sZnVuY3Rpb24oYSxjKXtyZXR1cm4gYz8oYz14YShhLGIpLHZhLnRlc3QoYyk/bihhKS5wb3NpdGlvbigpW2JdK1wicHhcIjpjKTp2b2lkIDB9KX0pLG4uZWFjaCh7SGVpZ2h0OlwiaGVpZ2h0XCIsV2lkdGg6XCJ3aWR0aFwifSxmdW5jdGlvbihhLGIpe24uZWFjaCh7cGFkZGluZzpcImlubmVyXCIrYSxjb250ZW50OmIsXCJcIjpcIm91dGVyXCIrYX0sZnVuY3Rpb24oYyxkKXtuLmZuW2RdPWZ1bmN0aW9uKGQsZSl7dmFyIGY9YXJndW1lbnRzLmxlbmd0aCYmKGN8fFwiYm9vbGVhblwiIT10eXBlb2YgZCksZz1jfHwoZD09PSEwfHxlPT09ITA/XCJtYXJnaW5cIjpcImJvcmRlclwiKTtyZXR1cm4gSih0aGlzLGZ1bmN0aW9uKGIsYyxkKXt2YXIgZTtyZXR1cm4gbi5pc1dpbmRvdyhiKT9iLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiK2FdOjk9PT1iLm5vZGVUeXBlPyhlPWIuZG9jdW1lbnRFbGVtZW50LE1hdGgubWF4KGIuYm9keVtcInNjcm9sbFwiK2FdLGVbXCJzY3JvbGxcIithXSxiLmJvZHlbXCJvZmZzZXRcIithXSxlW1wib2Zmc2V0XCIrYV0sZVtcImNsaWVudFwiK2FdKSk6dm9pZCAwPT09ZD9uLmNzcyhiLGMsZyk6bi5zdHlsZShiLGMsZCxnKX0sYixmP2Q6dm9pZCAwLGYsbnVsbCl9fSl9KSxuLmZuLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZW5ndGh9LG4uZm4uYW5kU2VsZj1uLmZuLmFkZEJhY2ssXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoXCJqcXVlcnlcIixbXSxmdW5jdGlvbigpe3JldHVybiBufSk7dmFyIEtiPWEualF1ZXJ5LExiPWEuJDtyZXR1cm4gbi5ub0NvbmZsaWN0PWZ1bmN0aW9uKGIpe3JldHVybiBhLiQ9PT1uJiYoYS4kPUxiKSxiJiZhLmpRdWVyeT09PW4mJihhLmpRdWVyeT1LYiksbn0sdHlwZW9mIGI9PT1VJiYoYS5qUXVlcnk9YS4kPW4pLG59KTtcbiIsIi8qKlxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgZXJpY2g2NjYgLyBodHRwOi8vZXJpY2hhaW5lcy5jb21cbiAqL1xuLypnbG9iYWwgVEhSRUUsIGNvbnNvbGUgKi9cblxuLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuIEl0IG1haW50YWluc1xuLy8gdGhlIFwidXBcIiBkaXJlY3Rpb24gYXMgK1ksIHVubGlrZSB0aGUgVHJhY2tiYWxsQ29udHJvbHMuIFRvdWNoIG9uIHRhYmxldCBhbmQgcGhvbmVzIGlzXG4vLyBzdXBwb3J0ZWQuXG4vL1xuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZSBmaW5nZXIgbW92ZVxuLy8gICAgWm9vbSAtIG1pZGRsZSBtb3VzZSwgb3IgbW91c2V3aGVlbCAvIHRvdWNoOiB0d28gZmluZ2VyIHNwcmVhZCBvciBzcXVpc2hcbi8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHRocmVlIGZpbnRlciBzd2lwZVxudmFyIFRIUkVFID0gcmVxdWlyZShcIi4vdGhyZWUuanNcIik7XG5cbnZhciBPcmJpdENvbnRyb2xzID0gZnVuY3Rpb24gKG9iamVjdCwgZG9tRWxlbWVudCkge1xuXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gKCBkb21FbGVtZW50ICE9PSB1bmRlZmluZWQgKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcblxuICAgIC8vIEFQSVxuXG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBjb250cm9sIG9yYml0cyBhcm91bmRcbiAgICAvLyBhbmQgd2hlcmUgaXQgcGFucyB3aXRoIHJlc3BlY3QgdG8uXG4gICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgLy8gY2VudGVyIGlzIG9sZCwgZGVwcmVjYXRlZDsgdXNlIFwidGFyZ2V0XCIgaW5zdGVhZFxuICAgIHRoaXMuY2VudGVyID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBUaGlzIG9wdGlvbiBhY3R1YWxseSBlbmFibGVzIGRvbGx5aW5nIGluIGFuZCBvdXQ7IGxlZnQgYXMgXCJ6b29tXCIgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLm5vWm9vbSA9IGZhbHNlO1xuICAgIHRoaXMuem9vbVNwZWVkID0gMS4wO1xuXG4gICAgLy8gTGltaXRzIHRvIGhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0ICggUGVyc3BlY3RpdmVDYW1lcmEgb25seSApXG4gICAgdGhpcy5taW5EaXN0YW5jZSA9IDA7XG4gICAgdGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgLy8gTGltaXRzIHRvIGhvdyBmYXIgeW91IGNhbiB6b29tIGluIGFuZCBvdXQgKCBPcnRob2dyYXBoaWNDYW1lcmEgb25seSApXG4gICAgdGhpcy5taW5ab29tID0gMDtcbiAgICB0aGlzLm1heFpvb20gPSBJbmZpbml0eTtcblxuICAgIC8vIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG4gICAgdGhpcy5ub1JvdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMucm90YXRlU3BlZWQgPSAxLjA7XG5cbiAgICAvLyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuICAgIHRoaXMubm9QYW4gPSBmYWxzZTtcbiAgICB0aGlzLmtleVBhblNwZWVkID0gNy4wO1x0Ly8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuXG4gICAgLy8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcbiAgICB0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcblxuICAgIC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCB2ZXJ0aWNhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuICAgIC8vIFJhbmdlIGlzIDAgdG8gTWF0aC5QSSByYWRpYW5zLlxuICAgIHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcbiAgICB0aGlzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJOyAvLyByYWRpYW5zXG5cbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgaG9yaXpvbnRhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuICAgIC8vIElmIHNldCwgbXVzdCBiZSBhIHN1Yi1pbnRlcnZhbCBvZiB0aGUgaW50ZXJ2YWwgWyAtIE1hdGguUEksIE1hdGguUEkgXS5cbiAgICB0aGlzLm1pbkF6aW11dGhBbmdsZSA9IC1JbmZpbml0eTsgLy8gcmFkaWFuc1xuICAgIHRoaXMubWF4QXppbXV0aEFuZ2xlID0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblxuICAgIC8vIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdXNlIG9mIHRoZSBrZXlzXG4gICAgdGhpcy5ub0tleXMgPSBmYWxzZTtcblxuICAgIC8vIFRoZSBmb3VyIGFycm93IGtleXNcbiAgICB0aGlzLmtleXMgPSB7TEVGVDogMzcsIFVQOiAzOCwgUklHSFQ6IDM5LCBCT1RUT006IDQwfTtcblxuICAgIC8vIE1vdXNlIGJ1dHRvbnNcbiAgICB0aGlzLm1vdXNlQnV0dG9ucyA9IHtPUkJJVDogVEhSRUUuTU9VU0UuTUlERExFLCBaT09NOiAzLCBQQU46IDN9O1xuXG4gICAgLy8vLy8vLy8vLy8vXG4gICAgLy8gaW50ZXJuYWxzXG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgdmFyIHJvdGF0ZVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICB2YXIgcm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICB2YXIgcm90YXRlRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgdmFyIHBhblN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICB2YXIgcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICB2YXIgcGFuRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIHZhciBwYW5PZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2YXIgZG9sbHlTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgdmFyIGRvbGx5RW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICB2YXIgZG9sbHlEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICB2YXIgdGhldGE7XG4gICAgdmFyIHBoaTtcbiAgICB2YXIgcGhpRGVsdGEgPSAwO1xuICAgIHZhciB0aGV0YURlbHRhID0gMDtcbiAgICB2YXIgc2NhbGUgPSAxO1xuICAgIHZhciBwYW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmFyIGxhc3RQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGxhc3RRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIHZhciBTVEFURSA9IHtOT05FOiAtMSwgUk9UQVRFOiAwLCBET0xMWTogMSwgUEFOOiAyLCBUT1VDSF9ST1RBVEU6IDMsIFRPVUNIX0RPTExZOiA0LCBUT1VDSF9QQU46IDV9O1xuXG4gICAgdmFyIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgIC8vIGZvciByZXNldFxuXG4gICAgdGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcbiAgICB0aGlzLnBvc2l0aW9uMCA9IHRoaXMub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XG4gICAgdGhpcy56b29tMCA9IHRoaXMub2JqZWN0Lnpvb207XG5cbiAgICAvLyBzbyBjYW1lcmEudXAgaXMgdGhlIG9yYml0IGF4aXNcblxuICAgIHZhciBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnMob2JqZWN0LnVwLCBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSk7XG4gICAgdmFyIHF1YXRJbnZlcnNlID0gcXVhdC5jbG9uZSgpLmludmVyc2UoKTtcblxuICAgIC8vIGV2ZW50c1xuXG4gICAgdmFyIGNoYW5nZUV2ZW50ID0ge3R5cGU6ICdjaGFuZ2UnfTtcbiAgICB2YXIgc3RhcnRFdmVudCA9IHt0eXBlOiAnc3RhcnQnfTtcbiAgICB2YXIgZW5kRXZlbnQgPSB7dHlwZTogJ2VuZCd9O1xuXG4gICAgdGhpcy5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG5cbiAgICAgICAgaWYgKGFuZ2xlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgYW5nbGUgPSBnZXRBdXRvUm90YXRpb25BbmdsZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGV0YURlbHRhIC09IGFuZ2xlO1xuXG4gICAgfTtcblxuICAgIHRoaXMucm90YXRlVXAgPSBmdW5jdGlvbiAoYW5nbGUpIHtcblxuICAgICAgICBpZiAoYW5nbGUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBoaURlbHRhIC09IGFuZ2xlO1xuXG4gICAgfTtcblxuICAgIC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSBsZWZ0XG4gICAgdGhpcy5wYW5MZWZ0ID0gZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG5cbiAgICAgICAgdmFyIHRlID0gdGhpcy5vYmplY3QubWF0cml4LmVsZW1lbnRzO1xuXG4gICAgICAgIC8vIGdldCBYIGNvbHVtbiBvZiBtYXRyaXhcbiAgICAgICAgcGFuT2Zmc2V0LnNldCh0ZVswXSwgdGVbMV0sIHRlWzJdKTtcbiAgICAgICAgcGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKC1kaXN0YW5jZSk7XG5cbiAgICAgICAgcGFuLmFkZChwYW5PZmZzZXQpO1xuXG4gICAgfTtcblxuICAgIC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSB1cFxuICAgIHRoaXMucGFuVXAgPSBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcblxuICAgICAgICB2YXIgdGUgPSB0aGlzLm9iamVjdC5tYXRyaXguZWxlbWVudHM7XG5cbiAgICAgICAgLy8gZ2V0IFkgY29sdW1uIG9mIG1hdHJpeFxuICAgICAgICBwYW5PZmZzZXQuc2V0KHRlWzRdLCB0ZVs1XSwgdGVbNl0pO1xuICAgICAgICBwYW5PZmZzZXQubXVsdGlwbHlTY2FsYXIoZGlzdGFuY2UpO1xuXG4gICAgICAgIHBhbi5hZGQocGFuT2Zmc2V0KTtcblxuICAgIH07XG5cbiAgICAvLyBwYXNzIGluIHgseSBvZiBjaGFuZ2UgZGVzaXJlZCBpbiBwaXhlbCBzcGFjZSxcbiAgICAvLyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcbiAgICB0aGlzLnBhbiA9IGZ1bmN0aW9uIChkZWx0YVgsIGRlbHRhWSkge1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG4gICAgICAgIGlmIChzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSkge1xuXG4gICAgICAgICAgICAvLyBwZXJzcGVjdGl2ZVxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHBvc2l0aW9uLmNsb25lKCkuc3ViKHNjb3BlLnRhcmdldCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgIC8vIGhhbGYgb2YgdGhlIGZvdiBpcyBjZW50ZXIgdG8gdG9wIG9mIHNjcmVlblxuICAgICAgICAgICAgdGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oKCBzY29wZS5vYmplY3QuZm92IC8gMiApICogTWF0aC5QSSAvIDE4MC4wKTtcblxuICAgICAgICAgICAgLy8gd2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHNjcmVlbldpZHRoLCBzaW5jZSBwZXJzcGVjdGl2ZSBjYW1lcmEgaXMgZml4ZWQgdG8gc2NyZWVuIGhlaWdodFxuICAgICAgICAgICAgc2NvcGUucGFuTGVmdCgyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICBzY29wZS5wYW5VcCgyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEpIHtcblxuICAgICAgICAgICAgLy8gb3J0aG9ncmFwaGljXG4gICAgICAgICAgICBzY29wZS5wYW5MZWZ0KGRlbHRhWCAqIChzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCkgLyBlbGVtZW50LmNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgIHNjb3BlLnBhblVwKGRlbHRhWSAqIChzY29wZS5vYmplY3QudG9wIC0gc2NvcGUub2JqZWN0LmJvdHRvbSkgLyBlbGVtZW50LmNsaWVudEhlaWdodCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gY2FtZXJhIG5laXRoZXIgb3J0aG9ncmFwaGljIG9yIHBlcnNwZWN0aXZlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHBhbiBkaXNhYmxlZC4nKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy5kb2xseUluID0gZnVuY3Rpb24gKGRvbGx5U2NhbGUpIHtcblxuICAgICAgICBpZiAoZG9sbHlTY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIGRvbGx5U2NhbGUgPSBnZXRab29tU2NhbGUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKSB7XG5cbiAgICAgICAgICAgIHNjYWxlIC89IGRvbGx5U2NhbGU7XG5cbiAgICAgICAgfSBlbHNlIGlmIChzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEpIHtcblxuICAgICAgICAgICAgc2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCh0aGlzLm1pblpvb20sIE1hdGgubWluKHRoaXMubWF4Wm9vbSwgdGhpcy5vYmplY3Quem9vbSAqIGRvbGx5U2NhbGUpKTtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuZG9sbHlPdXQgPSBmdW5jdGlvbiAoZG9sbHlTY2FsZSkge1xuXG4gICAgICAgIGlmIChkb2xseVNjYWxlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEpIHtcblxuICAgICAgICAgICAgc2NhbGUgKj0gZG9sbHlTY2FsZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSkge1xuXG4gICAgICAgICAgICBzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KHRoaXMubWluWm9vbSwgTWF0aC5taW4odGhpcy5tYXhab29tLCB0aGlzLm9iamVjdC56b29tIC8gZG9sbHlTY2FsZSkpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4nKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5vYmplY3QucG9zaXRpb247XG5cbiAgICAgICAgb2Zmc2V0LmNvcHkocG9zaXRpb24pLnN1Yih0aGlzLnRhcmdldCk7XG5cbiAgICAgICAgLy8gcm90YXRlIG9mZnNldCB0byBcInktYXhpcy1pcy11cFwiIHNwYWNlXG4gICAgICAgIG9mZnNldC5hcHBseVF1YXRlcm5pb24ocXVhdCk7XG5cbiAgICAgICAgLy8gYW5nbGUgZnJvbSB6LWF4aXMgYXJvdW5kIHktYXhpc1xuXG4gICAgICAgIHRoZXRhID0gTWF0aC5hdGFuMihvZmZzZXQueCwgb2Zmc2V0LnopO1xuXG4gICAgICAgIC8vIGFuZ2xlIGZyb20geS1heGlzXG5cbiAgICAgICAgcGhpID0gTWF0aC5hdGFuMihNYXRoLnNxcnQob2Zmc2V0LnggKiBvZmZzZXQueCArIG9mZnNldC56ICogb2Zmc2V0LnopLCBvZmZzZXQueSk7XG5cbiAgICAgICAgaWYgKHRoaXMuYXV0b1JvdGF0ZSAmJiBzdGF0ZSA9PT0gU1RBVEUuTk9ORSkge1xuXG4gICAgICAgICAgICB0aGlzLnJvdGF0ZUxlZnQoZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoZXRhICs9IHRoZXRhRGVsdGE7XG4gICAgICAgIHBoaSArPSBwaGlEZWx0YTtcblxuICAgICAgICAvLyByZXN0cmljdCB0aGV0YSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4gICAgICAgIHRoZXRhID0gTWF0aC5tYXgodGhpcy5taW5BemltdXRoQW5nbGUsIE1hdGgubWluKHRoaXMubWF4QXppbXV0aEFuZ2xlLCB0aGV0YSkpO1xuXG4gICAgICAgIC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4gICAgICAgIHBoaSA9IE1hdGgubWF4KHRoaXMubWluUG9sYXJBbmdsZSwgTWF0aC5taW4odGhpcy5tYXhQb2xhckFuZ2xlLCBwaGkpKTtcblxuICAgICAgICAvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlIEVQUyBhbmQgUEktRVBTXG4gICAgICAgIHBoaSA9IE1hdGgubWF4KEVQUywgTWF0aC5taW4oTWF0aC5QSSAtIEVQUywgcGhpKSk7XG5cbiAgICAgICAgdmFyIHJhZGl1cyA9IG9mZnNldC5sZW5ndGgoKSAqIHNjYWxlO1xuXG4gICAgICAgIC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4gICAgICAgIHJhZGl1cyA9IE1hdGgubWF4KHRoaXMubWluRGlzdGFuY2UsIE1hdGgubWluKHRoaXMubWF4RGlzdGFuY2UsIHJhZGl1cykpO1xuXG4gICAgICAgIC8vIG1vdmUgdGFyZ2V0IHRvIHBhbm5lZCBsb2NhdGlvblxuICAgICAgICB0aGlzLnRhcmdldC5hZGQocGFuKTtcblxuICAgICAgICBvZmZzZXQueCA9IHJhZGl1cyAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIG9mZnNldC55ID0gcmFkaXVzICogTWF0aC5jb3MocGhpKTtcbiAgICAgICAgb2Zmc2V0LnogPSByYWRpdXMgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpO1xuXG4gICAgICAgIC8vIHJvdGF0ZSBvZmZzZXQgYmFjayB0byBcImNhbWVyYS11cC12ZWN0b3ItaXMtdXBcIiBzcGFjZVxuICAgICAgICBvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKHF1YXRJbnZlcnNlKTtcblxuICAgICAgICBwb3NpdGlvbi5jb3B5KHRoaXMudGFyZ2V0KS5hZGQob2Zmc2V0KTtcblxuICAgICAgICB0aGlzLm9iamVjdC5sb29rQXQodGhpcy50YXJnZXQpO1xuXG4gICAgICAgIHRoZXRhRGVsdGEgPSAwO1xuICAgICAgICBwaGlEZWx0YSA9IDA7XG4gICAgICAgIHNjYWxlID0gMTtcbiAgICAgICAgcGFuLnNldCgwLCAwLCAwKTtcblxuICAgICAgICAvLyB1cGRhdGUgY29uZGl0aW9uIGlzOlxuICAgICAgICAvLyBtaW4oY2FtZXJhIGRpc3BsYWNlbWVudCwgY2FtZXJhIHJvdGF0aW9uIGluIHJhZGlhbnMpXjIgPiBFUFNcbiAgICAgICAgLy8gdXNpbmcgc21hbGwtYW5nbGUgYXBwcm94aW1hdGlvbiBjb3MoeC8yKSA9IDEgLSB4XjIgLyA4XG5cbiAgICAgICAgaWYgKGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLm9iamVjdC5wb3NpdGlvbikgPiBFUFNcbiAgICAgICAgICAgIHx8IDggKiAoMSAtIGxhc3RRdWF0ZXJuaW9uLmRvdCh0aGlzLm9iamVjdC5xdWF0ZXJuaW9uKSkgPiBFUFMpIHtcblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcblxuICAgICAgICAgICAgbGFzdFBvc2l0aW9uLmNvcHkodGhpcy5vYmplY3QucG9zaXRpb24pO1xuICAgICAgICAgICAgbGFzdFF1YXRlcm5pb24uY29weSh0aGlzLm9iamVjdC5xdWF0ZXJuaW9uKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICB0aGlzLnRhcmdldC5jb3B5KHRoaXMudGFyZ2V0MCk7XG4gICAgICAgIHRoaXMub2JqZWN0LnBvc2l0aW9uLmNvcHkodGhpcy5wb3NpdGlvbjApO1xuICAgICAgICB0aGlzLm9iamVjdC56b29tID0gdGhpcy56b29tMDtcblxuICAgICAgICB0aGlzLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmdldFBvbGFyQW5nbGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIHBoaTtcblxuICAgIH07XG5cbiAgICB0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiB0aGV0YVxuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuXG4gICAgICAgIHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQ7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab29tU2NhbGUoKSB7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDAuOTUsIHNjb3BlLnpvb21TcGVlZCk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudCkge1xuXG4gICAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT09IHNjb3BlLm1vdXNlQnV0dG9ucy5PUkJJVCkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLm5vUm90YXRlID09PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG4gICAgICAgICAgICByb3RhdGVTdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5idXR0b24gPT09IHNjb3BlLm1vdXNlQnV0dG9ucy5aT09NKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUubm9ab29tID09PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuRE9MTFk7XG5cbiAgICAgICAgICAgIGRvbGx5U3RhcnQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09PSBzY29wZS5tb3VzZUJ1dHRvbnMuUEFOKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUubm9QYW4gPT09IHRydWUpIHJldHVybjtcblxuICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5QQU47XG5cbiAgICAgICAgICAgIHBhblN0YXJ0LnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlICE9PSBTVEFURS5OT05FKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcblxuICAgICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gU1RBVEUuUk9UQVRFKSB7XG5cbiAgICAgICAgICAgIGlmIChzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICByb3RhdGVFbmQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICAgICAgcm90YXRlRGVsdGEuc3ViVmVjdG9ycyhyb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0KTtcblxuICAgICAgICAgICAgLy8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuICAgICAgICAgICAgc2NvcGUucm90YXRlTGVmdCgyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogc2NvcGUucm90YXRlU3BlZWQpO1xuXG4gICAgICAgICAgICAvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcbiAgICAgICAgICAgIHNjb3BlLnJvdGF0ZVVwKDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQpO1xuXG4gICAgICAgICAgICByb3RhdGVTdGFydC5jb3B5KHJvdGF0ZUVuZCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gU1RBVEUuRE9MTFkpIHtcblxuICAgICAgICAgICAgaWYgKHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBkb2xseUVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgICBkb2xseURlbHRhLnN1YlZlY3RvcnMoZG9sbHlFbmQsIGRvbGx5U3RhcnQpO1xuXG4gICAgICAgICAgICBpZiAoZG9sbHlEZWx0YS55ID4gMCkge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZG9sbHlJbigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvbGx5RGVsdGEueSA8IDApIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmRvbGx5T3V0KCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9sbHlTdGFydC5jb3B5KGRvbGx5RW5kKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBTVEFURS5QQU4pIHtcblxuICAgICAgICAgICAgaWYgKHNjb3BlLm5vUGFuID09PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgICAgIHBhbkVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgICBwYW5EZWx0YS5zdWJWZWN0b3JzKHBhbkVuZCwgcGFuU3RhcnQpO1xuXG4gICAgICAgICAgICBzY29wZS5wYW4ocGFuRGVsdGEueCwgcGFuRGVsdGEueSk7XG5cbiAgICAgICAgICAgIHBhblN0YXJ0LmNvcHkocGFuRW5kKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlICE9PSBTVEFURS5OT05FKSBzY29wZS51cGRhdGUoKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgvKiBldmVudCAqLykge1xuXG4gICAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkge1xuXG4gICAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5ub1pvb20gPT09IHRydWUgfHwgc3RhdGUgIT09IFNUQVRFLk5PTkUpIHJldHVybjtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB2YXIgZGVsdGEgPSAwO1xuXG4gICAgICAgIGlmIChldmVudC53aGVlbERlbHRhICE9PSB1bmRlZmluZWQpIHsgLy8gV2ViS2l0IC8gT3BlcmEgLyBFeHBsb3JlciA5XG5cbiAgICAgICAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YTtcblxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCAhPT0gdW5kZWZpbmVkKSB7IC8vIEZpcmVmb3hcblxuICAgICAgICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG5cbiAgICAgICAgICAgIHNjb3BlLmRvbGx5T3V0KCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcblxuICAgICAgICAgICAgc2NvcGUuZG9sbHlJbigpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcblxuICAgICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUubm9LZXlzID09PSB0cnVlIHx8IHNjb3BlLm5vUGFuID09PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG5cbiAgICAgICAgICAgIGNhc2Ugc2NvcGUua2V5cy5VUDpcbiAgICAgICAgICAgICAgICBzY29wZS5wYW4oMCwgc2NvcGUua2V5UGFuU3BlZWQpO1xuICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuICAgICAgICAgICAgICAgIHNjb3BlLnBhbigwLCAtc2NvcGUua2V5UGFuU3BlZWQpO1xuICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIHNjb3BlLmtleXMuTEVGVDpcbiAgICAgICAgICAgICAgICBzY29wZS5wYW4oc2NvcGUua2V5UGFuU3BlZWQsIDApO1xuICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIHNjb3BlLmtleXMuUklHSFQ6XG4gICAgICAgICAgICAgICAgc2NvcGUucGFuKC1zY29wZS5rZXlQYW5TcGVlZCwgMCk7XG4gICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG91Y2hzdGFydChldmVudCkge1xuXG4gICAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgY2FzZSAxOlx0Ly8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XG5cbiAgICAgICAgICAgICAgICByb3RhdGVTdGFydC5zZXQoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcdC8vIHR3by1maW5nZXJlZCB0b3VjaDogZG9sbHlcblxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5ub1pvb20gPT09IHRydWUpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcbiAgICAgICAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgICAgIGRvbGx5U3RhcnQuc2V0KDAsIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXG5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUubm9QYW4gPT09IHRydWUpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfUEFOO1xuXG4gICAgICAgICAgICAgICAgcGFuU3RhcnQuc2V0KGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUgIT09IFNUQVRFLk5PTkUpIHNjb3BlLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b3VjaG1vdmUoZXZlbnQpIHtcblxuICAgICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGNhc2UgMTogLy8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfUk9UQVRFKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICByb3RhdGVFbmQuc2V0KGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpO1xuICAgICAgICAgICAgICAgIHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMocm90YXRlRW5kLCByb3RhdGVTdGFydCk7XG5cbiAgICAgICAgICAgICAgICAvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXG4gICAgICAgICAgICAgICAgc2NvcGUucm90YXRlTGVmdCgyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogc2NvcGUucm90YXRlU3BlZWQpO1xuICAgICAgICAgICAgICAgIC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuICAgICAgICAgICAgICAgIHNjb3BlLnJvdGF0ZVVwKDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQpO1xuXG4gICAgICAgICAgICAgICAgcm90YXRlU3RhcnQuY29weShyb3RhdGVFbmQpO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjogLy8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfRE9MTFkpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICAgICAgICBkb2xseUVuZC5zZXQoMCwgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIGRvbGx5RGVsdGEuc3ViVmVjdG9ycyhkb2xseUVuZCwgZG9sbHlTdGFydCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9sbHlEZWx0YS55ID4gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmRvbGx5T3V0KCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRvbGx5RGVsdGEueSA8IDApIHtcblxuICAgICAgICAgICAgICAgICAgICBzY29wZS5kb2xseUluKCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb2xseVN0YXJ0LmNvcHkoZG9sbHlFbmQpO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLm5vUGFuID09PSB0cnVlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBTVEFURS5UT1VDSF9QQU4pIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHBhbkVuZC5zZXQoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSk7XG4gICAgICAgICAgICAgICAgcGFuRGVsdGEuc3ViVmVjdG9ycyhwYW5FbmQsIHBhblN0YXJ0KTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLnBhbihwYW5EZWx0YS54LCBwYW5EZWx0YS55KTtcblxuICAgICAgICAgICAgICAgIHBhblN0YXJ0LmNvcHkocGFuRW5kKTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvdWNoZW5kKC8qIGV2ZW50ICovKSB7XG5cbiAgICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgIH1cblxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIGZhbHNlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UpOyAvLyBmaXJlZm94XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaGVuZCwgZmFsc2UpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaG1vdmUsIGZhbHNlKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSk7XG5cbiAgICAvLyBmb3JjZSBhbiB1cGRhdGUgYXQgc3RhcnRcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5PcmJpdENvbnRyb2xzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSk7XG5PcmJpdENvbnRyb2xzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yYml0Q29udHJvbHM7XG5cbm1vZHVsZS5leHBvcnRzID0gT3JiaXRDb250cm9sczsiLCIvLyB0aHJlZWpzLm9yZy9saWNlbnNlXG4ndXNlIHN0cmljdCc7dmFyIFRIUkVFPXtSRVZJU0lPTjpcIjcxXCJ9O1wib2JqZWN0XCI9PT10eXBlb2YgbW9kdWxlJiYobW9kdWxlLmV4cG9ydHM9VEhSRUUpO3ZvaWQgMD09PU1hdGguc2lnbiYmKE1hdGguc2lnbj1mdW5jdGlvbihhKXtyZXR1cm4gMD5hPy0xOjA8YT8xOithfSk7VEhSRUUubG9nPWZ1bmN0aW9uKCl7Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSxhcmd1bWVudHMpfTtUSFJFRS53YXJuPWZ1bmN0aW9uKCl7Y29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKX07VEhSRUUuZXJyb3I9ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKX07VEhSRUUuTU9VU0U9e0xFRlQ6MCxNSURETEU6MSxSSUdIVDoyfTtUSFJFRS5DdWxsRmFjZU5vbmU9MDtUSFJFRS5DdWxsRmFjZUJhY2s9MTtUSFJFRS5DdWxsRmFjZUZyb250PTI7VEhSRUUuQ3VsbEZhY2VGcm9udEJhY2s9MztUSFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVz0wO1xuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXPTE7VEhSRUUuQmFzaWNTaGFkb3dNYXA9MDtUSFJFRS5QQ0ZTaGFkb3dNYXA9MTtUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwPTI7VEhSRUUuRnJvbnRTaWRlPTA7VEhSRUUuQmFja1NpZGU9MTtUSFJFRS5Eb3VibGVTaWRlPTI7VEhSRUUuTm9TaGFkaW5nPTA7VEhSRUUuRmxhdFNoYWRpbmc9MTtUSFJFRS5TbW9vdGhTaGFkaW5nPTI7VEhSRUUuTm9Db2xvcnM9MDtUSFJFRS5GYWNlQ29sb3JzPTE7VEhSRUUuVmVydGV4Q29sb3JzPTI7VEhSRUUuTm9CbGVuZGluZz0wO1RIUkVFLk5vcm1hbEJsZW5kaW5nPTE7VEhSRUUuQWRkaXRpdmVCbGVuZGluZz0yO1RIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmc9MztUSFJFRS5NdWx0aXBseUJsZW5kaW5nPTQ7VEhSRUUuQ3VzdG9tQmxlbmRpbmc9NTtUSFJFRS5BZGRFcXVhdGlvbj0xMDA7VEhSRUUuU3VidHJhY3RFcXVhdGlvbj0xMDE7VEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb249MTAyO1xuVEhSRUUuTWluRXF1YXRpb249MTAzO1RIUkVFLk1heEVxdWF0aW9uPTEwNDtUSFJFRS5aZXJvRmFjdG9yPTIwMDtUSFJFRS5PbmVGYWN0b3I9MjAxO1RIUkVFLlNyY0NvbG9yRmFjdG9yPTIwMjtUSFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yPTIwMztUSFJFRS5TcmNBbHBoYUZhY3Rvcj0yMDQ7VEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3Rvcj0yMDU7VEhSRUUuRHN0QWxwaGFGYWN0b3I9MjA2O1RIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3I9MjA3O1RIUkVFLkRzdENvbG9yRmFjdG9yPTIwODtUSFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yPTIwOTtUSFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yPTIxMDtUSFJFRS5NdWx0aXBseU9wZXJhdGlvbj0wO1RIUkVFLk1peE9wZXJhdGlvbj0xO1RIUkVFLkFkZE9wZXJhdGlvbj0yO1RIUkVFLlVWTWFwcGluZz0zMDA7VEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nPTMwMTtUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc9MzAyO1xuVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc9MzAzO1RIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nPTMwNDtUSFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZz0zMDU7VEhSRUUuUmVwZWF0V3JhcHBpbmc9MUUzO1RIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc9MTAwMTtUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nPTEwMDI7VEhSRUUuTmVhcmVzdEZpbHRlcj0xMDAzO1RIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyPTEwMDQ7VEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcj0xMDA1O1RIUkVFLkxpbmVhckZpbHRlcj0xMDA2O1RIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXI9MTAwNztUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI9MTAwODtUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlPTEwMDk7VEhSRUUuQnl0ZVR5cGU9MTAxMDtUSFJFRS5TaG9ydFR5cGU9MTAxMTtcblRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlPTEwMTI7VEhSRUUuSW50VHlwZT0xMDEzO1RIUkVFLlVuc2lnbmVkSW50VHlwZT0xMDE0O1RIUkVFLkZsb2F0VHlwZT0xMDE1O1RIUkVFLkhhbGZGbG9hdFR5cGU9MTAyNTtUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGU9MTAxNjtUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGU9MTAxNztUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZT0xMDE4O1RIUkVFLkFscGhhRm9ybWF0PTEwMTk7VEhSRUUuUkdCRm9ybWF0PTEwMjA7VEhSRUUuUkdCQUZvcm1hdD0xMDIxO1RIUkVFLkx1bWluYW5jZUZvcm1hdD0xMDIyO1RIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0PTEwMjM7VEhSRUUuUkdCRUZvcm1hdD1USFJFRS5SR0JBRm9ybWF0O1RIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0PTIwMDE7VEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0PTIwMDI7VEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0PTIwMDM7XG5USFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQ9MjAwNDtUSFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdD0yMTAwO1RIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0PTIxMDE7VEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0PTIxMDI7VEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0PTIxMDM7XG5USFJFRS5Qcm9qZWN0b3I9ZnVuY3Rpb24oKXtUSFJFRS5lcnJvcihcIlRIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy5cIik7dGhpcy5wcm9qZWN0VmVjdG9yPWZ1bmN0aW9uKGEsYil7VEhSRUUud2FybihcIlRIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS5cIik7YS5wcm9qZWN0KGIpfTt0aGlzLnVucHJvamVjdFZlY3Rvcj1mdW5jdGlvbihhLGIpe1RIUkVFLndhcm4oXCJUSFJFRS5Qcm9qZWN0b3I6IC51bnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnVucHJvamVjdCgpLlwiKTthLnVucHJvamVjdChiKX07dGhpcy5waWNraW5nUmF5PWZ1bmN0aW9uKGEsYil7VEhSRUUuZXJyb3IoXCJUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuXCIpfX07XG5USFJFRS5DYW52YXNSZW5kZXJlcj1mdW5jdGlvbigpe1RIUkVFLmVycm9yKFwiVEhSRUUuQ2FudmFzUmVuZGVyZXIgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9DYW52YXNSZW5kZXJlci5qc1wiKTt0aGlzLmRvbUVsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTt0aGlzLmNsZWFyPWZ1bmN0aW9uKCl7fTt0aGlzLnJlbmRlcj1mdW5jdGlvbigpe307dGhpcy5zZXRDbGVhckNvbG9yPWZ1bmN0aW9uKCl7fTt0aGlzLnNldFNpemU9ZnVuY3Rpb24oKXt9fTtUSFJFRS5Db2xvcj1mdW5jdGlvbihhKXtyZXR1cm4gMz09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5zZXRSR0IoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pOnRoaXMuc2V0KGEpfTtcblRIUkVFLkNvbG9yLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuQ29sb3IscjoxLGc6MSxiOjEsc2V0OmZ1bmN0aW9uKGEpe2EgaW5zdGFuY2VvZiBUSFJFRS5Db2xvcj90aGlzLmNvcHkoYSk6XCJudW1iZXJcIj09PXR5cGVvZiBhP3RoaXMuc2V0SGV4KGEpOlwic3RyaW5nXCI9PT10eXBlb2YgYSYmdGhpcy5zZXRTdHlsZShhKTtyZXR1cm4gdGhpc30sc2V0SGV4OmZ1bmN0aW9uKGEpe2E9TWF0aC5mbG9vcihhKTt0aGlzLnI9KGE+PjE2JjI1NSkvMjU1O3RoaXMuZz0oYT4+OCYyNTUpLzI1NTt0aGlzLmI9KGEmMjU1KS8yNTU7cmV0dXJuIHRoaXN9LHNldFJHQjpmdW5jdGlvbihhLGIsYyl7dGhpcy5yPWE7dGhpcy5nPWI7dGhpcy5iPWM7cmV0dXJuIHRoaXN9LHNldEhTTDpmdW5jdGlvbihhLGIsYyl7aWYoMD09PWIpdGhpcy5yPXRoaXMuZz10aGlzLmI9YztlbHNle3ZhciBkPWZ1bmN0aW9uKGEsYixjKXswPmMmJihjKz0xKTsxPGMmJihjLT0xKTtyZXR1cm4gYzwxLzY/YSs2KihiLWEpKlxuYzouNT5jP2I6YzwyLzM/YSs2KihiLWEpKigyLzMtYyk6YX07Yj0uNT49Yz9jKigxK2IpOmMrYi1jKmI7Yz0yKmMtYjt0aGlzLnI9ZChjLGIsYSsxLzMpO3RoaXMuZz1kKGMsYixhKTt0aGlzLmI9ZChjLGIsYS0xLzMpfXJldHVybiB0aGlzfSxzZXRTdHlsZTpmdW5jdGlvbihhKXtpZigvXnJnYlxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS50ZXN0KGEpKXJldHVybiBhPS9ecmdiXFwoKFxcZCspLCA/KFxcZCspLCA/KFxcZCspXFwpJC9pLmV4ZWMoYSksdGhpcy5yPU1hdGgubWluKDI1NSxwYXJzZUludChhWzFdLDEwKSkvMjU1LHRoaXMuZz1NYXRoLm1pbigyNTUscGFyc2VJbnQoYVsyXSwxMCkpLzI1NSx0aGlzLmI9TWF0aC5taW4oMjU1LHBhcnNlSW50KGFbM10sMTApKS8yNTUsdGhpcztpZigvXnJnYlxcKChcXGQrKVxcJSwgPyhcXGQrKVxcJSwgPyhcXGQrKVxcJVxcKSQvaS50ZXN0KGEpKXJldHVybiBhPS9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLmV4ZWMoYSksdGhpcy5yPVxuICAgIE1hdGgubWluKDEwMCxwYXJzZUludChhWzFdLDEwKSkvMTAwLHRoaXMuZz1NYXRoLm1pbigxMDAscGFyc2VJbnQoYVsyXSwxMCkpLzEwMCx0aGlzLmI9TWF0aC5taW4oMTAwLHBhcnNlSW50KGFbM10sMTApKS8xMDAsdGhpcztpZigvXlxcIyhbMC05YS1mXXs2fSkkL2kudGVzdChhKSlyZXR1cm4gYT0vXlxcIyhbMC05YS1mXXs2fSkkL2kuZXhlYyhhKSx0aGlzLnNldEhleChwYXJzZUludChhWzFdLDE2KSksdGhpcztpZigvXlxcIyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaS50ZXN0KGEpKXJldHVybiBhPS9eXFwjKFswLTlhLWZdKShbMC05YS1mXSkoWzAtOWEtZl0pJC9pLmV4ZWMoYSksdGhpcy5zZXRIZXgocGFyc2VJbnQoYVsxXSthWzFdK2FbMl0rYVsyXSthWzNdK2FbM10sMTYpKSx0aGlzO2lmKC9eKFxcdyspJC9pLnRlc3QoYSkpcmV0dXJuIHRoaXMuc2V0SGV4KFRIUkVFLkNvbG9yS2V5d29yZHNbYV0pLHRoaXN9LGNvcHk6ZnVuY3Rpb24oYSl7dGhpcy5yPWEucjt0aGlzLmc9XG4gICAgYS5nO3RoaXMuYj1hLmI7cmV0dXJuIHRoaXN9LGNvcHlHYW1tYVRvTGluZWFyOmZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9Mik7dGhpcy5yPU1hdGgucG93KGEucixiKTt0aGlzLmc9TWF0aC5wb3coYS5nLGIpO3RoaXMuYj1NYXRoLnBvdyhhLmIsYik7cmV0dXJuIHRoaXN9LGNvcHlMaW5lYXJUb0dhbW1hOmZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9Mik7dmFyIGM9MDxiPzEvYjoxO3RoaXMucj1NYXRoLnBvdyhhLnIsYyk7dGhpcy5nPU1hdGgucG93KGEuZyxjKTt0aGlzLmI9TWF0aC5wb3coYS5iLGMpO3JldHVybiB0aGlzfSxjb252ZXJ0R2FtbWFUb0xpbmVhcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMucixiPXRoaXMuZyxjPXRoaXMuYjt0aGlzLnI9YSphO3RoaXMuZz1iKmI7dGhpcy5iPWMqYztyZXR1cm4gdGhpc30sY29udmVydExpbmVhclRvR2FtbWE6ZnVuY3Rpb24oKXt0aGlzLnI9TWF0aC5zcXJ0KHRoaXMucik7dGhpcy5nPU1hdGguc3FydCh0aGlzLmcpO3RoaXMuYj1cbiAgICBNYXRoLnNxcnQodGhpcy5iKTtyZXR1cm4gdGhpc30sZ2V0SGV4OmZ1bmN0aW9uKCl7cmV0dXJuIDI1NSp0aGlzLnI8PDE2XjI1NSp0aGlzLmc8PDheMjU1KnRoaXMuYjw8MH0sZ2V0SGV4U3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuKFwiMDAwMDAwXCIrdGhpcy5nZXRIZXgoKS50b1N0cmluZygxNikpLnNsaWNlKC02KX0sZ2V0SFNMOmZ1bmN0aW9uKGEpe2E9YXx8e2g6MCxzOjAsbDowfTt2YXIgYj10aGlzLnIsYz10aGlzLmcsZD10aGlzLmIsZT1NYXRoLm1heChiLGMsZCksZj1NYXRoLm1pbihiLGMsZCksZyxoPShmK2UpLzI7aWYoZj09PWUpZj1nPTA7ZWxzZXt2YXIgaz1lLWYsZj0uNT49aD9rLyhlK2YpOmsvKDItZS1mKTtzd2l0Y2goZSl7Y2FzZSBiOmc9KGMtZCkvaysoYzxkPzY6MCk7YnJlYWs7Y2FzZSBjOmc9KGQtYikvaysyO2JyZWFrO2Nhc2UgZDpnPShiLWMpL2srNH1nLz02fWEuaD1nO2Eucz1mO2EubD1oO3JldHVybiBhfSxnZXRTdHlsZTpmdW5jdGlvbigpe3JldHVyblwicmdiKFwiK1xuICAgICgyNTUqdGhpcy5yfDApK1wiLFwiKygyNTUqdGhpcy5nfDApK1wiLFwiKygyNTUqdGhpcy5ifDApK1wiKVwifSxvZmZzZXRIU0w6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ2V0SFNMKCk7ZC5oKz1hO2Qucys9YjtkLmwrPWM7dGhpcy5zZXRIU0woZC5oLGQucyxkLmwpO3JldHVybiB0aGlzfSxhZGQ6ZnVuY3Rpb24oYSl7dGhpcy5yKz1hLnI7dGhpcy5nKz1hLmc7dGhpcy5iKz1hLmI7cmV0dXJuIHRoaXN9LGFkZENvbG9yczpmdW5jdGlvbihhLGIpe3RoaXMucj1hLnIrYi5yO3RoaXMuZz1hLmcrYi5nO3RoaXMuYj1hLmIrYi5iO3JldHVybiB0aGlzfSxhZGRTY2FsYXI6ZnVuY3Rpb24oYSl7dGhpcy5yKz1hO3RoaXMuZys9YTt0aGlzLmIrPWE7cmV0dXJuIHRoaXN9LG11bHRpcGx5OmZ1bmN0aW9uKGEpe3RoaXMucio9YS5yO3RoaXMuZyo9YS5nO3RoaXMuYio9YS5iO3JldHVybiB0aGlzfSxtdWx0aXBseVNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLnIqPWE7dGhpcy5nKj1hO3RoaXMuYio9YTtcbiAgICByZXR1cm4gdGhpc30sbGVycDpmdW5jdGlvbihhLGIpe3RoaXMucis9KGEuci10aGlzLnIpKmI7dGhpcy5nKz0oYS5nLXRoaXMuZykqYjt0aGlzLmIrPShhLmItdGhpcy5iKSpiO3JldHVybiB0aGlzfSxlcXVhbHM6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucj09PXRoaXMuciYmYS5nPT09dGhpcy5nJiZhLmI9PT10aGlzLmJ9LGZyb21BcnJheTpmdW5jdGlvbihhKXt0aGlzLnI9YVswXTt0aGlzLmc9YVsxXTt0aGlzLmI9YVsyXTtyZXR1cm4gdGhpc30sdG9BcnJheTpmdW5jdGlvbihhLGIpe3ZvaWQgMD09PWEmJihhPVtdKTt2b2lkIDA9PT1iJiYoYj0wKTthW2JdPXRoaXMucjthW2IrMV09dGhpcy5nO2FbYisyXT10aGlzLmI7cmV0dXJuIGF9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBUSFJFRS5Db2xvcikuc2V0UkdCKHRoaXMucix0aGlzLmcsdGhpcy5iKX19O1xuVEhSRUUuQ29sb3JLZXl3b3Jkcz17YWxpY2VibHVlOjE1NzkyMzgzLGFudGlxdWV3aGl0ZToxNjQ0NDM3NSxhcXVhOjY1NTM1LGFxdWFtYXJpbmU6ODM4ODU2NCxhenVyZToxNTc5NDE3NSxiZWlnZToxNjExOTI2MCxiaXNxdWU6MTY3NzAyNDQsYmxhY2s6MCxibGFuY2hlZGFsbW9uZDoxNjc3MjA0NSxibHVlOjI1NSxibHVldmlvbGV0OjkwNTUyMDIsYnJvd246MTA4MjQyMzQsYnVybHl3b29kOjE0NTk2MjMxLGNhZGV0Ymx1ZTo2MjY2NTI4LGNoYXJ0cmV1c2U6ODM4ODM1MixjaG9jb2xhdGU6MTM3ODk0NzAsY29yYWw6MTY3NDQyNzIsY29ybmZsb3dlcmJsdWU6NjU5MTk4MSxjb3Juc2lsazoxNjc3NTM4OCxjcmltc29uOjE0NDIzMTAwLGN5YW46NjU1MzUsZGFya2JsdWU6MTM5LGRhcmtjeWFuOjM1NzIzLGRhcmtnb2xkZW5yb2Q6MTIwOTI5MzksZGFya2dyYXk6MTExMTkwMTcsZGFya2dyZWVuOjI1NjAwLGRhcmtncmV5OjExMTE5MDE3LGRhcmtraGFraToxMjQzMzI1OSxkYXJrbWFnZW50YTo5MTA5NjQzLFxuICAgIGRhcmtvbGl2ZWdyZWVuOjU1OTc5OTksZGFya29yYW5nZToxNjc0NzUyMCxkYXJrb3JjaGlkOjEwMDQwMDEyLGRhcmtyZWQ6OTEwOTUwNCxkYXJrc2FsbW9uOjE1MzA4NDEwLGRhcmtzZWFncmVlbjo5NDE5OTE5LGRhcmtzbGF0ZWJsdWU6NDczNDM0NyxkYXJrc2xhdGVncmF5OjMxMDA0OTUsZGFya3NsYXRlZ3JleTozMTAwNDk1LGRhcmt0dXJxdW9pc2U6NTI5NDUsZGFya3Zpb2xldDo5Njk5NTM5LGRlZXBwaW5rOjE2NzE2OTQ3LGRlZXBza3libHVlOjQ5MTUxLGRpbWdyYXk6NjkwODI2NSxkaW1ncmV5OjY5MDgyNjUsZG9kZ2VyYmx1ZToyMDAzMTk5LGZpcmVicmljazoxMTY3NDE0NixmbG9yYWx3aGl0ZToxNjc3NTkyMCxmb3Jlc3RncmVlbjoyMjYzODQyLGZ1Y2hzaWE6MTY3MTE5MzUsZ2FpbnNib3JvOjE0NDc0NDYwLGdob3N0d2hpdGU6MTYzMTY2NzEsZ29sZDoxNjc2NjcyMCxnb2xkZW5yb2Q6MTQzMjkxMjAsZ3JheTo4NDIxNTA0LGdyZWVuOjMyNzY4LGdyZWVueWVsbG93OjExNDAzMDU1LFxuICAgIGdyZXk6ODQyMTUwNCxob25leWRldzoxNTc5NDE2MCxob3RwaW5rOjE2NzM4NzQwLGluZGlhbnJlZDoxMzQ1ODUyNCxpbmRpZ286NDkxNTMzMCxpdm9yeToxNjc3NzIwMCxraGFraToxNTc4NzY2MCxsYXZlbmRlcjoxNTEzMjQxMCxsYXZlbmRlcmJsdXNoOjE2NzczMzY1LGxhd25ncmVlbjo4MTkwOTc2LGxlbW9uY2hpZmZvbjoxNjc3NTg4NSxsaWdodGJsdWU6MTEzOTMyNTQsbGlnaHRjb3JhbDoxNTc2MTUzNixsaWdodGN5YW46MTQ3NDU1OTksbGlnaHRnb2xkZW5yb2R5ZWxsb3c6MTY0NDgyMTAsbGlnaHRncmF5OjEzODgyMzIzLGxpZ2h0Z3JlZW46OTQ5ODI1NixsaWdodGdyZXk6MTM4ODIzMjMsbGlnaHRwaW5rOjE2NzU4NDY1LGxpZ2h0c2FsbW9uOjE2NzUyNzYyLGxpZ2h0c2VhZ3JlZW46MjE0Mjg5MCxsaWdodHNreWJsdWU6ODkwMDM0NixsaWdodHNsYXRlZ3JheTo3ODMzNzUzLGxpZ2h0c2xhdGVncmV5Ojc4MzM3NTMsbGlnaHRzdGVlbGJsdWU6MTE1ODQ3MzQsbGlnaHR5ZWxsb3c6MTY3NzcxODQsXG4gICAgbGltZTo2NTI4MCxsaW1lZ3JlZW46MzMyOTMzMCxsaW5lbjoxNjQ0NTY3MCxtYWdlbnRhOjE2NzExOTM1LG1hcm9vbjo4Mzg4NjA4LG1lZGl1bWFxdWFtYXJpbmU6NjczNzMyMixtZWRpdW1ibHVlOjIwNSxtZWRpdW1vcmNoaWQ6MTIyMTE2NjcsbWVkaXVtcHVycGxlOjk2NjI2ODMsbWVkaXVtc2VhZ3JlZW46Mzk3ODA5NyxtZWRpdW1zbGF0ZWJsdWU6ODA4Nzc5MCxtZWRpdW1zcHJpbmdncmVlbjo2NDE1NCxtZWRpdW10dXJxdW9pc2U6NDc3MjMwMCxtZWRpdW12aW9sZXRyZWQ6MTMwNDcxNzMsbWlkbmlnaHRibHVlOjE2NDQ5MTIsbWludGNyZWFtOjE2MTIxODUwLG1pc3R5cm9zZToxNjc3MDI3Myxtb2NjYXNpbjoxNjc3MDIyOSxuYXZham93aGl0ZToxNjc2ODY4NSxuYXZ5OjEyOCxvbGRsYWNlOjE2NjQzNTU4LG9saXZlOjg0MjEzNzYsb2xpdmVkcmFiOjcwNDg3Mzksb3JhbmdlOjE2NzUzOTIwLG9yYW5nZXJlZDoxNjcyOTM0NCxvcmNoaWQ6MTQzMTU3MzQscGFsZWdvbGRlbnJvZDoxNTY1NzEzMCxcbiAgICBwYWxlZ3JlZW46MTAwMjU4ODAscGFsZXR1cnF1b2lzZToxMTUyOTk2NixwYWxldmlvbGV0cmVkOjE0MzgxMjAzLHBhcGF5YXdoaXA6MTY3NzMwNzcscGVhY2hwdWZmOjE2NzY3NjczLHBlcnU6MTM0Njg5OTEscGluazoxNjc2MTAzNSxwbHVtOjE0NTI0NjM3LHBvd2RlcmJsdWU6MTE1OTE5MTAscHVycGxlOjgzODg3MzYscmVkOjE2NzExNjgwLHJvc3licm93bjoxMjM1NzUxOSxyb3lhbGJsdWU6NDI4Njk0NSxzYWRkbGVicm93bjo5MTI3MTg3LHNhbG1vbjoxNjQxNjg4MixzYW5keWJyb3duOjE2MDMyODY0LHNlYWdyZWVuOjMwNTAzMjcsc2Vhc2hlbGw6MTY3NzQ2Mzgsc2llbm5hOjEwNTA2Nzk3LHNpbHZlcjoxMjYzMjI1Nixza3libHVlOjg5MDAzMzEsc2xhdGVibHVlOjY5NzAwNjEsc2xhdGVncmF5OjczNzI5NDQsc2xhdGVncmV5OjczNzI5NDQsc25vdzoxNjc3NTkzMCxzcHJpbmdncmVlbjo2NTQwNyxzdGVlbGJsdWU6NDYyMDk4MCx0YW46MTM4MDg3ODAsdGVhbDozMjg5Nix0aGlzdGxlOjE0MjA0ODg4LFxuICAgIHRvbWF0bzoxNjczNzA5NSx0dXJxdW9pc2U6NDI1MTg1Nix2aW9sZXQ6MTU2MzEwODYsd2hlYXQ6MTYxMTMzMzEsd2hpdGU6MTY3NzcyMTUsd2hpdGVzbW9rZToxNjExOTI4NSx5ZWxsb3c6MTY3NzY5NjAseWVsbG93Z3JlZW46MTAxNDUwNzR9O1RIUkVFLlF1YXRlcm5pb249ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5feD1hfHwwO3RoaXMuX3k9Ynx8MDt0aGlzLl96PWN8fDA7dGhpcy5fdz12b2lkIDAhPT1kP2Q6MX07XG5USFJFRS5RdWF0ZXJuaW9uLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuUXVhdGVybmlvbixfeDowLF95OjAsX3o6MCxfdzowLGdldCB4KCl7cmV0dXJuIHRoaXMuX3h9LHNldCB4KGEpe3RoaXMuX3g9YTt0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKX0sZ2V0IHkoKXtyZXR1cm4gdGhpcy5feX0sc2V0IHkoYSl7dGhpcy5feT1hO3RoaXMub25DaGFuZ2VDYWxsYmFjaygpfSxnZXQgeigpe3JldHVybiB0aGlzLl96fSxzZXQgeihhKXt0aGlzLl96PWE7dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCl9LGdldCB3KCl7cmV0dXJuIHRoaXMuX3d9LHNldCB3KGEpe3RoaXMuX3c9YTt0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKX0sc2V0OmZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuX3g9YTt0aGlzLl95PWI7dGhpcy5fej1jO3RoaXMuX3c9ZDt0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtyZXR1cm4gdGhpc30sY29weTpmdW5jdGlvbihhKXt0aGlzLl94PWEueDt0aGlzLl95PWEueTt0aGlzLl96PWEuejtcbiAgICB0aGlzLl93PWEudzt0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtyZXR1cm4gdGhpc30sc2V0RnJvbUV1bGVyOmZ1bmN0aW9uKGEsYil7aWYoITE9PT1hIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIpdGhyb3cgRXJyb3IoXCJUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLlwiKTt2YXIgYz1NYXRoLmNvcyhhLl94LzIpLGQ9TWF0aC5jb3MoYS5feS8yKSxlPU1hdGguY29zKGEuX3ovMiksZj1NYXRoLnNpbihhLl94LzIpLGc9TWF0aC5zaW4oYS5feS8yKSxoPU1hdGguc2luKGEuX3ovMik7XCJYWVpcIj09PWEub3JkZXI/KHRoaXMuX3g9ZipkKmUrYypnKmgsdGhpcy5feT1jKmcqZS1mKmQqaCx0aGlzLl96PWMqZCpoK2YqZyplLHRoaXMuX3c9YypkKmUtZipnKmgpOlwiWVhaXCI9PT1hLm9yZGVyPyh0aGlzLl94PWYqZCplK2MqZypoLHRoaXMuX3k9YypnKmUtZipkKmgsdGhpcy5fej1cbiAgICBjKmQqaC1mKmcqZSx0aGlzLl93PWMqZCplK2YqZypoKTpcIlpYWVwiPT09YS5vcmRlcj8odGhpcy5feD1mKmQqZS1jKmcqaCx0aGlzLl95PWMqZyplK2YqZCpoLHRoaXMuX3o9YypkKmgrZipnKmUsdGhpcy5fdz1jKmQqZS1mKmcqaCk6XCJaWVhcIj09PWEub3JkZXI/KHRoaXMuX3g9ZipkKmUtYypnKmgsdGhpcy5feT1jKmcqZStmKmQqaCx0aGlzLl96PWMqZCpoLWYqZyplLHRoaXMuX3c9YypkKmUrZipnKmgpOlwiWVpYXCI9PT1hLm9yZGVyPyh0aGlzLl94PWYqZCplK2MqZypoLHRoaXMuX3k9YypnKmUrZipkKmgsdGhpcy5fej1jKmQqaC1mKmcqZSx0aGlzLl93PWMqZCplLWYqZypoKTpcIlhaWVwiPT09YS5vcmRlciYmKHRoaXMuX3g9ZipkKmUtYypnKmgsdGhpcy5feT1jKmcqZS1mKmQqaCx0aGlzLl96PWMqZCpoK2YqZyplLHRoaXMuX3c9YypkKmUrZipnKmgpO2lmKCExIT09Yil0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtyZXR1cm4gdGhpc30sc2V0RnJvbUF4aXNBbmdsZTpmdW5jdGlvbihhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiKXt2YXIgYz1iLzIsZD1NYXRoLnNpbihjKTt0aGlzLl94PWEueCpkO3RoaXMuX3k9YS55KmQ7dGhpcy5fej1hLnoqZDt0aGlzLl93PU1hdGguY29zKGMpO3RoaXMub25DaGFuZ2VDYWxsYmFjaygpO3JldHVybiB0aGlzfSxzZXRGcm9tUm90YXRpb25NYXRyaXg6ZnVuY3Rpb24oYSl7dmFyIGI9YS5lbGVtZW50cyxjPWJbMF07YT1iWzRdO3ZhciBkPWJbOF0sZT1iWzFdLGY9Yls1XSxnPWJbOV0saD1iWzJdLGs9Yls2XSxiPWJbMTBdLGw9YytmK2I7MDxsPyhjPS41L01hdGguc3FydChsKzEpLHRoaXMuX3c9LjI1L2MsdGhpcy5feD0oay1nKSpjLHRoaXMuX3k9KGQtaCkqYyx0aGlzLl96PShlLWEpKmMpOmM+ZiYmYz5iPyhjPTIqTWF0aC5zcXJ0KDErYy1mLWIpLHRoaXMuX3c9KGstZykvYyx0aGlzLl94PS4yNSpjLHRoaXMuX3k9KGErZSkvYyx0aGlzLl96PShkK2gpL2MpOmY+Yj8oYz0yKk1hdGguc3FydCgxK2YtYy1iKSx0aGlzLl93PShkLWgpL2MsdGhpcy5feD0oYStlKS9jLHRoaXMuX3k9XG4gICAgLjI1KmMsdGhpcy5fej0oZytrKS9jKTooYz0yKk1hdGguc3FydCgxK2ItYy1mKSx0aGlzLl93PShlLWEpL2MsdGhpcy5feD0oZCtoKS9jLHRoaXMuX3k9KGcraykvYyx0aGlzLl96PS4yNSpjKTt0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtyZXR1cm4gdGhpc30sc2V0RnJvbVVuaXRWZWN0b3JzOmZ1bmN0aW9uKCl7dmFyIGEsYjtyZXR1cm4gZnVuY3Rpb24oYyxkKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuVmVjdG9yMyk7Yj1jLmRvdChkKSsxOzFFLTY+Yj8oYj0wLE1hdGguYWJzKGMueCk+TWF0aC5hYnMoYy56KT9hLnNldCgtYy55LGMueCwwKTphLnNldCgwLC1jLnosYy55KSk6YS5jcm9zc1ZlY3RvcnMoYyxkKTt0aGlzLl94PWEueDt0aGlzLl95PWEueTt0aGlzLl96PWEuejt0aGlzLl93PWI7dGhpcy5ub3JtYWxpemUoKTtyZXR1cm4gdGhpc319KCksaW52ZXJzZTpmdW5jdGlvbigpe3RoaXMuY29uanVnYXRlKCkubm9ybWFsaXplKCk7cmV0dXJuIHRoaXN9LGNvbmp1Z2F0ZTpmdW5jdGlvbigpe3RoaXMuX3gqPVxuICAgIC0xO3RoaXMuX3kqPS0xO3RoaXMuX3oqPS0xO3RoaXMub25DaGFuZ2VDYWxsYmFjaygpO3JldHVybiB0aGlzfSxkb3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX3gqYS5feCt0aGlzLl95KmEuX3krdGhpcy5feiphLl96K3RoaXMuX3cqYS5fd30sbGVuZ3RoU3E6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5feCp0aGlzLl94K3RoaXMuX3kqdGhpcy5feSt0aGlzLl96KnRoaXMuX3ordGhpcy5fdyp0aGlzLl93fSxsZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3gqdGhpcy5feCt0aGlzLl95KnRoaXMuX3krdGhpcy5feip0aGlzLl96K3RoaXMuX3cqdGhpcy5fdyl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMubGVuZ3RoKCk7MD09PWE/KHRoaXMuX3o9dGhpcy5feT10aGlzLl94PTAsdGhpcy5fdz0xKTooYT0xL2EsdGhpcy5feCo9YSx0aGlzLl95Kj1hLHRoaXMuX3oqPWEsdGhpcy5fdyo9YSk7dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7cmV0dXJuIHRoaXN9LFxuICAgIG11bHRpcGx5OmZ1bmN0aW9uKGEsYil7cmV0dXJuIHZvaWQgMCE9PWI/KFRIUkVFLndhcm4oXCJUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC5cIiksdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKGEsYikpOnRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLGEpfSxtdWx0aXBseVF1YXRlcm5pb25zOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5feCxkPWEuX3ksZT1hLl96LGY9YS5fdyxnPWIuX3gsaD1iLl95LGs9Yi5feixsPWIuX3c7dGhpcy5feD1jKmwrZipnK2Qqay1lKmg7dGhpcy5feT1kKmwrZipoK2UqZy1jKms7dGhpcy5fej1lKmwrZiprK2MqaC1kKmc7dGhpcy5fdz1mKmwtYypnLWQqaC1lKms7dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7cmV0dXJuIHRoaXN9LG11bHRpcGx5VmVjdG9yMzpmdW5jdGlvbihhKXtUSFJFRS53YXJuKFwiVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuXCIpO1xuICAgICAgICByZXR1cm4gYS5hcHBseVF1YXRlcm5pb24odGhpcyl9LHNsZXJwOmZ1bmN0aW9uKGEsYil7aWYoMD09PWIpcmV0dXJuIHRoaXM7aWYoMT09PWIpcmV0dXJuIHRoaXMuY29weShhKTt2YXIgYz10aGlzLl94LGQ9dGhpcy5feSxlPXRoaXMuX3osZj10aGlzLl93LGc9ZiphLl93K2MqYS5feCtkKmEuX3krZSphLl96OzA+Zz8odGhpcy5fdz0tYS5fdyx0aGlzLl94PS1hLl94LHRoaXMuX3k9LWEuX3ksdGhpcy5fej0tYS5feixnPS1nKTp0aGlzLmNvcHkoYSk7aWYoMTw9ZylyZXR1cm4gdGhpcy5fdz1mLHRoaXMuX3g9Yyx0aGlzLl95PWQsdGhpcy5fej1lLHRoaXM7dmFyIGg9TWF0aC5hY29zKGcpLGs9TWF0aC5zcXJ0KDEtZypnKTtpZiguMDAxPk1hdGguYWJzKGspKXJldHVybiB0aGlzLl93PS41KihmK3RoaXMuX3cpLHRoaXMuX3g9LjUqKGMrdGhpcy5feCksdGhpcy5feT0uNSooZCt0aGlzLl95KSx0aGlzLl96PS41KihlK3RoaXMuX3opLHRoaXM7Zz1NYXRoLnNpbigoMS1iKSpoKS9rO2g9XG4gICAgICAgIE1hdGguc2luKGIqaCkvazt0aGlzLl93PWYqZyt0aGlzLl93Kmg7dGhpcy5feD1jKmcrdGhpcy5feCpoO3RoaXMuX3k9ZCpnK3RoaXMuX3kqaDt0aGlzLl96PWUqZyt0aGlzLl96Kmg7dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5feD09PXRoaXMuX3gmJmEuX3k9PT10aGlzLl95JiZhLl96PT09dGhpcy5feiYmYS5fdz09PXRoaXMuX3d9LGZyb21BcnJheTpmdW5jdGlvbihhLGIpe3ZvaWQgMD09PWImJihiPTApO3RoaXMuX3g9YVtiXTt0aGlzLl95PWFbYisxXTt0aGlzLl96PWFbYisyXTt0aGlzLl93PWFbYiszXTt0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtyZXR1cm4gdGhpc30sdG9BcnJheTpmdW5jdGlvbihhLGIpe3ZvaWQgMD09PWEmJihhPVtdKTt2b2lkIDA9PT1iJiYoYj0wKTthW2JdPXRoaXMuX3g7YVtiKzFdPXRoaXMuX3k7YVtiKzJdPXRoaXMuX3o7YVtiKzNdPXRoaXMuX3c7cmV0dXJuIGF9LG9uQ2hhbmdlOmZ1bmN0aW9uKGEpe3RoaXMub25DaGFuZ2VDYWxsYmFjaz1cbiAgICAgICAgYTtyZXR1cm4gdGhpc30sb25DaGFuZ2VDYWxsYmFjazpmdW5jdGlvbigpe30sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24odGhpcy5feCx0aGlzLl95LHRoaXMuX3osdGhpcy5fdyl9fTtUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBjLmNvcHkoYSkuc2xlcnAoYixkKX07VEhSRUUuVmVjdG9yMj1mdW5jdGlvbihhLGIpe3RoaXMueD1hfHwwO3RoaXMueT1ifHwwfTtcblRIUkVFLlZlY3RvcjIucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5WZWN0b3IyLHNldDpmdW5jdGlvbihhLGIpe3RoaXMueD1hO3RoaXMueT1iO3JldHVybiB0aGlzfSxzZXRYOmZ1bmN0aW9uKGEpe3RoaXMueD1hO3JldHVybiB0aGlzfSxzZXRZOmZ1bmN0aW9uKGEpe3RoaXMueT1hO3JldHVybiB0aGlzfSxzZXRDb21wb25lbnQ6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYSl7Y2FzZSAwOnRoaXMueD1iO2JyZWFrO2Nhc2UgMTp0aGlzLnk9YjticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIithKTt9fSxnZXRDb21wb25lbnQ6ZnVuY3Rpb24oYSl7c3dpdGNoKGEpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiK2EpO319LGNvcHk6ZnVuY3Rpb24oYSl7dGhpcy54PWEueDt0aGlzLnk9YS55O3JldHVybiB0aGlzfSxhZGQ6ZnVuY3Rpb24oYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiKXtpZih2b2lkIDAhPT1iKXJldHVybiBUSFJFRS53YXJuKFwiVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLmFkZFZlY3RvcnMoYSxiKTt0aGlzLngrPWEueDt0aGlzLnkrPWEueTtyZXR1cm4gdGhpc30sYWRkU2NhbGFyOmZ1bmN0aW9uKGEpe3RoaXMueCs9YTt0aGlzLnkrPWE7cmV0dXJuIHRoaXN9LGFkZFZlY3RvcnM6ZnVuY3Rpb24oYSxiKXt0aGlzLng9YS54K2IueDt0aGlzLnk9YS55K2IueTtyZXR1cm4gdGhpc30sc3ViOmZ1bmN0aW9uKGEsYil7aWYodm9pZCAwIT09YilyZXR1cm4gVEhSRUUud2FybihcIlRIUkVFLlZlY3RvcjI6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC5cIiksdGhpcy5zdWJWZWN0b3JzKGEsYik7dGhpcy54LT1hLng7dGhpcy55LT1hLnk7cmV0dXJuIHRoaXN9LFxuICAgIHN1YlNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLngtPWE7dGhpcy55LT1hO3JldHVybiB0aGlzfSxzdWJWZWN0b3JzOmZ1bmN0aW9uKGEsYil7dGhpcy54PWEueC1iLng7dGhpcy55PWEueS1iLnk7cmV0dXJuIHRoaXN9LG11bHRpcGx5OmZ1bmN0aW9uKGEpe3RoaXMueCo9YS54O3RoaXMueSo9YS55O3JldHVybiB0aGlzfSxtdWx0aXBseVNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLngqPWE7dGhpcy55Kj1hO3JldHVybiB0aGlzfSxkaXZpZGU6ZnVuY3Rpb24oYSl7dGhpcy54Lz1hLng7dGhpcy55Lz1hLnk7cmV0dXJuIHRoaXN9LGRpdmlkZVNjYWxhcjpmdW5jdGlvbihhKXswIT09YT8oYT0xL2EsdGhpcy54Kj1hLHRoaXMueSo9YSk6dGhpcy55PXRoaXMueD0wO3JldHVybiB0aGlzfSxtaW46ZnVuY3Rpb24oYSl7dGhpcy54PmEueCYmKHRoaXMueD1hLngpO3RoaXMueT5hLnkmJih0aGlzLnk9YS55KTtyZXR1cm4gdGhpc30sbWF4OmZ1bmN0aW9uKGEpe3RoaXMueDxhLngmJih0aGlzLng9YS54KTtcbiAgICAgICAgdGhpcy55PGEueSYmKHRoaXMueT1hLnkpO3JldHVybiB0aGlzfSxjbGFtcDpmdW5jdGlvbihhLGIpe3RoaXMueDxhLng/dGhpcy54PWEueDp0aGlzLng+Yi54JiYodGhpcy54PWIueCk7dGhpcy55PGEueT90aGlzLnk9YS55OnRoaXMueT5iLnkmJih0aGlzLnk9Yi55KTtyZXR1cm4gdGhpc30sY2xhbXBTY2FsYXI6ZnVuY3Rpb24oKXt2YXIgYSxiO3JldHVybiBmdW5jdGlvbihjLGQpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5WZWN0b3IyLGI9bmV3IFRIUkVFLlZlY3RvcjIpO2Euc2V0KGMsYyk7Yi5zZXQoZCxkKTtyZXR1cm4gdGhpcy5jbGFtcChhLGIpfX0oKSxmbG9vcjpmdW5jdGlvbigpe3RoaXMueD1NYXRoLmZsb29yKHRoaXMueCk7dGhpcy55PU1hdGguZmxvb3IodGhpcy55KTtyZXR1cm4gdGhpc30sY2VpbDpmdW5jdGlvbigpe3RoaXMueD1NYXRoLmNlaWwodGhpcy54KTt0aGlzLnk9TWF0aC5jZWlsKHRoaXMueSk7cmV0dXJuIHRoaXN9LHJvdW5kOmZ1bmN0aW9uKCl7dGhpcy54PVxuICAgICAgICBNYXRoLnJvdW5kKHRoaXMueCk7dGhpcy55PU1hdGgucm91bmQodGhpcy55KTtyZXR1cm4gdGhpc30scm91bmRUb1plcm86ZnVuY3Rpb24oKXt0aGlzLng9MD50aGlzLng/TWF0aC5jZWlsKHRoaXMueCk6TWF0aC5mbG9vcih0aGlzLngpO3RoaXMueT0wPnRoaXMueT9NYXRoLmNlaWwodGhpcy55KTpNYXRoLmZsb29yKHRoaXMueSk7cmV0dXJuIHRoaXN9LG5lZ2F0ZTpmdW5jdGlvbigpe3RoaXMueD0tdGhpcy54O3RoaXMueT0tdGhpcy55O3JldHVybiB0aGlzfSxkb3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMueCphLngrdGhpcy55KmEueX0sbGVuZ3RoU3E6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55fSxsZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpKX0sZGlzdGFuY2VUbzpmdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoYSkpfSxcbiAgICBkaXN0YW5jZVRvU3F1YXJlZDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLngtYS54O2E9dGhpcy55LWEueTtyZXR1cm4gYipiK2EqYX0sc2V0TGVuZ3RoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGVuZ3RoKCk7MCE9PWImJmEhPT1iJiZ0aGlzLm11bHRpcGx5U2NhbGFyKGEvYik7cmV0dXJuIHRoaXN9LGxlcnA6ZnVuY3Rpb24oYSxiKXt0aGlzLngrPShhLngtdGhpcy54KSpiO3RoaXMueSs9KGEueS10aGlzLnkpKmI7cmV0dXJuIHRoaXN9LGxlcnBWZWN0b3JzOmZ1bmN0aW9uKGEsYixjKXt0aGlzLnN1YlZlY3RvcnMoYixhKS5tdWx0aXBseVNjYWxhcihjKS5hZGQoYSk7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS54PT09dGhpcy54JiZhLnk9PT10aGlzLnl9LGZyb21BcnJheTpmdW5jdGlvbihhLGIpe3ZvaWQgMD09PWImJihiPTApO3RoaXMueD1hW2JdO3RoaXMueT1hW2IrMV07cmV0dXJuIHRoaXN9LHRvQXJyYXk6ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1cbiAgICBhJiYoYT1bXSk7dm9pZCAwPT09YiYmKGI9MCk7YVtiXT10aGlzLng7YVtiKzFdPXRoaXMueTtyZXR1cm4gYX0sZnJvbUF0dHJpYnV0ZTpmdW5jdGlvbihhLGIsYyl7dm9pZCAwPT09YyYmKGM9MCk7Yj1iKmEuaXRlbVNpemUrYzt0aGlzLng9YS5hcnJheVtiXTt0aGlzLnk9YS5hcnJheVtiKzFdO3JldHVybiB0aGlzfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLngsdGhpcy55KX19O1RIUkVFLlZlY3RvcjM9ZnVuY3Rpb24oYSxiLGMpe3RoaXMueD1hfHwwO3RoaXMueT1ifHwwO3RoaXMuej1jfHwwfTtcblRIUkVFLlZlY3RvcjMucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5WZWN0b3IzLHNldDpmdW5jdGlvbihhLGIsYyl7dGhpcy54PWE7dGhpcy55PWI7dGhpcy56PWM7cmV0dXJuIHRoaXN9LHNldFg6ZnVuY3Rpb24oYSl7dGhpcy54PWE7cmV0dXJuIHRoaXN9LHNldFk6ZnVuY3Rpb24oYSl7dGhpcy55PWE7cmV0dXJuIHRoaXN9LHNldFo6ZnVuY3Rpb24oYSl7dGhpcy56PWE7cmV0dXJuIHRoaXN9LHNldENvbXBvbmVudDpmdW5jdGlvbihhLGIpe3N3aXRjaChhKXtjYXNlIDA6dGhpcy54PWI7YnJlYWs7Y2FzZSAxOnRoaXMueT1iO2JyZWFrO2Nhc2UgMjp0aGlzLno9YjticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIithKTt9fSxnZXRDb21wb25lbnQ6ZnVuY3Rpb24oYSl7c3dpdGNoKGEpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2Nhc2UgMjpyZXR1cm4gdGhpcy56O2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiK1xuICAgIGEpO319LGNvcHk6ZnVuY3Rpb24oYSl7dGhpcy54PWEueDt0aGlzLnk9YS55O3RoaXMuej1hLno7cmV0dXJuIHRoaXN9LGFkZDpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PWIpcmV0dXJuIFRIUkVFLndhcm4oXCJUSFJFRS5WZWN0b3IzOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLHRoaXMuYWRkVmVjdG9ycyhhLGIpO3RoaXMueCs9YS54O3RoaXMueSs9YS55O3RoaXMueis9YS56O3JldHVybiB0aGlzfSxhZGRTY2FsYXI6ZnVuY3Rpb24oYSl7dGhpcy54Kz1hO3RoaXMueSs9YTt0aGlzLnorPWE7cmV0dXJuIHRoaXN9LGFkZFZlY3RvcnM6ZnVuY3Rpb24oYSxiKXt0aGlzLng9YS54K2IueDt0aGlzLnk9YS55K2IueTt0aGlzLno9YS56K2IuejtyZXR1cm4gdGhpc30sc3ViOmZ1bmN0aW9uKGEsYil7aWYodm9pZCAwIT09YilyZXR1cm4gVEhSRUUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC5cIiksXG4gICAgdGhpcy5zdWJWZWN0b3JzKGEsYik7dGhpcy54LT1hLng7dGhpcy55LT1hLnk7dGhpcy56LT1hLno7cmV0dXJuIHRoaXN9LHN1YlNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLngtPWE7dGhpcy55LT1hO3RoaXMuei09YTtyZXR1cm4gdGhpc30sc3ViVmVjdG9yczpmdW5jdGlvbihhLGIpe3RoaXMueD1hLngtYi54O3RoaXMueT1hLnktYi55O3RoaXMuej1hLnotYi56O3JldHVybiB0aGlzfSxtdWx0aXBseTpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PWIpcmV0dXJuIFRIUkVFLndhcm4oXCJUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLm11bHRpcGx5VmVjdG9ycyhhLGIpO3RoaXMueCo9YS54O3RoaXMueSo9YS55O3RoaXMueio9YS56O3JldHVybiB0aGlzfSxtdWx0aXBseVNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLngqPWE7dGhpcy55Kj1hO3RoaXMueio9XG4gICAgYTtyZXR1cm4gdGhpc30sbXVsdGlwbHlWZWN0b3JzOmZ1bmN0aW9uKGEsYil7dGhpcy54PWEueCpiLng7dGhpcy55PWEueSpiLnk7dGhpcy56PWEueipiLno7cmV0dXJuIHRoaXN9LGFwcGx5RXVsZXI6ZnVuY3Rpb24oKXt2YXIgYTtyZXR1cm4gZnVuY3Rpb24oYil7ITE9PT1iIGluc3RhbmNlb2YgVEhSRUUuRXVsZXImJlRIUkVFLmVycm9yKFwiVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuXCIpO3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5RdWF0ZXJuaW9uKTt0aGlzLmFwcGx5UXVhdGVybmlvbihhLnNldEZyb21FdWxlcihiKSk7cmV0dXJuIHRoaXN9fSgpLGFwcGx5QXhpc0FuZ2xlOmZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7dm9pZCAwPT09YSYmKGE9bmV3IFRIUkVFLlF1YXRlcm5pb24pO3RoaXMuYXBwbHlRdWF0ZXJuaW9uKGEuc2V0RnJvbUF4aXNBbmdsZShiLFxuICAgIGMpKTtyZXR1cm4gdGhpc319KCksYXBwbHlNYXRyaXgzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMueCxjPXRoaXMueSxkPXRoaXMuejthPWEuZWxlbWVudHM7dGhpcy54PWFbMF0qYithWzNdKmMrYVs2XSpkO3RoaXMueT1hWzFdKmIrYVs0XSpjK2FbN10qZDt0aGlzLno9YVsyXSpiK2FbNV0qYythWzhdKmQ7cmV0dXJuIHRoaXN9LGFwcGx5TWF0cml4NDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLngsYz10aGlzLnksZD10aGlzLno7YT1hLmVsZW1lbnRzO3RoaXMueD1hWzBdKmIrYVs0XSpjK2FbOF0qZCthWzEyXTt0aGlzLnk9YVsxXSpiK2FbNV0qYythWzldKmQrYVsxM107dGhpcy56PWFbMl0qYithWzZdKmMrYVsxMF0qZCthWzE0XTtyZXR1cm4gdGhpc30sYXBwbHlQcm9qZWN0aW9uOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMueCxjPXRoaXMueSxkPXRoaXMuejthPWEuZWxlbWVudHM7dmFyIGU9MS8oYVszXSpiK2FbN10qYythWzExXSpkK2FbMTVdKTt0aGlzLng9KGFbMF0qYithWzRdKlxuICAgIGMrYVs4XSpkK2FbMTJdKSplO3RoaXMueT0oYVsxXSpiK2FbNV0qYythWzldKmQrYVsxM10pKmU7dGhpcy56PShhWzJdKmIrYVs2XSpjK2FbMTBdKmQrYVsxNF0pKmU7cmV0dXJuIHRoaXN9LGFwcGx5UXVhdGVybmlvbjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLngsYz10aGlzLnksZD10aGlzLnosZT1hLngsZj1hLnksZz1hLno7YT1hLnc7dmFyIGg9YSpiK2YqZC1nKmMsaz1hKmMrZypiLWUqZCxsPWEqZCtlKmMtZipiLGI9LWUqYi1mKmMtZypkO3RoaXMueD1oKmErYiotZStrKi1nLWwqLWY7dGhpcy55PWsqYStiKi1mK2wqLWUtaCotZzt0aGlzLno9bCphK2IqLWcraCotZi1rKi1lO3JldHVybiB0aGlzfSxwcm9qZWN0OmZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5NYXRyaXg0KTthLm11bHRpcGx5TWF0cmljZXMoYi5wcm9qZWN0aW9uTWF0cml4LGEuZ2V0SW52ZXJzZShiLm1hdHJpeFdvcmxkKSk7cmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKGEpfX0oKSxcbiAgICB1bnByb2plY3Q6ZnVuY3Rpb24oKXt2YXIgYTtyZXR1cm4gZnVuY3Rpb24oYil7dm9pZCAwPT09YSYmKGE9bmV3IFRIUkVFLk1hdHJpeDQpO2EubXVsdGlwbHlNYXRyaWNlcyhiLm1hdHJpeFdvcmxkLGEuZ2V0SW52ZXJzZShiLnByb2plY3Rpb25NYXRyaXgpKTtyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oYSl9fSgpLHRyYW5zZm9ybURpcmVjdGlvbjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLngsYz10aGlzLnksZD10aGlzLno7YT1hLmVsZW1lbnRzO3RoaXMueD1hWzBdKmIrYVs0XSpjK2FbOF0qZDt0aGlzLnk9YVsxXSpiK2FbNV0qYythWzldKmQ7dGhpcy56PWFbMl0qYithWzZdKmMrYVsxMF0qZDt0aGlzLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzfSxkaXZpZGU6ZnVuY3Rpb24oYSl7dGhpcy54Lz1hLng7dGhpcy55Lz1hLnk7dGhpcy56Lz1hLno7cmV0dXJuIHRoaXN9LGRpdmlkZVNjYWxhcjpmdW5jdGlvbihhKXswIT09YT8oYT0xL2EsdGhpcy54Kj1hLHRoaXMueSo9YSx0aGlzLnoqPVxuICAgICAgICBhKTp0aGlzLno9dGhpcy55PXRoaXMueD0wO3JldHVybiB0aGlzfSxtaW46ZnVuY3Rpb24oYSl7dGhpcy54PmEueCYmKHRoaXMueD1hLngpO3RoaXMueT5hLnkmJih0aGlzLnk9YS55KTt0aGlzLno+YS56JiYodGhpcy56PWEueik7cmV0dXJuIHRoaXN9LG1heDpmdW5jdGlvbihhKXt0aGlzLng8YS54JiYodGhpcy54PWEueCk7dGhpcy55PGEueSYmKHRoaXMueT1hLnkpO3RoaXMuejxhLnomJih0aGlzLno9YS56KTtyZXR1cm4gdGhpc30sY2xhbXA6ZnVuY3Rpb24oYSxiKXt0aGlzLng8YS54P3RoaXMueD1hLng6dGhpcy54PmIueCYmKHRoaXMueD1iLngpO3RoaXMueTxhLnk/dGhpcy55PWEueTp0aGlzLnk+Yi55JiYodGhpcy55PWIueSk7dGhpcy56PGEuej90aGlzLno9YS56OnRoaXMuej5iLnomJih0aGlzLno9Yi56KTtyZXR1cm4gdGhpc30sY2xhbXBTY2FsYXI6ZnVuY3Rpb24oKXt2YXIgYSxiO3JldHVybiBmdW5jdGlvbihjLGQpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5WZWN0b3IzLFxuICAgICAgICBiPW5ldyBUSFJFRS5WZWN0b3IzKTthLnNldChjLGMsYyk7Yi5zZXQoZCxkLGQpO3JldHVybiB0aGlzLmNsYW1wKGEsYil9fSgpLGZsb29yOmZ1bmN0aW9uKCl7dGhpcy54PU1hdGguZmxvb3IodGhpcy54KTt0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpO3RoaXMuej1NYXRoLmZsb29yKHRoaXMueik7cmV0dXJuIHRoaXN9LGNlaWw6ZnVuY3Rpb24oKXt0aGlzLng9TWF0aC5jZWlsKHRoaXMueCk7dGhpcy55PU1hdGguY2VpbCh0aGlzLnkpO3RoaXMuej1NYXRoLmNlaWwodGhpcy56KTtyZXR1cm4gdGhpc30scm91bmQ6ZnVuY3Rpb24oKXt0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngpO3RoaXMueT1NYXRoLnJvdW5kKHRoaXMueSk7dGhpcy56PU1hdGgucm91bmQodGhpcy56KTtyZXR1cm4gdGhpc30scm91bmRUb1plcm86ZnVuY3Rpb24oKXt0aGlzLng9MD50aGlzLng/TWF0aC5jZWlsKHRoaXMueCk6TWF0aC5mbG9vcih0aGlzLngpO3RoaXMueT0wPnRoaXMueT9NYXRoLmNlaWwodGhpcy55KTpcbiAgICAgICAgTWF0aC5mbG9vcih0aGlzLnkpO3RoaXMuej0wPnRoaXMuej9NYXRoLmNlaWwodGhpcy56KTpNYXRoLmZsb29yKHRoaXMueik7cmV0dXJuIHRoaXN9LG5lZ2F0ZTpmdW5jdGlvbigpe3RoaXMueD0tdGhpcy54O3RoaXMueT0tdGhpcy55O3RoaXMuej0tdGhpcy56O3JldHVybiB0aGlzfSxkb3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMueCphLngrdGhpcy55KmEueSt0aGlzLnoqYS56fSxsZW5ndGhTcTpmdW5jdGlvbigpe3JldHVybiB0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMuen0sbGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMueil9LGxlbmd0aE1hbmhhdHRhbjpmdW5jdGlvbigpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK01hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkpfSxcbiAgICBzZXRMZW5ndGg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5sZW5ndGgoKTswIT09YiYmYSE9PWImJnRoaXMubXVsdGlwbHlTY2FsYXIoYS9iKTtyZXR1cm4gdGhpc30sbGVycDpmdW5jdGlvbihhLGIpe3RoaXMueCs9KGEueC10aGlzLngpKmI7dGhpcy55Kz0oYS55LXRoaXMueSkqYjt0aGlzLnorPShhLnotdGhpcy56KSpiO3JldHVybiB0aGlzfSxsZXJwVmVjdG9yczpmdW5jdGlvbihhLGIsYyl7dGhpcy5zdWJWZWN0b3JzKGIsYSkubXVsdGlwbHlTY2FsYXIoYykuYWRkKGEpO3JldHVybiB0aGlzfSxjcm9zczpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PWIpcmV0dXJuIFRIUkVFLndhcm4oXCJUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLmNyb3NzVmVjdG9ycyhhLGIpO3ZhciBjPXRoaXMueCxkPXRoaXMueSxlPXRoaXMuejt0aGlzLng9ZCphLnotZSphLnk7dGhpcy55PVxuICAgICAgICBlKmEueC1jKmEuejt0aGlzLno9YyphLnktZCphLng7cmV0dXJuIHRoaXN9LGNyb3NzVmVjdG9yczpmdW5jdGlvbihhLGIpe3ZhciBjPWEueCxkPWEueSxlPWEueixmPWIueCxnPWIueSxoPWIuejt0aGlzLng9ZCpoLWUqZzt0aGlzLnk9ZSpmLWMqaDt0aGlzLno9YypnLWQqZjtyZXR1cm4gdGhpc30scHJvamVjdE9uVmVjdG9yOmZ1bmN0aW9uKCl7dmFyIGEsYjtyZXR1cm4gZnVuY3Rpb24oYyl7dm9pZCAwPT09YSYmKGE9bmV3IFRIUkVFLlZlY3RvcjMpO2EuY29weShjKS5ub3JtYWxpemUoKTtiPXRoaXMuZG90KGEpO3JldHVybiB0aGlzLmNvcHkoYSkubXVsdGlwbHlTY2FsYXIoYil9fSgpLHByb2plY3RPblBsYW5lOmZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5WZWN0b3IzKTthLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKGIpO3JldHVybiB0aGlzLnN1YihhKX19KCkscmVmbGVjdDpmdW5jdGlvbigpe3ZhciBhO3JldHVybiBmdW5jdGlvbihiKXt2b2lkIDA9PT1cbiAgICBhJiYoYT1uZXcgVEhSRUUuVmVjdG9yMyk7cmV0dXJuIHRoaXMuc3ViKGEuY29weShiKS5tdWx0aXBseVNjYWxhcigyKnRoaXMuZG90KGIpKSl9fSgpLGFuZ2xlVG86ZnVuY3Rpb24oYSl7YT10aGlzLmRvdChhKS8odGhpcy5sZW5ndGgoKSphLmxlbmd0aCgpKTtyZXR1cm4gTWF0aC5hY29zKFRIUkVFLk1hdGguY2xhbXAoYSwtMSwxKSl9LGRpc3RhbmNlVG86ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKGEpKX0sZGlzdGFuY2VUb1NxdWFyZWQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy54LWEueCxjPXRoaXMueS1hLnk7YT10aGlzLnotYS56O3JldHVybiBiKmIrYypjK2EqYX0sc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6ZnVuY3Rpb24oYSxiKXtUSFJFRS5lcnJvcihcIlRIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLlwiKX0sXG4gICAgc2V0RXVsZXJGcm9tUXVhdGVybmlvbjpmdW5jdGlvbihhLGIpe1RIUkVFLmVycm9yKFwiVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLlwiKX0sZ2V0UG9zaXRpb25Gcm9tTWF0cml4OmZ1bmN0aW9uKGEpe1RIUkVFLndhcm4oXCJUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuXCIpO3JldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbihhKX0sZ2V0U2NhbGVGcm9tTWF0cml4OmZ1bmN0aW9uKGEpe1RIUkVFLndhcm4oXCJUSFJFRS5WZWN0b3IzOiAuZ2V0U2NhbGVGcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFNjYWxlKCkuXCIpO3JldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZShhKX0sZ2V0Q29sdW1uRnJvbU1hdHJpeDpmdW5jdGlvbihhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYil7VEhSRUUud2FybihcIlRIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLlwiKTtyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKGEsYil9LHNldEZyb21NYXRyaXhQb3NpdGlvbjpmdW5jdGlvbihhKXt0aGlzLng9YS5lbGVtZW50c1sxMl07dGhpcy55PWEuZWxlbWVudHNbMTNdO3RoaXMuej1hLmVsZW1lbnRzWzE0XTtyZXR1cm4gdGhpc30sc2V0RnJvbU1hdHJpeFNjYWxlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2V0KGEuZWxlbWVudHNbMF0sYS5lbGVtZW50c1sxXSxhLmVsZW1lbnRzWzJdKS5sZW5ndGgoKSxjPXRoaXMuc2V0KGEuZWxlbWVudHNbNF0sYS5lbGVtZW50c1s1XSxhLmVsZW1lbnRzWzZdKS5sZW5ndGgoKTthPXRoaXMuc2V0KGEuZWxlbWVudHNbOF0sYS5lbGVtZW50c1s5XSxhLmVsZW1lbnRzWzEwXSkubGVuZ3RoKCk7dGhpcy54PWI7dGhpcy55PWM7dGhpcy56PWE7XG4gICAgICAgIHJldHVybiB0aGlzfSxzZXRGcm9tTWF0cml4Q29sdW1uOmZ1bmN0aW9uKGEsYil7dmFyIGM9NCphLGQ9Yi5lbGVtZW50czt0aGlzLng9ZFtjXTt0aGlzLnk9ZFtjKzFdO3RoaXMuej1kW2MrMl07cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS54PT09dGhpcy54JiZhLnk9PT10aGlzLnkmJmEuej09PXRoaXMuen0sZnJvbUFycmF5OmZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9MCk7dGhpcy54PWFbYl07dGhpcy55PWFbYisxXTt0aGlzLno9YVtiKzJdO3JldHVybiB0aGlzfSx0b0FycmF5OmZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YSYmKGE9W10pO3ZvaWQgMD09PWImJihiPTApO2FbYl09dGhpcy54O2FbYisxXT10aGlzLnk7YVtiKzJdPXRoaXMuejtyZXR1cm4gYX0sZnJvbUF0dHJpYnV0ZTpmdW5jdGlvbihhLGIsYyl7dm9pZCAwPT09YyYmKGM9MCk7Yj1iKmEuaXRlbVNpemUrYzt0aGlzLng9YS5hcnJheVtiXTt0aGlzLnk9YS5hcnJheVtiKzFdO3RoaXMuej1cbiAgICAgICAgYS5hcnJheVtiKzJdO3JldHVybiB0aGlzfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiBuZXcgVEhSRUUuVmVjdG9yMyh0aGlzLngsdGhpcy55LHRoaXMueil9fTtUSFJFRS5WZWN0b3I0PWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMueD1hfHwwO3RoaXMueT1ifHwwO3RoaXMuej1jfHwwO3RoaXMudz12b2lkIDAhPT1kP2Q6MX07XG5USFJFRS5WZWN0b3I0LnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuVmVjdG9yNCxzZXQ6ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy54PWE7dGhpcy55PWI7dGhpcy56PWM7dGhpcy53PWQ7cmV0dXJuIHRoaXN9LHNldFg6ZnVuY3Rpb24oYSl7dGhpcy54PWE7cmV0dXJuIHRoaXN9LHNldFk6ZnVuY3Rpb24oYSl7dGhpcy55PWE7cmV0dXJuIHRoaXN9LHNldFo6ZnVuY3Rpb24oYSl7dGhpcy56PWE7cmV0dXJuIHRoaXN9LHNldFc6ZnVuY3Rpb24oYSl7dGhpcy53PWE7cmV0dXJuIHRoaXN9LHNldENvbXBvbmVudDpmdW5jdGlvbihhLGIpe3N3aXRjaChhKXtjYXNlIDA6dGhpcy54PWI7YnJlYWs7Y2FzZSAxOnRoaXMueT1iO2JyZWFrO2Nhc2UgMjp0aGlzLno9YjticmVhaztjYXNlIDM6dGhpcy53PWI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImluZGV4IGlzIG91dCBvZiByYW5nZTogXCIrYSk7fX0sZ2V0Q29tcG9uZW50OmZ1bmN0aW9uKGEpe3N3aXRjaChhKXtjYXNlIDA6cmV0dXJuIHRoaXMueDtcbiAgICBjYXNlIDE6cmV0dXJuIHRoaXMueTtjYXNlIDI6cmV0dXJuIHRoaXMuejtjYXNlIDM6cmV0dXJuIHRoaXMudztkZWZhdWx0OnRocm93IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIithKTt9fSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMueD1hLng7dGhpcy55PWEueTt0aGlzLno9YS56O3RoaXMudz12b2lkIDAhPT1hLnc/YS53OjE7cmV0dXJuIHRoaXN9LGFkZDpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PWIpcmV0dXJuIFRIUkVFLndhcm4oXCJUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLHRoaXMuYWRkVmVjdG9ycyhhLGIpO3RoaXMueCs9YS54O3RoaXMueSs9YS55O3RoaXMueis9YS56O3RoaXMudys9YS53O3JldHVybiB0aGlzfSxhZGRTY2FsYXI6ZnVuY3Rpb24oYSl7dGhpcy54Kz1hO3RoaXMueSs9YTt0aGlzLnorPWE7dGhpcy53Kz1hO3JldHVybiB0aGlzfSxhZGRWZWN0b3JzOmZ1bmN0aW9uKGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIpe3RoaXMueD1hLngrYi54O3RoaXMueT1hLnkrYi55O3RoaXMuej1hLnorYi56O3RoaXMudz1hLncrYi53O3JldHVybiB0aGlzfSxzdWI6ZnVuY3Rpb24oYSxiKXtpZih2b2lkIDAhPT1iKXJldHVybiBUSFJFRS53YXJuKFwiVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLnN1YlZlY3RvcnMoYSxiKTt0aGlzLngtPWEueDt0aGlzLnktPWEueTt0aGlzLnotPWEuejt0aGlzLnctPWEudztyZXR1cm4gdGhpc30sc3ViU2NhbGFyOmZ1bmN0aW9uKGEpe3RoaXMueC09YTt0aGlzLnktPWE7dGhpcy56LT1hO3RoaXMudy09YTtyZXR1cm4gdGhpc30sc3ViVmVjdG9yczpmdW5jdGlvbihhLGIpe3RoaXMueD1hLngtYi54O3RoaXMueT1hLnktYi55O3RoaXMuej1hLnotYi56O3RoaXMudz1hLnctYi53O3JldHVybiB0aGlzfSxtdWx0aXBseVNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLngqPVxuICAgIGE7dGhpcy55Kj1hO3RoaXMueio9YTt0aGlzLncqPWE7cmV0dXJuIHRoaXN9LGFwcGx5TWF0cml4NDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLngsYz10aGlzLnksZD10aGlzLnosZT10aGlzLnc7YT1hLmVsZW1lbnRzO3RoaXMueD1hWzBdKmIrYVs0XSpjK2FbOF0qZCthWzEyXSplO3RoaXMueT1hWzFdKmIrYVs1XSpjK2FbOV0qZCthWzEzXSplO3RoaXMuej1hWzJdKmIrYVs2XSpjK2FbMTBdKmQrYVsxNF0qZTt0aGlzLnc9YVszXSpiK2FbN10qYythWzExXSpkK2FbMTVdKmU7cmV0dXJuIHRoaXN9LGRpdmlkZVNjYWxhcjpmdW5jdGlvbihhKXswIT09YT8oYT0xL2EsdGhpcy54Kj1hLHRoaXMueSo9YSx0aGlzLnoqPWEsdGhpcy53Kj1hKToodGhpcy56PXRoaXMueT10aGlzLng9MCx0aGlzLnc9MSk7cmV0dXJuIHRoaXN9LHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOmZ1bmN0aW9uKGEpe3RoaXMudz0yKk1hdGguYWNvcyhhLncpO3ZhciBiPU1hdGguc3FydCgxLWEudyphLncpOzFFLTQ+XG5iPyh0aGlzLng9MSx0aGlzLno9dGhpcy55PTApOih0aGlzLng9YS54L2IsdGhpcy55PWEueS9iLHRoaXMuej1hLnovYik7cmV0dXJuIHRoaXN9LHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDpmdW5jdGlvbihhKXt2YXIgYixjLGQ7YT1hLmVsZW1lbnRzO3ZhciBlPWFbMF07ZD1hWzRdO3ZhciBmPWFbOF0sZz1hWzFdLGg9YVs1XSxrPWFbOV07Yz1hWzJdO2I9YVs2XTt2YXIgbD1hWzEwXTtpZiguMDE+TWF0aC5hYnMoZC1nKSYmLjAxPk1hdGguYWJzKGYtYykmJi4wMT5NYXRoLmFicyhrLWIpKXtpZiguMT5NYXRoLmFicyhkK2cpJiYuMT5NYXRoLmFicyhmK2MpJiYuMT5NYXRoLmFicyhrK2IpJiYuMT5NYXRoLmFicyhlK2grbC0zKSlyZXR1cm4gdGhpcy5zZXQoMSwwLDAsMCksdGhpczthPU1hdGguUEk7ZT0oZSsxKS8yO2g9KGgrMSkvMjtsPShsKzEpLzI7ZD0oZCtnKS80O2Y9KGYrYykvNDtrPShrK2IpLzQ7ZT5oJiZlPmw/LjAxPmU/KGI9MCxkPWM9LjcwNzEwNjc4MSk6KGI9XG4gICAgTWF0aC5zcXJ0KGUpLGM9ZC9iLGQ9Zi9iKTpoPmw/LjAxPmg/KGI9LjcwNzEwNjc4MSxjPTAsZD0uNzA3MTA2NzgxKTooYz1NYXRoLnNxcnQoaCksYj1kL2MsZD1rL2MpOi4wMT5sPyhjPWI9LjcwNzEwNjc4MSxkPTApOihkPU1hdGguc3FydChsKSxiPWYvZCxjPWsvZCk7dGhpcy5zZXQoYixjLGQsYSk7cmV0dXJuIHRoaXN9YT1NYXRoLnNxcnQoKGItaykqKGItaykrKGYtYykqKGYtYykrKGctZCkqKGctZCkpOy4wMDE+TWF0aC5hYnMoYSkmJihhPTEpO3RoaXMueD0oYi1rKS9hO3RoaXMueT0oZi1jKS9hO3RoaXMuej0oZy1kKS9hO3RoaXMudz1NYXRoLmFjb3MoKGUraCtsLTEpLzIpO3JldHVybiB0aGlzfSxtaW46ZnVuY3Rpb24oYSl7dGhpcy54PmEueCYmKHRoaXMueD1hLngpO3RoaXMueT5hLnkmJih0aGlzLnk9YS55KTt0aGlzLno+YS56JiYodGhpcy56PWEueik7dGhpcy53PmEudyYmKHRoaXMudz1hLncpO3JldHVybiB0aGlzfSxtYXg6ZnVuY3Rpb24oYSl7dGhpcy54PGEueCYmXG4odGhpcy54PWEueCk7dGhpcy55PGEueSYmKHRoaXMueT1hLnkpO3RoaXMuejxhLnomJih0aGlzLno9YS56KTt0aGlzLnc8YS53JiYodGhpcy53PWEudyk7cmV0dXJuIHRoaXN9LGNsYW1wOmZ1bmN0aW9uKGEsYil7dGhpcy54PGEueD90aGlzLng9YS54OnRoaXMueD5iLngmJih0aGlzLng9Yi54KTt0aGlzLnk8YS55P3RoaXMueT1hLnk6dGhpcy55PmIueSYmKHRoaXMueT1iLnkpO3RoaXMuejxhLno/dGhpcy56PWEuejp0aGlzLno+Yi56JiYodGhpcy56PWIueik7dGhpcy53PGEudz90aGlzLnc9YS53OnRoaXMudz5iLncmJih0aGlzLnc9Yi53KTtyZXR1cm4gdGhpc30sY2xhbXBTY2FsYXI6ZnVuY3Rpb24oKXt2YXIgYSxiO3JldHVybiBmdW5jdGlvbihjLGQpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5WZWN0b3I0LGI9bmV3IFRIUkVFLlZlY3RvcjQpO2Euc2V0KGMsYyxjLGMpO2Iuc2V0KGQsZCxkLGQpO3JldHVybiB0aGlzLmNsYW1wKGEsYil9fSgpLGZsb29yOmZ1bmN0aW9uKCl7dGhpcy54PVxuICAgIE1hdGguZmxvb3IodGhpcy54KTt0aGlzLnk9TWF0aC5mbG9vcih0aGlzLnkpO3RoaXMuej1NYXRoLmZsb29yKHRoaXMueik7dGhpcy53PU1hdGguZmxvb3IodGhpcy53KTtyZXR1cm4gdGhpc30sY2VpbDpmdW5jdGlvbigpe3RoaXMueD1NYXRoLmNlaWwodGhpcy54KTt0aGlzLnk9TWF0aC5jZWlsKHRoaXMueSk7dGhpcy56PU1hdGguY2VpbCh0aGlzLnopO3RoaXMudz1NYXRoLmNlaWwodGhpcy53KTtyZXR1cm4gdGhpc30scm91bmQ6ZnVuY3Rpb24oKXt0aGlzLng9TWF0aC5yb3VuZCh0aGlzLngpO3RoaXMueT1NYXRoLnJvdW5kKHRoaXMueSk7dGhpcy56PU1hdGgucm91bmQodGhpcy56KTt0aGlzLnc9TWF0aC5yb3VuZCh0aGlzLncpO3JldHVybiB0aGlzfSxyb3VuZFRvWmVybzpmdW5jdGlvbigpe3RoaXMueD0wPnRoaXMueD9NYXRoLmNlaWwodGhpcy54KTpNYXRoLmZsb29yKHRoaXMueCk7dGhpcy55PTA+dGhpcy55P01hdGguY2VpbCh0aGlzLnkpOk1hdGguZmxvb3IodGhpcy55KTtcbiAgICB0aGlzLno9MD50aGlzLno/TWF0aC5jZWlsKHRoaXMueik6TWF0aC5mbG9vcih0aGlzLnopO3RoaXMudz0wPnRoaXMudz9NYXRoLmNlaWwodGhpcy53KTpNYXRoLmZsb29yKHRoaXMudyk7cmV0dXJuIHRoaXN9LG5lZ2F0ZTpmdW5jdGlvbigpe3RoaXMueD0tdGhpcy54O3RoaXMueT0tdGhpcy55O3RoaXMuej0tdGhpcy56O3RoaXMudz0tdGhpcy53O3JldHVybiB0aGlzfSxkb3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMueCphLngrdGhpcy55KmEueSt0aGlzLnoqYS56K3RoaXMudyphLnd9LGxlbmd0aFNxOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLnd9LGxlbmd0aDpmdW5jdGlvbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudyl9LGxlbmd0aE1hbmhhdHRhbjpmdW5jdGlvbigpe3JldHVybiBNYXRoLmFicyh0aGlzLngpK1xuICAgIE1hdGguYWJzKHRoaXMueSkrTWF0aC5hYnModGhpcy56KStNYXRoLmFicyh0aGlzLncpfSxub3JtYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSl9LHNldExlbmd0aDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxlbmd0aCgpOzAhPT1iJiZhIT09YiYmdGhpcy5tdWx0aXBseVNjYWxhcihhL2IpO3JldHVybiB0aGlzfSxsZXJwOmZ1bmN0aW9uKGEsYil7dGhpcy54Kz0oYS54LXRoaXMueCkqYjt0aGlzLnkrPShhLnktdGhpcy55KSpiO3RoaXMueis9KGEuei10aGlzLnopKmI7dGhpcy53Kz0oYS53LXRoaXMudykqYjtyZXR1cm4gdGhpc30sbGVycFZlY3RvcnM6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuc3ViVmVjdG9ycyhiLGEpLm11bHRpcGx5U2NhbGFyKGMpLmFkZChhKTtyZXR1cm4gdGhpc30sZXF1YWxzOmZ1bmN0aW9uKGEpe3JldHVybiBhLng9PT10aGlzLngmJmEueT09PXRoaXMueSYmYS56PT09dGhpcy56JiZhLnc9PT10aGlzLnd9LFxuICAgIGZyb21BcnJheTpmdW5jdGlvbihhLGIpe3ZvaWQgMD09PWImJihiPTApO3RoaXMueD1hW2JdO3RoaXMueT1hW2IrMV07dGhpcy56PWFbYisyXTt0aGlzLnc9YVtiKzNdO3JldHVybiB0aGlzfSx0b0FycmF5OmZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YSYmKGE9W10pO3ZvaWQgMD09PWImJihiPTApO2FbYl09dGhpcy54O2FbYisxXT10aGlzLnk7YVtiKzJdPXRoaXMuejthW2IrM109dGhpcy53O3JldHVybiBhfSxmcm9tQXR0cmlidXRlOmZ1bmN0aW9uKGEsYixjKXt2b2lkIDA9PT1jJiYoYz0wKTtiPWIqYS5pdGVtU2l6ZStjO3RoaXMueD1hLmFycmF5W2JdO3RoaXMueT1hLmFycmF5W2IrMV07dGhpcy56PWEuYXJyYXlbYisyXTt0aGlzLnc9YS5hcnJheVtiKzNdO3JldHVybiB0aGlzfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiBuZXcgVEhSRUUuVmVjdG9yNCh0aGlzLngsdGhpcy55LHRoaXMueix0aGlzLncpfX07XG5USFJFRS5FdWxlcj1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLl94PWF8fDA7dGhpcy5feT1ifHwwO3RoaXMuX3o9Y3x8MDt0aGlzLl9vcmRlcj1kfHxUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXJ9O1RIUkVFLkV1bGVyLlJvdGF0aW9uT3JkZXJzPVwiWFlaIFlaWCBaWFkgWFpZIFlYWiBaWVhcIi5zcGxpdChcIiBcIik7VEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyPVwiWFlaXCI7XG5USFJFRS5FdWxlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkV1bGVyLF94OjAsX3k6MCxfejowLF9vcmRlcjpUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXIsZ2V0IHgoKXtyZXR1cm4gdGhpcy5feH0sc2V0IHgoYSl7dGhpcy5feD1hO3RoaXMub25DaGFuZ2VDYWxsYmFjaygpfSxnZXQgeSgpe3JldHVybiB0aGlzLl95fSxzZXQgeShhKXt0aGlzLl95PWE7dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCl9LGdldCB6KCl7cmV0dXJuIHRoaXMuX3p9LHNldCB6KGEpe3RoaXMuX3o9YTt0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKX0sZ2V0IG9yZGVyKCl7cmV0dXJuIHRoaXMuX29yZGVyfSxzZXQgb3JkZXIoYSl7dGhpcy5fb3JkZXI9YTt0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKX0sc2V0OmZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuX3g9YTt0aGlzLl95PWI7dGhpcy5fej1jO3RoaXMuX29yZGVyPWR8fHRoaXMuX29yZGVyO3RoaXMub25DaGFuZ2VDYWxsYmFjaygpO3JldHVybiB0aGlzfSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMuX3g9XG4gICAgYS5feDt0aGlzLl95PWEuX3k7dGhpcy5fej1hLl96O3RoaXMuX29yZGVyPWEuX29yZGVyO3RoaXMub25DaGFuZ2VDYWxsYmFjaygpO3JldHVybiB0aGlzfSxzZXRGcm9tUm90YXRpb25NYXRyaXg6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVRIUkVFLk1hdGguY2xhbXAsZT1hLmVsZW1lbnRzO2E9ZVswXTt2YXIgZj1lWzRdLGc9ZVs4XSxoPWVbMV0saz1lWzVdLGw9ZVs5XSxwPWVbMl0scT1lWzZdLGU9ZVsxMF07Yj1ifHx0aGlzLl9vcmRlcjtcIlhZWlwiPT09Yj8odGhpcy5feT1NYXRoLmFzaW4oZChnLC0xLDEpKSwuOTk5OTk+TWF0aC5hYnMoZyk/KHRoaXMuX3g9TWF0aC5hdGFuMigtbCxlKSx0aGlzLl96PU1hdGguYXRhbjIoLWYsYSkpOih0aGlzLl94PU1hdGguYXRhbjIocSxrKSx0aGlzLl96PTApKTpcIllYWlwiPT09Yj8odGhpcy5feD1NYXRoLmFzaW4oLWQobCwtMSwxKSksLjk5OTk5Pk1hdGguYWJzKGwpPyh0aGlzLl95PU1hdGguYXRhbjIoZyxlKSx0aGlzLl96PU1hdGguYXRhbjIoaCxcbiAgICBrKSk6KHRoaXMuX3k9TWF0aC5hdGFuMigtcCxhKSx0aGlzLl96PTApKTpcIlpYWVwiPT09Yj8odGhpcy5feD1NYXRoLmFzaW4oZChxLC0xLDEpKSwuOTk5OTk+TWF0aC5hYnMocSk/KHRoaXMuX3k9TWF0aC5hdGFuMigtcCxlKSx0aGlzLl96PU1hdGguYXRhbjIoLWYsaykpOih0aGlzLl95PTAsdGhpcy5fej1NYXRoLmF0YW4yKGgsYSkpKTpcIlpZWFwiPT09Yj8odGhpcy5feT1NYXRoLmFzaW4oLWQocCwtMSwxKSksLjk5OTk5Pk1hdGguYWJzKHApPyh0aGlzLl94PU1hdGguYXRhbjIocSxlKSx0aGlzLl96PU1hdGguYXRhbjIoaCxhKSk6KHRoaXMuX3g9MCx0aGlzLl96PU1hdGguYXRhbjIoLWYsaykpKTpcIllaWFwiPT09Yj8odGhpcy5fej1NYXRoLmFzaW4oZChoLC0xLDEpKSwuOTk5OTk+TWF0aC5hYnMoaCk/KHRoaXMuX3g9TWF0aC5hdGFuMigtbCxrKSx0aGlzLl95PU1hdGguYXRhbjIoLXAsYSkpOih0aGlzLl94PTAsdGhpcy5feT1NYXRoLmF0YW4yKGcsZSkpKTpcIlhaWVwiPT09Yj8odGhpcy5fej1cbiAgICBNYXRoLmFzaW4oLWQoZiwtMSwxKSksLjk5OTk5Pk1hdGguYWJzKGYpPyh0aGlzLl94PU1hdGguYXRhbjIocSxrKSx0aGlzLl95PU1hdGguYXRhbjIoZyxhKSk6KHRoaXMuX3g9TWF0aC5hdGFuMigtbCxlKSx0aGlzLl95PTApKTpUSFJFRS53YXJuKFwiVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogXCIrYik7dGhpcy5fb3JkZXI9YjtpZighMSE9PWMpdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7cmV0dXJuIHRoaXN9LHNldEZyb21RdWF0ZXJuaW9uOmZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGZ1bmN0aW9uKGIsYyxkKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuTWF0cml4NCk7YS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihiKTt0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeChhLGMsZCk7cmV0dXJuIHRoaXN9fSgpLHNldEZyb21WZWN0b3IzOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuc2V0KGEueCxhLnksYS56LFxuICAgIGJ8fHRoaXMuX29yZGVyKX0scmVvcmRlcjpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5RdWF0ZXJuaW9uO3JldHVybiBmdW5jdGlvbihiKXthLnNldEZyb21FdWxlcih0aGlzKTt0aGlzLnNldEZyb21RdWF0ZXJuaW9uKGEsYil9fSgpLGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5feD09PXRoaXMuX3gmJmEuX3k9PT10aGlzLl95JiZhLl96PT09dGhpcy5feiYmYS5fb3JkZXI9PT10aGlzLl9vcmRlcn0sZnJvbUFycmF5OmZ1bmN0aW9uKGEpe3RoaXMuX3g9YVswXTt0aGlzLl95PWFbMV07dGhpcy5fej1hWzJdO3ZvaWQgMCE9PWFbM10mJih0aGlzLl9vcmRlcj1hWzNdKTt0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtyZXR1cm4gdGhpc30sdG9BcnJheTpmdW5jdGlvbihhLGIpe3ZvaWQgMD09PWEmJihhPVtdKTt2b2lkIDA9PT1iJiYoYj0wKTthW2JdPXRoaXMuX3g7YVtiKzFdPXRoaXMuX3k7YVtiKzJdPXRoaXMuX3o7YVtiKzNdPXRoaXMuX29yZGVyO3JldHVybiBhfSx0b1ZlY3RvcjM6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/XG4gICAgYS5zZXQodGhpcy5feCx0aGlzLl95LHRoaXMuX3opOm5ldyBUSFJFRS5WZWN0b3IzKHRoaXMuX3gsdGhpcy5feSx0aGlzLl96KX0sb25DaGFuZ2U6ZnVuY3Rpb24oYSl7dGhpcy5vbkNoYW5nZUNhbGxiYWNrPWE7cmV0dXJuIHRoaXN9LG9uQ2hhbmdlQ2FsbGJhY2s6ZnVuY3Rpb24oKXt9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUSFJFRS5FdWxlcih0aGlzLl94LHRoaXMuX3ksdGhpcy5feix0aGlzLl9vcmRlcil9fTtUSFJFRS5MaW5lMz1mdW5jdGlvbihhLGIpe3RoaXMuc3RhcnQ9dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5WZWN0b3IzO3RoaXMuZW5kPXZvaWQgMCE9PWI/YjpuZXcgVEhSRUUuVmVjdG9yM307XG5USFJFRS5MaW5lMy5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkxpbmUzLHNldDpmdW5jdGlvbihhLGIpe3RoaXMuc3RhcnQuY29weShhKTt0aGlzLmVuZC5jb3B5KGIpO3JldHVybiB0aGlzfSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMuc3RhcnQuY29weShhLnN0YXJ0KTt0aGlzLmVuZC5jb3B5KGEuZW5kKTtyZXR1cm4gdGhpc30sY2VudGVyOmZ1bmN0aW9uKGEpe3JldHVybihhfHxuZXcgVEhSRUUuVmVjdG9yMykuYWRkVmVjdG9ycyh0aGlzLnN0YXJ0LHRoaXMuZW5kKS5tdWx0aXBseVNjYWxhciguNSl9LGRlbHRhOmZ1bmN0aW9uKGEpe3JldHVybihhfHxuZXcgVEhSRUUuVmVjdG9yMykuc3ViVmVjdG9ycyh0aGlzLmVuZCx0aGlzLnN0YXJ0KX0sZGlzdGFuY2VTcTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuZW5kKX0sZGlzdGFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKHRoaXMuZW5kKX0sYXQ6ZnVuY3Rpb24oYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiKXt2YXIgYz1ifHxuZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gdGhpcy5kZWx0YShjKS5tdWx0aXBseVNjYWxhcihhKS5hZGQodGhpcy5zdGFydCl9LGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihjLGQpe2Euc3ViVmVjdG9ycyhjLHRoaXMuc3RhcnQpO2Iuc3ViVmVjdG9ycyh0aGlzLmVuZCx0aGlzLnN0YXJ0KTt2YXIgZT1iLmRvdChiKSxlPWIuZG90KGEpL2U7ZCYmKGU9VEhSRUUuTWF0aC5jbGFtcChlLDAsMSkpO3JldHVybiBlfX0oKSxjbG9zZXN0UG9pbnRUb1BvaW50OmZ1bmN0aW9uKGEsYixjKXthPXRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcihhLGIpO2M9Y3x8bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIHRoaXMuZGVsdGEoYykubXVsdGlwbHlTY2FsYXIoYSkuYWRkKHRoaXMuc3RhcnQpfSxhcHBseU1hdHJpeDQ6ZnVuY3Rpb24oYSl7dGhpcy5zdGFydC5hcHBseU1hdHJpeDQoYSk7XG4gICAgdGhpcy5lbmQuYXBwbHlNYXRyaXg0KGEpO3JldHVybiB0aGlzfSxlcXVhbHM6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3RhcnQuZXF1YWxzKHRoaXMuc3RhcnQpJiZhLmVuZC5lcXVhbHModGhpcy5lbmQpfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybihuZXcgVEhSRUUuTGluZTMpLmNvcHkodGhpcyl9fTtUSFJFRS5Cb3gyPWZ1bmN0aW9uKGEsYil7dGhpcy5taW49dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5WZWN0b3IyKEluZmluaXR5LEluZmluaXR5KTt0aGlzLm1heD12b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlZlY3RvcjIoLUluZmluaXR5LC1JbmZpbml0eSl9O1xuVEhSRUUuQm94Mi5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkJveDIsc2V0OmZ1bmN0aW9uKGEsYil7dGhpcy5taW4uY29weShhKTt0aGlzLm1heC5jb3B5KGIpO3JldHVybiB0aGlzfSxzZXRGcm9tUG9pbnRzOmZ1bmN0aW9uKGEpe3RoaXMubWFrZUVtcHR5KCk7Zm9yKHZhciBiPTAsYz1hLmxlbmd0aDtiPGM7YisrKXRoaXMuZXhwYW5kQnlQb2ludChhW2JdKTtyZXR1cm4gdGhpc30sc2V0RnJvbUNlbnRlckFuZFNpemU6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMjtyZXR1cm4gZnVuY3Rpb24oYixjKXt2YXIgZD1hLmNvcHkoYykubXVsdGlwbHlTY2FsYXIoLjUpO3RoaXMubWluLmNvcHkoYikuc3ViKGQpO3RoaXMubWF4LmNvcHkoYikuYWRkKGQpO3JldHVybiB0aGlzfX0oKSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMubWluLmNvcHkoYS5taW4pO3RoaXMubWF4LmNvcHkoYS5tYXgpO3JldHVybiB0aGlzfSxtYWtlRW1wdHk6ZnVuY3Rpb24oKXt0aGlzLm1pbi54PVxuICAgIHRoaXMubWluLnk9SW5maW5pdHk7dGhpcy5tYXgueD10aGlzLm1heC55PS1JbmZpbml0eTtyZXR1cm4gdGhpc30sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXgueDx0aGlzLm1pbi54fHx0aGlzLm1heC55PHRoaXMubWluLnl9LGNlbnRlcjpmdW5jdGlvbihhKXtyZXR1cm4oYXx8bmV3IFRIUkVFLlZlY3RvcjIpLmFkZFZlY3RvcnModGhpcy5taW4sdGhpcy5tYXgpLm11bHRpcGx5U2NhbGFyKC41KX0sc2l6ZTpmdW5jdGlvbihhKXtyZXR1cm4oYXx8bmV3IFRIUkVFLlZlY3RvcjIpLnN1YlZlY3RvcnModGhpcy5tYXgsdGhpcy5taW4pfSxleHBhbmRCeVBvaW50OmZ1bmN0aW9uKGEpe3RoaXMubWluLm1pbihhKTt0aGlzLm1heC5tYXgoYSk7cmV0dXJuIHRoaXN9LGV4cGFuZEJ5VmVjdG9yOmZ1bmN0aW9uKGEpe3RoaXMubWluLnN1YihhKTt0aGlzLm1heC5hZGQoYSk7cmV0dXJuIHRoaXN9LGV4cGFuZEJ5U2NhbGFyOmZ1bmN0aW9uKGEpe3RoaXMubWluLmFkZFNjYWxhcigtYSk7XG4gICAgdGhpcy5tYXguYWRkU2NhbGFyKGEpO3JldHVybiB0aGlzfSxjb250YWluc1BvaW50OmZ1bmN0aW9uKGEpe3JldHVybiBhLng8dGhpcy5taW4ueHx8YS54PnRoaXMubWF4Lnh8fGEueTx0aGlzLm1pbi55fHxhLnk+dGhpcy5tYXgueT8hMTohMH0sY29udGFpbnNCb3g6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubWluLng8PWEubWluLngmJmEubWF4Lng8PXRoaXMubWF4LngmJnRoaXMubWluLnk8PWEubWluLnkmJmEubWF4Lnk8PXRoaXMubWF4Lnk/ITA6ITF9LGdldFBhcmFtZXRlcjpmdW5jdGlvbihhLGIpe3JldHVybihifHxuZXcgVEhSRUUuVmVjdG9yMikuc2V0KChhLngtdGhpcy5taW4ueCkvKHRoaXMubWF4LngtdGhpcy5taW4ueCksKGEueS10aGlzLm1pbi55KS8odGhpcy5tYXgueS10aGlzLm1pbi55KSl9LGlzSW50ZXJzZWN0aW9uQm94OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1heC54PHRoaXMubWluLnh8fGEubWluLng+dGhpcy5tYXgueHx8YS5tYXgueTx0aGlzLm1pbi55fHxhLm1pbi55PlxudGhpcy5tYXgueT8hMTohMH0sY2xhbXBQb2ludDpmdW5jdGlvbihhLGIpe3JldHVybihifHxuZXcgVEhSRUUuVmVjdG9yMikuY29weShhKS5jbGFtcCh0aGlzLm1pbix0aGlzLm1heCl9LGRpc3RhbmNlVG9Qb2ludDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IyO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gYS5jb3B5KGIpLmNsYW1wKHRoaXMubWluLHRoaXMubWF4KS5zdWIoYikubGVuZ3RoKCl9fSgpLGludGVyc2VjdDpmdW5jdGlvbihhKXt0aGlzLm1pbi5tYXgoYS5taW4pO3RoaXMubWF4Lm1pbihhLm1heCk7cmV0dXJuIHRoaXN9LHVuaW9uOmZ1bmN0aW9uKGEpe3RoaXMubWluLm1pbihhLm1pbik7dGhpcy5tYXgubWF4KGEubWF4KTtyZXR1cm4gdGhpc30sdHJhbnNsYXRlOmZ1bmN0aW9uKGEpe3RoaXMubWluLmFkZChhKTt0aGlzLm1heC5hZGQoYSk7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5taW4uZXF1YWxzKHRoaXMubWluKSYmXG4gICAgYS5tYXguZXF1YWxzKHRoaXMubWF4KX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4obmV3IFRIUkVFLkJveDIpLmNvcHkodGhpcyl9fTtUSFJFRS5Cb3gzPWZ1bmN0aW9uKGEsYil7dGhpcy5taW49dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5WZWN0b3IzKEluZmluaXR5LEluZmluaXR5LEluZmluaXR5KTt0aGlzLm1heD12b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlZlY3RvcjMoLUluZmluaXR5LC1JbmZpbml0eSwtSW5maW5pdHkpfTtcblRIUkVFLkJveDMucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5Cb3gzLHNldDpmdW5jdGlvbihhLGIpe3RoaXMubWluLmNvcHkoYSk7dGhpcy5tYXguY29weShiKTtyZXR1cm4gdGhpc30sc2V0RnJvbVBvaW50czpmdW5jdGlvbihhKXt0aGlzLm1ha2VFbXB0eSgpO2Zvcih2YXIgYj0wLGM9YS5sZW5ndGg7YjxjO2IrKyl0aGlzLmV4cGFuZEJ5UG9pbnQoYVtiXSk7cmV0dXJuIHRoaXN9LHNldEZyb21DZW50ZXJBbmRTaXplOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5jb3B5KGMpLm11bHRpcGx5U2NhbGFyKC41KTt0aGlzLm1pbi5jb3B5KGIpLnN1YihkKTt0aGlzLm1heC5jb3B5KGIpLmFkZChkKTtyZXR1cm4gdGhpc319KCksc2V0RnJvbU9iamVjdDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz10aGlzO2IudXBkYXRlTWF0cml4V29ybGQoITApO1xuICAgIHRoaXMubWFrZUVtcHR5KCk7Yi50cmF2ZXJzZShmdW5jdGlvbihiKXt2YXIgZT1iLmdlb21ldHJ5O2lmKHZvaWQgMCE9PWUpaWYoZSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5KWZvcih2YXIgZj1lLnZlcnRpY2VzLGU9MCxnPWYubGVuZ3RoO2U8ZztlKyspYS5jb3B5KGZbZV0pLGEuYXBwbHlNYXRyaXg0KGIubWF0cml4V29ybGQpLGMuZXhwYW5kQnlQb2ludChhKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSYmdm9pZCAwIT09ZS5hdHRyaWJ1dGVzLnBvc2l0aW9uKWZvcihmPWUuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSxlPTAsZz1mLmxlbmd0aDtlPGc7ZSs9MylhLnNldChmW2VdLGZbZSsxXSxmW2UrMl0pLGEuYXBwbHlNYXRyaXg0KGIubWF0cml4V29ybGQpLGMuZXhwYW5kQnlQb2ludChhKX0pO3JldHVybiB0aGlzfX0oKSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMubWluLmNvcHkoYS5taW4pO3RoaXMubWF4LmNvcHkoYS5tYXgpO3JldHVybiB0aGlzfSxcbiAgICBtYWtlRW1wdHk6ZnVuY3Rpb24oKXt0aGlzLm1pbi54PXRoaXMubWluLnk9dGhpcy5taW4uej1JbmZpbml0eTt0aGlzLm1heC54PXRoaXMubWF4Lnk9dGhpcy5tYXguej0tSW5maW5pdHk7cmV0dXJuIHRoaXN9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4Lng8dGhpcy5taW4ueHx8dGhpcy5tYXgueTx0aGlzLm1pbi55fHx0aGlzLm1heC56PHRoaXMubWluLnp9LGNlbnRlcjpmdW5jdGlvbihhKXtyZXR1cm4oYXx8bmV3IFRIUkVFLlZlY3RvcjMpLmFkZFZlY3RvcnModGhpcy5taW4sdGhpcy5tYXgpLm11bHRpcGx5U2NhbGFyKC41KX0sc2l6ZTpmdW5jdGlvbihhKXtyZXR1cm4oYXx8bmV3IFRIUkVFLlZlY3RvcjMpLnN1YlZlY3RvcnModGhpcy5tYXgsdGhpcy5taW4pfSxleHBhbmRCeVBvaW50OmZ1bmN0aW9uKGEpe3RoaXMubWluLm1pbihhKTt0aGlzLm1heC5tYXgoYSk7cmV0dXJuIHRoaXN9LGV4cGFuZEJ5VmVjdG9yOmZ1bmN0aW9uKGEpe3RoaXMubWluLnN1YihhKTtcbiAgICAgICAgdGhpcy5tYXguYWRkKGEpO3JldHVybiB0aGlzfSxleHBhbmRCeVNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLm1pbi5hZGRTY2FsYXIoLWEpO3RoaXMubWF4LmFkZFNjYWxhcihhKTtyZXR1cm4gdGhpc30sY29udGFpbnNQb2ludDpmdW5jdGlvbihhKXtyZXR1cm4gYS54PHRoaXMubWluLnh8fGEueD50aGlzLm1heC54fHxhLnk8dGhpcy5taW4ueXx8YS55PnRoaXMubWF4Lnl8fGEuejx0aGlzLm1pbi56fHxhLno+dGhpcy5tYXguej8hMTohMH0sY29udGFpbnNCb3g6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubWluLng8PWEubWluLngmJmEubWF4Lng8PXRoaXMubWF4LngmJnRoaXMubWluLnk8PWEubWluLnkmJmEubWF4Lnk8PXRoaXMubWF4LnkmJnRoaXMubWluLno8PWEubWluLnomJmEubWF4Lno8PXRoaXMubWF4Lno/ITA6ITF9LGdldFBhcmFtZXRlcjpmdW5jdGlvbihhLGIpe3JldHVybihifHxuZXcgVEhSRUUuVmVjdG9yMykuc2V0KChhLngtdGhpcy5taW4ueCkvKHRoaXMubWF4LngtXG4gICAgICAgIHRoaXMubWluLngpLChhLnktdGhpcy5taW4ueSkvKHRoaXMubWF4LnktdGhpcy5taW4ueSksKGEuei10aGlzLm1pbi56KS8odGhpcy5tYXguei10aGlzLm1pbi56KSl9LGlzSW50ZXJzZWN0aW9uQm94OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1heC54PHRoaXMubWluLnh8fGEubWluLng+dGhpcy5tYXgueHx8YS5tYXgueTx0aGlzLm1pbi55fHxhLm1pbi55PnRoaXMubWF4Lnl8fGEubWF4Lno8dGhpcy5taW4uenx8YS5taW4uej50aGlzLm1heC56PyExOiEwfSxjbGFtcFBvaW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuKGJ8fG5ldyBUSFJFRS5WZWN0b3IzKS5jb3B5KGEpLmNsYW1wKHRoaXMubWluLHRoaXMubWF4KX0sZGlzdGFuY2VUb1BvaW50OmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiBhLmNvcHkoYikuY2xhbXAodGhpcy5taW4sdGhpcy5tYXgpLnN1YihiKS5sZW5ndGgoKX19KCksZ2V0Qm91bmRpbmdTcGhlcmU6ZnVuY3Rpb24oKXt2YXIgYT1cbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIpe2I9Ynx8bmV3IFRIUkVFLlNwaGVyZTtiLmNlbnRlcj10aGlzLmNlbnRlcigpO2IucmFkaXVzPS41KnRoaXMuc2l6ZShhKS5sZW5ndGgoKTtyZXR1cm4gYn19KCksaW50ZXJzZWN0OmZ1bmN0aW9uKGEpe3RoaXMubWluLm1heChhLm1pbik7dGhpcy5tYXgubWluKGEubWF4KTtyZXR1cm4gdGhpc30sdW5pb246ZnVuY3Rpb24oYSl7dGhpcy5taW4ubWluKGEubWluKTt0aGlzLm1heC5tYXgoYS5tYXgpO3JldHVybiB0aGlzfSxhcHBseU1hdHJpeDQ6ZnVuY3Rpb24oKXt2YXIgYT1bbmV3IFRIUkVFLlZlY3RvcjMsbmV3IFRIUkVFLlZlY3RvcjMsbmV3IFRIUkVFLlZlY3RvcjMsbmV3IFRIUkVFLlZlY3RvcjMsbmV3IFRIUkVFLlZlY3RvcjMsbmV3IFRIUkVFLlZlY3RvcjMsbmV3IFRIUkVFLlZlY3RvcjMsbmV3IFRIUkVFLlZlY3RvcjNdO3JldHVybiBmdW5jdGlvbihiKXthWzBdLnNldCh0aGlzLm1pbi54LHRoaXMubWluLnksXG4gICAgICAgIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChiKTthWzFdLnNldCh0aGlzLm1pbi54LHRoaXMubWluLnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KGIpO2FbMl0uc2V0KHRoaXMubWluLngsdGhpcy5tYXgueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoYik7YVszXS5zZXQodGhpcy5taW4ueCx0aGlzLm1heC55LHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChiKTthWzRdLnNldCh0aGlzLm1heC54LHRoaXMubWluLnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KGIpO2FbNV0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoYik7YVs2XS5zZXQodGhpcy5tYXgueCx0aGlzLm1heC55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NChiKTthWzddLnNldCh0aGlzLm1heC54LHRoaXMubWF4LnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KGIpO3RoaXMubWFrZUVtcHR5KCk7dGhpcy5zZXRGcm9tUG9pbnRzKGEpO3JldHVybiB0aGlzfX0oKSx0cmFuc2xhdGU6ZnVuY3Rpb24oYSl7dGhpcy5taW4uYWRkKGEpO1xuICAgICAgICB0aGlzLm1heC5hZGQoYSk7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5taW4uZXF1YWxzKHRoaXMubWluKSYmYS5tYXguZXF1YWxzKHRoaXMubWF4KX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4obmV3IFRIUkVFLkJveDMpLmNvcHkodGhpcyl9fTtUSFJFRS5NYXRyaXgzPWZ1bmN0aW9uKCl7dGhpcy5lbGVtZW50cz1uZXcgRmxvYXQzMkFycmF5KFsxLDAsMCwwLDEsMCwwLDAsMV0pOzA8YXJndW1lbnRzLmxlbmd0aCYmVEhSRUUuZXJyb3IoXCJUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLlwiKX07XG5USFJFRS5NYXRyaXgzLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuTWF0cml4MyxzZXQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGspe3ZhciBsPXRoaXMuZWxlbWVudHM7bFswXT1hO2xbM109YjtsWzZdPWM7bFsxXT1kO2xbNF09ZTtsWzddPWY7bFsyXT1nO2xbNV09aDtsWzhdPWs7cmV0dXJuIHRoaXN9LGlkZW50aXR5OmZ1bmN0aW9uKCl7dGhpcy5zZXQoMSwwLDAsMCwxLDAsMCwwLDEpO3JldHVybiB0aGlzfSxjb3B5OmZ1bmN0aW9uKGEpe2E9YS5lbGVtZW50czt0aGlzLnNldChhWzBdLGFbM10sYVs2XSxhWzFdLGFbNF0sYVs3XSxhWzJdLGFbNV0sYVs4XSk7cmV0dXJuIHRoaXN9LG11bHRpcGx5VmVjdG9yMzpmdW5jdGlvbihhKXtUSFJFRS53YXJuKFwiVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLlwiKTtyZXR1cm4gYS5hcHBseU1hdHJpeDModGhpcyl9LFxuICAgIG11bHRpcGx5VmVjdG9yM0FycmF5OmZ1bmN0aW9uKGEpe1RIUkVFLndhcm4oXCJUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC5cIik7cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheShhKX0sYXBwbHlUb1ZlY3RvcjNBcnJheTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiLGMsZCl7dm9pZCAwPT09YyYmKGM9MCk7dm9pZCAwPT09ZCYmKGQ9Yi5sZW5ndGgpO2Zvcih2YXIgZT0wO2U8ZDtlKz0zLGMrPTMpYS54PWJbY10sYS55PWJbYysxXSxhLno9YltjKzJdLGEuYXBwbHlNYXRyaXgzKHRoaXMpLGJbY109YS54LGJbYysxXT1hLnksYltjKzJdPWEuejtyZXR1cm4gYn19KCksbXVsdGlwbHlTY2FsYXI6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50cztiWzBdKj1hO2JbM10qPWE7Yls2XSo9XG4gICAgICAgIGE7YlsxXSo9YTtiWzRdKj1hO2JbN10qPWE7YlsyXSo9YTtiWzVdKj1hO2JbOF0qPWE7cmV0dXJuIHRoaXN9LGRldGVybWluYW50OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50cyxiPWFbMF0sYz1hWzFdLGQ9YVsyXSxlPWFbM10sZj1hWzRdLGc9YVs1XSxoPWFbNl0saz1hWzddLGE9YVs4XTtyZXR1cm4gYipmKmEtYipnKmstYyplKmErYypnKmgrZCplKmstZCpmKmh9LGdldEludmVyc2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmVsZW1lbnRzLGQ9dGhpcy5lbGVtZW50cztkWzBdPWNbMTBdKmNbNV0tY1s2XSpjWzldO2RbMV09LWNbMTBdKmNbMV0rY1syXSpjWzldO2RbMl09Y1s2XSpjWzFdLWNbMl0qY1s1XTtkWzNdPS1jWzEwXSpjWzRdK2NbNl0qY1s4XTtkWzRdPWNbMTBdKmNbMF0tY1syXSpjWzhdO2RbNV09LWNbNl0qY1swXStjWzJdKmNbNF07ZFs2XT1jWzldKmNbNF0tY1s1XSpjWzhdO2RbN109LWNbOV0qY1swXStjWzFdKmNbOF07ZFs4XT1jWzVdKmNbMF0tY1sxXSpjWzRdO1xuICAgICAgICBjPWNbMF0qZFswXStjWzFdKmRbM10rY1syXSpkWzZdO2lmKDA9PT1jKXtpZihiKXRocm93IEVycm9yKFwiTWF0cml4My5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIik7VEhSRUUud2FybihcIk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCIpO3RoaXMuaWRlbnRpdHkoKTtyZXR1cm4gdGhpc310aGlzLm11bHRpcGx5U2NhbGFyKDEvYyk7cmV0dXJuIHRoaXN9LHRyYW5zcG9zZTpmdW5jdGlvbigpe3ZhciBhLGI9dGhpcy5lbGVtZW50czthPWJbMV07YlsxXT1iWzNdO2JbM109YTthPWJbMl07YlsyXT1iWzZdO2JbNl09YTthPWJbNV07Yls1XT1iWzddO2JbN109YTtyZXR1cm4gdGhpc30sZmxhdHRlblRvQXJyYXlPZmZzZXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmVsZW1lbnRzO2FbYl09Y1swXTthW2IrMV09Y1sxXTthW2IrMl09Y1syXTthW2IrM109Y1szXTthW2IrNF09Y1s0XTtcbiAgICAgICAgYVtiKzVdPWNbNV07YVtiKzZdPWNbNl07YVtiKzddPWNbN107YVtiKzhdPWNbOF07cmV0dXJuIGF9LGdldE5vcm1hbE1hdHJpeDpmdW5jdGlvbihhKXt0aGlzLmdldEludmVyc2UoYSkudHJhbnNwb3NlKCk7cmV0dXJuIHRoaXN9LHRyYW5zcG9zZUludG9BcnJheTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnRzO2FbMF09YlswXTthWzFdPWJbM107YVsyXT1iWzZdO2FbM109YlsxXTthWzRdPWJbNF07YVs1XT1iWzddO2FbNl09YlsyXTthWzddPWJbNV07YVs4XT1iWzhdO3JldHVybiB0aGlzfSxmcm9tQXJyYXk6ZnVuY3Rpb24oYSl7dGhpcy5lbGVtZW50cy5zZXQoYSk7cmV0dXJuIHRoaXN9LHRvQXJyYXk6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnRzO3JldHVyblthWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10sYVs4XV19LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBUSFJFRS5NYXRyaXgzKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyl9fTtcblRIUkVFLk1hdHJpeDQ9ZnVuY3Rpb24oKXt0aGlzLmVsZW1lbnRzPW5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdKTswPGFyZ3VtZW50cy5sZW5ndGgmJlRIUkVFLmVycm9yKFwiVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC5cIil9O1xuVEhSRUUuTWF0cml4NC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLk1hdHJpeDQsc2V0OmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrLGwscCxxLG4sdCxyLHMpe3ZhciB1PXRoaXMuZWxlbWVudHM7dVswXT1hO3VbNF09Yjt1WzhdPWM7dVsxMl09ZDt1WzFdPWU7dVs1XT1mO3VbOV09Zzt1WzEzXT1oO3VbMl09azt1WzZdPWw7dVsxMF09cDt1WzE0XT1xO3VbM109bjt1WzddPXQ7dVsxMV09cjt1WzE1XT1zO3JldHVybiB0aGlzfSxpZGVudGl0eTpmdW5jdGlvbigpe3RoaXMuc2V0KDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDEpO3JldHVybiB0aGlzfSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMuZWxlbWVudHMuc2V0KGEuZWxlbWVudHMpO3JldHVybiB0aGlzfSxleHRyYWN0UG9zaXRpb246ZnVuY3Rpb24oYSl7VEhSRUUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5leHRyYWN0UG9zaXRpb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5jb3B5UG9zaXRpb24oKS5cIik7cmV0dXJuIHRoaXMuY29weVBvc2l0aW9uKGEpfSxcbiAgICBjb3B5UG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50czthPWEuZWxlbWVudHM7YlsxMl09YVsxMl07YlsxM109YVsxM107YlsxNF09YVsxNF07cmV0dXJuIHRoaXN9LGV4dHJhY3RCYXNpczpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5lbGVtZW50czthLnNldChkWzBdLGRbMV0sZFsyXSk7Yi5zZXQoZFs0XSxkWzVdLGRbNl0pO2Muc2V0KGRbOF0sZFs5XSxkWzEwXSk7cmV0dXJuIHRoaXN9LG1ha2VCYXNpczpmdW5jdGlvbihhLGIsYyl7dGhpcy5zZXQoYS54LGIueCxjLngsMCxhLnksYi55LGMueSwwLGEueixiLnosYy56LDAsMCwwLDAsMSk7cmV0dXJuIHRoaXN9LGV4dHJhY3RSb3RhdGlvbjpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz10aGlzLmVsZW1lbnRzO2I9Yi5lbGVtZW50czt2YXIgZD0xL2Euc2V0KGJbMF0sYlsxXSxiWzJdKS5sZW5ndGgoKSxlPTEvYS5zZXQoYls0XSxiWzVdLGJbNl0pLmxlbmd0aCgpLFxuICAgICAgICBmPTEvYS5zZXQoYls4XSxiWzldLGJbMTBdKS5sZW5ndGgoKTtjWzBdPWJbMF0qZDtjWzFdPWJbMV0qZDtjWzJdPWJbMl0qZDtjWzRdPWJbNF0qZTtjWzVdPWJbNV0qZTtjWzZdPWJbNl0qZTtjWzhdPWJbOF0qZjtjWzldPWJbOV0qZjtjWzEwXT1iWzEwXSpmO3JldHVybiB0aGlzfX0oKSxtYWtlUm90YXRpb25Gcm9tRXVsZXI6ZnVuY3Rpb24oYSl7ITE9PT1hIGluc3RhbmNlb2YgVEhSRUUuRXVsZXImJlRIUkVFLmVycm9yKFwiVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLlwiKTt2YXIgYj10aGlzLmVsZW1lbnRzLGM9YS54LGQ9YS55LGU9YS56LGY9TWF0aC5jb3MoYyksYz1NYXRoLnNpbihjKSxnPU1hdGguY29zKGQpLGQ9TWF0aC5zaW4oZCksaD1NYXRoLmNvcyhlKSxlPU1hdGguc2luKGUpO2lmKFwiWFlaXCI9PT1hLm9yZGVyKXthPWYqaDt2YXIgaz1mKmUsXG4gICAgICAgIGw9YypoLHA9YyplO2JbMF09ZypoO2JbNF09LWcqZTtiWzhdPWQ7YlsxXT1rK2wqZDtiWzVdPWEtcCpkO2JbOV09LWMqZztiWzJdPXAtYSpkO2JbNl09bCtrKmQ7YlsxMF09ZipnfWVsc2VcIllYWlwiPT09YS5vcmRlcj8oYT1nKmgsaz1nKmUsbD1kKmgscD1kKmUsYlswXT1hK3AqYyxiWzRdPWwqYy1rLGJbOF09ZipkLGJbMV09ZiplLGJbNV09ZipoLGJbOV09LWMsYlsyXT1rKmMtbCxiWzZdPXArYSpjLGJbMTBdPWYqZyk6XCJaWFlcIj09PWEub3JkZXI/KGE9ZypoLGs9ZyplLGw9ZCpoLHA9ZCplLGJbMF09YS1wKmMsYls0XT0tZiplLGJbOF09bCtrKmMsYlsxXT1rK2wqYyxiWzVdPWYqaCxiWzldPXAtYSpjLGJbMl09LWYqZCxiWzZdPWMsYlsxMF09ZipnKTpcIlpZWFwiPT09YS5vcmRlcj8oYT1mKmgsaz1mKmUsbD1jKmgscD1jKmUsYlswXT1nKmgsYls0XT1sKmQtayxiWzhdPWEqZCtwLGJbMV09ZyplLGJbNV09cCpkK2EsYls5XT1rKmQtbCxiWzJdPS1kLGJbNl09YypnLGJbMTBdPWYqZyk6XCJZWlhcIj09PVxuICAgIGEub3JkZXI/KGE9ZipnLGs9ZipkLGw9YypnLHA9YypkLGJbMF09ZypoLGJbNF09cC1hKmUsYls4XT1sKmUrayxiWzFdPWUsYls1XT1mKmgsYls5XT0tYypoLGJbMl09LWQqaCxiWzZdPWsqZStsLGJbMTBdPWEtcCplKTpcIlhaWVwiPT09YS5vcmRlciYmKGE9ZipnLGs9ZipkLGw9YypnLHA9YypkLGJbMF09ZypoLGJbNF09LWUsYls4XT1kKmgsYlsxXT1hKmUrcCxiWzVdPWYqaCxiWzldPWsqZS1sLGJbMl09bCplLWssYls2XT1jKmgsYlsxMF09cCplK2EpO2JbM109MDtiWzddPTA7YlsxMV09MDtiWzEyXT0wO2JbMTNdPTA7YlsxNF09MDtiWzE1XT0xO3JldHVybiB0aGlzfSxzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOmZ1bmN0aW9uKGEpe1RIUkVFLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuXCIpO3JldHVybiB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGEpfSxcbiAgICBtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnRzLGM9YS54LGQ9YS55LGU9YS56LGY9YS53LGc9YytjLGg9ZCtkLGs9ZStlO2E9YypnO3ZhciBsPWMqaCxjPWMqayxwPWQqaCxkPWQqayxlPWUqayxnPWYqZyxoPWYqaCxmPWYqaztiWzBdPTEtKHArZSk7Yls0XT1sLWY7Yls4XT1jK2g7YlsxXT1sK2Y7Yls1XT0xLShhK2UpO2JbOV09ZC1nO2JbMl09Yy1oO2JbNl09ZCtnO2JbMTBdPTEtKGErcCk7YlszXT0wO2JbN109MDtiWzExXT0wO2JbMTJdPTA7YlsxM109MDtiWzE0XT0wO2JbMTVdPTE7cmV0dXJuIHRoaXN9LGxvb2tBdDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzLGI9bmV3IFRIUkVFLlZlY3RvcjMsYz1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oZCxlLGYpe3ZhciBnPXRoaXMuZWxlbWVudHM7Yy5zdWJWZWN0b3JzKGQsZSkubm9ybWFsaXplKCk7MD09PWMubGVuZ3RoKCkmJihjLno9MSk7YS5jcm9zc1ZlY3RvcnMoZixcbiAgICAgICAgYykubm9ybWFsaXplKCk7MD09PWEubGVuZ3RoKCkmJihjLngrPTFFLTQsYS5jcm9zc1ZlY3RvcnMoZixjKS5ub3JtYWxpemUoKSk7Yi5jcm9zc1ZlY3RvcnMoYyxhKTtnWzBdPWEueDtnWzRdPWIueDtnWzhdPWMueDtnWzFdPWEueTtnWzVdPWIueTtnWzldPWMueTtnWzJdPWEuejtnWzZdPWIuejtnWzEwXT1jLno7cmV0dXJuIHRoaXN9fSgpLG11bHRpcGx5OmZ1bmN0aW9uKGEsYil7cmV0dXJuIHZvaWQgMCE9PWI/KFRIUkVFLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC5cIiksdGhpcy5tdWx0aXBseU1hdHJpY2VzKGEsYikpOnRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLGEpfSxtdWx0aXBseU1hdHJpY2VzOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5lbGVtZW50cyxkPWIuZWxlbWVudHMsZT10aGlzLmVsZW1lbnRzLGY9Y1swXSxnPWNbNF0saD1jWzhdLFxuICAgICAgICBrPWNbMTJdLGw9Y1sxXSxwPWNbNV0scT1jWzldLG49Y1sxM10sdD1jWzJdLHI9Y1s2XSxzPWNbMTBdLHU9Y1sxNF0sdj1jWzNdLHg9Y1s3XSxEPWNbMTFdLGM9Y1sxNV0sdz1kWzBdLHk9ZFs0XSxBPWRbOF0sRT1kWzEyXSxHPWRbMV0sRj1kWzVdLHo9ZFs5XSxJPWRbMTNdLFU9ZFsyXSxNPWRbNl0sSD1kWzEwXSxMPWRbMTRdLFA9ZFszXSxOPWRbN10sUj1kWzExXSxkPWRbMTVdO2VbMF09Zip3K2cqRytoKlUraypQO2VbNF09Zip5K2cqRitoKk0raypOO2VbOF09ZipBK2cqeitoKkgraypSO2VbMTJdPWYqRStnKkkraCpMK2sqZDtlWzFdPWwqdytwKkcrcSpVK24qUDtlWzVdPWwqeStwKkYrcSpNK24qTjtlWzldPWwqQStwKnorcSpIK24qUjtlWzEzXT1sKkUrcCpJK3EqTCtuKmQ7ZVsyXT10KncrcipHK3MqVSt1KlA7ZVs2XT10KnkrcipGK3MqTSt1Kk47ZVsxMF09dCpBK3IqeitzKkgrdSpSO2VbMTRdPXQqRStyKkkrcypMK3UqZDtlWzNdPXYqdyt4KkcrRCpVK2MqUDtlWzddPXYqeStcbiAgICAgICAgeCpGK0QqTStjKk47ZVsxMV09dipBK3gqeitEKkgrYypSO2VbMTVdPXYqRSt4KkkrRCpMK2MqZDtyZXR1cm4gdGhpc30sbXVsdGlwbHlUb0FycmF5OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmVsZW1lbnRzO3RoaXMubXVsdGlwbHlNYXRyaWNlcyhhLGIpO2NbMF09ZFswXTtjWzFdPWRbMV07Y1syXT1kWzJdO2NbM109ZFszXTtjWzRdPWRbNF07Y1s1XT1kWzVdO2NbNl09ZFs2XTtjWzddPWRbN107Y1s4XT1kWzhdO2NbOV09ZFs5XTtjWzEwXT1kWzEwXTtjWzExXT1kWzExXTtjWzEyXT1kWzEyXTtjWzEzXT1kWzEzXTtjWzE0XT1kWzE0XTtjWzE1XT1kWzE1XTtyZXR1cm4gdGhpc30sbXVsdGlwbHlTY2FsYXI6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50cztiWzBdKj1hO2JbNF0qPWE7Yls4XSo9YTtiWzEyXSo9YTtiWzFdKj1hO2JbNV0qPWE7Yls5XSo9YTtiWzEzXSo9YTtiWzJdKj1hO2JbNl0qPWE7YlsxMF0qPWE7YlsxNF0qPWE7YlszXSo9YTtiWzddKj1hO2JbMTFdKj1cbiAgICAgICAgYTtiWzE1XSo9YTtyZXR1cm4gdGhpc30sbXVsdGlwbHlWZWN0b3IzOmZ1bmN0aW9uKGEpe1RIUkVFLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIG9yIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuXCIpO3JldHVybiBhLmFwcGx5UHJvamVjdGlvbih0aGlzKX0sbXVsdGlwbHlWZWN0b3I0OmZ1bmN0aW9uKGEpe1RIUkVFLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuXCIpO3JldHVybiBhLmFwcGx5TWF0cml4NCh0aGlzKX0sbXVsdGlwbHlWZWN0b3IzQXJyYXk6ZnVuY3Rpb24oYSl7VEhSRUUud2FybihcIlRIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheShhKX0sYXBwbHlUb1ZlY3RvcjNBcnJheTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiLGMsZCl7dm9pZCAwPT09YyYmKGM9MCk7dm9pZCAwPT09ZCYmKGQ9Yi5sZW5ndGgpO2Zvcih2YXIgZT0wO2U8ZDtlKz0zLGMrPTMpYS54PWJbY10sYS55PWJbYysxXSxhLno9YltjKzJdLGEuYXBwbHlNYXRyaXg0KHRoaXMpLGJbY109YS54LGJbYysxXT1hLnksYltjKzJdPWEuejtyZXR1cm4gYn19KCkscm90YXRlQXhpczpmdW5jdGlvbihhKXtUSFJFRS53YXJuKFwiVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuXCIpO2EudHJhbnNmb3JtRGlyZWN0aW9uKHRoaXMpfSxjcm9zc1ZlY3RvcjpmdW5jdGlvbihhKXtUSFJFRS53YXJuKFwiVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuXCIpO1xuICAgICAgICByZXR1cm4gYS5hcHBseU1hdHJpeDQodGhpcyl9LGRldGVybWluYW50OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50cyxiPWFbMF0sYz1hWzRdLGQ9YVs4XSxlPWFbMTJdLGY9YVsxXSxnPWFbNV0saD1hWzldLGs9YVsxM10sbD1hWzJdLHA9YVs2XSxxPWFbMTBdLG49YVsxNF07cmV0dXJuIGFbM10qKCtlKmgqcC1kKmsqcC1lKmcqcStjKmsqcStkKmcqbi1jKmgqbikrYVs3XSooK2IqaCpuLWIqaypxK2UqZipxLWQqZipuK2QqaypsLWUqaCpsKSthWzExXSooK2IqaypwLWIqZypuLWUqZipwK2MqZipuK2UqZypsLWMqaypsKSthWzE1XSooLWQqZypsLWIqaCpwK2IqZypxK2QqZipwLWMqZipxK2MqaCpsKX0sdHJhbnNwb3NlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50cyxiO2I9YVsxXTthWzFdPWFbNF07YVs0XT1iO2I9YVsyXTthWzJdPWFbOF07YVs4XT1iO2I9YVs2XTthWzZdPWFbOV07YVs5XT1iO2I9YVszXTthWzNdPWFbMTJdO2FbMTJdPWI7Yj1hWzddO2FbN109YVsxM107XG4gICAgICAgIGFbMTNdPWI7Yj1hWzExXTthWzExXT1hWzE0XTthWzE0XT1iO3JldHVybiB0aGlzfSxmbGF0dGVuVG9BcnJheU9mZnNldDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZWxlbWVudHM7YVtiXT1jWzBdO2FbYisxXT1jWzFdO2FbYisyXT1jWzJdO2FbYiszXT1jWzNdO2FbYis0XT1jWzRdO2FbYis1XT1jWzVdO2FbYis2XT1jWzZdO2FbYis3XT1jWzddO2FbYis4XT1jWzhdO2FbYis5XT1jWzldO2FbYisxMF09Y1sxMF07YVtiKzExXT1jWzExXTthW2IrMTJdPWNbMTJdO2FbYisxM109Y1sxM107YVtiKzE0XT1jWzE0XTthW2IrMTVdPWNbMTVdO3JldHVybiBhfSxnZXRQb3NpdGlvbjpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbigpe1RIUkVFLndhcm4oXCJUSFJFRS5NYXRyaXg0OiAuZ2V0UG9zaXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG1hdHJpeCApIGluc3RlYWQuXCIpO3ZhciBiPVxuICAgICAgICB0aGlzLmVsZW1lbnRzO3JldHVybiBhLnNldChiWzEyXSxiWzEzXSxiWzE0XSl9fSgpLHNldFBvc2l0aW9uOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudHM7YlsxMl09YS54O2JbMTNdPWEueTtiWzE0XT1hLno7cmV0dXJuIHRoaXN9LGdldEludmVyc2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmVsZW1lbnRzLGQ9YS5lbGVtZW50cyxlPWRbMF0sZj1kWzRdLGc9ZFs4XSxoPWRbMTJdLGs9ZFsxXSxsPWRbNV0scD1kWzldLHE9ZFsxM10sbj1kWzJdLHQ9ZFs2XSxyPWRbMTBdLHM9ZFsxNF0sdT1kWzNdLHY9ZFs3XSx4PWRbMTFdLGQ9ZFsxNV07Y1swXT1wKnMqdi1xKnIqditxKnQqeC1sKnMqeC1wKnQqZCtsKnIqZDtjWzRdPWgqcip2LWcqcyp2LWgqdCp4K2Yqcyp4K2cqdCpkLWYqcipkO2NbOF09ZypxKnYtaCpwKnYraCpsKngtZipxKngtZypsKmQrZipwKmQ7Y1sxMl09aCpwKnQtZypxKnQtaCpsKnIrZipxKnIrZypsKnMtZipwKnM7Y1sxXT1xKnIqdS1wKnMqdS1xKm4qeCtcbiAgICAgICAgaypzKngrcCpuKmQtaypyKmQ7Y1s1XT1nKnMqdS1oKnIqdStoKm4qeC1lKnMqeC1nKm4qZCtlKnIqZDtjWzldPWgqcCp1LWcqcSp1LWgqayp4K2UqcSp4K2cqaypkLWUqcCpkO2NbMTNdPWcqcSpuLWgqcCpuK2gqaypyLWUqcSpyLWcqaypzK2UqcCpzO2NbMl09bCpzKnUtcSp0KnUrcSpuKnYtaypzKnYtbCpuKmQrayp0KmQ7Y1s2XT1oKnQqdS1mKnMqdS1oKm4qditlKnMqditmKm4qZC1lKnQqZDtjWzEwXT1mKnEqdS1oKmwqdStoKmsqdi1lKnEqdi1mKmsqZCtlKmwqZDtjWzE0XT1oKmwqbi1mKnEqbi1oKmsqdCtlKnEqdCtmKmsqcy1lKmwqcztjWzNdPXAqdCp1LWwqcip1LXAqbip2K2sqcip2K2wqbip4LWsqdCp4O2NbN109ZipyKnUtZyp0KnUrZypuKnYtZSpyKnYtZipuKngrZSp0Kng7Y1sxMV09ZypsKnUtZipwKnUtZyprKnYrZSpwKnYrZiprKngtZSpsKng7Y1sxNV09ZipwKm4tZypsKm4rZyprKnQtZSpwKnQtZiprKnIrZSpsKnI7Yz1lKmNbMF0raypjWzRdK24qY1s4XSt1KmNbMTJdO1xuICAgICAgICBpZigwPT1jKXtpZihiKXRocm93IEVycm9yKFwiVEhSRUUuTWF0cml4NC5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIik7VEhSRUUud2FybihcIlRIUkVFLk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCIpO3RoaXMuaWRlbnRpdHkoKTtyZXR1cm4gdGhpc310aGlzLm11bHRpcGx5U2NhbGFyKDEvYyk7cmV0dXJuIHRoaXN9LHRyYW5zbGF0ZTpmdW5jdGlvbihhKXtUSFJFRS5lcnJvcihcIlRIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0scm90YXRlWDpmdW5jdGlvbihhKXtUSFJFRS5lcnJvcihcIlRIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHJvdGF0ZVk6ZnVuY3Rpb24oYSl7VEhSRUUuZXJyb3IoXCJUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxyb3RhdGVaOmZ1bmN0aW9uKGEpe1RIUkVFLmVycm9yKFwiVEhSRUUuTWF0cml4NDogLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0sXG4gICAgcm90YXRlQnlBeGlzOmZ1bmN0aW9uKGEsYil7VEhSRUUuZXJyb3IoXCJUSFJFRS5NYXRyaXg0OiAucm90YXRlQnlBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHNjYWxlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudHMsYz1hLngsZD1hLnk7YT1hLno7YlswXSo9YztiWzRdKj1kO2JbOF0qPWE7YlsxXSo9YztiWzVdKj1kO2JbOV0qPWE7YlsyXSo9YztiWzZdKj1kO2JbMTBdKj1hO2JbM10qPWM7Yls3XSo9ZDtiWzExXSo9YTtyZXR1cm4gdGhpc30sZ2V0TWF4U2NhbGVPbkF4aXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnRzO3JldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoYVswXSphWzBdK2FbMV0qYVsxXSthWzJdKmFbMl0sTWF0aC5tYXgoYVs0XSphWzRdK2FbNV0qYVs1XSthWzZdKmFbNl0sYVs4XSphWzhdK2FbOV0qYVs5XSthWzEwXSphWzEwXSkpKX0sbWFrZVRyYW5zbGF0aW9uOmZ1bmN0aW9uKGEsYixjKXt0aGlzLnNldCgxLDAsMCxhLDAsMSwwLGIsMCwwLDEsXG4gICAgICAgIGMsMCwwLDAsMSk7cmV0dXJuIHRoaXN9LG1ha2VSb3RhdGlvblg6ZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5jb3MoYSk7YT1NYXRoLnNpbihhKTt0aGlzLnNldCgxLDAsMCwwLDAsYiwtYSwwLDAsYSxiLDAsMCwwLDAsMSk7cmV0dXJuIHRoaXN9LG1ha2VSb3RhdGlvblk6ZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5jb3MoYSk7YT1NYXRoLnNpbihhKTt0aGlzLnNldChiLDAsYSwwLDAsMSwwLDAsLWEsMCxiLDAsMCwwLDAsMSk7cmV0dXJuIHRoaXN9LG1ha2VSb3RhdGlvblo6ZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5jb3MoYSk7YT1NYXRoLnNpbihhKTt0aGlzLnNldChiLC1hLDAsMCxhLGIsMCwwLDAsMCwxLDAsMCwwLDAsMSk7cmV0dXJuIHRoaXN9LG1ha2VSb3RhdGlvbkF4aXM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1NYXRoLmNvcyhiKSxkPU1hdGguc2luKGIpLGU9MS1jLGY9YS54LGc9YS55LGg9YS56LGs9ZSpmLGw9ZSpnO3RoaXMuc2V0KGsqZitjLGsqZy1kKmgsaypoK2QqZywwLGsqZytcbiAgICAgICAgZCpoLGwqZytjLGwqaC1kKmYsMCxrKmgtZCpnLGwqaCtkKmYsZSpoKmgrYywwLDAsMCwwLDEpO3JldHVybiB0aGlzfSxtYWtlU2NhbGU6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuc2V0KGEsMCwwLDAsMCxiLDAsMCwwLDAsYywwLDAsMCwwLDEpO3JldHVybiB0aGlzfSxjb21wb3NlOmZ1bmN0aW9uKGEsYixjKXt0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGIpO3RoaXMuc2NhbGUoYyk7dGhpcy5zZXRQb3NpdGlvbihhKTtyZXR1cm4gdGhpc30sZGVjb21wb3NlOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuTWF0cml4NDtyZXR1cm4gZnVuY3Rpb24oYyxkLGUpe3ZhciBmPXRoaXMuZWxlbWVudHMsZz1hLnNldChmWzBdLGZbMV0sZlsyXSkubGVuZ3RoKCksaD1hLnNldChmWzRdLGZbNV0sZls2XSkubGVuZ3RoKCksaz1hLnNldChmWzhdLGZbOV0sZlsxMF0pLmxlbmd0aCgpOzA+dGhpcy5kZXRlcm1pbmFudCgpJiYoZz0tZyk7Yy54PWZbMTJdO1xuICAgICAgICBjLnk9ZlsxM107Yy56PWZbMTRdO2IuZWxlbWVudHMuc2V0KHRoaXMuZWxlbWVudHMpO2M9MS9nO3ZhciBmPTEvaCxsPTEvaztiLmVsZW1lbnRzWzBdKj1jO2IuZWxlbWVudHNbMV0qPWM7Yi5lbGVtZW50c1syXSo9YztiLmVsZW1lbnRzWzRdKj1mO2IuZWxlbWVudHNbNV0qPWY7Yi5lbGVtZW50c1s2XSo9ZjtiLmVsZW1lbnRzWzhdKj1sO2IuZWxlbWVudHNbOV0qPWw7Yi5lbGVtZW50c1sxMF0qPWw7ZC5zZXRGcm9tUm90YXRpb25NYXRyaXgoYik7ZS54PWc7ZS55PWg7ZS56PWs7cmV0dXJuIHRoaXN9fSgpLG1ha2VGcnVzdHVtOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz10aGlzLmVsZW1lbnRzO2dbMF09MiplLyhiLWEpO2dbNF09MDtnWzhdPShiK2EpLyhiLWEpO2dbMTJdPTA7Z1sxXT0wO2dbNV09MiplLyhkLWMpO2dbOV09KGQrYykvKGQtYyk7Z1sxM109MDtnWzJdPTA7Z1s2XT0wO2dbMTBdPS0oZitlKS8oZi1lKTtnWzE0XT0tMipmKmUvKGYtZSk7Z1szXT0wO2dbN109MDtcbiAgICAgICAgZ1sxMV09LTE7Z1sxNV09MDtyZXR1cm4gdGhpc30sbWFrZVBlcnNwZWN0aXZlOmZ1bmN0aW9uKGEsYixjLGQpe2E9YypNYXRoLnRhbihUSFJFRS5NYXRoLmRlZ1RvUmFkKC41KmEpKTt2YXIgZT0tYTtyZXR1cm4gdGhpcy5tYWtlRnJ1c3R1bShlKmIsYSpiLGUsYSxjLGQpfSxtYWtlT3J0aG9ncmFwaGljOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz10aGlzLmVsZW1lbnRzLGg9Yi1hLGs9Yy1kLGw9Zi1lO2dbMF09Mi9oO2dbNF09MDtnWzhdPTA7Z1sxMl09LSgoYithKS9oKTtnWzFdPTA7Z1s1XT0yL2s7Z1s5XT0wO2dbMTNdPS0oKGMrZCkvayk7Z1syXT0wO2dbNl09MDtnWzEwXT0tMi9sO2dbMTRdPS0oKGYrZSkvbCk7Z1szXT0wO2dbN109MDtnWzExXT0wO2dbMTVdPTE7cmV0dXJuIHRoaXN9LGZyb21BcnJheTpmdW5jdGlvbihhKXt0aGlzLmVsZW1lbnRzLnNldChhKTtyZXR1cm4gdGhpc30sdG9BcnJheTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudHM7cmV0dXJuW2FbMF0sXG4gICAgICAgIGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10sYVs4XSxhWzldLGFbMTBdLGFbMTFdLGFbMTJdLGFbMTNdLGFbMTRdLGFbMTVdXX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4obmV3IFRIUkVFLk1hdHJpeDQpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKX19O1RIUkVFLlJheT1mdW5jdGlvbihhLGIpe3RoaXMub3JpZ2luPXZvaWQgMCE9PWE/YTpuZXcgVEhSRUUuVmVjdG9yMzt0aGlzLmRpcmVjdGlvbj12b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlZlY3RvcjN9O1xuVEhSRUUuUmF5LnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuUmF5LHNldDpmdW5jdGlvbihhLGIpe3RoaXMub3JpZ2luLmNvcHkoYSk7dGhpcy5kaXJlY3Rpb24uY29weShiKTtyZXR1cm4gdGhpc30sY29weTpmdW5jdGlvbihhKXt0aGlzLm9yaWdpbi5jb3B5KGEub3JpZ2luKTt0aGlzLmRpcmVjdGlvbi5jb3B5KGEuZGlyZWN0aW9uKTtyZXR1cm4gdGhpc30sYXQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYnx8bmV3IFRIUkVFLlZlY3RvcjMpLmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKGEpLmFkZCh0aGlzLm9yaWdpbil9LHJlY2FzdDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiKXt0aGlzLm9yaWdpbi5jb3B5KHRoaXMuYXQoYixhKSk7cmV0dXJuIHRoaXN9fSgpLGNsb3Nlc3RQb2ludFRvUG9pbnQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1ifHxuZXcgVEhSRUUuVmVjdG9yMztjLnN1YlZlY3RvcnMoYSx0aGlzLm9yaWdpbik7XG4gICAgdmFyIGQ9Yy5kb3QodGhpcy5kaXJlY3Rpb24pO3JldHVybiAwPmQ/Yy5jb3B5KHRoaXMub3JpZ2luKTpjLmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKGQpLmFkZCh0aGlzLm9yaWdpbil9LGRpc3RhbmNlVG9Qb2ludDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1hLnN1YlZlY3RvcnMoYix0aGlzLm9yaWdpbikuZG90KHRoaXMuZGlyZWN0aW9uKTtpZigwPmMpcmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG8oYik7YS5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihjKS5hZGQodGhpcy5vcmlnaW4pO3JldHVybiBhLmRpc3RhbmNlVG8oYil9fSgpLGRpc3RhbmNlU3FUb1NlZ21lbnQ6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5WZWN0b3IzLGM9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGQsZSxmLGcpe2EuY29weShkKS5hZGQoZSkubXVsdGlwbHlTY2FsYXIoLjUpO1xuICAgIGIuY29weShlKS5zdWIoZCkubm9ybWFsaXplKCk7Yy5jb3B5KHRoaXMub3JpZ2luKS5zdWIoYSk7dmFyIGg9LjUqZC5kaXN0YW5jZVRvKGUpLGs9LXRoaXMuZGlyZWN0aW9uLmRvdChiKSxsPWMuZG90KHRoaXMuZGlyZWN0aW9uKSxwPS1jLmRvdChiKSxxPWMubGVuZ3RoU3EoKSxuPU1hdGguYWJzKDEtayprKSx0OzA8bj8oZD1rKnAtbCxlPWsqbC1wLHQ9aCpuLDA8PWQ/ZT49LXQ/ZTw9dD8oaD0xL24sZCo9aCxlKj1oLGs9ZCooZCtrKmUrMipsKStlKihrKmQrZSsyKnApK3EpOihlPWgsZD1NYXRoLm1heCgwLC0oayplK2wpKSxrPS1kKmQrZSooZSsyKnApK3EpOihlPS1oLGQ9TWF0aC5tYXgoMCwtKGsqZStsKSksaz0tZCpkK2UqKGUrMipwKStxKTplPD0tdD8oZD1NYXRoLm1heCgwLC0oLWsqaCtsKSksZT0wPGQ/LWg6TWF0aC5taW4oTWF0aC5tYXgoLWgsLXApLGgpLGs9LWQqZCtlKihlKzIqcCkrcSk6ZTw9dD8oZD0wLGU9TWF0aC5taW4oTWF0aC5tYXgoLWgsLXApLGgpLGs9ZSooZStcbiAgICAgICAgMipwKStxKTooZD1NYXRoLm1heCgwLC0oaypoK2wpKSxlPTA8ZD9oOk1hdGgubWluKE1hdGgubWF4KC1oLC1wKSxoKSxrPS1kKmQrZSooZSsyKnApK3EpKTooZT0wPGs/LWg6aCxkPU1hdGgubWF4KDAsLShrKmUrbCkpLGs9LWQqZCtlKihlKzIqcCkrcSk7ZiYmZi5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihkKS5hZGQodGhpcy5vcmlnaW4pO2cmJmcuY29weShiKS5tdWx0aXBseVNjYWxhcihlKS5hZGQoYSk7cmV0dXJuIGt9fSgpLGlzSW50ZXJzZWN0aW9uU3BoZXJlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludChhLmNlbnRlcik8PWEucmFkaXVzfSxpbnRlcnNlY3RTcGhlcmU6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYixjKXthLnN1YlZlY3RvcnMoYi5jZW50ZXIsdGhpcy5vcmlnaW4pO3ZhciBkPWEuZG90KHRoaXMuZGlyZWN0aW9uKSxlPWEuZG90KGEpLWQqZCxmPWIucmFkaXVzKmIucmFkaXVzO1xuICAgIGlmKGU+ZilyZXR1cm4gbnVsbDtmPU1hdGguc3FydChmLWUpO2U9ZC1mO2QrPWY7cmV0dXJuIDA+ZSYmMD5kP251bGw6MD5lP3RoaXMuYXQoZCxjKTp0aGlzLmF0KGUsYyl9fSgpLGlzSW50ZXJzZWN0aW9uUGxhbmU6ZnVuY3Rpb24oYSl7dmFyIGI9YS5kaXN0YW5jZVRvUG9pbnQodGhpcy5vcmlnaW4pO3JldHVybiAwPT09Ynx8MD5hLm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pKmI/ITA6ITF9LGRpc3RhbmNlVG9QbGFuZTpmdW5jdGlvbihhKXt2YXIgYj1hLm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pO2lmKDA9PWIpcmV0dXJuIDA9PWEuZGlzdGFuY2VUb1BvaW50KHRoaXMub3JpZ2luKT8wOm51bGw7YT0tKHRoaXMub3JpZ2luLmRvdChhLm5vcm1hbCkrYS5jb25zdGFudCkvYjtyZXR1cm4gMDw9YT9hOm51bGx9LGludGVyc2VjdFBsYW5lOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5kaXN0YW5jZVRvUGxhbmUoYSk7cmV0dXJuIG51bGw9PT1jP251bGw6dGhpcy5hdChjLGIpfSxcbiAgICBpc0ludGVyc2VjdGlvbkJveDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gbnVsbCE9PXRoaXMuaW50ZXJzZWN0Qm94KGIsYSl9fSgpLGludGVyc2VjdEJveDpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGc7ZD0xL3RoaXMuZGlyZWN0aW9uLng7Zj0xL3RoaXMuZGlyZWN0aW9uLnk7Zz0xL3RoaXMuZGlyZWN0aW9uLno7dmFyIGg9dGhpcy5vcmlnaW47MDw9ZD8oYz0oYS5taW4ueC1oLngpKmQsZCo9YS5tYXgueC1oLngpOihjPShhLm1heC54LWgueCkqZCxkKj1hLm1pbi54LWgueCk7MDw9Zj8oZT0oYS5taW4ueS1oLnkpKmYsZio9YS5tYXgueS1oLnkpOihlPShhLm1heC55LWgueSkqZixmKj1hLm1pbi55LWgueSk7aWYoYz5mfHxlPmQpcmV0dXJuIG51bGw7aWYoZT5jfHxjIT09YyljPWU7aWYoZjxkfHxkIT09ZClkPWY7MDw9Zz8oZT0oYS5taW4uei1oLnopKmcsZyo9YS5tYXguei1oLnopOihlPShhLm1heC56LWgueikqXG4gICAgICAgIGcsZyo9YS5taW4uei1oLnopO2lmKGM+Z3x8ZT5kKXJldHVybiBudWxsO2lmKGU+Y3x8YyE9PWMpYz1lO2lmKGc8ZHx8ZCE9PWQpZD1nO3JldHVybiAwPmQ/bnVsbDp0aGlzLmF0KDA8PWM/YzpkLGIpfSxpbnRlcnNlY3RUcmlhbmdsZTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzLGI9bmV3IFRIUkVFLlZlY3RvcjMsYz1uZXcgVEhSRUUuVmVjdG9yMyxkPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihlLGYsZyxoLGspe2Iuc3ViVmVjdG9ycyhmLGUpO2Muc3ViVmVjdG9ycyhnLGUpO2QuY3Jvc3NWZWN0b3JzKGIsYyk7Zj10aGlzLmRpcmVjdGlvbi5kb3QoZCk7aWYoMDxmKXtpZihoKXJldHVybiBudWxsO2g9MX1lbHNlIGlmKDA+ZiloPS0xLGY9LWY7ZWxzZSByZXR1cm4gbnVsbDthLnN1YlZlY3RvcnModGhpcy5vcmlnaW4sZSk7ZT1oKnRoaXMuZGlyZWN0aW9uLmRvdChjLmNyb3NzVmVjdG9ycyhhLGMpKTtpZigwPmUpcmV0dXJuIG51bGw7Zz1oKnRoaXMuZGlyZWN0aW9uLmRvdChiLmNyb3NzKGEpKTtcbiAgICAgICAgaWYoMD5nfHxlK2c+ZilyZXR1cm4gbnVsbDtlPS1oKmEuZG90KGQpO3JldHVybiAwPmU/bnVsbDp0aGlzLmF0KGUvZixrKX19KCksYXBwbHlNYXRyaXg0OmZ1bmN0aW9uKGEpe3RoaXMuZGlyZWN0aW9uLmFkZCh0aGlzLm9yaWdpbikuYXBwbHlNYXRyaXg0KGEpO3RoaXMub3JpZ2luLmFwcGx5TWF0cml4NChhKTt0aGlzLmRpcmVjdGlvbi5zdWIodGhpcy5vcmlnaW4pO3RoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzfSxlcXVhbHM6ZnVuY3Rpb24oYSl7cmV0dXJuIGEub3JpZ2luLmVxdWFscyh0aGlzLm9yaWdpbikmJmEuZGlyZWN0aW9uLmVxdWFscyh0aGlzLmRpcmVjdGlvbil9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBUSFJFRS5SYXkpLmNvcHkodGhpcyl9fTtUSFJFRS5TcGhlcmU9ZnVuY3Rpb24oYSxiKXt0aGlzLmNlbnRlcj12b2lkIDAhPT1hP2E6bmV3IFRIUkVFLlZlY3RvcjM7dGhpcy5yYWRpdXM9dm9pZCAwIT09Yj9iOjB9O1xuVEhSRUUuU3BoZXJlLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuU3BoZXJlLHNldDpmdW5jdGlvbihhLGIpe3RoaXMuY2VudGVyLmNvcHkoYSk7dGhpcy5yYWRpdXM9YjtyZXR1cm4gdGhpc30sc2V0RnJvbVBvaW50czpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5Cb3gzO3JldHVybiBmdW5jdGlvbihiLGMpe3ZhciBkPXRoaXMuY2VudGVyO3ZvaWQgMCE9PWM/ZC5jb3B5KGMpOmEuc2V0RnJvbVBvaW50cyhiKS5jZW50ZXIoZCk7Zm9yKHZhciBlPTAsZj0wLGc9Yi5sZW5ndGg7ZjxnO2YrKyllPU1hdGgubWF4KGUsZC5kaXN0YW5jZVRvU3F1YXJlZChiW2ZdKSk7dGhpcy5yYWRpdXM9TWF0aC5zcXJ0KGUpO3JldHVybiB0aGlzfX0oKSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMuY2VudGVyLmNvcHkoYS5jZW50ZXIpO3RoaXMucmFkaXVzPWEucmFkaXVzO3JldHVybiB0aGlzfSxlbXB0eTpmdW5jdGlvbigpe3JldHVybiAwPj10aGlzLnJhZGl1c30sY29udGFpbnNQb2ludDpmdW5jdGlvbihhKXtyZXR1cm4gYS5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcik8PVxuICAgIHRoaXMucmFkaXVzKnRoaXMucmFkaXVzfSxkaXN0YW5jZVRvUG9pbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGlzdGFuY2VUbyh0aGlzLmNlbnRlciktdGhpcy5yYWRpdXN9LGludGVyc2VjdHNTcGhlcmU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5yYWRpdXMrYS5yYWRpdXM7cmV0dXJuIGEuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKTw9YipifSxjbGFtcFBvaW50OmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoYSksZD1ifHxuZXcgVEhSRUUuVmVjdG9yMztkLmNvcHkoYSk7Yz50aGlzLnJhZGl1cyp0aGlzLnJhZGl1cyYmKGQuc3ViKHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKSxkLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKS5hZGQodGhpcy5jZW50ZXIpKTtyZXR1cm4gZH0sZ2V0Qm91bmRpbmdCb3g6ZnVuY3Rpb24oYSl7YT1hfHxuZXcgVEhSRUUuQm94MzthLnNldCh0aGlzLmNlbnRlcix0aGlzLmNlbnRlcik7YS5leHBhbmRCeVNjYWxhcih0aGlzLnJhZGl1cyk7XG4gICAgcmV0dXJuIGF9LGFwcGx5TWF0cml4NDpmdW5jdGlvbihhKXt0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoYSk7dGhpcy5yYWRpdXMqPWEuZ2V0TWF4U2NhbGVPbkF4aXMoKTtyZXR1cm4gdGhpc30sdHJhbnNsYXRlOmZ1bmN0aW9uKGEpe3RoaXMuY2VudGVyLmFkZChhKTtyZXR1cm4gdGhpc30sZXF1YWxzOmZ1bmN0aW9uKGEpe3JldHVybiBhLmNlbnRlci5lcXVhbHModGhpcy5jZW50ZXIpJiZhLnJhZGl1cz09PXRoaXMucmFkaXVzfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybihuZXcgVEhSRUUuU3BoZXJlKS5jb3B5KHRoaXMpfX07XG5USFJFRS5GcnVzdHVtPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLnBsYW5lcz1bdm9pZCAwIT09YT9hOm5ldyBUSFJFRS5QbGFuZSx2b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlBsYW5lLHZvaWQgMCE9PWM/YzpuZXcgVEhSRUUuUGxhbmUsdm9pZCAwIT09ZD9kOm5ldyBUSFJFRS5QbGFuZSx2b2lkIDAhPT1lP2U6bmV3IFRIUkVFLlBsYW5lLHZvaWQgMCE9PWY/ZjpuZXcgVEhSRUUuUGxhbmVdfTtcblRIUkVFLkZydXN0dW0ucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5GcnVzdHVtLHNldDpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9dGhpcy5wbGFuZXM7Z1swXS5jb3B5KGEpO2dbMV0uY29weShiKTtnWzJdLmNvcHkoYyk7Z1szXS5jb3B5KGQpO2dbNF0uY29weShlKTtnWzVdLmNvcHkoZik7cmV0dXJuIHRoaXN9LGNvcHk6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMucGxhbmVzLGM9MDs2PmM7YysrKWJbY10uY29weShhLnBsYW5lc1tjXSk7cmV0dXJuIHRoaXN9LHNldEZyb21NYXRyaXg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5wbGFuZXMsYz1hLmVsZW1lbnRzO2E9Y1swXTt2YXIgZD1jWzFdLGU9Y1syXSxmPWNbM10sZz1jWzRdLGg9Y1s1XSxrPWNbNl0sbD1jWzddLHA9Y1s4XSxxPWNbOV0sbj1jWzEwXSx0PWNbMTFdLHI9Y1sxMl0scz1jWzEzXSx1PWNbMTRdLGM9Y1sxNV07YlswXS5zZXRDb21wb25lbnRzKGYtYSxsLWcsdC1wLGMtcikubm9ybWFsaXplKCk7YlsxXS5zZXRDb21wb25lbnRzKGYrXG4gICAgYSxsK2csdCtwLGMrcikubm9ybWFsaXplKCk7YlsyXS5zZXRDb21wb25lbnRzKGYrZCxsK2gsdCtxLGMrcykubm9ybWFsaXplKCk7YlszXS5zZXRDb21wb25lbnRzKGYtZCxsLWgsdC1xLGMtcykubm9ybWFsaXplKCk7Yls0XS5zZXRDb21wb25lbnRzKGYtZSxsLWssdC1uLGMtdSkubm9ybWFsaXplKCk7Yls1XS5zZXRDb21wb25lbnRzKGYrZSxsK2ssdCtuLGMrdSkubm9ybWFsaXplKCk7cmV0dXJuIHRoaXN9LGludGVyc2VjdHNPYmplY3Q6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuU3BoZXJlO3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1iLmdlb21ldHJ5O251bGw9PT1jLmJvdW5kaW5nU3BoZXJlJiZjLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO2EuY29weShjLmJvdW5kaW5nU3BoZXJlKTthLmFwcGx5TWF0cml4NChiLm1hdHJpeFdvcmxkKTtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKGEpfX0oKSxpbnRlcnNlY3RzU3BoZXJlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMucGxhbmVzLFxuICAgIGM9YS5jZW50ZXI7YT0tYS5yYWRpdXM7Zm9yKHZhciBkPTA7Nj5kO2QrKylpZihiW2RdLmRpc3RhbmNlVG9Qb2ludChjKTxhKXJldHVybiExO3JldHVybiEwfSxpbnRlcnNlY3RzQm94OmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYyl7Zm9yKHZhciBkPXRoaXMucGxhbmVzLGU9MDs2PmU7ZSsrKXt2YXIgZj1kW2VdO2EueD0wPGYubm9ybWFsLng/Yy5taW4ueDpjLm1heC54O2IueD0wPGYubm9ybWFsLng/Yy5tYXgueDpjLm1pbi54O2EueT0wPGYubm9ybWFsLnk/Yy5taW4ueTpjLm1heC55O2IueT0wPGYubm9ybWFsLnk/Yy5tYXgueTpjLm1pbi55O2Euej0wPGYubm9ybWFsLno/Yy5taW4uejpjLm1heC56O2Iuej0wPGYubm9ybWFsLno/Yy5tYXguejpjLm1pbi56O3ZhciBnPWYuZGlzdGFuY2VUb1BvaW50KGEpLGY9Zi5kaXN0YW5jZVRvUG9pbnQoYik7aWYoMD5nJiYwPmYpcmV0dXJuITF9cmV0dXJuITB9fSgpLFxuICAgIGNvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMucGxhbmVzLGM9MDs2PmM7YysrKWlmKDA+YltjXS5kaXN0YW5jZVRvUG9pbnQoYSkpcmV0dXJuITE7cmV0dXJuITB9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBUSFJFRS5GcnVzdHVtKS5jb3B5KHRoaXMpfX07VEhSRUUuUGxhbmU9ZnVuY3Rpb24oYSxiKXt0aGlzLm5vcm1hbD12b2lkIDAhPT1hP2E6bmV3IFRIUkVFLlZlY3RvcjMoMSwwLDApO3RoaXMuY29uc3RhbnQ9dm9pZCAwIT09Yj9iOjB9O1xuVEhSRUUuUGxhbmUucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5QbGFuZSxzZXQ6ZnVuY3Rpb24oYSxiKXt0aGlzLm5vcm1hbC5jb3B5KGEpO3RoaXMuY29uc3RhbnQ9YjtyZXR1cm4gdGhpc30sc2V0Q29tcG9uZW50czpmdW5jdGlvbihhLGIsYyxkKXt0aGlzLm5vcm1hbC5zZXQoYSxiLGMpO3RoaXMuY29uc3RhbnQ9ZDtyZXR1cm4gdGhpc30sc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6ZnVuY3Rpb24oYSxiKXt0aGlzLm5vcm1hbC5jb3B5KGEpO3RoaXMuY29uc3RhbnQ9LWIuZG90KHRoaXMubm9ybWFsKTtyZXR1cm4gdGhpc30sc2V0RnJvbUNvcGxhbmFyUG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYyxkLGUpe2Q9YS5zdWJWZWN0b3JzKGUsZCkuY3Jvc3MoYi5zdWJWZWN0b3JzKGMsZCkpLm5vcm1hbGl6ZSgpO3RoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoZCxcbiAgICBjKTtyZXR1cm4gdGhpc319KCksY29weTpmdW5jdGlvbihhKXt0aGlzLm5vcm1hbC5jb3B5KGEubm9ybWFsKTt0aGlzLmNvbnN0YW50PWEuY29uc3RhbnQ7cmV0dXJuIHRoaXN9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe3ZhciBhPTEvdGhpcy5ub3JtYWwubGVuZ3RoKCk7dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoYSk7dGhpcy5jb25zdGFudCo9YTtyZXR1cm4gdGhpc30sbmVnYXRlOmZ1bmN0aW9uKCl7dGhpcy5jb25zdGFudCo9LTE7dGhpcy5ub3JtYWwubmVnYXRlKCk7cmV0dXJuIHRoaXN9LGRpc3RhbmNlVG9Qb2ludDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ub3JtYWwuZG90KGEpK3RoaXMuY29uc3RhbnR9LGRpc3RhbmNlVG9TcGhlcmU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KGEuY2VudGVyKS1hLnJhZGl1c30scHJvamVjdFBvaW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMub3J0aG9Qb2ludChhLGIpLnN1YihhKS5uZWdhdGUoKX0sb3J0aG9Qb2ludDpmdW5jdGlvbihhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIpe3ZhciBjPXRoaXMuZGlzdGFuY2VUb1BvaW50KGEpO3JldHVybihifHxuZXcgVEhSRUUuVmVjdG9yMykuY29weSh0aGlzLm5vcm1hbCkubXVsdGlwbHlTY2FsYXIoYyl9LGlzSW50ZXJzZWN0aW9uTGluZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmRpc3RhbmNlVG9Qb2ludChhLnN0YXJ0KTthPXRoaXMuZGlzdGFuY2VUb1BvaW50KGEuZW5kKTtyZXR1cm4gMD5iJiYwPGF8fDA+YSYmMDxifSxpbnRlcnNlY3RMaW5lOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7dmFyIGQ9Y3x8bmV3IFRIUkVFLlZlY3RvcjMsZT1iLmRlbHRhKGEpLGY9dGhpcy5ub3JtYWwuZG90KGUpO2lmKDA9PWYpe2lmKDA9PXRoaXMuZGlzdGFuY2VUb1BvaW50KGIuc3RhcnQpKXJldHVybiBkLmNvcHkoYi5zdGFydCl9ZWxzZSByZXR1cm4gZj0tKGIuc3RhcnQuZG90KHRoaXMubm9ybWFsKSt0aGlzLmNvbnN0YW50KS9mLDA+Znx8MTxmP3ZvaWQgMDpkLmNvcHkoZSkubXVsdGlwbHlTY2FsYXIoZikuYWRkKGIuc3RhcnQpfX0oKSxcbiAgICBjb3BsYW5hclBvaW50OmZ1bmN0aW9uKGEpe3JldHVybihhfHxuZXcgVEhSRUUuVmVjdG9yMykuY29weSh0aGlzLm5vcm1hbCkubXVsdGlwbHlTY2FsYXIoLXRoaXMuY29uc3RhbnQpfSxhcHBseU1hdHJpeDQ6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5WZWN0b3IzLGM9bmV3IFRIUkVFLk1hdHJpeDM7cmV0dXJuIGZ1bmN0aW9uKGQsZSl7dmFyIGY9ZXx8Yy5nZXROb3JtYWxNYXRyaXgoZCksZj1hLmNvcHkodGhpcy5ub3JtYWwpLmFwcGx5TWF0cml4MyhmKSxnPXRoaXMuY29wbGFuYXJQb2ludChiKTtnLmFwcGx5TWF0cml4NChkKTt0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KGYsZyk7cmV0dXJuIHRoaXN9fSgpLHRyYW5zbGF0ZTpmdW5jdGlvbihhKXt0aGlzLmNvbnN0YW50LT1hLmRvdCh0aGlzLm5vcm1hbCk7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5ub3JtYWwuZXF1YWxzKHRoaXMubm9ybWFsKSYmXG4gICAgICAgIGEuY29uc3RhbnQ9PXRoaXMuY29uc3RhbnR9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBUSFJFRS5QbGFuZSkuY29weSh0aGlzKX19O1xuVEhSRUUuTWF0aD17Z2VuZXJhdGVVVUlEOmZ1bmN0aW9uKCl7dmFyIGE9XCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLnNwbGl0KFwiXCIpLGI9QXJyYXkoMzYpLGM9MCxkO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgZT0wOzM2PmU7ZSsrKTg9PWV8fDEzPT1lfHwxOD09ZXx8MjM9PWU/YltlXT1cIi1cIjoxND09ZT9iW2VdPVwiNFwiOigyPj1jJiYoYz0zMzU1NDQzMisxNjc3NzIxNipNYXRoLnJhbmRvbSgpfDApLGQ9YyYxNSxjPj49NCxiW2VdPWFbMTk9PWU/ZCYzfDg6ZF0pO3JldHVybiBiLmpvaW4oXCJcIil9fSgpLGNsYW1wOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYTxiP2I6YT5jP2M6YX0sY2xhbXBCb3R0b206ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYTxiP2I6YX0sbWFwTGluZWFyOmZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIGQrKGEtYikqKGUtZCkvKGMtYil9LHNtb290aHN0ZXA6ZnVuY3Rpb24oYSxiLGMpe2lmKGE8PVxuICAgIGIpcmV0dXJuIDA7aWYoYT49YylyZXR1cm4gMTthPShhLWIpLyhjLWIpO3JldHVybiBhKmEqKDMtMiphKX0sc21vb3RoZXJzdGVwOmZ1bmN0aW9uKGEsYixjKXtpZihhPD1iKXJldHVybiAwO2lmKGE+PWMpcmV0dXJuIDE7YT0oYS1iKS8oYy1iKTtyZXR1cm4gYSphKmEqKGEqKDYqYS0xNSkrMTApfSxyYW5kb20xNjpmdW5jdGlvbigpe3JldHVybig2NTI4MCpNYXRoLnJhbmRvbSgpKzI1NSpNYXRoLnJhbmRvbSgpKS82NTUzNX0scmFuZEludDpmdW5jdGlvbihhLGIpe3JldHVybiBNYXRoLmZsb29yKHRoaXMucmFuZEZsb2F0KGEsYikpfSxyYW5kRmxvYXQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYStNYXRoLnJhbmRvbSgpKihiLWEpfSxyYW5kRmxvYXRTcHJlYWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEqKC41LU1hdGgucmFuZG9tKCkpfSxkZWdUb1JhZDpmdW5jdGlvbigpe3ZhciBhPU1hdGguUEkvMTgwO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gYiphfX0oKSxyYWRUb0RlZzpmdW5jdGlvbigpe3ZhciBhPVxuICAgIDE4MC9NYXRoLlBJO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gYiphfX0oKSxpc1Bvd2VyT2ZUd286ZnVuY3Rpb24oYSl7cmV0dXJuIDA9PT0oYSZhLTEpJiYwIT09YX0sbmV4dFBvd2VyT2ZUd286ZnVuY3Rpb24oYSl7YS0tO2F8PWE+PjE7YXw9YT4+MjthfD1hPj40O2F8PWE+Pjg7YXw9YT4+MTY7YSsrO3JldHVybiBhfX07XG5USFJFRS5TcGxpbmU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIsYyxkLGUsZixnKXthPS41KihjLWEpO2Q9LjUqKGQtYik7cmV0dXJuKDIqKGItYykrYStkKSpnKygtMyooYi1jKS0yKmEtZCkqZithKmUrYn10aGlzLnBvaW50cz1hO3ZhciBjPVtdLGQ9e3g6MCx5OjAsejowfSxlLGYsZyxoLGssbCxwLHEsbjt0aGlzLmluaXRGcm9tQXJyYXk9ZnVuY3Rpb24oYSl7dGhpcy5wb2ludHM9W107Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy5wb2ludHNbYl09e3g6YVtiXVswXSx5OmFbYl1bMV0sejphW2JdWzJdfX07dGhpcy5nZXRQb2ludD1mdW5jdGlvbihhKXtlPSh0aGlzLnBvaW50cy5sZW5ndGgtMSkqYTtmPU1hdGguZmxvb3IoZSk7Zz1lLWY7Y1swXT0wPT09Zj9mOmYtMTtjWzFdPWY7Y1syXT1mPnRoaXMucG9pbnRzLmxlbmd0aC0yP3RoaXMucG9pbnRzLmxlbmd0aC0xOmYrMTtjWzNdPWY+dGhpcy5wb2ludHMubGVuZ3RoLTM/dGhpcy5wb2ludHMubGVuZ3RoLTE6ZitcbjI7bD10aGlzLnBvaW50c1tjWzBdXTtwPXRoaXMucG9pbnRzW2NbMV1dO3E9dGhpcy5wb2ludHNbY1syXV07bj10aGlzLnBvaW50c1tjWzNdXTtoPWcqZztrPWcqaDtkLng9YihsLngscC54LHEueCxuLngsZyxoLGspO2QueT1iKGwueSxwLnkscS55LG4ueSxnLGgsayk7ZC56PWIobC56LHAueixxLnosbi56LGcsaCxrKTtyZXR1cm4gZH07dGhpcy5nZXRDb250cm9sUG9pbnRzQXJyYXk9ZnVuY3Rpb24oKXt2YXIgYSxiLGM9dGhpcy5wb2ludHMubGVuZ3RoLGQ9W107Zm9yKGE9MDthPGM7YSsrKWI9dGhpcy5wb2ludHNbYV0sZFthXT1bYi54LGIueSxiLnpdO3JldHVybiBkfTt0aGlzLmdldExlbmd0aD1mdW5jdGlvbihhKXt2YXIgYixjLGQsZT1iPWI9MCxmPW5ldyBUSFJFRS5WZWN0b3IzLGc9bmV3IFRIUkVFLlZlY3RvcjMsaD1bXSxrPTA7aFswXT0wO2F8fChhPTEwMCk7Yz10aGlzLnBvaW50cy5sZW5ndGgqYTtmLmNvcHkodGhpcy5wb2ludHNbMF0pO2ZvcihhPTE7YTxjO2ErKyliPVxuICAgIGEvYyxkPXRoaXMuZ2V0UG9pbnQoYiksZy5jb3B5KGQpLGsrPWcuZGlzdGFuY2VUbyhmKSxmLmNvcHkoZCksYio9dGhpcy5wb2ludHMubGVuZ3RoLTEsYj1NYXRoLmZsb29yKGIpLGIhPWUmJihoW2JdPWssZT1iKTtoW2gubGVuZ3RoXT1rO3JldHVybntjaHVua3M6aCx0b3RhbDprfX07dGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGg9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGg9W10saz1uZXcgVEhSRUUuVmVjdG9yMyxuPXRoaXMuZ2V0TGVuZ3RoKCk7aC5wdXNoKGsuY29weSh0aGlzLnBvaW50c1swXSkuY2xvbmUoKSk7Zm9yKGI9MTtiPHRoaXMucG9pbnRzLmxlbmd0aDtiKyspe2M9bi5jaHVua3NbYl0tbi5jaHVua3NbYi0xXTtnPU1hdGguY2VpbChhKmMvbi50b3RhbCk7ZT0oYi0xKS8odGhpcy5wb2ludHMubGVuZ3RoLTEpO2Y9Yi8odGhpcy5wb2ludHMubGVuZ3RoLTEpO2ZvcihjPTE7YzxnLTE7YysrKWQ9ZSsxL2cqYyooZi1lKSxkPXRoaXMuZ2V0UG9pbnQoZCksaC5wdXNoKGsuY29weShkKS5jbG9uZSgpKTtcbiAgICBoLnB1c2goay5jb3B5KHRoaXMucG9pbnRzW2JdKS5jbG9uZSgpKX10aGlzLnBvaW50cz1ofX07VEhSRUUuVHJpYW5nbGU9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuYT12b2lkIDAhPT1hP2E6bmV3IFRIUkVFLlZlY3RvcjM7dGhpcy5iPXZvaWQgMCE9PWI/YjpuZXcgVEhSRUUuVmVjdG9yMzt0aGlzLmM9dm9pZCAwIT09Yz9jOm5ldyBUSFJFRS5WZWN0b3IzfTtUSFJFRS5UcmlhbmdsZS5ub3JtYWw9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYixjLGQsZSl7ZT1lfHxuZXcgVEhSRUUuVmVjdG9yMztlLnN1YlZlY3RvcnMoZCxjKTthLnN1YlZlY3RvcnMoYixjKTtlLmNyb3NzKGEpO2I9ZS5sZW5ndGhTcSgpO3JldHVybiAwPGI/ZS5tdWx0aXBseVNjYWxhcigxL01hdGguc3FydChiKSk6ZS5zZXQoMCwwLDApfX0oKTtcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludD1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzLGI9bmV3IFRIUkVFLlZlY3RvcjMsYz1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oZCxlLGYsZyxoKXthLnN1YlZlY3RvcnMoZyxlKTtiLnN1YlZlY3RvcnMoZixlKTtjLnN1YlZlY3RvcnMoZCxlKTtkPWEuZG90KGEpO2U9YS5kb3QoYik7Zj1hLmRvdChjKTt2YXIgaz1iLmRvdChiKTtnPWIuZG90KGMpO3ZhciBsPWQqay1lKmU7aD1ofHxuZXcgVEhSRUUuVmVjdG9yMztpZigwPT1sKXJldHVybiBoLnNldCgtMiwtMSwtMSk7bD0xL2w7az0oaypmLWUqZykqbDtkPShkKmctZSpmKSpsO3JldHVybiBoLnNldCgxLWstZCxkLGspfX0oKTtcblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQ9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYixjLGQsZSl7Yj1USFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoYixjLGQsZSxhKTtyZXR1cm4gMDw9Yi54JiYwPD1iLnkmJjE+PWIueCtiLnl9fSgpO1xuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5UcmlhbmdsZSxzZXQ6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuYS5jb3B5KGEpO3RoaXMuYi5jb3B5KGIpO3RoaXMuYy5jb3B5KGMpO3JldHVybiB0aGlzfSxzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczpmdW5jdGlvbihhLGIsYyxkKXt0aGlzLmEuY29weShhW2JdKTt0aGlzLmIuY29weShhW2NdKTt0aGlzLmMuY29weShhW2RdKTtyZXR1cm4gdGhpc30sY29weTpmdW5jdGlvbihhKXt0aGlzLmEuY29weShhLmEpO3RoaXMuYi5jb3B5KGEuYik7dGhpcy5jLmNvcHkoYS5jKTtyZXR1cm4gdGhpc30sYXJlYTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzLGI9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKCl7YS5zdWJWZWN0b3JzKHRoaXMuYyx0aGlzLmIpO2Iuc3ViVmVjdG9ycyh0aGlzLmEsdGhpcy5iKTtyZXR1cm4uNSphLmNyb3NzKGIpLmxlbmd0aCgpfX0oKSxtaWRwb2ludDpmdW5jdGlvbihhKXtyZXR1cm4oYXx8XG5uZXcgVEhSRUUuVmVjdG9yMykuYWRkVmVjdG9ycyh0aGlzLmEsdGhpcy5iKS5hZGQodGhpcy5jKS5tdWx0aXBseVNjYWxhcigxLzMpfSxub3JtYWw6ZnVuY3Rpb24oYSl7cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCh0aGlzLmEsdGhpcy5iLHRoaXMuYyxhKX0scGxhbmU6ZnVuY3Rpb24oYSl7cmV0dXJuKGF8fG5ldyBUSFJFRS5QbGFuZSkuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHRoaXMuYSx0aGlzLmIsdGhpcy5jKX0sYmFyeWNvb3JkRnJvbVBvaW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludChhLHRoaXMuYSx0aGlzLmIsdGhpcy5jLGIpfSxjb250YWluc1BvaW50OmZ1bmN0aW9uKGEpe3JldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KGEsdGhpcy5hLHRoaXMuYix0aGlzLmMpfSxlcXVhbHM6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuYS5lcXVhbHModGhpcy5hKSYmYS5iLmVxdWFscyh0aGlzLmIpJiZhLmMuZXF1YWxzKHRoaXMuYyl9LFxuICAgIGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBUSFJFRS5UcmlhbmdsZSkuY29weSh0aGlzKX19O1RIUkVFLkNsb2NrPWZ1bmN0aW9uKGEpe3RoaXMuYXV0b1N0YXJ0PXZvaWQgMCE9PWE/YTohMDt0aGlzLmVsYXBzZWRUaW1lPXRoaXMub2xkVGltZT10aGlzLnN0YXJ0VGltZT0wO3RoaXMucnVubmluZz0hMX07XG5USFJFRS5DbG9jay5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkNsb2NrLHN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5vbGRUaW1lPXRoaXMuc3RhcnRUaW1lPXZvaWQgMCE9PXNlbGYucGVyZm9ybWFuY2UmJnZvaWQgMCE9PXNlbGYucGVyZm9ybWFuY2Uubm93P3NlbGYucGVyZm9ybWFuY2Uubm93KCk6RGF0ZS5ub3coKTt0aGlzLnJ1bm5pbmc9ITB9LHN0b3A6ZnVuY3Rpb24oKXt0aGlzLmdldEVsYXBzZWRUaW1lKCk7dGhpcy5ydW5uaW5nPSExfSxnZXRFbGFwc2VkVGltZTpmdW5jdGlvbigpe3RoaXMuZ2V0RGVsdGEoKTtyZXR1cm4gdGhpcy5lbGFwc2VkVGltZX0sZ2V0RGVsdGE6ZnVuY3Rpb24oKXt2YXIgYT0wO3RoaXMuYXV0b1N0YXJ0JiYhdGhpcy5ydW5uaW5nJiZ0aGlzLnN0YXJ0KCk7aWYodGhpcy5ydW5uaW5nKXt2YXIgYj12b2lkIDAhPT1zZWxmLnBlcmZvcm1hbmNlJiZ2b2lkIDAhPT1zZWxmLnBlcmZvcm1hbmNlLm5vdz9zZWxmLnBlcmZvcm1hbmNlLm5vdygpOkRhdGUubm93KCksXG4gICAgYT0uMDAxKihiLXRoaXMub2xkVGltZSk7dGhpcy5vbGRUaW1lPWI7dGhpcy5lbGFwc2VkVGltZSs9YX1yZXR1cm4gYX19O1RIUkVFLkV2ZW50RGlzcGF0Y2hlcj1mdW5jdGlvbigpe307XG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5FdmVudERpc3BhdGNoZXIsYXBwbHk6ZnVuY3Rpb24oYSl7YS5hZGRFdmVudExpc3RlbmVyPVRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjthLmhhc0V2ZW50TGlzdGVuZXI9VEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNFdmVudExpc3RlbmVyO2EucmVtb3ZlRXZlbnRMaXN0ZW5lcj1USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7YS5kaXNwYXRjaEV2ZW50PVRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudH0sYWRkRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIpe3ZvaWQgMD09PXRoaXMuX2xpc3RlbmVycyYmKHRoaXMuX2xpc3RlbmVycz17fSk7dmFyIGM9dGhpcy5fbGlzdGVuZXJzO3ZvaWQgMD09PWNbYV0mJihjW2FdPVtdKTstMT09PWNbYV0uaW5kZXhPZihiKSYmXG5jW2FdLnB1c2goYil9LGhhc0V2ZW50TGlzdGVuZXI6ZnVuY3Rpb24oYSxiKXtpZih2b2lkIDA9PT10aGlzLl9saXN0ZW5lcnMpcmV0dXJuITE7dmFyIGM9dGhpcy5fbGlzdGVuZXJzO3JldHVybiB2b2lkIDAhPT1jW2FdJiYtMSE9PWNbYV0uaW5kZXhPZihiKT8hMDohMX0scmVtb3ZlRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PXRoaXMuX2xpc3RlbmVycyl7dmFyIGM9dGhpcy5fbGlzdGVuZXJzW2FdO2lmKHZvaWQgMCE9PWMpe3ZhciBkPWMuaW5kZXhPZihiKTstMSE9PWQmJmMuc3BsaWNlKGQsMSl9fX0sZGlzcGF0Y2hFdmVudDpmdW5jdGlvbihhKXtpZih2b2lkIDAhPT10aGlzLl9saXN0ZW5lcnMpe3ZhciBiPXRoaXMuX2xpc3RlbmVyc1thLnR5cGVdO2lmKHZvaWQgMCE9PWIpe2EudGFyZ2V0PXRoaXM7Zm9yKHZhciBjPVtdLGQ9Yi5sZW5ndGgsZT0wO2U8ZDtlKyspY1tlXT1iW2VdO2ZvcihlPTA7ZTxkO2UrKyljW2VdLmNhbGwodGhpcyxhKX19fX07XG4oZnVuY3Rpb24oYSl7YS5SYXljYXN0ZXI9ZnVuY3Rpb24oYixjLGYsZyl7dGhpcy5yYXk9bmV3IGEuUmF5KGIsYyk7dGhpcy5uZWFyPWZ8fDA7dGhpcy5mYXI9Z3x8SW5maW5pdHk7dGhpcy5wYXJhbXM9e1Nwcml0ZTp7fSxNZXNoOnt9LFBvaW50Q2xvdWQ6e3RocmVzaG9sZDoxfSxMT0Q6e30sTGluZTp7fX19O3ZhciBiPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZGlzdGFuY2UtYi5kaXN0YW5jZX0sYz1mdW5jdGlvbihhLGIsZixnKXthLnJheWNhc3QoYixmKTtpZighMD09PWcpe2E9YS5jaGlsZHJlbjtnPTA7Zm9yKHZhciBoPWEubGVuZ3RoO2c8aDtnKyspYyhhW2ddLGIsZiwhMCl9fTthLlJheWNhc3Rlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmEuUmF5Y2FzdGVyLHByZWNpc2lvbjoxRS00LGxpbmVQcmVjaXNpb246MSxzZXQ6ZnVuY3Rpb24oYSxiKXt0aGlzLnJheS5zZXQoYSxiKX0sc2V0RnJvbUNhbWVyYTpmdW5jdGlvbihiLGMpe2MgaW5zdGFuY2VvZiBhLlBlcnNwZWN0aXZlQ2FtZXJhP1xuICAgICh0aGlzLnJheS5vcmlnaW4uY29weShjLnBvc2l0aW9uKSx0aGlzLnJheS5kaXJlY3Rpb24uc2V0KGIueCxiLnksLjUpLnVucHJvamVjdChjKS5zdWIoYy5wb3NpdGlvbikubm9ybWFsaXplKCkpOmMgaW5zdGFuY2VvZiBhLk9ydGhvZ3JhcGhpY0NhbWVyYT8odGhpcy5yYXkub3JpZ2luLnNldChiLngsYi55LC0xKS51bnByb2plY3QoYyksdGhpcy5yYXkuZGlyZWN0aW9uLnNldCgwLDAsLTEpLnRyYW5zZm9ybURpcmVjdGlvbihjLm1hdHJpeFdvcmxkKSk6YS5lcnJvcihcIlRIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGUuXCIpfSxpbnRlcnNlY3RPYmplY3Q6ZnVuY3Rpb24oYSxlKXt2YXIgZj1bXTtjKGEsdGhpcyxmLGUpO2Yuc29ydChiKTtyZXR1cm4gZn0saW50ZXJzZWN0T2JqZWN0czpmdW5jdGlvbihkLGUpe3ZhciBmPVtdO2lmKCExPT09ZCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiBhLndhcm4oXCJUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuXCIpLFxuICAgIGY7Zm9yKHZhciBnPTAsaD1kLmxlbmd0aDtnPGg7ZysrKWMoZFtnXSx0aGlzLGYsZSk7Zi5zb3J0KGIpO3JldHVybiBmfX19KShUSFJFRSk7XG5USFJFRS5PYmplY3QzRD1mdW5jdGlvbigpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiaWRcIix7dmFsdWU6VEhSRUUuT2JqZWN0M0RJZENvdW50Kyt9KTt0aGlzLnV1aWQ9VEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTt0aGlzLm5hbWU9XCJcIjt0aGlzLnR5cGU9XCJPYmplY3QzRFwiO3RoaXMucGFyZW50PXZvaWQgMDt0aGlzLmNoaWxkcmVuPVtdO3RoaXMudXA9VEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwLmNsb25lKCk7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuRXVsZXIsYz1uZXcgVEhSRUUuUXVhdGVybmlvbixkPW5ldyBUSFJFRS5WZWN0b3IzKDEsMSwxKTtiLm9uQ2hhbmdlKGZ1bmN0aW9uKCl7Yy5zZXRGcm9tRXVsZXIoYiwhMSl9KTtjLm9uQ2hhbmdlKGZ1bmN0aW9uKCl7Yi5zZXRGcm9tUXVhdGVybmlvbihjLHZvaWQgMCwhMSl9KTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHtwb3NpdGlvbjp7ZW51bWVyYWJsZTohMCx2YWx1ZTphfSxyb3RhdGlvbjp7ZW51bWVyYWJsZTohMCxcbiAgICB2YWx1ZTpifSxxdWF0ZXJuaW9uOntlbnVtZXJhYmxlOiEwLHZhbHVlOmN9LHNjYWxlOntlbnVtZXJhYmxlOiEwLHZhbHVlOmR9fSk7dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGU9ITA7dGhpcy5tYXRyaXg9bmV3IFRIUkVFLk1hdHJpeDQ7dGhpcy5tYXRyaXhXb3JsZD1uZXcgVEhSRUUuTWF0cml4NDt0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ITA7dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSExO3RoaXMudmlzaWJsZT0hMDt0aGlzLnJlY2VpdmVTaGFkb3c9dGhpcy5jYXN0U2hhZG93PSExO3RoaXMuZnJ1c3R1bUN1bGxlZD0hMDt0aGlzLnJlbmRlck9yZGVyPTA7dGhpcy51c2VyRGF0YT17fX07VEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwPW5ldyBUSFJFRS5WZWN0b3IzKDAsMSwwKTtcblRIUkVFLk9iamVjdDNELnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuT2JqZWN0M0QsZ2V0IGV1bGVyT3JkZXIoKXtUSFJFRS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGhhcyBiZWVuIG1vdmVkIHRvIC5yb3RhdGlvbi5vcmRlci5cIik7cmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXJ9LHNldCBldWxlck9yZGVyKGEpe1RIUkVFLndhcm4oXCJUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaGFzIGJlZW4gbW92ZWQgdG8gLnJvdGF0aW9uLm9yZGVyLlwiKTt0aGlzLnJvdGF0aW9uLm9yZGVyPWF9LGdldCB1c2VRdWF0ZXJuaW9uKCl7VEhSRUUud2FybihcIlRIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LlwiKX0sc2V0IHVzZVF1YXRlcm5pb24oYSl7VEhSRUUud2FybihcIlRIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LlwiKX0sXG4gICAgYXBwbHlNYXRyaXg6ZnVuY3Rpb24oYSl7dGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhhLHRoaXMubWF0cml4KTt0aGlzLm1hdHJpeC5kZWNvbXBvc2UodGhpcy5wb3NpdGlvbix0aGlzLnF1YXRlcm5pb24sdGhpcy5zY2FsZSl9LHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTpmdW5jdGlvbihhLGIpe3RoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKGEsYil9LHNldFJvdGF0aW9uRnJvbUV1bGVyOmZ1bmN0aW9uKGEpe3RoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoYSwhMCl9LHNldFJvdGF0aW9uRnJvbU1hdHJpeDpmdW5jdGlvbihhKXt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGEpfSxzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOmZ1bmN0aW9uKGEpe3RoaXMucXVhdGVybmlvbi5jb3B5KGEpfSxyb3RhdGVPbkF4aXM6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuUXVhdGVybmlvbjtyZXR1cm4gZnVuY3Rpb24oYixjKXthLnNldEZyb21BeGlzQW5nbGUoYixcbiAgICAgICAgYyk7dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KGEpO3JldHVybiB0aGlzfX0oKSxyb3RhdGVYOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMoMSwwLDApO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoYSxiKX19KCkscm90YXRlWTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKGEsYil9fSgpLHJvdGF0ZVo6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMygwLDAsMSk7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhhLGIpfX0oKSx0cmFuc2xhdGVPbkF4aXM6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYixjKXthLmNvcHkoYikuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7dGhpcy5wb3NpdGlvbi5hZGQoYS5tdWx0aXBseVNjYWxhcihjKSk7XG4gICAgICAgIHJldHVybiB0aGlzfX0oKSx0cmFuc2xhdGU6ZnVuY3Rpb24oYSxiKXtUSFJFRS53YXJuKFwiVEhSRUUuT2JqZWN0M0Q6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLlwiKTtyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoYixhKX0sdHJhbnNsYXRlWDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzKDEsMCwwKTtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKGEsYil9fSgpLHRyYW5zbGF0ZVk6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMygwLDEsMCk7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhhLGIpfX0oKSx0cmFuc2xhdGVaOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMoMCwwLDEpO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoYSxcbiAgICAgICAgYil9fSgpLGxvY2FsVG9Xb3JsZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCl9LHdvcmxkVG9Mb2NhbDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5NYXRyaXg0O3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gYi5hcHBseU1hdHJpeDQoYS5nZXRJbnZlcnNlKHRoaXMubWF0cml4V29ybGQpKX19KCksbG9va0F0OmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLk1hdHJpeDQ7cmV0dXJuIGZ1bmN0aW9uKGIpe2EubG9va0F0KGIsdGhpcy5wb3NpdGlvbix0aGlzLnVwKTt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGEpfX0oKSxhZGQ6ZnVuY3Rpb24oYSl7aWYoMTxhcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGI9MDtiPGFyZ3VtZW50cy5sZW5ndGg7YisrKXRoaXMuYWRkKGFyZ3VtZW50c1tiXSk7cmV0dXJuIHRoaXN9aWYoYT09PXRoaXMpcmV0dXJuIFRIUkVFLmVycm9yKFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXCIsXG4gICAgICAgIGEpLHRoaXM7YSBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEPyh2b2lkIDAhPT1hLnBhcmVudCYmYS5wYXJlbnQucmVtb3ZlKGEpLGEucGFyZW50PXRoaXMsYS5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiYWRkZWRcIn0pLHRoaXMuY2hpbGRyZW4ucHVzaChhKSk6VEhSRUUuZXJyb3IoXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuXCIsYSk7cmV0dXJuIHRoaXN9LHJlbW92ZTpmdW5jdGlvbihhKXtpZigxPGFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBiPTA7Yjxhcmd1bWVudHMubGVuZ3RoO2IrKyl0aGlzLnJlbW92ZShhcmd1bWVudHNbYl0pO2I9dGhpcy5jaGlsZHJlbi5pbmRleE9mKGEpOy0xIT09YiYmKGEucGFyZW50PXZvaWQgMCxhLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJyZW1vdmVkXCJ9KSx0aGlzLmNoaWxkcmVuLnNwbGljZShiLDEpKX0sZ2V0Q2hpbGRCeU5hbWU6ZnVuY3Rpb24oYSl7VEhSRUUud2FybihcIlRIUkVFLk9iamVjdDNEOiAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEJ5TmFtZShhKX0sZ2V0T2JqZWN0QnlJZDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KFwiaWRcIixhKX0sZ2V0T2JqZWN0QnlOYW1lOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoXCJuYW1lXCIsYSl9LGdldE9iamVjdEJ5UHJvcGVydHk6ZnVuY3Rpb24oYSxiKXtpZih0aGlzW2FdPT09YilyZXR1cm4gdGhpcztmb3IodmFyIGM9MCxkPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2M8ZDtjKyspe3ZhciBlPXRoaXMuY2hpbGRyZW5bY10uZ2V0T2JqZWN0QnlQcm9wZXJ0eShhLGIpO2lmKHZvaWQgMCE9PWUpcmV0dXJuIGV9fSxnZXRXb3JsZFBvc2l0aW9uOmZ1bmN0aW9uKGEpe2E9YXx8bmV3IFRIUkVFLlZlY3RvcjM7dGhpcy51cGRhdGVNYXRyaXhXb3JsZCghMCk7cmV0dXJuIGEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpfSxnZXRXb3JsZFF1YXRlcm5pb246ZnVuY3Rpb24oKXt2YXIgYT1cbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYyl7Yz1jfHxuZXcgVEhSRUUuUXVhdGVybmlvbjt0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCEwKTt0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShhLGMsYik7cmV0dXJuIGN9fSgpLGdldFdvcmxkUm90YXRpb246ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuUXVhdGVybmlvbjtyZXR1cm4gZnVuY3Rpb24oYil7Yj1ifHxuZXcgVEhSRUUuRXVsZXI7dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oYSk7cmV0dXJuIGIuc2V0RnJvbVF1YXRlcm5pb24oYSx0aGlzLnJvdGF0aW9uLm9yZGVyLCExKX19KCksZ2V0V29ybGRTY2FsZTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzLGI9bmV3IFRIUkVFLlF1YXRlcm5pb247cmV0dXJuIGZ1bmN0aW9uKGMpe2M9Y3x8bmV3IFRIUkVFLlZlY3RvcjM7dGhpcy51cGRhdGVNYXRyaXhXb3JsZCghMCk7dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoYSxcbiAgICAgICAgYixjKTtyZXR1cm4gY319KCksZ2V0V29ybGREaXJlY3Rpb246ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuUXVhdGVybmlvbjtyZXR1cm4gZnVuY3Rpb24oYil7Yj1ifHxuZXcgVEhSRUUuVmVjdG9yMzt0aGlzLmdldFdvcmxkUXVhdGVybmlvbihhKTtyZXR1cm4gYi5zZXQoMCwwLDEpLmFwcGx5UXVhdGVybmlvbihhKX19KCkscmF5Y2FzdDpmdW5jdGlvbigpe30sdHJhdmVyc2U6ZnVuY3Rpb24oYSl7YSh0aGlzKTtmb3IodmFyIGI9MCxjPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2I8YztiKyspdGhpcy5jaGlsZHJlbltiXS50cmF2ZXJzZShhKX0sdHJhdmVyc2VWaXNpYmxlOmZ1bmN0aW9uKGEpe2lmKCExIT09dGhpcy52aXNpYmxlKXthKHRoaXMpO2Zvcih2YXIgYj0wLGM9dGhpcy5jaGlsZHJlbi5sZW5ndGg7YjxjO2IrKyl0aGlzLmNoaWxkcmVuW2JdLnRyYXZlcnNlVmlzaWJsZShhKX19LHRyYXZlcnNlQW5jZXN0b3JzOmZ1bmN0aW9uKGEpe3RoaXMucGFyZW50JiYoYSh0aGlzLnBhcmVudCksXG4gICAgICAgIHRoaXMucGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKGEpKX0sdXBkYXRlTWF0cml4OmZ1bmN0aW9uKCl7dGhpcy5tYXRyaXguY29tcG9zZSh0aGlzLnBvc2l0aW9uLHRoaXMucXVhdGVybmlvbix0aGlzLnNjYWxlKTt0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITB9LHVwZGF0ZU1hdHJpeFdvcmxkOmZ1bmN0aW9uKGEpeyEwPT09dGhpcy5tYXRyaXhBdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZU1hdHJpeCgpO2lmKCEwPT09dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlfHwhMD09PWEpdm9pZCAwPT09dGhpcy5wYXJlbnQ/dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTp0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMSxhPSEwO2Zvcih2YXIgYj0wLGM9dGhpcy5jaGlsZHJlbi5sZW5ndGg7YjxjO2IrKyl0aGlzLmNoaWxkcmVuW2JdLnVwZGF0ZU1hdHJpeFdvcmxkKGEpfSxcbiAgICB0b0pTT046ZnVuY3Rpb24oKXt2YXIgYT17bWV0YWRhdGE6e3ZlcnNpb246NC4zLHR5cGU6XCJPYmplY3RcIixnZW5lcmF0b3I6XCJPYmplY3RFeHBvcnRlclwifX0sYj17fSxjPXt9LGQ9ZnVuY3Rpb24oYil7dm9pZCAwPT09YS5tYXRlcmlhbHMmJihhLm1hdGVyaWFscz1bXSk7aWYodm9pZCAwPT09Y1tiLnV1aWRdKXt2YXIgZD1iLnRvSlNPTigpO2RlbGV0ZSBkLm1ldGFkYXRhO2NbYi51dWlkXT1kO2EubWF0ZXJpYWxzLnB1c2goZCl9cmV0dXJuIGIudXVpZH0sZT1mdW5jdGlvbihjKXt2YXIgZz17fTtnLnV1aWQ9Yy51dWlkO2cudHlwZT1jLnR5cGU7XCJcIiE9PWMubmFtZSYmKGcubmFtZT1jLm5hbWUpO1wie31cIiE9PUpTT04uc3RyaW5naWZ5KGMudXNlckRhdGEpJiYoZy51c2VyRGF0YT1jLnVzZXJEYXRhKTshMCE9PWMudmlzaWJsZSYmKGcudmlzaWJsZT1jLnZpc2libGUpO2lmKGMgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSlnLmZvdj1jLmZvdixnLmFzcGVjdD1jLmFzcGVjdCxcbiAgICAgICAgZy5uZWFyPWMubmVhcixnLmZhcj1jLmZhcjtlbHNlIGlmKGMgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEpZy5sZWZ0PWMubGVmdCxnLnJpZ2h0PWMucmlnaHQsZy50b3A9Yy50b3AsZy5ib3R0b209Yy5ib3R0b20sZy5uZWFyPWMubmVhcixnLmZhcj1jLmZhcjtlbHNlIGlmKGMgaW5zdGFuY2VvZiBUSFJFRS5BbWJpZW50TGlnaHQpZy5jb2xvcj1jLmNvbG9yLmdldEhleCgpO2Vsc2UgaWYoYyBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQpZy5jb2xvcj1jLmNvbG9yLmdldEhleCgpLGcuaW50ZW5zaXR5PWMuaW50ZW5zaXR5O2Vsc2UgaWYoYyBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQpZy5jb2xvcj1jLmNvbG9yLmdldEhleCgpLGcuaW50ZW5zaXR5PWMuaW50ZW5zaXR5LGcuZGlzdGFuY2U9Yy5kaXN0YW5jZSxnLmRlY2F5PWMuZGVjYXk7ZWxzZSBpZihjIGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0KWcuY29sb3I9Yy5jb2xvci5nZXRIZXgoKSxcbiAgICAgICAgZy5pbnRlbnNpdHk9Yy5pbnRlbnNpdHksZy5kaXN0YW5jZT1jLmRpc3RhbmNlLGcuYW5nbGU9Yy5hbmdsZSxnLmV4cG9uZW50PWMuZXhwb25lbnQsZy5kZWNheT1jLmRlY2F5O2Vsc2UgaWYoYyBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodClnLmNvbG9yPWMuY29sb3IuZ2V0SGV4KCksZy5ncm91bmRDb2xvcj1jLmdyb3VuZENvbG9yLmdldEhleCgpO2Vsc2UgaWYoYyBpbnN0YW5jZW9mIFRIUkVFLk1lc2h8fGMgaW5zdGFuY2VvZiBUSFJFRS5MaW5lfHxjIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCl7dmFyIGg9Yy5nZW9tZXRyeTt2b2lkIDA9PT1hLmdlb21ldHJpZXMmJihhLmdlb21ldHJpZXM9W10pO2lmKHZvaWQgMD09PWJbaC51dWlkXSl7dmFyIGs9aC50b0pTT04oKTtkZWxldGUgay5tZXRhZGF0YTtiW2gudXVpZF09azthLmdlb21ldHJpZXMucHVzaChrKX1nLmdlb21ldHJ5PWgudXVpZDtnLm1hdGVyaWFsPWQoYy5tYXRlcmlhbCk7YyBpbnN0YW5jZW9mIFRIUkVFLkxpbmUmJlxuICAgIChnLm1vZGU9Yy5tb2RlKX1lbHNlIGMgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUmJihnLm1hdGVyaWFsPWQoYy5tYXRlcmlhbCkpO2cubWF0cml4PWMubWF0cml4LnRvQXJyYXkoKTtpZigwPGMuY2hpbGRyZW4ubGVuZ3RoKWZvcihnLmNoaWxkcmVuPVtdLGg9MDtoPGMuY2hpbGRyZW4ubGVuZ3RoO2grKylnLmNoaWxkcmVuLnB1c2goZShjLmNoaWxkcmVuW2hdKSk7cmV0dXJuIGd9O2Eub2JqZWN0PWUodGhpcyk7cmV0dXJuIGF9LGNsb25lOmZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YSYmKGE9bmV3IFRIUkVFLk9iamVjdDNEKTt2b2lkIDA9PT1iJiYoYj0hMCk7YS5uYW1lPXRoaXMubmFtZTthLnVwLmNvcHkodGhpcy51cCk7YS5wb3NpdGlvbi5jb3B5KHRoaXMucG9zaXRpb24pO2EucXVhdGVybmlvbi5jb3B5KHRoaXMucXVhdGVybmlvbik7YS5zY2FsZS5jb3B5KHRoaXMuc2NhbGUpO2Eucm90YXRpb25BdXRvVXBkYXRlPXRoaXMucm90YXRpb25BdXRvVXBkYXRlO2EubWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgICBhLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXhXb3JsZCk7YS5tYXRyaXhBdXRvVXBkYXRlPXRoaXMubWF0cml4QXV0b1VwZGF0ZTthLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO2EudmlzaWJsZT10aGlzLnZpc2libGU7YS5jYXN0U2hhZG93PXRoaXMuY2FzdFNoYWRvdzthLnJlY2VpdmVTaGFkb3c9dGhpcy5yZWNlaXZlU2hhZG93O2EuZnJ1c3R1bUN1bGxlZD10aGlzLmZydXN0dW1DdWxsZWQ7YS51c2VyRGF0YT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMudXNlckRhdGEpKTtpZighMD09PWIpZm9yKHZhciBjPTA7Yzx0aGlzLmNoaWxkcmVuLmxlbmd0aDtjKyspYS5hZGQodGhpcy5jaGlsZHJlbltjXS5jbG9uZSgpKTtyZXR1cm4gYX19O1RIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5PYmplY3QzRElkQ291bnQ9MDtcblRIUkVFLkZhY2UzPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLmE9YTt0aGlzLmI9Yjt0aGlzLmM9Yzt0aGlzLm5vcm1hbD1kIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMz9kOm5ldyBUSFJFRS5WZWN0b3IzO3RoaXMudmVydGV4Tm9ybWFscz1kIGluc3RhbmNlb2YgQXJyYXk/ZDpbXTt0aGlzLmNvbG9yPWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvcj9lOm5ldyBUSFJFRS5Db2xvcjt0aGlzLnZlcnRleENvbG9ycz1lIGluc3RhbmNlb2YgQXJyYXk/ZTpbXTt0aGlzLnZlcnRleFRhbmdlbnRzPVtdO3RoaXMubWF0ZXJpYWxJbmRleD12b2lkIDAhPT1mP2Y6MH07XG5USFJFRS5GYWNlMy5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkZhY2UzLGNsb25lOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLkZhY2UzKHRoaXMuYSx0aGlzLmIsdGhpcy5jKTthLm5vcm1hbC5jb3B5KHRoaXMubm9ybWFsKTthLmNvbG9yLmNvcHkodGhpcy5jb2xvcik7YS5tYXRlcmlhbEluZGV4PXRoaXMubWF0ZXJpYWxJbmRleDtmb3IodmFyIGI9MCxjPXRoaXMudmVydGV4Tm9ybWFscy5sZW5ndGg7YjxjO2IrKylhLnZlcnRleE5vcm1hbHNbYl09dGhpcy52ZXJ0ZXhOb3JtYWxzW2JdLmNsb25lKCk7Yj0wO2ZvcihjPXRoaXMudmVydGV4Q29sb3JzLmxlbmd0aDtiPGM7YisrKWEudmVydGV4Q29sb3JzW2JdPXRoaXMudmVydGV4Q29sb3JzW2JdLmNsb25lKCk7Yj0wO2ZvcihjPXRoaXMudmVydGV4VGFuZ2VudHMubGVuZ3RoO2I8YztiKyspYS52ZXJ0ZXhUYW5nZW50c1tiXT10aGlzLnZlcnRleFRhbmdlbnRzW2JdLmNsb25lKCk7cmV0dXJuIGF9fTtcblRIUkVFLkZhY2U0PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe1RIUkVFLndhcm4oXCJUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLlwiKTtyZXR1cm4gbmV3IFRIUkVFLkZhY2UzKGEsYixjLGUsZixnKX07VEhSRUUuQnVmZmVyQXR0cmlidXRlPWZ1bmN0aW9uKGEsYil7dGhpcy5hcnJheT1hO3RoaXMuaXRlbVNpemU9Yjt0aGlzLm5lZWRzVXBkYXRlPSExfTtcblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSxnZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RofSxjb3B5QXQ6ZnVuY3Rpb24oYSxiLGMpe2EqPXRoaXMuaXRlbVNpemU7Yyo9Yi5pdGVtU2l6ZTtmb3IodmFyIGQ9MCxlPXRoaXMuaXRlbVNpemU7ZDxlO2QrKyl0aGlzLmFycmF5W2ErZF09Yi5hcnJheVtjK2RdO3JldHVybiB0aGlzfSxzZXQ6ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj0wKTt0aGlzLmFycmF5LnNldChhLGIpO3JldHVybiB0aGlzfSxzZXRYOmZ1bmN0aW9uKGEsYil7dGhpcy5hcnJheVthKnRoaXMuaXRlbVNpemVdPWI7cmV0dXJuIHRoaXN9LHNldFk6ZnVuY3Rpb24oYSxiKXt0aGlzLmFycmF5W2EqdGhpcy5pdGVtU2l6ZSsxXT1iO3JldHVybiB0aGlzfSxzZXRaOmZ1bmN0aW9uKGEsYil7dGhpcy5hcnJheVthKnRoaXMuaXRlbVNpemUrMl09YjtyZXR1cm4gdGhpc30sc2V0WFk6ZnVuY3Rpb24oYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYixjKXthKj10aGlzLml0ZW1TaXplO3RoaXMuYXJyYXlbYV09Yjt0aGlzLmFycmF5W2ErMV09YztyZXR1cm4gdGhpc30sc2V0WFlaOmZ1bmN0aW9uKGEsYixjLGQpe2EqPXRoaXMuaXRlbVNpemU7dGhpcy5hcnJheVthXT1iO3RoaXMuYXJyYXlbYSsxXT1jO3RoaXMuYXJyYXlbYSsyXT1kO3JldHVybiB0aGlzfSxzZXRYWVpXOmZ1bmN0aW9uKGEsYixjLGQsZSl7YSo9dGhpcy5pdGVtU2l6ZTt0aGlzLmFycmF5W2FdPWI7dGhpcy5hcnJheVthKzFdPWM7dGhpcy5hcnJheVthKzJdPWQ7dGhpcy5hcnJheVthKzNdPWU7cmV0dXJuIHRoaXN9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IodGhpcy5hcnJheSksdGhpcy5pdGVtU2l6ZSl9fTtcblRIUkVFLkludDhBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiKXtUSFJFRS53YXJuKFwiVEhSRUUuSW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLlwiKTtyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShhLGIpfTtUSFJFRS5VaW50OEF0dHJpYnV0ZT1mdW5jdGlvbihhLGIpe1RIUkVFLndhcm4oXCJUSFJFRS5VaW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLlwiKTtyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShhLGIpfTtcblRIUkVFLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZT1mdW5jdGlvbihhLGIpe1RIUkVFLndhcm4oXCJUSFJFRS5VaW50OENsYW1wZWRBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkgaW5zdGVhZC5cIik7cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoYSxiKX07VEhSRUUuSW50MTZBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiKXtUSFJFRS53YXJuKFwiVEhSRUUuSW50MTZBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkgaW5zdGVhZC5cIik7cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoYSxiKX07XG5USFJFRS5VaW50MTZBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiKXtUSFJFRS53YXJuKFwiVEhSRUUuVWludDE2QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIGluc3RlYWQuXCIpO3JldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGEsYil9O1RIUkVFLkludDMyQXR0cmlidXRlPWZ1bmN0aW9uKGEsYil7VEhSRUUud2FybihcIlRIUkVFLkludDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIGluc3RlYWQuXCIpO3JldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGEsYil9O1xuVEhSRUUuVWludDMyQXR0cmlidXRlPWZ1bmN0aW9uKGEsYil7VEhSRUUud2FybihcIlRIUkVFLlVpbnQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLlwiKTtyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShhLGIpfTtUSFJFRS5GbG9hdDMyQXR0cmlidXRlPWZ1bmN0aW9uKGEsYil7VEhSRUUud2FybihcIlRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkgaW5zdGVhZC5cIik7cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoYSxiKX07XG5USFJFRS5GbG9hdDY0QXR0cmlidXRlPWZ1bmN0aW9uKGEsYil7VEhSRUUud2FybihcIlRIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkgaW5zdGVhZC5cIik7cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoYSxiKX07VEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZT1mdW5jdGlvbihhLGIpe1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jYWxsKHRoaXMsYSxiKTt0aGlzLnVwZGF0ZVJhbmdlPXtvZmZzZXQ6MCxjb3VudDotMX19O1RIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSk7VEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZTtcblRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlKG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKHRoaXMuYXJyYXkpLHRoaXMuaXRlbVNpemUpfTtUSFJFRS5CdWZmZXJHZW9tZXRyeT1mdW5jdGlvbigpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiaWRcIix7dmFsdWU6VEhSRUUuR2VvbWV0cnlJZENvdW50Kyt9KTt0aGlzLnV1aWQ9VEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTt0aGlzLm5hbWU9XCJcIjt0aGlzLnR5cGU9XCJCdWZmZXJHZW9tZXRyeVwiO3RoaXMuYXR0cmlidXRlcz17fTt0aGlzLmF0dHJpYnV0ZXNLZXlzPVtdO3RoaXMub2Zmc2V0cz10aGlzLmRyYXdjYWxscz1bXTt0aGlzLmJvdW5kaW5nU3BoZXJlPXRoaXMuYm91bmRpbmdCb3g9bnVsbH07XG5USFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkJ1ZmZlckdlb21ldHJ5LGFkZEF0dHJpYnV0ZTpmdW5jdGlvbihhLGIsYyl7ITE9PT1iIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyQXR0cmlidXRlPyhUSFJFRS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLlwiKSx0aGlzLmF0dHJpYnV0ZXNbYV09e2FycmF5OmIsaXRlbVNpemU6Y30pOih0aGlzLmF0dHJpYnV0ZXNbYV09Yix0aGlzLmF0dHJpYnV0ZXNLZXlzPU9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykpfSxnZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1thXX0sYWRkRHJhd0NhbGw6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuZHJhd2NhbGxzLnB1c2goe3N0YXJ0OmEsY291bnQ6YixpbmRleDp2b2lkIDAhPT1jP2M6MH0pfSxhcHBseU1hdHJpeDpmdW5jdGlvbihhKXt2YXIgYj1cbiAgICB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247dm9pZCAwIT09YiYmKGEuYXBwbHlUb1ZlY3RvcjNBcnJheShiLmFycmF5KSxiLm5lZWRzVXBkYXRlPSEwKTtiPXRoaXMuYXR0cmlidXRlcy5ub3JtYWw7dm9pZCAwIT09YiYmKChuZXcgVEhSRUUuTWF0cml4MykuZ2V0Tm9ybWFsTWF0cml4KGEpLmFwcGx5VG9WZWN0b3IzQXJyYXkoYi5hcnJheSksYi5uZWVkc1VwZGF0ZT0hMCk7bnVsbCE9PXRoaXMuYm91bmRpbmdCb3gmJnRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7bnVsbCE9PXRoaXMuYm91bmRpbmdTcGhlcmUmJnRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCl9LGNlbnRlcjpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7dmFyIGE9dGhpcy5ib3VuZGluZ0JveC5jZW50ZXIoKS5uZWdhdGUoKTt0aGlzLmFwcGx5TWF0cml4KChuZXcgVEhSRUUuTWF0cml4NCkuc2V0UG9zaXRpb24oYSkpO3JldHVybiBhfSxmcm9tR2VvbWV0cnk6ZnVuY3Rpb24oYSxiKXtiPWJ8fHt2ZXJ0ZXhDb2xvcnM6VEhSRUUuTm9Db2xvcnN9O1xuICAgIHZhciBjPWEudmVydGljZXMsZD1hLmZhY2VzLGU9YS5mYWNlVmVydGV4VXZzLGY9Yi52ZXJ0ZXhDb2xvcnMsZz0wPGVbMF0ubGVuZ3RoLGg9Mz09ZFswXS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCxrPW5ldyBGbG9hdDMyQXJyYXkoOSpkLmxlbmd0aCk7dGhpcy5hZGRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoaywzKSk7dmFyIGw9bmV3IEZsb2F0MzJBcnJheSg5KmQubGVuZ3RoKTt0aGlzLmFkZEF0dHJpYnV0ZShcIm5vcm1hbFwiLG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobCwzKSk7aWYoZiE9PVRIUkVFLk5vQ29sb3JzKXt2YXIgcD1uZXcgRmxvYXQzMkFycmF5KDkqZC5sZW5ndGgpO3RoaXMuYWRkQXR0cmlidXRlKFwiY29sb3JcIixuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHAsMykpfWlmKCEwPT09Zyl7dmFyIHE9bmV3IEZsb2F0MzJBcnJheSg2KmQubGVuZ3RoKTt0aGlzLmFkZEF0dHJpYnV0ZShcInV2XCIsbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShxLFxuICAgICAgICAyKSl9Zm9yKHZhciBuPTAsdD0wLHI9MDtuPGQubGVuZ3RoO24rKyx0Kz02LHIrPTkpe3ZhciBzPWRbbl0sdT1jW3MuYV0sdj1jW3MuYl0seD1jW3MuY107a1tyXT11Lng7a1tyKzFdPXUueTtrW3IrMl09dS56O2tbciszXT12Lng7a1tyKzRdPXYueTtrW3IrNV09di56O2tbcis2XT14Lng7a1tyKzddPXgueTtrW3IrOF09eC56OyEwPT09aD8odT1zLnZlcnRleE5vcm1hbHNbMF0sdj1zLnZlcnRleE5vcm1hbHNbMV0seD1zLnZlcnRleE5vcm1hbHNbMl0sbFtyXT11LngsbFtyKzFdPXUueSxsW3IrMl09dS56LGxbciszXT12LngsbFtyKzRdPXYueSxsW3IrNV09di56LGxbcis2XT14LngsbFtyKzddPXgueSxsW3IrOF09eC56KToodT1zLm5vcm1hbCxsW3JdPXUueCxsW3IrMV09dS55LGxbcisyXT11LnosbFtyKzNdPXUueCxsW3IrNF09dS55LGxbcis1XT11LnosbFtyKzZdPXUueCxsW3IrN109dS55LGxbcis4XT11LnopO2Y9PT1USFJFRS5GYWNlQ29sb3JzPyhzPXMuY29sb3IscFtyXT1cbiAgICAgICAgcy5yLHBbcisxXT1zLmcscFtyKzJdPXMuYixwW3IrM109cy5yLHBbcis0XT1zLmcscFtyKzVdPXMuYixwW3IrNl09cy5yLHBbcis3XT1zLmcscFtyKzhdPXMuYik6Zj09PVRIUkVFLlZlcnRleENvbG9ycyYmKHU9cy52ZXJ0ZXhDb2xvcnNbMF0sdj1zLnZlcnRleENvbG9yc1sxXSxzPXMudmVydGV4Q29sb3JzWzJdLHBbcl09dS5yLHBbcisxXT11LmcscFtyKzJdPXUuYixwW3IrM109di5yLHBbcis0XT12LmcscFtyKzVdPXYuYixwW3IrNl09cy5yLHBbcis3XT1zLmcscFtyKzhdPXMuYik7ITA9PT1nJiYocz1lWzBdW25dWzBdLHU9ZVswXVtuXVsxXSx2PWVbMF1bbl1bMl0scVt0XT1zLngscVt0KzFdPXMueSxxW3QrMl09dS54LHFbdCszXT11LnkscVt0KzRdPXYueCxxW3QrNV09di55KX10aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO3JldHVybiB0aGlzfSxjb21wdXRlQm91bmRpbmdCb3g6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oKXtudWxsPT09XG50aGlzLmJvdW5kaW5nQm94JiYodGhpcy5ib3VuZGluZ0JveD1uZXcgVEhSRUUuQm94Myk7dmFyIGI9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O2lmKGIpe3ZhciBjPXRoaXMuYm91bmRpbmdCb3g7Yy5tYWtlRW1wdHkoKTtmb3IodmFyIGQ9MCxlPWIubGVuZ3RoO2Q8ZTtkKz0zKWEuc2V0KGJbZF0sYltkKzFdLGJbZCsyXSksYy5leHBhbmRCeVBvaW50KGEpfWlmKHZvaWQgMD09PWJ8fDA9PT1iLmxlbmd0aCl0aGlzLmJvdW5kaW5nQm94Lm1pbi5zZXQoMCwwLDApLHRoaXMuYm91bmRpbmdCb3gubWF4LnNldCgwLDAsMCk7KGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLngpfHxpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi55KXx8aXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueikpJiZUSFJFRS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94OiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nKX19KCksXG4gICAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLkJveDMsYj1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oKXtudWxsPT09dGhpcy5ib3VuZGluZ1NwaGVyZSYmKHRoaXMuYm91bmRpbmdTcGhlcmU9bmV3IFRIUkVFLlNwaGVyZSk7dmFyIGM9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O2lmKGMpe2EubWFrZUVtcHR5KCk7Zm9yKHZhciBkPXRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyLGU9MCxmPWMubGVuZ3RoO2U8ZjtlKz0zKWIuc2V0KGNbZV0sY1tlKzFdLGNbZSsyXSksYS5leHBhbmRCeVBvaW50KGIpO2EuY2VudGVyKGQpO2Zvcih2YXIgZz0wLGU9MCxmPWMubGVuZ3RoO2U8ZjtlKz0zKWIuc2V0KGNbZV0sY1tlKzFdLGNbZSsyXSksZz1NYXRoLm1heChnLGQuZGlzdGFuY2VUb1NxdWFyZWQoYikpO3RoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzPU1hdGguc3FydChnKTtpc05hTih0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cykmJlxuICAgIFRIUkVFLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nKX19fSgpLGNvbXB1dGVGYWNlTm9ybWFsczpmdW5jdGlvbigpe30sY29tcHV0ZVZlcnRleE5vcm1hbHM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmF0dHJpYnV0ZXM7aWYoYS5wb3NpdGlvbil7dmFyIGI9YS5wb3NpdGlvbi5hcnJheTtpZih2b2lkIDA9PT1hLm5vcm1hbCl0aGlzLmFkZEF0dHJpYnV0ZShcIm5vcm1hbFwiLG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShiLmxlbmd0aCksMykpO2Vsc2UgZm9yKHZhciBjPWEubm9ybWFsLmFycmF5LGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspY1tkXT0wO3ZhciBjPWEubm9ybWFsLmFycmF5LGYsZyxoLGs9bmV3IFRIUkVFLlZlY3RvcjMsbD1uZXcgVEhSRUUuVmVjdG9yMyxcbiAgICAgICAgcD1uZXcgVEhSRUUuVmVjdG9yMyxxPW5ldyBUSFJFRS5WZWN0b3IzLG49bmV3IFRIUkVFLlZlY3RvcjM7aWYoYS5pbmRleClmb3IodmFyIHQ9YS5pbmRleC5hcnJheSxyPTA8dGhpcy5vZmZzZXRzLmxlbmd0aD90aGlzLm9mZnNldHM6W3tzdGFydDowLGNvdW50OnQubGVuZ3RoLGluZGV4OjB9XSxzPTAsdT1yLmxlbmd0aDtzPHU7KytzKXtlPXJbc10uc3RhcnQ7Zj1yW3NdLmNvdW50O2Zvcih2YXIgdj1yW3NdLmluZGV4LGQ9ZSxlPWUrZjtkPGU7ZCs9MylmPTMqKHYrdFtkXSksZz0zKih2K3RbZCsxXSksaD0zKih2K3RbZCsyXSksay5mcm9tQXJyYXkoYixmKSxsLmZyb21BcnJheShiLGcpLHAuZnJvbUFycmF5KGIsaCkscS5zdWJWZWN0b3JzKHAsbCksbi5zdWJWZWN0b3JzKGssbCkscS5jcm9zcyhuKSxjW2ZdKz1xLngsY1tmKzFdKz1xLnksY1tmKzJdKz1xLnosY1tnXSs9cS54LGNbZysxXSs9cS55LGNbZysyXSs9cS56LGNbaF0rPXEueCxjW2grMV0rPXEueSxjW2grMl0rPXEuen1lbHNlIGZvcihkPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLGU9Yi5sZW5ndGg7ZDxlO2QrPTkpay5mcm9tQXJyYXkoYixkKSxsLmZyb21BcnJheShiLGQrMykscC5mcm9tQXJyYXkoYixkKzYpLHEuc3ViVmVjdG9ycyhwLGwpLG4uc3ViVmVjdG9ycyhrLGwpLHEuY3Jvc3MobiksY1tkXT1xLngsY1tkKzFdPXEueSxjW2QrMl09cS56LGNbZCszXT1xLngsY1tkKzRdPXEueSxjW2QrNV09cS56LGNbZCs2XT1xLngsY1tkKzddPXEueSxjW2QrOF09cS56O3RoaXMubm9ybWFsaXplTm9ybWFscygpO2Eubm9ybWFsLm5lZWRzVXBkYXRlPSEwfX0sY29tcHV0ZVRhbmdlbnRzOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyl7cS5mcm9tQXJyYXkoZCwzKmEpO24uZnJvbUFycmF5KGQsMypiKTt0LmZyb21BcnJheShkLDMqYyk7ci5mcm9tQXJyYXkoZiwyKmEpO3MuZnJvbUFycmF5KGYsMipiKTt1LmZyb21BcnJheShmLDIqYyk7dj1uLngtcS54O3g9dC54LXEueDtEPW4ueS1xLnk7dz10LnktcS55O3k9bi56LXEuejtBPXQuei1xLno7RT1zLngtci54O0c9XG4gICAgICAgIHUueC1yLng7Rj1zLnktci55O3o9dS55LXIueTtJPTEvKEUqei1HKkYpO1Uuc2V0KCh6KnYtRip4KSpJLCh6KkQtRip3KSpJLCh6KnktRipBKSpJKTtNLnNldCgoRSp4LUcqdikqSSwoRSp3LUcqRCkqSSwoRSpBLUcqeSkqSSk7a1thXS5hZGQoVSk7a1tiXS5hZGQoVSk7a1tjXS5hZGQoVSk7bFthXS5hZGQoTSk7bFtiXS5hZGQoTSk7bFtjXS5hZGQoTSl9ZnVuY3Rpb24gYihhKXtoYS5mcm9tQXJyYXkoZSwzKmEpO08uY29weShoYSk7YmE9a1thXTtvYS5jb3B5KGJhKTtvYS5zdWIoaGEubXVsdGlwbHlTY2FsYXIoaGEuZG90KGJhKSkpLm5vcm1hbGl6ZSgpO2phLmNyb3NzVmVjdG9ycyhPLGJhKTtxYT1qYS5kb3QobFthXSk7Y2E9MD5xYT8tMToxO2hbNCphXT1vYS54O2hbNCphKzFdPW9hLnk7aFs0KmErMl09b2EuejtoWzQqYSszXT1jYX1pZih2b2lkIDA9PT10aGlzLmF0dHJpYnV0ZXMuaW5kZXh8fHZvaWQgMD09PXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbnx8dm9pZCAwPT09dGhpcy5hdHRyaWJ1dGVzLm5vcm1hbHx8XG4gICAgICAgIHZvaWQgMD09PXRoaXMuYXR0cmlidXRlcy51dilUSFJFRS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnk6IE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpIGluIEJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpXCIpO2Vsc2V7dmFyIGM9dGhpcy5hdHRyaWJ1dGVzLmluZGV4LmFycmF5LGQ9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5LGU9dGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSxmPXRoaXMuYXR0cmlidXRlcy51di5hcnJheSxnPWQubGVuZ3RoLzM7dm9pZCAwPT09dGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQmJnRoaXMuYWRkQXR0cmlidXRlKFwidGFuZ2VudFwiLG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSg0KmcpLDQpKTtmb3IodmFyIGg9dGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQuYXJyYXksaz1bXSxsPVtdLHA9MDtwPGc7cCsrKWtbcF09bmV3IFRIUkVFLlZlY3RvcjMsXG4gICAgICAgIGxbcF09bmV3IFRIUkVFLlZlY3RvcjM7dmFyIHE9bmV3IFRIUkVFLlZlY3RvcjMsbj1uZXcgVEhSRUUuVmVjdG9yMyx0PW5ldyBUSFJFRS5WZWN0b3IzLHI9bmV3IFRIUkVFLlZlY3RvcjIscz1uZXcgVEhSRUUuVmVjdG9yMix1PW5ldyBUSFJFRS5WZWN0b3IyLHYseCxELHcseSxBLEUsRyxGLHosSSxVPW5ldyBUSFJFRS5WZWN0b3IzLE09bmV3IFRIUkVFLlZlY3RvcjMsSCxMLFAsTixSOzA9PT10aGlzLmRyYXdjYWxscy5sZW5ndGgmJnRoaXMuYWRkRHJhd0NhbGwoMCxjLmxlbmd0aCwwKTt2YXIgVj10aGlzLmRyYXdjYWxscyxwPTA7Zm9yKEw9Vi5sZW5ndGg7cDxMOysrcCl7SD1WW3BdLnN0YXJ0O1A9VltwXS5jb3VudDt2YXIgSj1WW3BdLmluZGV4LGc9SDtmb3IoSCs9UDtnPEg7Zys9MylQPUorY1tnXSxOPUorY1tnKzFdLFI9SitjW2crMl0sYShQLE4sUil9dmFyIG9hPW5ldyBUSFJFRS5WZWN0b3IzLGphPW5ldyBUSFJFRS5WZWN0b3IzLGhhPW5ldyBUSFJFRS5WZWN0b3IzLE89bmV3IFRIUkVFLlZlY3RvcjMsXG4gICAgICAgIGNhLGJhLHFhLHA9MDtmb3IoTD1WLmxlbmd0aDtwPEw7KytwKWZvcihIPVZbcF0uc3RhcnQsUD1WW3BdLmNvdW50LEo9VltwXS5pbmRleCxnPUgsSCs9UDtnPEg7Zys9MylQPUorY1tnXSxOPUorY1tnKzFdLFI9SitjW2crMl0sYihQKSxiKE4pLGIoUil9fSxjb21wdXRlT2Zmc2V0czpmdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT02NTUzNSk7Zm9yKHZhciBiPXRoaXMuYXR0cmlidXRlcy5pbmRleC5hcnJheSxjPXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSxkPWIubGVuZ3RoLzMsZT1uZXcgVWludDE2QXJyYXkoYi5sZW5ndGgpLGY9MCxnPTAsaD1be3N0YXJ0OjAsY291bnQ6MCxpbmRleDowfV0saz1oWzBdLGw9MCxwPTAscT1uZXcgSW50MzJBcnJheSg2KSxuPW5ldyBJbnQzMkFycmF5KGMubGVuZ3RoKSx0PW5ldyBJbnQzMkFycmF5KGMubGVuZ3RoKSxyPTA7cjxjLmxlbmd0aDtyKyspbltyXT0tMSx0W3JdPS0xO2ZvcihjPTA7YzxkO2MrKyl7Zm9yKHZhciBzPXA9MDszPlxuICAgIHM7cysrKXI9YlszKmMrc10sLTE9PW5bcl0/KHFbMipzXT1yLHFbMipzKzFdPS0xLHArKyk6bltyXTxrLmluZGV4PyhxWzIqc109cixxWzIqcysxXT0tMSxsKyspOihxWzIqc109cixxWzIqcysxXT1uW3JdKTtpZihnK3A+ay5pbmRleCthKWZvcihrPXtzdGFydDpmLGNvdW50OjAsaW5kZXg6Z30saC5wdXNoKGspLHA9MDs2PnA7cCs9MilzPXFbcCsxXSwtMTxzJiZzPGsuaW5kZXgmJihxW3ArMV09LTEpO2ZvcihwPTA7Nj5wO3ArPTIpcj1xW3BdLHM9cVtwKzFdLC0xPT09cyYmKHM9ZysrKSxuW3JdPXMsdFtzXT1yLGVbZisrXT1zLWsuaW5kZXgsay5jb3VudCsrfXRoaXMucmVvcmRlckJ1ZmZlcnMoZSx0LGcpO3JldHVybiB0aGlzLmRyYXdjYWxscz10aGlzLm9mZnNldHM9aH0sbWVyZ2U6ZnVuY3Rpb24oYSxiKXtpZighMT09PWEgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSlUSFJFRS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS5cIixcbiAgICAgICAgYSk7ZWxzZXt2b2lkIDA9PT1iJiYoYj0wKTt2YXIgYz10aGlzLmF0dHJpYnV0ZXMsZDtmb3IoZCBpbiBjKWlmKHZvaWQgMCE9PWEuYXR0cmlidXRlc1tkXSlmb3IodmFyIGU9Y1tkXS5hcnJheSxmPWEuYXR0cmlidXRlc1tkXSxnPWYuYXJyYXksaD0wLGY9Zi5pdGVtU2l6ZSpiO2g8Zy5sZW5ndGg7aCsrLGYrKyllW2ZdPWdbaF07cmV0dXJuIHRoaXN9fSxub3JtYWxpemVOb3JtYWxzOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXksYixjLGQsZT0wLGY9YS5sZW5ndGg7ZTxmO2UrPTMpYj1hW2VdLGM9YVtlKzFdLGQ9YVtlKzJdLGI9MS9NYXRoLnNxcnQoYipiK2MqYytkKmQpLGFbZV0qPWIsYVtlKzFdKj1iLGFbZSsyXSo9Yn0scmVvcmRlckJ1ZmZlcnM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXt9LGU7Zm9yKGUgaW4gdGhpcy5hdHRyaWJ1dGVzKVwiaW5kZXhcIiE9ZSYmKGRbZV09bmV3IHRoaXMuYXR0cmlidXRlc1tlXS5hcnJheS5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXNbZV0uaXRlbVNpemUqXG4gICAgICAgIGMpKTtmb3IodmFyIGY9MDtmPGM7ZisrKXt2YXIgZz1iW2ZdO2ZvcihlIGluIHRoaXMuYXR0cmlidXRlcylpZihcImluZGV4XCIhPWUpZm9yKHZhciBoPXRoaXMuYXR0cmlidXRlc1tlXS5hcnJheSxrPXRoaXMuYXR0cmlidXRlc1tlXS5pdGVtU2l6ZSxsPWRbZV0scD0wO3A8aztwKyspbFtmKmsrcF09aFtnKmsrcF19dGhpcy5hdHRyaWJ1dGVzLmluZGV4LmFycmF5PWE7Zm9yKGUgaW4gdGhpcy5hdHRyaWJ1dGVzKVwiaW5kZXhcIiE9ZSYmKHRoaXMuYXR0cmlidXRlc1tlXS5hcnJheT1kW2VdLHRoaXMuYXR0cmlidXRlc1tlXS5udW1JdGVtcz10aGlzLmF0dHJpYnV0ZXNbZV0uaXRlbVNpemUqYyl9LHRvSlNPTjpmdW5jdGlvbigpe3ZhciBhPXttZXRhZGF0YTp7dmVyc2lvbjo0LHR5cGU6XCJCdWZmZXJHZW9tZXRyeVwiLGdlbmVyYXRvcjpcIkJ1ZmZlckdlb21ldHJ5RXhwb3J0ZXJcIn0sdXVpZDp0aGlzLnV1aWQsdHlwZTp0aGlzLnR5cGUsZGF0YTp7YXR0cmlidXRlczp7fX19LGI9dGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICBjPXRoaXMub2Zmc2V0cyxkPXRoaXMuYm91bmRpbmdTcGhlcmUsZTtmb3IoZSBpbiBiKXt2YXIgZj1iW2VdLGc9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZi5hcnJheSk7YS5kYXRhLmF0dHJpYnV0ZXNbZV09e2l0ZW1TaXplOmYuaXRlbVNpemUsdHlwZTpmLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsYXJyYXk6Z319MDxjLmxlbmd0aCYmKGEuZGF0YS5vZmZzZXRzPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpKTtudWxsIT09ZCYmKGEuZGF0YS5ib3VuZGluZ1NwaGVyZT17Y2VudGVyOmQuY2VudGVyLnRvQXJyYXkoKSxyYWRpdXM6ZC5yYWRpdXN9KTtyZXR1cm4gYX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnksYjtmb3IoYiBpbiB0aGlzLmF0dHJpYnV0ZXMpYS5hZGRBdHRyaWJ1dGUoYix0aGlzLmF0dHJpYnV0ZXNbYl0uY2xvbmUoKSk7Yj0wO2Zvcih2YXIgYz10aGlzLm9mZnNldHMubGVuZ3RoO2I8YztiKyspe3ZhciBkPXRoaXMub2Zmc2V0c1tiXTtcbiAgICAgICAgYS5vZmZzZXRzLnB1c2goe3N0YXJ0OmQuc3RhcnQsaW5kZXg6ZC5pbmRleCxjb3VudDpkLmNvdW50fSl9cmV0dXJuIGF9LGRpc3Bvc2U6ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJkaXNwb3NlXCJ9KX19O1RIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlKTtcblRIUkVFLkdlb21ldHJ5PWZ1bmN0aW9uKCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJpZFwiLHt2YWx1ZTpUSFJFRS5HZW9tZXRyeUlkQ291bnQrK30pO3RoaXMudXVpZD1USFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO3RoaXMubmFtZT1cIlwiO3RoaXMudHlwZT1cIkdlb21ldHJ5XCI7dGhpcy52ZXJ0aWNlcz1bXTt0aGlzLmNvbG9ycz1bXTt0aGlzLmZhY2VzPVtdO3RoaXMuZmFjZVZlcnRleFV2cz1bW11dO3RoaXMubW9ycGhUYXJnZXRzPVtdO3RoaXMubW9ycGhDb2xvcnM9W107dGhpcy5tb3JwaE5vcm1hbHM9W107dGhpcy5za2luV2VpZ2h0cz1bXTt0aGlzLnNraW5JbmRpY2VzPVtdO3RoaXMubGluZURpc3RhbmNlcz1bXTt0aGlzLmJvdW5kaW5nU3BoZXJlPXRoaXMuYm91bmRpbmdCb3g9bnVsbDt0aGlzLmhhc1RhbmdlbnRzPSExO3RoaXMuZHluYW1pYz0hMDt0aGlzLmdyb3Vwc05lZWRVcGRhdGU9dGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZT10aGlzLmNvbG9yc05lZWRVcGRhdGU9XG4gICAgdGhpcy50YW5nZW50c05lZWRVcGRhdGU9dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZT10aGlzLnV2c05lZWRVcGRhdGU9dGhpcy5lbGVtZW50c05lZWRVcGRhdGU9dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGU9ITF9O1xuVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5HZW9tZXRyeSxhcHBseU1hdHJpeDpmdW5jdGlvbihhKXtmb3IodmFyIGI9KG5ldyBUSFJFRS5NYXRyaXgzKS5nZXROb3JtYWxNYXRyaXgoYSksYz0wLGQ9dGhpcy52ZXJ0aWNlcy5sZW5ndGg7YzxkO2MrKyl0aGlzLnZlcnRpY2VzW2NdLmFwcGx5TWF0cml4NChhKTtjPTA7Zm9yKGQ9dGhpcy5mYWNlcy5sZW5ndGg7YzxkO2MrKyl7YT10aGlzLmZhY2VzW2NdO2Eubm9ybWFsLmFwcGx5TWF0cml4MyhiKS5ub3JtYWxpemUoKTtmb3IodmFyIGU9MCxmPWEudmVydGV4Tm9ybWFscy5sZW5ndGg7ZTxmO2UrKylhLnZlcnRleE5vcm1hbHNbZV0uYXBwbHlNYXRyaXgzKGIpLm5vcm1hbGl6ZSgpfW51bGwhPT10aGlzLmJvdW5kaW5nQm94JiZ0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO251bGwhPT10aGlzLmJvdW5kaW5nU3BoZXJlJiZ0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO3RoaXMubm9ybWFsc05lZWRVcGRhdGU9XG4gICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGU9ITB9LGZyb21CdWZmZXJHZW9tZXRyeTpmdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcyxjPWEuYXR0cmlidXRlcyxkPWMucG9zaXRpb24uYXJyYXksZT12b2lkIDAhPT1jLmluZGV4P2MuaW5kZXguYXJyYXk6dm9pZCAwLGY9dm9pZCAwIT09Yy5ub3JtYWw/Yy5ub3JtYWwuYXJyYXk6dm9pZCAwLGc9dm9pZCAwIT09Yy5jb2xvcj9jLmNvbG9yLmFycmF5OnZvaWQgMCxoPXZvaWQgMCE9PWMudXY/Yy51di5hcnJheTp2b2lkIDAsaz1bXSxsPVtdLHA9Yz0wO2M8ZC5sZW5ndGg7Yys9MyxwKz0yKWIudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhkW2NdLGRbYysxXSxkW2MrMl0pKSx2b2lkIDAhPT1mJiZrLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoZltjXSxmW2MrMV0sZltjKzJdKSksdm9pZCAwIT09ZyYmYi5jb2xvcnMucHVzaChuZXcgVEhSRUUuQ29sb3IoZ1tjXSxnW2MrMV0sZ1tjKzJdKSksdm9pZCAwIT09aCYmbC5wdXNoKG5ldyBUSFJFRS5WZWN0b3IyKGhbcF0sXG4gICAgaFtwKzFdKSk7dmFyIHE9ZnVuY3Rpb24oYSxjLGQpe3ZhciBlPXZvaWQgMCE9PWY/W2tbYV0uY2xvbmUoKSxrW2NdLmNsb25lKCksa1tkXS5jbG9uZSgpXTpbXSxuPXZvaWQgMCE9PWc/W2IuY29sb3JzW2FdLmNsb25lKCksYi5jb2xvcnNbY10uY2xvbmUoKSxiLmNvbG9yc1tkXS5jbG9uZSgpXTpbXTtiLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGEsYyxkLGUsbikpO3ZvaWQgMCE9PWgmJmIuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtsW2FdLmNsb25lKCksbFtjXS5jbG9uZSgpLGxbZF0uY2xvbmUoKV0pfTtpZih2b2lkIDAhPT1lKWlmKGQ9YS5kcmF3Y2FsbHMsMDxkLmxlbmd0aClmb3IoYz0wO2M8ZC5sZW5ndGg7YysrKWZvcih2YXIgcD1kW2NdLG49cC5zdGFydCx0PXAuY291bnQscj1wLmluZGV4LHA9bixuPW4rdDtwPG47cCs9MylxKHIrZVtwXSxyK2VbcCsxXSxyK2VbcCsyXSk7ZWxzZSBmb3IoYz0wO2M8ZS5sZW5ndGg7Yys9MylxKGVbY10sZVtjKzFdLGVbYysyXSk7ZWxzZSBmb3IoYz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtjPGQubGVuZ3RoLzM7Yys9MylxKGMsYysxLGMrMik7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtudWxsIT09YS5ib3VuZGluZ0JveCYmKHRoaXMuYm91bmRpbmdCb3g9YS5ib3VuZGluZ0JveC5jbG9uZSgpKTtudWxsIT09YS5ib3VuZGluZ1NwaGVyZSYmKHRoaXMuYm91bmRpbmdTcGhlcmU9YS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpKTtyZXR1cm4gdGhpc30sY2VudGVyOmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTt2YXIgYT10aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO3RoaXMuYXBwbHlNYXRyaXgoKG5ldyBUSFJFRS5NYXRyaXg0KS5zZXRQb3NpdGlvbihhKSk7cmV0dXJuIGF9LGNvbXB1dGVGYWNlTm9ybWFsczpmdW5jdGlvbigpe2Zvcih2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5WZWN0b3IzLGM9MCxkPXRoaXMuZmFjZXMubGVuZ3RoO2M8ZDtjKyspe3ZhciBlPXRoaXMuZmFjZXNbY10sZj10aGlzLnZlcnRpY2VzW2UuYV0sXG4gICAgZz10aGlzLnZlcnRpY2VzW2UuYl07YS5zdWJWZWN0b3JzKHRoaXMudmVydGljZXNbZS5jXSxnKTtiLnN1YlZlY3RvcnMoZixnKTthLmNyb3NzKGIpO2Eubm9ybWFsaXplKCk7ZS5ub3JtYWwuY29weShhKX19LGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZDtkPUFycmF5KHRoaXMudmVydGljZXMubGVuZ3RoKTtiPTA7Zm9yKGM9dGhpcy52ZXJ0aWNlcy5sZW5ndGg7YjxjO2IrKylkW2JdPW5ldyBUSFJFRS5WZWN0b3IzO2lmKGEpe3ZhciBlLGYsZyxoPW5ldyBUSFJFRS5WZWN0b3IzLGs9bmV3IFRIUkVFLlZlY3RvcjM7YT0wO2ZvcihiPXRoaXMuZmFjZXMubGVuZ3RoO2E8YjthKyspYz10aGlzLmZhY2VzW2FdLGU9dGhpcy52ZXJ0aWNlc1tjLmFdLGY9dGhpcy52ZXJ0aWNlc1tjLmJdLGc9dGhpcy52ZXJ0aWNlc1tjLmNdLGguc3ViVmVjdG9ycyhnLGYpLGsuc3ViVmVjdG9ycyhlLGYpLGguY3Jvc3MoayksZFtjLmFdLmFkZChoKSxkW2MuYl0uYWRkKGgpLGRbYy5jXS5hZGQoaCl9ZWxzZSBmb3IoYT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxiPXRoaXMuZmFjZXMubGVuZ3RoO2E8YjthKyspYz10aGlzLmZhY2VzW2FdLGRbYy5hXS5hZGQoYy5ub3JtYWwpLGRbYy5iXS5hZGQoYy5ub3JtYWwpLGRbYy5jXS5hZGQoYy5ub3JtYWwpO2I9MDtmb3IoYz10aGlzLnZlcnRpY2VzLmxlbmd0aDtiPGM7YisrKWRbYl0ubm9ybWFsaXplKCk7YT0wO2ZvcihiPXRoaXMuZmFjZXMubGVuZ3RoO2E8YjthKyspYz10aGlzLmZhY2VzW2FdLGMudmVydGV4Tm9ybWFsc1swXT1kW2MuYV0uY2xvbmUoKSxjLnZlcnRleE5vcm1hbHNbMV09ZFtjLmJdLmNsb25lKCksYy52ZXJ0ZXhOb3JtYWxzWzJdPWRbYy5jXS5jbG9uZSgpfSxjb21wdXRlTW9ycGhOb3JtYWxzOmZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZTtjPTA7Zm9yKGQ9dGhpcy5mYWNlcy5sZW5ndGg7YzxkO2MrKylmb3IoZT10aGlzLmZhY2VzW2NdLGUuX19vcmlnaW5hbEZhY2VOb3JtYWw/ZS5fX29yaWdpbmFsRmFjZU5vcm1hbC5jb3B5KGUubm9ybWFsKTplLl9fb3JpZ2luYWxGYWNlTm9ybWFsPVxuICAgIGUubm9ybWFsLmNsb25lKCksZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc3x8KGUuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM9W10pLGE9MCxiPWUudmVydGV4Tm9ybWFscy5sZW5ndGg7YTxiO2ErKyllLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzW2FdP2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbYV0uY29weShlLnZlcnRleE5vcm1hbHNbYV0pOmUuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbYV09ZS52ZXJ0ZXhOb3JtYWxzW2FdLmNsb25lKCk7dmFyIGY9bmV3IFRIUkVFLkdlb21ldHJ5O2YuZmFjZXM9dGhpcy5mYWNlczthPTA7Zm9yKGI9dGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoO2E8YjthKyspe2lmKCF0aGlzLm1vcnBoTm9ybWFsc1thXSl7dGhpcy5tb3JwaE5vcm1hbHNbYV09e307dGhpcy5tb3JwaE5vcm1hbHNbYV0uZmFjZU5vcm1hbHM9W107dGhpcy5tb3JwaE5vcm1hbHNbYV0udmVydGV4Tm9ybWFscz1bXTtlPXRoaXMubW9ycGhOb3JtYWxzW2FdLmZhY2VOb3JtYWxzO3ZhciBnPVxuICAgIHRoaXMubW9ycGhOb3JtYWxzW2FdLnZlcnRleE5vcm1hbHMsaCxrO2M9MDtmb3IoZD10aGlzLmZhY2VzLmxlbmd0aDtjPGQ7YysrKWg9bmV3IFRIUkVFLlZlY3RvcjMsaz17YTpuZXcgVEhSRUUuVmVjdG9yMyxiOm5ldyBUSFJFRS5WZWN0b3IzLGM6bmV3IFRIUkVFLlZlY3RvcjN9LGUucHVzaChoKSxnLnB1c2goayl9Zz10aGlzLm1vcnBoTm9ybWFsc1thXTtmLnZlcnRpY2VzPXRoaXMubW9ycGhUYXJnZXRzW2FdLnZlcnRpY2VzO2YuY29tcHV0ZUZhY2VOb3JtYWxzKCk7Zi5jb21wdXRlVmVydGV4Tm9ybWFscygpO2M9MDtmb3IoZD10aGlzLmZhY2VzLmxlbmd0aDtjPGQ7YysrKWU9dGhpcy5mYWNlc1tjXSxoPWcuZmFjZU5vcm1hbHNbY10saz1nLnZlcnRleE5vcm1hbHNbY10saC5jb3B5KGUubm9ybWFsKSxrLmEuY29weShlLnZlcnRleE5vcm1hbHNbMF0pLGsuYi5jb3B5KGUudmVydGV4Tm9ybWFsc1sxXSksay5jLmNvcHkoZS52ZXJ0ZXhOb3JtYWxzWzJdKX1jPTA7Zm9yKGQ9dGhpcy5mYWNlcy5sZW5ndGg7YzxcbmQ7YysrKWU9dGhpcy5mYWNlc1tjXSxlLm5vcm1hbD1lLl9fb3JpZ2luYWxGYWNlTm9ybWFsLGUudmVydGV4Tm9ybWFscz1lLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzfSxjb21wdXRlVGFuZ2VudHM6ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZyxoLGssbCxwLHEsbix0LHIscyx1LHY9W10seD1bXTtjPW5ldyBUSFJFRS5WZWN0b3IzO3ZhciBEPW5ldyBUSFJFRS5WZWN0b3IzLHc9bmV3IFRIUkVFLlZlY3RvcjMseT1uZXcgVEhSRUUuVmVjdG9yMyxBPW5ldyBUSFJFRS5WZWN0b3IzO2E9MDtmb3IoYj10aGlzLnZlcnRpY2VzLmxlbmd0aDthPGI7YSsrKXZbYV09bmV3IFRIUkVFLlZlY3RvcjMseFthXT1uZXcgVEhSRUUuVmVjdG9yMzthPTA7Zm9yKGI9dGhpcy5mYWNlcy5sZW5ndGg7YTxiO2ErKyllPXRoaXMuZmFjZXNbYV0sZj10aGlzLmZhY2VWZXJ0ZXhVdnNbMF1bYV0sZD1lLmEsdT1lLmIsZT1lLmMsZz10aGlzLnZlcnRpY2VzW2RdLGg9dGhpcy52ZXJ0aWNlc1t1XSxrPXRoaXMudmVydGljZXNbZV0sXG4gICAgbD1mWzBdLHA9ZlsxXSxxPWZbMl0sZj1oLngtZy54LG49ay54LWcueCx0PWgueS1nLnkscj1rLnktZy55LGg9aC56LWcueixnPWsuei1nLnosaz1wLngtbC54LHM9cS54LWwueCxwPXAueS1sLnksbD1xLnktbC55LHE9MS8oaypsLXMqcCksYy5zZXQoKGwqZi1wKm4pKnEsKGwqdC1wKnIpKnEsKGwqaC1wKmcpKnEpLEQuc2V0KChrKm4tcypmKSpxLChrKnItcyp0KSpxLChrKmctcypoKSpxKSx2W2RdLmFkZChjKSx2W3VdLmFkZChjKSx2W2VdLmFkZChjKSx4W2RdLmFkZChEKSx4W3VdLmFkZChEKSx4W2VdLmFkZChEKTtEPVtcImFcIixcImJcIixcImNcIixcImRcIl07YT0wO2ZvcihiPXRoaXMuZmFjZXMubGVuZ3RoO2E8YjthKyspZm9yKGU9dGhpcy5mYWNlc1thXSxjPTA7YzxNYXRoLm1pbihlLnZlcnRleE5vcm1hbHMubGVuZ3RoLDMpO2MrKylBLmNvcHkoZS52ZXJ0ZXhOb3JtYWxzW2NdKSxkPWVbRFtjXV0sdT12W2RdLHcuY29weSh1KSx3LnN1YihBLm11bHRpcGx5U2NhbGFyKEEuZG90KHUpKSkubm9ybWFsaXplKCksXG4gICAgeS5jcm9zc1ZlY3RvcnMoZS52ZXJ0ZXhOb3JtYWxzW2NdLHUpLGQ9eS5kb3QoeFtkXSksZD0wPmQ/LTE6MSxlLnZlcnRleFRhbmdlbnRzW2NdPW5ldyBUSFJFRS5WZWN0b3I0KHcueCx3Lnksdy56LGQpO3RoaXMuaGFzVGFuZ2VudHM9ITB9LGNvbXB1dGVMaW5lRGlzdGFuY2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPTAsYj10aGlzLnZlcnRpY2VzLGM9MCxkPWIubGVuZ3RoO2M8ZDtjKyspMDxjJiYoYSs9YltjXS5kaXN0YW5jZVRvKGJbYy0xXSkpLHRoaXMubGluZURpc3RhbmNlc1tjXT1hfSxjb21wdXRlQm91bmRpbmdCb3g6ZnVuY3Rpb24oKXtudWxsPT09dGhpcy5ib3VuZGluZ0JveCYmKHRoaXMuYm91bmRpbmdCb3g9bmV3IFRIUkVFLkJveDMpO3RoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzKX0sY29tcHV0ZUJvdW5kaW5nU3BoZXJlOmZ1bmN0aW9uKCl7bnVsbD09PXRoaXMuYm91bmRpbmdTcGhlcmUmJih0aGlzLmJvdW5kaW5nU3BoZXJlPW5ldyBUSFJFRS5TcGhlcmUpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzKX0sbWVyZ2U6ZnVuY3Rpb24oYSxiLGMpe2lmKCExPT09YSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5KVRIUkVFLmVycm9yKFwiVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LlwiLGEpO2Vsc2V7dmFyIGQsZT10aGlzLnZlcnRpY2VzLmxlbmd0aCxmPXRoaXMudmVydGljZXMsZz1hLnZlcnRpY2VzLGg9dGhpcy5mYWNlcyxrPWEuZmFjZXMsbD10aGlzLmZhY2VWZXJ0ZXhVdnNbMF07YT1hLmZhY2VWZXJ0ZXhVdnNbMF07dm9pZCAwPT09YyYmKGM9MCk7dm9pZCAwIT09YiYmKGQ9KG5ldyBUSFJFRS5NYXRyaXgzKS5nZXROb3JtYWxNYXRyaXgoYikpO2Zvcih2YXIgcD0wLHE9Zy5sZW5ndGg7cDxxO3ArKyl7dmFyIG49Z1twXS5jbG9uZSgpO3ZvaWQgMCE9PWImJm4uYXBwbHlNYXRyaXg0KGIpO2YucHVzaChuKX1wPTA7Zm9yKHE9ay5sZW5ndGg7cDxcbnE7cCsrKXt2YXIgZz1rW3BdLHQscj1nLnZlcnRleE5vcm1hbHMscz1nLnZlcnRleENvbG9ycyxuPW5ldyBUSFJFRS5GYWNlMyhnLmErZSxnLmIrZSxnLmMrZSk7bi5ub3JtYWwuY29weShnLm5vcm1hbCk7dm9pZCAwIT09ZCYmbi5ub3JtYWwuYXBwbHlNYXRyaXgzKGQpLm5vcm1hbGl6ZSgpO2I9MDtmb3IoZj1yLmxlbmd0aDtiPGY7YisrKXQ9cltiXS5jbG9uZSgpLHZvaWQgMCE9PWQmJnQuYXBwbHlNYXRyaXgzKGQpLm5vcm1hbGl6ZSgpLG4udmVydGV4Tm9ybWFscy5wdXNoKHQpO24uY29sb3IuY29weShnLmNvbG9yKTtiPTA7Zm9yKGY9cy5sZW5ndGg7YjxmO2IrKyl0PXNbYl0sbi52ZXJ0ZXhDb2xvcnMucHVzaCh0LmNsb25lKCkpO24ubWF0ZXJpYWxJbmRleD1nLm1hdGVyaWFsSW5kZXgrYztoLnB1c2gobil9cD0wO2ZvcihxPWEubGVuZ3RoO3A8cTtwKyspaWYoYz1hW3BdLGQ9W10sdm9pZCAwIT09Yyl7Yj0wO2ZvcihmPWMubGVuZ3RoO2I8ZjtiKyspZC5wdXNoKGNbYl0uY2xvbmUoKSk7XG4gICAgbC5wdXNoKGQpfX19LG1lcmdlTWVzaDpmdW5jdGlvbihhKXshMT09PWEgaW5zdGFuY2VvZiBUSFJFRS5NZXNoP1RIUkVFLmVycm9yKFwiVEhSRUUuR2VvbWV0cnkubWVyZ2VNZXNoKCk6IG1lc2ggbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk1lc2guXCIsYSk6KGEubWF0cml4QXV0b1VwZGF0ZSYmYS51cGRhdGVNYXRyaXgoKSx0aGlzLm1lcmdlKGEuZ2VvbWV0cnksYS5tYXRyaXgpKX0sbWVyZ2VWZXJ0aWNlczpmdW5jdGlvbigpe3ZhciBhPXt9LGI9W10sYz1bXSxkLGU9TWF0aC5wb3coMTAsNCksZixnO2Y9MDtmb3IoZz10aGlzLnZlcnRpY2VzLmxlbmd0aDtmPGc7ZisrKWQ9dGhpcy52ZXJ0aWNlc1tmXSxkPU1hdGgucm91bmQoZC54KmUpK1wiX1wiK01hdGgucm91bmQoZC55KmUpK1wiX1wiK01hdGgucm91bmQoZC56KmUpLHZvaWQgMD09PWFbZF0/KGFbZF09ZixiLnB1c2godGhpcy52ZXJ0aWNlc1tmXSksY1tmXT1iLmxlbmd0aC0xKTpjW2ZdPWNbYVtkXV07YT1bXTtmPTA7Zm9yKGc9dGhpcy5mYWNlcy5sZW5ndGg7Zjxcbmc7ZisrKWZvcihlPXRoaXMuZmFjZXNbZl0sZS5hPWNbZS5hXSxlLmI9Y1tlLmJdLGUuYz1jW2UuY10sZT1bZS5hLGUuYixlLmNdLGQ9MDszPmQ7ZCsrKWlmKGVbZF09PWVbKGQrMSklM10pe2EucHVzaChmKTticmVha31mb3IoZj1hLmxlbmd0aC0xOzA8PWY7Zi0tKWZvcihlPWFbZl0sdGhpcy5mYWNlcy5zcGxpY2UoZSwxKSxjPTAsZz10aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoO2M8ZztjKyspdGhpcy5mYWNlVmVydGV4VXZzW2NdLnNwbGljZShlLDEpO2Y9dGhpcy52ZXJ0aWNlcy5sZW5ndGgtYi5sZW5ndGg7dGhpcy52ZXJ0aWNlcz1iO3JldHVybiBmfSx0b0pTT046ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYixjKXtyZXR1cm4gYz9hfDE8PGI6YSZ+KDE8PGIpfWZ1bmN0aW9uIGIoYSl7dmFyIGI9YS54LnRvU3RyaW5nKCkrYS55LnRvU3RyaW5nKCkrYS56LnRvU3RyaW5nKCk7aWYodm9pZCAwIT09bFtiXSlyZXR1cm4gbFtiXTtsW2JdPWsubGVuZ3RoLzM7ay5wdXNoKGEueCxhLnksXG4gICAgYS56KTtyZXR1cm4gbFtiXX1mdW5jdGlvbiBjKGEpe3ZhciBiPWEuci50b1N0cmluZygpK2EuZy50b1N0cmluZygpK2EuYi50b1N0cmluZygpO2lmKHZvaWQgMCE9PXFbYl0pcmV0dXJuIHFbYl07cVtiXT1wLmxlbmd0aDtwLnB1c2goYS5nZXRIZXgoKSk7cmV0dXJuIHFbYl19ZnVuY3Rpb24gZChhKXt2YXIgYj1hLngudG9TdHJpbmcoKSthLnkudG9TdHJpbmcoKTtpZih2b2lkIDAhPT10W2JdKXJldHVybiB0W2JdO3RbYl09bi5sZW5ndGgvMjtuLnB1c2goYS54LGEueSk7cmV0dXJuIHRbYl19dmFyIGU9e21ldGFkYXRhOnt2ZXJzaW9uOjQsdHlwZTpcIkJ1ZmZlckdlb21ldHJ5XCIsZ2VuZXJhdG9yOlwiQnVmZmVyR2VvbWV0cnlFeHBvcnRlclwifSx1dWlkOnRoaXMudXVpZCx0eXBlOnRoaXMudHlwZX07XCJcIiE9PXRoaXMubmFtZSYmKGUubmFtZT10aGlzLm5hbWUpO2lmKHZvaWQgMCE9PXRoaXMucGFyYW1ldGVycyl7dmFyIGY9dGhpcy5wYXJhbWV0ZXJzLGc7Zm9yKGcgaW4gZil2b2lkIDAhPT1cbmZbZ10mJihlW2ddPWZbZ10pO3JldHVybiBlfWY9W107Zm9yKGc9MDtnPHRoaXMudmVydGljZXMubGVuZ3RoO2crKyl7dmFyIGg9dGhpcy52ZXJ0aWNlc1tnXTtmLnB1c2goaC54LGgueSxoLnopfXZhciBoPVtdLGs9W10sbD17fSxwPVtdLHE9e30sbj1bXSx0PXt9O2ZvcihnPTA7Zzx0aGlzLmZhY2VzLmxlbmd0aDtnKyspe3ZhciByPXRoaXMuZmFjZXNbZ10scz12b2lkIDAhPT10aGlzLmZhY2VWZXJ0ZXhVdnNbMF1bZ10sdT0wPHIubm9ybWFsLmxlbmd0aCgpLHY9MDxyLnZlcnRleE5vcm1hbHMubGVuZ3RoLHg9MSE9PXIuY29sb3Iucnx8MSE9PXIuY29sb3IuZ3x8MSE9PXIuY29sb3IuYixEPTA8ci52ZXJ0ZXhDb2xvcnMubGVuZ3RoLHc9MCx3PWEodywwLDApLHc9YSh3LDEsITEpLHc9YSh3LDIsITEpLHc9YSh3LDMscyksdz1hKHcsNCx1KSx3PWEodyw1LHYpLHc9YSh3LDYseCksdz1hKHcsNyxEKTtoLnB1c2godyk7aC5wdXNoKHIuYSxyLmIsci5jKTtzJiYocz10aGlzLmZhY2VWZXJ0ZXhVdnNbMF1bZ10sXG4gICAgaC5wdXNoKGQoc1swXSksZChzWzFdKSxkKHNbMl0pKSk7dSYmaC5wdXNoKGIoci5ub3JtYWwpKTt2JiYodT1yLnZlcnRleE5vcm1hbHMsaC5wdXNoKGIodVswXSksYih1WzFdKSxiKHVbMl0pKSk7eCYmaC5wdXNoKGMoci5jb2xvcikpO0QmJihyPXIudmVydGV4Q29sb3JzLGgucHVzaChjKHJbMF0pLGMoclsxXSksYyhyWzJdKSkpfWUuZGF0YT17fTtlLmRhdGEudmVydGljZXM9ZjtlLmRhdGEubm9ybWFscz1rOzA8cC5sZW5ndGgmJihlLmRhdGEuY29sb3JzPXApOzA8bi5sZW5ndGgmJihlLmRhdGEudXZzPVtuXSk7ZS5kYXRhLmZhY2VzPWg7cmV0dXJuIGV9LGNsb25lOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPW5ldyBUSFJFRS5HZW9tZXRyeSxiPXRoaXMudmVydGljZXMsYz0wLGQ9Yi5sZW5ndGg7YzxkO2MrKylhLnZlcnRpY2VzLnB1c2goYltjXS5jbG9uZSgpKTtiPXRoaXMuZmFjZXM7Yz0wO2ZvcihkPWIubGVuZ3RoO2M8ZDtjKyspYS5mYWNlcy5wdXNoKGJbY10uY2xvbmUoKSk7Yz0wO1xuICAgIGZvcihkPXRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7YzxkO2MrKyl7Yj10aGlzLmZhY2VWZXJ0ZXhVdnNbY107dm9pZCAwPT09YS5mYWNlVmVydGV4VXZzW2NdJiYoYS5mYWNlVmVydGV4VXZzW2NdPVtdKTtmb3IodmFyIGU9MCxmPWIubGVuZ3RoO2U8ZjtlKyspe2Zvcih2YXIgZz1iW2VdLGg9W10saz0wLGw9Zy5sZW5ndGg7azxsO2srKyloLnB1c2goZ1trXS5jbG9uZSgpKTthLmZhY2VWZXJ0ZXhVdnNbY10ucHVzaChoKX19cmV0dXJuIGF9LGRpc3Bvc2U6ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJkaXNwb3NlXCJ9KX19O1RIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5HZW9tZXRyeUlkQ291bnQ9MDtcblRIUkVFLkNhbWVyYT1mdW5jdGlvbigpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy50eXBlPVwiQ2FtZXJhXCI7dGhpcy5tYXRyaXhXb3JsZEludmVyc2U9bmV3IFRIUkVFLk1hdHJpeDQ7dGhpcy5wcm9qZWN0aW9uTWF0cml4PW5ldyBUSFJFRS5NYXRyaXg0fTtUSFJFRS5DYW1lcmEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkNhbWVyYTtUSFJFRS5DYW1lcmEucHJvdG90eXBlLmdldFdvcmxkRGlyZWN0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlF1YXRlcm5pb247cmV0dXJuIGZ1bmN0aW9uKGIpe2I9Ynx8bmV3IFRIUkVFLlZlY3RvcjM7dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oYSk7cmV0dXJuIGIuc2V0KDAsMCwtMSkuYXBwbHlRdWF0ZXJuaW9uKGEpfX0oKTtcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUubG9va0F0PWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLk1hdHJpeDQ7cmV0dXJuIGZ1bmN0aW9uKGIpe2EubG9va0F0KHRoaXMucG9zaXRpb24sYix0aGlzLnVwKTt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGEpfX0oKTtUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5DYW1lcmEpO1RIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSk7YS5wcm9qZWN0aW9uTWF0cml4LmNvcHkodGhpcy5wcm9qZWN0aW9uTWF0cml4KTtyZXR1cm4gYX07XG5USFJFRS5DdWJlQ2FtZXJhPWZ1bmN0aW9uKGEsYixjKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIkN1YmVDYW1lcmFcIjt2YXIgZD1uZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoOTAsMSxhLGIpO2QudXAuc2V0KDAsLTEsMCk7ZC5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoMSwwLDApKTt0aGlzLmFkZChkKTt2YXIgZT1uZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoOTAsMSxhLGIpO2UudXAuc2V0KDAsLTEsMCk7ZS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoLTEsMCwwKSk7dGhpcy5hZGQoZSk7dmFyIGY9bmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDkwLDEsYSxiKTtmLnVwLnNldCgwLDAsMSk7Zi5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoMCwxLDApKTt0aGlzLmFkZChmKTt2YXIgZz1uZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoOTAsMSxhLGIpO2cudXAuc2V0KDAsMCwtMSk7Zy5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoMCwtMSwwKSk7XG4gICAgdGhpcy5hZGQoZyk7dmFyIGg9bmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDkwLDEsYSxiKTtoLnVwLnNldCgwLC0xLDApO2gubG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwxKSk7dGhpcy5hZGQoaCk7dmFyIGs9bmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDkwLDEsYSxiKTtrLnVwLnNldCgwLC0xLDApO2subG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwtMSkpO3RoaXMuYWRkKGspO3RoaXMucmVuZGVyVGFyZ2V0PW5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoYyxjLHtmb3JtYXQ6VEhSRUUuUkdCRm9ybWF0LG1hZ0ZpbHRlcjpUSFJFRS5MaW5lYXJGaWx0ZXIsbWluRmlsdGVyOlRIUkVFLkxpbmVhckZpbHRlcn0pO3RoaXMudXBkYXRlQ3ViZU1hcD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMucmVuZGVyVGFyZ2V0LG49Yy5nZW5lcmF0ZU1pcG1hcHM7Yy5nZW5lcmF0ZU1pcG1hcHM9ITE7Yy5hY3RpdmVDdWJlRmFjZT0wO2EucmVuZGVyKGIsZCxjKTtjLmFjdGl2ZUN1YmVGYWNlPVxuICAgICAgICAxO2EucmVuZGVyKGIsZSxjKTtjLmFjdGl2ZUN1YmVGYWNlPTI7YS5yZW5kZXIoYixmLGMpO2MuYWN0aXZlQ3ViZUZhY2U9MzthLnJlbmRlcihiLGcsYyk7Yy5hY3RpdmVDdWJlRmFjZT00O2EucmVuZGVyKGIsaCxjKTtjLmdlbmVyYXRlTWlwbWFwcz1uO2MuYWN0aXZlQ3ViZUZhY2U9NTthLnJlbmRlcihiLGssYyl9fTtUSFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuQ3ViZUNhbWVyYTtcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYT1mdW5jdGlvbihhLGIsYyxkLGUsZil7VEhSRUUuQ2FtZXJhLmNhbGwodGhpcyk7dGhpcy50eXBlPVwiT3J0aG9ncmFwaGljQ2FtZXJhXCI7dGhpcy56b29tPTE7dGhpcy5sZWZ0PWE7dGhpcy5yaWdodD1iO3RoaXMudG9wPWM7dGhpcy5ib3R0b209ZDt0aGlzLm5lYXI9dm9pZCAwIT09ZT9lOi4xO3RoaXMuZmFyPXZvaWQgMCE9PWY/ZjoyRTM7dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9O1RIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DYW1lcmEucHJvdG90eXBlKTtUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYTtcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeD1mdW5jdGlvbigpe3ZhciBhPSh0aGlzLnJpZ2h0LXRoaXMubGVmdCkvKDIqdGhpcy56b29tKSxiPSh0aGlzLnRvcC10aGlzLmJvdHRvbSkvKDIqdGhpcy56b29tKSxjPSh0aGlzLnJpZ2h0K3RoaXMubGVmdCkvMixkPSh0aGlzLnRvcCt0aGlzLmJvdHRvbSkvMjt0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyhjLWEsYythLGQrYixkLWIsdGhpcy5uZWFyLHRoaXMuZmFyKX07XG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYTtUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLnpvb209dGhpcy56b29tO2EubGVmdD10aGlzLmxlZnQ7YS5yaWdodD10aGlzLnJpZ2h0O2EudG9wPXRoaXMudG9wO2EuYm90dG9tPXRoaXMuYm90dG9tO2EubmVhcj10aGlzLm5lYXI7YS5mYXI9dGhpcy5mYXI7YS5wcm9qZWN0aW9uTWF0cml4LmNvcHkodGhpcy5wcm9qZWN0aW9uTWF0cml4KTtyZXR1cm4gYX07XG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYT1mdW5jdGlvbihhLGIsYyxkKXtUSFJFRS5DYW1lcmEuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJQZXJzcGVjdGl2ZUNhbWVyYVwiO3RoaXMuem9vbT0xO3RoaXMuZm92PXZvaWQgMCE9PWE/YTo1MDt0aGlzLmFzcGVjdD12b2lkIDAhPT1iP2I6MTt0aGlzLm5lYXI9dm9pZCAwIT09Yz9jOi4xO3RoaXMuZmFyPXZvaWQgMCE9PWQ/ZDoyRTM7dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9O1RIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkNhbWVyYS5wcm90b3R5cGUpO1RIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYTtcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRMZW5zPWZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9MjQpO3RoaXMuZm92PTIqVEhSRUUuTWF0aC5yYWRUb0RlZyhNYXRoLmF0YW4oYi8oMiphKSkpO3RoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfTtUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0Vmlld09mZnNldD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5mdWxsV2lkdGg9YTt0aGlzLmZ1bGxIZWlnaHQ9Yjt0aGlzLng9Yzt0aGlzLnk9ZDt0aGlzLndpZHRoPWU7dGhpcy5oZWlnaHQ9Zjt0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX07XG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeD1mdW5jdGlvbigpe3ZhciBhPVRIUkVFLk1hdGgucmFkVG9EZWcoMipNYXRoLmF0YW4oTWF0aC50YW4oLjUqVEhSRUUuTWF0aC5kZWdUb1JhZCh0aGlzLmZvdikpL3RoaXMuem9vbSkpO2lmKHRoaXMuZnVsbFdpZHRoKXt2YXIgYj10aGlzLmZ1bGxXaWR0aC90aGlzLmZ1bGxIZWlnaHQsYT1NYXRoLnRhbihUSFJFRS5NYXRoLmRlZ1RvUmFkKC41KmEpKSp0aGlzLm5lYXIsYz0tYSxkPWIqYyxiPU1hdGguYWJzKGIqYS1kKSxjPU1hdGguYWJzKGEtYyk7dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VGcnVzdHVtKGQrdGhpcy54KmIvdGhpcy5mdWxsV2lkdGgsZCsodGhpcy54K3RoaXMud2lkdGgpKmIvdGhpcy5mdWxsV2lkdGgsYS0odGhpcy55K3RoaXMuaGVpZ2h0KSpjL3RoaXMuZnVsbEhlaWdodCxhLXRoaXMueSpjL3RoaXMuZnVsbEhlaWdodCx0aGlzLm5lYXIsdGhpcy5mYXIpfWVsc2UgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZShhLFxuICAgIHRoaXMuYXNwZWN0LHRoaXMubmVhcix0aGlzLmZhcil9O1RIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYTtUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLnpvb209dGhpcy56b29tO2EuZm92PXRoaXMuZm92O2EuYXNwZWN0PXRoaXMuYXNwZWN0O2EubmVhcj10aGlzLm5lYXI7YS5mYXI9dGhpcy5mYXI7YS5wcm9qZWN0aW9uTWF0cml4LmNvcHkodGhpcy5wcm9qZWN0aW9uTWF0cml4KTtyZXR1cm4gYX07VEhSRUUuTGlnaHQ9ZnVuY3Rpb24oYSl7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJMaWdodFwiO3RoaXMuY29sb3I9bmV3IFRIUkVFLkNvbG9yKGEpfTtUSFJFRS5MaWdodC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUpO1RIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5MaWdodDtcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuTGlnaHQpO1RIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5jb2xvci5jb3B5KHRoaXMuY29sb3IpO3JldHVybiBhfTtUSFJFRS5BbWJpZW50TGlnaHQ9ZnVuY3Rpb24oYSl7VEhSRUUuTGlnaHQuY2FsbCh0aGlzLGEpO3RoaXMudHlwZT1cIkFtYmllbnRMaWdodFwifTtUSFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTGlnaHQucHJvdG90eXBlKTtUSFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkFtYmllbnRMaWdodDtUSFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLkFtYmllbnRMaWdodDtUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtcblRIUkVFLkFyZWFMaWdodD1mdW5jdGlvbihhLGIpe1RIUkVFLkxpZ2h0LmNhbGwodGhpcyxhKTt0aGlzLnR5cGU9XCJBcmVhTGlnaHRcIjt0aGlzLm5vcm1hbD1uZXcgVEhSRUUuVmVjdG9yMygwLC0xLDApO3RoaXMucmlnaHQ9bmV3IFRIUkVFLlZlY3RvcjMoMSwwLDApO3RoaXMuaW50ZW5zaXR5PXZvaWQgMCE9PWI/YjoxO3RoaXMuaGVpZ2h0PXRoaXMud2lkdGg9MTt0aGlzLmNvbnN0YW50QXR0ZW51YXRpb249MS41O3RoaXMubGluZWFyQXR0ZW51YXRpb249LjU7dGhpcy5xdWFkcmF0aWNBdHRlbnVhdGlvbj0uMX07VEhSRUUuQXJlYUxpZ2h0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpZ2h0LnByb3RvdHlwZSk7VEhSRUUuQXJlYUxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5BcmVhTGlnaHQ7XG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0PWZ1bmN0aW9uKGEsYil7VEhSRUUuTGlnaHQuY2FsbCh0aGlzLGEpO3RoaXMudHlwZT1cIkRpcmVjdGlvbmFsTGlnaHRcIjt0aGlzLnBvc2l0aW9uLnNldCgwLDEsMCk7dGhpcy50YXJnZXQ9bmV3IFRIUkVFLk9iamVjdDNEO3RoaXMuaW50ZW5zaXR5PXZvaWQgMCE9PWI/YjoxO3RoaXMub25seVNoYWRvdz10aGlzLmNhc3RTaGFkb3c9ITE7dGhpcy5zaGFkb3dDYW1lcmFOZWFyPTUwO3RoaXMuc2hhZG93Q2FtZXJhRmFyPTVFMzt0aGlzLnNoYWRvd0NhbWVyYUxlZnQ9LTUwMDt0aGlzLnNoYWRvd0NhbWVyYVRvcD10aGlzLnNoYWRvd0NhbWVyYVJpZ2h0PTUwMDt0aGlzLnNoYWRvd0NhbWVyYUJvdHRvbT0tNTAwO3RoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZT0hMTt0aGlzLnNoYWRvd0JpYXM9MDt0aGlzLnNoYWRvd0RhcmtuZXNzPS41O3RoaXMuc2hhZG93TWFwSGVpZ2h0PXRoaXMuc2hhZG93TWFwV2lkdGg9NTEyO3RoaXMuc2hhZG93Q2FzY2FkZT0hMTtcbiAgICB0aGlzLnNoYWRvd0Nhc2NhZGVPZmZzZXQ9bmV3IFRIUkVFLlZlY3RvcjMoMCwwLC0xRTMpO3RoaXMuc2hhZG93Q2FzY2FkZUNvdW50PTI7dGhpcy5zaGFkb3dDYXNjYWRlQmlhcz1bMCwwLDBdO3RoaXMuc2hhZG93Q2FzY2FkZVdpZHRoPVs1MTIsNTEyLDUxMl07dGhpcy5zaGFkb3dDYXNjYWRlSGVpZ2h0PVs1MTIsNTEyLDUxMl07dGhpcy5zaGFkb3dDYXNjYWRlTmVhclo9Wy0xLC45OSwuOTk4XTt0aGlzLnNoYWRvd0Nhc2NhZGVGYXJaPVsuOTksLjk5OCwxXTt0aGlzLnNoYWRvd0Nhc2NhZGVBcnJheT1bXTt0aGlzLnNoYWRvd01hdHJpeD10aGlzLnNoYWRvd0NhbWVyYT10aGlzLnNoYWRvd01hcFNpemU9dGhpcy5zaGFkb3dNYXA9bnVsbH07VEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5MaWdodC5wcm90b3R5cGUpO1RIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkRpcmVjdGlvbmFsTGlnaHQ7XG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0O1RIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS50YXJnZXQ9dGhpcy50YXJnZXQuY2xvbmUoKTthLmludGVuc2l0eT10aGlzLmludGVuc2l0eTthLmNhc3RTaGFkb3c9dGhpcy5jYXN0U2hhZG93O2Eub25seVNoYWRvdz10aGlzLm9ubHlTaGFkb3c7YS5zaGFkb3dDYW1lcmFOZWFyPXRoaXMuc2hhZG93Q2FtZXJhTmVhcjthLnNoYWRvd0NhbWVyYUZhcj10aGlzLnNoYWRvd0NhbWVyYUZhcjthLnNoYWRvd0NhbWVyYUxlZnQ9dGhpcy5zaGFkb3dDYW1lcmFMZWZ0O2Euc2hhZG93Q2FtZXJhUmlnaHQ9dGhpcy5zaGFkb3dDYW1lcmFSaWdodDthLnNoYWRvd0NhbWVyYVRvcD10aGlzLnNoYWRvd0NhbWVyYVRvcDthLnNoYWRvd0NhbWVyYUJvdHRvbT10aGlzLnNoYWRvd0NhbWVyYUJvdHRvbTthLnNoYWRvd0NhbWVyYVZpc2libGU9XG4gICAgdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlO2Euc2hhZG93Qmlhcz10aGlzLnNoYWRvd0JpYXM7YS5zaGFkb3dEYXJrbmVzcz10aGlzLnNoYWRvd0RhcmtuZXNzO2Euc2hhZG93TWFwV2lkdGg9dGhpcy5zaGFkb3dNYXBXaWR0aDthLnNoYWRvd01hcEhlaWdodD10aGlzLnNoYWRvd01hcEhlaWdodDthLnNoYWRvd0Nhc2NhZGU9dGhpcy5zaGFkb3dDYXNjYWRlO2Euc2hhZG93Q2FzY2FkZU9mZnNldC5jb3B5KHRoaXMuc2hhZG93Q2FzY2FkZU9mZnNldCk7YS5zaGFkb3dDYXNjYWRlQ291bnQ9dGhpcy5zaGFkb3dDYXNjYWRlQ291bnQ7YS5zaGFkb3dDYXNjYWRlQmlhcz10aGlzLnNoYWRvd0Nhc2NhZGVCaWFzLnNsaWNlKDApO2Euc2hhZG93Q2FzY2FkZVdpZHRoPXRoaXMuc2hhZG93Q2FzY2FkZVdpZHRoLnNsaWNlKDApO2Euc2hhZG93Q2FzY2FkZUhlaWdodD10aGlzLnNoYWRvd0Nhc2NhZGVIZWlnaHQuc2xpY2UoMCk7YS5zaGFkb3dDYXNjYWRlTmVhclo9dGhpcy5zaGFkb3dDYXNjYWRlTmVhclouc2xpY2UoMCk7XG4gICAgYS5zaGFkb3dDYXNjYWRlRmFyWj10aGlzLnNoYWRvd0Nhc2NhZGVGYXJaLnNsaWNlKDApO3JldHVybiBhfTtUSFJFRS5IZW1pc3BoZXJlTGlnaHQ9ZnVuY3Rpb24oYSxiLGMpe1RIUkVFLkxpZ2h0LmNhbGwodGhpcyxhKTt0aGlzLnR5cGU9XCJIZW1pc3BoZXJlTGlnaHRcIjt0aGlzLnBvc2l0aW9uLnNldCgwLDEwMCwwKTt0aGlzLmdyb3VuZENvbG9yPW5ldyBUSFJFRS5Db2xvcihiKTt0aGlzLmludGVuc2l0eT12b2lkIDAhPT1jP2M6MX07VEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpZ2h0LnByb3RvdHlwZSk7VEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5IZW1pc3BoZXJlTGlnaHQ7XG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodDtUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2EuZ3JvdW5kQ29sb3IuY29weSh0aGlzLmdyb3VuZENvbG9yKTthLmludGVuc2l0eT10aGlzLmludGVuc2l0eTtyZXR1cm4gYX07VEhSRUUuUG9pbnRMaWdodD1mdW5jdGlvbihhLGIsYyxkKXtUSFJFRS5MaWdodC5jYWxsKHRoaXMsYSk7dGhpcy50eXBlPVwiUG9pbnRMaWdodFwiO3RoaXMuaW50ZW5zaXR5PXZvaWQgMCE9PWI/YjoxO3RoaXMuZGlzdGFuY2U9dm9pZCAwIT09Yz9jOjA7dGhpcy5kZWNheT12b2lkIDAhPT1kP2Q6MX07VEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5MaWdodC5wcm90b3R5cGUpO1RIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlBvaW50TGlnaHQ7XG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5Qb2ludExpZ2h0O1RIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5pbnRlbnNpdHk9dGhpcy5pbnRlbnNpdHk7YS5kaXN0YW5jZT10aGlzLmRpc3RhbmNlO2EuZGVjYXk9dGhpcy5kZWNheTtyZXR1cm4gYX07XG5USFJFRS5TcG90TGlnaHQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe1RIUkVFLkxpZ2h0LmNhbGwodGhpcyxhKTt0aGlzLnR5cGU9XCJTcG90TGlnaHRcIjt0aGlzLnBvc2l0aW9uLnNldCgwLDEsMCk7dGhpcy50YXJnZXQ9bmV3IFRIUkVFLk9iamVjdDNEO3RoaXMuaW50ZW5zaXR5PXZvaWQgMCE9PWI/YjoxO3RoaXMuZGlzdGFuY2U9dm9pZCAwIT09Yz9jOjA7dGhpcy5hbmdsZT12b2lkIDAhPT1kP2Q6TWF0aC5QSS8zO3RoaXMuZXhwb25lbnQ9dm9pZCAwIT09ZT9lOjEwO3RoaXMuZGVjYXk9dm9pZCAwIT09Zj9mOjE7dGhpcy5vbmx5U2hhZG93PXRoaXMuY2FzdFNoYWRvdz0hMTt0aGlzLnNoYWRvd0NhbWVyYU5lYXI9NTA7dGhpcy5zaGFkb3dDYW1lcmFGYXI9NUUzO3RoaXMuc2hhZG93Q2FtZXJhRm92PTUwO3RoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZT0hMTt0aGlzLnNoYWRvd0JpYXM9MDt0aGlzLnNoYWRvd0RhcmtuZXNzPS41O3RoaXMuc2hhZG93TWFwSGVpZ2h0PXRoaXMuc2hhZG93TWFwV2lkdGg9XG4gICAgNTEyO3RoaXMuc2hhZG93TWF0cml4PXRoaXMuc2hhZG93Q2FtZXJhPXRoaXMuc2hhZG93TWFwU2l6ZT10aGlzLnNoYWRvd01hcD1udWxsfTtUSFJFRS5TcG90TGlnaHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTGlnaHQucHJvdG90eXBlKTtUSFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlNwb3RMaWdodDtcblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuU3BvdExpZ2h0O1RIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS50YXJnZXQ9dGhpcy50YXJnZXQuY2xvbmUoKTthLmludGVuc2l0eT10aGlzLmludGVuc2l0eTthLmRpc3RhbmNlPXRoaXMuZGlzdGFuY2U7YS5hbmdsZT10aGlzLmFuZ2xlO2EuZXhwb25lbnQ9dGhpcy5leHBvbmVudDthLmRlY2F5PXRoaXMuZGVjYXk7YS5jYXN0U2hhZG93PXRoaXMuY2FzdFNoYWRvdzthLm9ubHlTaGFkb3c9dGhpcy5vbmx5U2hhZG93O2Euc2hhZG93Q2FtZXJhTmVhcj10aGlzLnNoYWRvd0NhbWVyYU5lYXI7YS5zaGFkb3dDYW1lcmFGYXI9dGhpcy5zaGFkb3dDYW1lcmFGYXI7YS5zaGFkb3dDYW1lcmFGb3Y9dGhpcy5zaGFkb3dDYW1lcmFGb3Y7YS5zaGFkb3dDYW1lcmFWaXNpYmxlPXRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZTthLnNoYWRvd0JpYXM9dGhpcy5zaGFkb3dCaWFzO1xuICAgIGEuc2hhZG93RGFya25lc3M9dGhpcy5zaGFkb3dEYXJrbmVzczthLnNoYWRvd01hcFdpZHRoPXRoaXMuc2hhZG93TWFwV2lkdGg7YS5zaGFkb3dNYXBIZWlnaHQ9dGhpcy5zaGFkb3dNYXBIZWlnaHQ7cmV0dXJuIGF9O1RIUkVFLkNhY2hlPXtmaWxlczp7fSxhZGQ6ZnVuY3Rpb24oYSxiKXt0aGlzLmZpbGVzW2FdPWJ9LGdldDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5maWxlc1thXX0scmVtb3ZlOmZ1bmN0aW9uKGEpe2RlbGV0ZSB0aGlzLmZpbGVzW2FdfSxjbGVhcjpmdW5jdGlvbigpe3RoaXMuZmlsZXM9e319fTtcblRIUkVFLkxvYWRlcj1mdW5jdGlvbihhKXt0aGlzLnN0YXR1c0RvbUVsZW1lbnQ9KHRoaXMuc2hvd1N0YXR1cz1hKT9USFJFRS5Mb2FkZXIucHJvdG90eXBlLmFkZFN0YXR1c0VsZW1lbnQoKTpudWxsO3RoaXMuaW1hZ2VMb2FkZXI9bmV3IFRIUkVFLkltYWdlTG9hZGVyO3RoaXMub25Mb2FkU3RhcnQ9ZnVuY3Rpb24oKXt9O3RoaXMub25Mb2FkUHJvZ3Jlc3M9ZnVuY3Rpb24oKXt9O3RoaXMub25Mb2FkQ29tcGxldGU9ZnVuY3Rpb24oKXt9fTtcblRIUkVFLkxvYWRlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkxvYWRlcixjcm9zc09yaWdpbjp2b2lkIDAsYWRkU3RhdHVzRWxlbWVudDpmdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7YS5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCI7YS5zdHlsZS5yaWdodD1cIjBweFwiO2Euc3R5bGUudG9wPVwiMHB4XCI7YS5zdHlsZS5mb250U2l6ZT1cIjAuOGVtXCI7YS5zdHlsZS50ZXh0QWxpZ249XCJsZWZ0XCI7YS5zdHlsZS5iYWNrZ3JvdW5kPVwicmdiYSgwLDAsMCwwLjI1KVwiO2Euc3R5bGUuY29sb3I9XCIjZmZmXCI7YS5zdHlsZS53aWR0aD1cIjEyMHB4XCI7YS5zdHlsZS5wYWRkaW5nPVwiMC41ZW0gMC41ZW0gMC41ZW0gMC41ZW1cIjthLnN0eWxlLnpJbmRleD0xRTM7YS5pbm5lckhUTUw9XCJMb2FkaW5nIC4uLlwiO3JldHVybiBhfSx1cGRhdGVQcm9ncmVzczpmdW5jdGlvbihhKXt2YXIgYj1cIkxvYWRlZCBcIixiPWEudG90YWw/YisoKDEwMCphLmxvYWRlZC9hLnRvdGFsKS50b0ZpeGVkKDApK1xuXCIlXCIpOmIrKChhLmxvYWRlZC8xMDI0KS50b0ZpeGVkKDIpK1wiIEtCXCIpO3RoaXMuc3RhdHVzRG9tRWxlbWVudC5pbm5lckhUTUw9Yn0sZXh0cmFjdFVybEJhc2U6ZnVuY3Rpb24oYSl7YT1hLnNwbGl0KFwiL1wiKTtpZigxPT09YS5sZW5ndGgpcmV0dXJuXCIuL1wiO2EucG9wKCk7cmV0dXJuIGEuam9pbihcIi9cIikrXCIvXCJ9LGluaXRNYXRlcmlhbHM6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W10sZD0wO2Q8YS5sZW5ndGg7KytkKWNbZF09dGhpcy5jcmVhdGVNYXRlcmlhbChhW2RdLGIpO3JldHVybiBjfSxuZWVkc1RhbmdlbnRzOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wLGM9YS5sZW5ndGg7YjxjO2IrKylpZihhW2JdaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbClyZXR1cm4hMDtyZXR1cm4hMX0sY3JlYXRlTWF0ZXJpYWw6ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe2E9TWF0aC5sb2coYSkvTWF0aC5MTjI7cmV0dXJuIE1hdGgucG93KDIsTWF0aC5yb3VuZChhKSl9ZnVuY3Rpb24gZChhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLGUsZyxoLGsscyl7dmFyIHU9YitlLHYseD1USFJFRS5Mb2FkZXIuSGFuZGxlcnMuZ2V0KHUpO251bGwhPT14P3Y9eC5sb2FkKHUpOih2PW5ldyBUSFJFRS5UZXh0dXJlLHg9Zi5pbWFnZUxvYWRlcix4LmNyb3NzT3JpZ2luPWYuY3Jvc3NPcmlnaW4seC5sb2FkKHUsZnVuY3Rpb24oYSl7aWYoITE9PT1USFJFRS5NYXRoLmlzUG93ZXJPZlR3byhhLndpZHRoKXx8ITE9PT1USFJFRS5NYXRoLmlzUG93ZXJPZlR3byhhLmhlaWdodCkpe3ZhciBiPWMoYS53aWR0aCksZD1jKGEuaGVpZ2h0KSxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7ZS53aWR0aD1iO2UuaGVpZ2h0PWQ7ZS5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKGEsMCwwLGIsZCk7di5pbWFnZT1lfWVsc2Ugdi5pbWFnZT1hO3YubmVlZHNVcGRhdGU9ITB9KSk7di5zb3VyY2VGaWxlPWU7ZyYmKHYucmVwZWF0LnNldChnWzBdLGdbMV0pLDEhPT1nWzBdJiYodi53cmFwUz1USFJFRS5SZXBlYXRXcmFwcGluZyksXG4xIT09Z1sxXSYmKHYud3JhcFQ9VEhSRUUuUmVwZWF0V3JhcHBpbmcpKTtoJiZ2Lm9mZnNldC5zZXQoaFswXSxoWzFdKTtrJiYoZT17cmVwZWF0OlRIUkVFLlJlcGVhdFdyYXBwaW5nLG1pcnJvcjpUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nfSx2b2lkIDAhPT1lW2tbMF1dJiYodi53cmFwUz1lW2tbMF1dKSx2b2lkIDAhPT1lW2tbMV1dJiYodi53cmFwVD1lW2tbMV1dKSk7cyYmKHYuYW5pc290cm9weT1zKTthW2RdPXZ9ZnVuY3Rpb24gZShhKXtyZXR1cm4oMjU1KmFbMF08PDE2KSsoMjU1KmFbMV08PDgpKzI1NSphWzJdfXZhciBmPXRoaXMsZz1cIk1lc2hMYW1iZXJ0TWF0ZXJpYWxcIixoPXtjb2xvcjoxNTY1ODczNCxvcGFjaXR5OjEsbWFwOm51bGwsbGlnaHRNYXA6bnVsbCxub3JtYWxNYXA6bnVsbCxidW1wTWFwOm51bGwsd2lyZWZyYW1lOiExfTtpZihhLnNoYWRpbmcpe3ZhciBrPWEuc2hhZGluZy50b0xvd2VyQ2FzZSgpO1wicGhvbmdcIj09PWs/Zz1cIk1lc2hQaG9uZ01hdGVyaWFsXCI6XG5cImJhc2ljXCI9PT1rJiYoZz1cIk1lc2hCYXNpY01hdGVyaWFsXCIpfXZvaWQgMCE9PWEuYmxlbmRpbmcmJnZvaWQgMCE9PVRIUkVFW2EuYmxlbmRpbmddJiYoaC5ibGVuZGluZz1USFJFRVthLmJsZW5kaW5nXSk7dm9pZCAwIT09YS50cmFuc3BhcmVudCYmKGgudHJhbnNwYXJlbnQ9YS50cmFuc3BhcmVudCk7dm9pZCAwIT09YS5vcGFjaXR5JiYxPmEub3BhY2l0eSYmKGgudHJhbnNwYXJlbnQ9ITApO3ZvaWQgMCE9PWEuZGVwdGhUZXN0JiYoaC5kZXB0aFRlc3Q9YS5kZXB0aFRlc3QpO3ZvaWQgMCE9PWEuZGVwdGhXcml0ZSYmKGguZGVwdGhXcml0ZT1hLmRlcHRoV3JpdGUpO3ZvaWQgMCE9PWEudmlzaWJsZSYmKGgudmlzaWJsZT1hLnZpc2libGUpO3ZvaWQgMCE9PWEuZmxpcFNpZGVkJiYoaC5zaWRlPVRIUkVFLkJhY2tTaWRlKTt2b2lkIDAhPT1hLmRvdWJsZVNpZGVkJiYoaC5zaWRlPVRIUkVFLkRvdWJsZVNpZGUpO3ZvaWQgMCE9PWEud2lyZWZyYW1lJiYoaC53aXJlZnJhbWU9YS53aXJlZnJhbWUpO1xuICAgIHZvaWQgMCE9PWEudmVydGV4Q29sb3JzJiYoXCJmYWNlXCI9PT1hLnZlcnRleENvbG9ycz9oLnZlcnRleENvbG9ycz1USFJFRS5GYWNlQ29sb3JzOmEudmVydGV4Q29sb3JzJiYoaC52ZXJ0ZXhDb2xvcnM9VEhSRUUuVmVydGV4Q29sb3JzKSk7YS5jb2xvckRpZmZ1c2U/aC5jb2xvcj1lKGEuY29sb3JEaWZmdXNlKTphLkRiZ0NvbG9yJiYoaC5jb2xvcj1hLkRiZ0NvbG9yKTthLmNvbG9yU3BlY3VsYXImJihoLnNwZWN1bGFyPWUoYS5jb2xvclNwZWN1bGFyKSk7YS5jb2xvckVtaXNzaXZlJiYoaC5lbWlzc2l2ZT1lKGEuY29sb3JFbWlzc2l2ZSkpO3ZvaWQgMCE9PWEudHJhbnNwYXJlbmN5JiYoY29uc29sZS53YXJuKFwiVEhSRUUuTG9hZGVyOiB0cmFuc3BhcmVuY3kgaGFzIGJlZW4gcmVuYW1lZCB0byBvcGFjaXR5XCIpLGEub3BhY2l0eT1hLnRyYW5zcGFyZW5jeSk7dm9pZCAwIT09YS5vcGFjaXR5JiYoaC5vcGFjaXR5PWEub3BhY2l0eSk7YS5zcGVjdWxhckNvZWYmJihoLnNoaW5pbmVzcz1cbiAgICAgICAgYS5zcGVjdWxhckNvZWYpO2EubWFwRGlmZnVzZSYmYiYmZChoLFwibWFwXCIsYS5tYXBEaWZmdXNlLGEubWFwRGlmZnVzZVJlcGVhdCxhLm1hcERpZmZ1c2VPZmZzZXQsYS5tYXBEaWZmdXNlV3JhcCxhLm1hcERpZmZ1c2VBbmlzb3Ryb3B5KTthLm1hcExpZ2h0JiZiJiZkKGgsXCJsaWdodE1hcFwiLGEubWFwTGlnaHQsYS5tYXBMaWdodFJlcGVhdCxhLm1hcExpZ2h0T2Zmc2V0LGEubWFwTGlnaHRXcmFwLGEubWFwTGlnaHRBbmlzb3Ryb3B5KTthLm1hcEJ1bXAmJmImJmQoaCxcImJ1bXBNYXBcIixhLm1hcEJ1bXAsYS5tYXBCdW1wUmVwZWF0LGEubWFwQnVtcE9mZnNldCxhLm1hcEJ1bXBXcmFwLGEubWFwQnVtcEFuaXNvdHJvcHkpO2EubWFwTm9ybWFsJiZiJiZkKGgsXCJub3JtYWxNYXBcIixhLm1hcE5vcm1hbCxhLm1hcE5vcm1hbFJlcGVhdCxhLm1hcE5vcm1hbE9mZnNldCxhLm1hcE5vcm1hbFdyYXAsYS5tYXBOb3JtYWxBbmlzb3Ryb3B5KTthLm1hcFNwZWN1bGFyJiZiJiZkKGgsXCJzcGVjdWxhck1hcFwiLFxuICAgICAgICBhLm1hcFNwZWN1bGFyLGEubWFwU3BlY3VsYXJSZXBlYXQsYS5tYXBTcGVjdWxhck9mZnNldCxhLm1hcFNwZWN1bGFyV3JhcCxhLm1hcFNwZWN1bGFyQW5pc290cm9weSk7YS5tYXBBbHBoYSYmYiYmZChoLFwiYWxwaGFNYXBcIixhLm1hcEFscGhhLGEubWFwQWxwaGFSZXBlYXQsYS5tYXBBbHBoYU9mZnNldCxhLm1hcEFscGhhV3JhcCxhLm1hcEFscGhhQW5pc290cm9weSk7YS5tYXBCdW1wU2NhbGUmJihoLmJ1bXBTY2FsZT1hLm1hcEJ1bXBTY2FsZSk7YS5tYXBOb3JtYWxGYWN0b3ImJihoLm5vcm1hbFNjYWxlPW5ldyBUSFJFRS5WZWN0b3IyKGEubWFwTm9ybWFsRmFjdG9yLGEubWFwTm9ybWFsRmFjdG9yKSk7Zz1uZXcgVEhSRUVbZ10oaCk7dm9pZCAwIT09YS5EYmdOYW1lJiYoZy5uYW1lPWEuRGJnTmFtZSk7cmV0dXJuIGd9fTtcblRIUkVFLkxvYWRlci5IYW5kbGVycz17aGFuZGxlcnM6W10sYWRkOmZ1bmN0aW9uKGEsYil7dGhpcy5oYW5kbGVycy5wdXNoKGEsYil9LGdldDpmdW5jdGlvbihhKXtmb3IodmFyIGI9MCxjPXRoaXMuaGFuZGxlcnMubGVuZ3RoO2I8YztiKz0yKXt2YXIgZD10aGlzLmhhbmRsZXJzW2IrMV07aWYodGhpcy5oYW5kbGVyc1tiXS50ZXN0KGEpKXJldHVybiBkfXJldHVybiBudWxsfX07VEhSRUUuWEhSTG9hZGVyPWZ1bmN0aW9uKGEpe3RoaXMubWFuYWdlcj12b2lkIDAhPT1hP2E6VEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyfTtcblRIUkVFLlhIUkxvYWRlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLlhIUkxvYWRlcixsb2FkOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMsZj1USFJFRS5DYWNoZS5nZXQoYSk7dm9pZCAwIT09Zj9iJiZiKGYpOihmPW5ldyBYTUxIdHRwUmVxdWVzdCxmLm9wZW4oXCJHRVRcIixhLCEwKSxmLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZnVuY3Rpb24oYyl7VEhSRUUuQ2FjaGUuYWRkKGEsdGhpcy5yZXNwb25zZSk7YiYmYih0aGlzLnJlc3BvbnNlKTtlLm1hbmFnZXIuaXRlbUVuZChhKX0sITEpLHZvaWQgMCE9PWMmJmYuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsZnVuY3Rpb24oYSl7YyhhKX0sITEpLHZvaWQgMCE9PWQmJmYuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZnVuY3Rpb24oYSl7ZChhKX0sITEpLHZvaWQgMCE9PXRoaXMuY3Jvc3NPcmlnaW4mJihmLmNyb3NzT3JpZ2luPXRoaXMuY3Jvc3NPcmlnaW4pLHZvaWQgMCE9PXRoaXMucmVzcG9uc2VUeXBlJiYoZi5yZXNwb25zZVR5cGU9XG4gICAgdGhpcy5yZXNwb25zZVR5cGUpLGYuc2VuZChudWxsKSxlLm1hbmFnZXIuaXRlbVN0YXJ0KGEpKX0sc2V0UmVzcG9uc2VUeXBlOmZ1bmN0aW9uKGEpe3RoaXMucmVzcG9uc2VUeXBlPWF9LHNldENyb3NzT3JpZ2luOmZ1bmN0aW9uKGEpe3RoaXMuY3Jvc3NPcmlnaW49YX19O1RIUkVFLkltYWdlTG9hZGVyPWZ1bmN0aW9uKGEpe3RoaXMubWFuYWdlcj12b2lkIDAhPT1hP2E6VEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyfTtcblRIUkVFLkltYWdlTG9hZGVyLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuSW1hZ2VMb2FkZXIsbG9hZDpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLGY9VEhSRUUuQ2FjaGUuZ2V0KGEpO2lmKHZvaWQgMCE9PWYpYihmKTtlbHNlIHJldHVybiBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiksZi5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKGMpe1RIUkVFLkNhY2hlLmFkZChhLHRoaXMpO2ImJmIodGhpcyk7ZS5tYW5hZ2VyLml0ZW1FbmQoYSl9LCExKSx2b2lkIDAhPT1jJiZmLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLGZ1bmN0aW9uKGEpe2MoYSl9LCExKSx2b2lkIDAhPT1kJiZmLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKGEpe2QoYSl9LCExKSx2b2lkIDAhPT10aGlzLmNyb3NzT3JpZ2luJiYoZi5jcm9zc09yaWdpbj10aGlzLmNyb3NzT3JpZ2luKSxmLnNyYz1hLGUubWFuYWdlci5pdGVtU3RhcnQoYSksZn0sc2V0Q3Jvc3NPcmlnaW46ZnVuY3Rpb24oYSl7dGhpcy5jcm9zc09yaWdpbj1cbiAgICBhfX07VEhSRUUuSlNPTkxvYWRlcj1mdW5jdGlvbihhKXtUSFJFRS5Mb2FkZXIuY2FsbCh0aGlzLGEpO3RoaXMud2l0aENyZWRlbnRpYWxzPSExfTtUSFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxvYWRlci5wcm90b3R5cGUpO1RIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkpTT05Mb2FkZXI7VEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhLGIsYyl7Yz1jJiZcInN0cmluZ1wiPT09dHlwZW9mIGM/Yzp0aGlzLmV4dHJhY3RVcmxCYXNlKGEpO3RoaXMub25Mb2FkU3RhcnQoKTt0aGlzLmxvYWRBamF4SlNPTih0aGlzLGEsYixjKX07XG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5sb2FkQWpheEpTT049ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1uZXcgWE1MSHR0cFJlcXVlc3QsZz0wO2Yub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoZi5yZWFkeVN0YXRlPT09Zi5ET05FKWlmKDIwMD09PWYuc3RhdHVzfHwwPT09Zi5zdGF0dXMpe2lmKGYucmVzcG9uc2VUZXh0KXt2YXIgaD1KU09OLnBhcnNlKGYucmVzcG9uc2VUZXh0KSxrPWgubWV0YWRhdGE7aWYodm9pZCAwIT09ayl7aWYoXCJvYmplY3RcIj09PWsudHlwZSl7VEhSRUUuZXJyb3IoXCJUSFJFRS5KU09OTG9hZGVyOiBcIitiK1wiIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5PYmplY3RMb2FkZXIgaW5zdGVhZC5cIik7cmV0dXJufWlmKFwic2NlbmVcIj09PWsudHlwZSl7VEhSRUUuZXJyb3IoXCJUSFJFRS5KU09OTG9hZGVyOiBcIitiK1wiIHNlZW1zIHRvIGJlIGEgU2NlbmUuIFVzZSBUSFJFRS5TY2VuZUxvYWRlciBpbnN0ZWFkLlwiKTtyZXR1cm59fWg9YS5wYXJzZShoLFxuICAgIGQpO2MoaC5nZW9tZXRyeSxoLm1hdGVyaWFscyl9ZWxzZSBUSFJFRS5lcnJvcihcIlRIUkVFLkpTT05Mb2FkZXI6IFwiK2IrXCIgc2VlbXMgdG8gYmUgdW5yZWFjaGFibGUgb3IgdGhlIGZpbGUgaXMgZW1wdHkuXCIpO2Eub25Mb2FkQ29tcGxldGUoKX1lbHNlIFRIUkVFLmVycm9yKFwiVEhSRUUuSlNPTkxvYWRlcjogQ291bGRuJ3QgbG9hZCBcIitiK1wiIChcIitmLnN0YXR1cytcIilcIik7ZWxzZSBmLnJlYWR5U3RhdGU9PT1mLkxPQURJTkc/ZSYmKDA9PT1nJiYoZz1mLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1MZW5ndGhcIikpLGUoe3RvdGFsOmcsbG9hZGVkOmYucmVzcG9uc2VUZXh0Lmxlbmd0aH0pKTpmLnJlYWR5U3RhdGU9PT1mLkhFQURFUlNfUkVDRUlWRUQmJnZvaWQgMCE9PWUmJihnPWYuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUxlbmd0aFwiKSl9O2Yub3BlbihcIkdFVFwiLGIsITApO2Yud2l0aENyZWRlbnRpYWxzPXRoaXMud2l0aENyZWRlbnRpYWxzO2Yuc2VuZChudWxsKX07XG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5wYXJzZT1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBUSFJFRS5HZW9tZXRyeSxkPXZvaWQgMCE9PWEuc2NhbGU/MS9hLnNjYWxlOjE7KGZ1bmN0aW9uKGIpe3ZhciBkLGcsaCxrLGwscCxxLG4sdCxyLHMsdSx2LHg9YS5mYWNlcztwPWEudmVydGljZXM7dmFyIEQ9YS5ub3JtYWxzLHc9YS5jb2xvcnMseT0wO2lmKHZvaWQgMCE9PWEudXZzKXtmb3IoZD0wO2Q8YS51dnMubGVuZ3RoO2QrKylhLnV2c1tkXS5sZW5ndGgmJnkrKztmb3IoZD0wO2Q8eTtkKyspYy5mYWNlVmVydGV4VXZzW2RdPVtdfWs9MDtmb3IobD1wLmxlbmd0aDtrPGw7KWQ9bmV3IFRIUkVFLlZlY3RvcjMsZC54PXBbaysrXSpiLGQueT1wW2srK10qYixkLno9cFtrKytdKmIsYy52ZXJ0aWNlcy5wdXNoKGQpO2s9MDtmb3IobD14Lmxlbmd0aDtrPGw7KWlmKGI9eFtrKytdLHQ9YiYxLGg9YiYyLGQ9YiY4LHE9YiYxNixyPWImMzIscD1iJjY0LGImPTEyOCx0KXt0PW5ldyBUSFJFRS5GYWNlMztcbiAgICB0LmE9eFtrXTt0LmI9eFtrKzFdO3QuYz14W2srM107cz1uZXcgVEhSRUUuRmFjZTM7cy5hPXhbaysxXTtzLmI9eFtrKzJdO3MuYz14W2srM107ays9NDtoJiYoaD14W2srK10sdC5tYXRlcmlhbEluZGV4PWgscy5tYXRlcmlhbEluZGV4PWgpO2g9Yy5mYWNlcy5sZW5ndGg7aWYoZClmb3IoZD0wO2Q8eTtkKyspZm9yKHU9YS51dnNbZF0sYy5mYWNlVmVydGV4VXZzW2RdW2hdPVtdLGMuZmFjZVZlcnRleFV2c1tkXVtoKzFdPVtdLGc9MDs0Pmc7ZysrKW49eFtrKytdLHY9dVsyKm5dLG49dVsyKm4rMV0sdj1uZXcgVEhSRUUuVmVjdG9yMih2LG4pLDIhPT1nJiZjLmZhY2VWZXJ0ZXhVdnNbZF1baF0ucHVzaCh2KSwwIT09ZyYmYy5mYWNlVmVydGV4VXZzW2RdW2grMV0ucHVzaCh2KTtxJiYocT0zKnhbaysrXSx0Lm5vcm1hbC5zZXQoRFtxKytdLERbcSsrXSxEW3FdKSxzLm5vcm1hbC5jb3B5KHQubm9ybWFsKSk7aWYocilmb3IoZD0wOzQ+ZDtkKyspcT0zKnhbaysrXSxyPW5ldyBUSFJFRS5WZWN0b3IzKERbcSsrXSxcbiAgICAgICAgRFtxKytdLERbcV0pLDIhPT1kJiZ0LnZlcnRleE5vcm1hbHMucHVzaChyKSwwIT09ZCYmcy52ZXJ0ZXhOb3JtYWxzLnB1c2gocik7cCYmKHA9eFtrKytdLHA9d1twXSx0LmNvbG9yLnNldEhleChwKSxzLmNvbG9yLnNldEhleChwKSk7aWYoYilmb3IoZD0wOzQ+ZDtkKyspcD14W2srK10scD13W3BdLDIhPT1kJiZ0LnZlcnRleENvbG9ycy5wdXNoKG5ldyBUSFJFRS5Db2xvcihwKSksMCE9PWQmJnMudmVydGV4Q29sb3JzLnB1c2gobmV3IFRIUkVFLkNvbG9yKHApKTtjLmZhY2VzLnB1c2godCk7Yy5mYWNlcy5wdXNoKHMpfWVsc2V7dD1uZXcgVEhSRUUuRmFjZTM7dC5hPXhbaysrXTt0LmI9eFtrKytdO3QuYz14W2srK107aCYmKGg9eFtrKytdLHQubWF0ZXJpYWxJbmRleD1oKTtoPWMuZmFjZXMubGVuZ3RoO2lmKGQpZm9yKGQ9MDtkPHk7ZCsrKWZvcih1PWEudXZzW2RdLGMuZmFjZVZlcnRleFV2c1tkXVtoXT1bXSxnPTA7Mz5nO2crKyluPXhbaysrXSx2PXVbMipuXSxuPXVbMipuKzFdLFxuICAgIHY9bmV3IFRIUkVFLlZlY3RvcjIodixuKSxjLmZhY2VWZXJ0ZXhVdnNbZF1baF0ucHVzaCh2KTtxJiYocT0zKnhbaysrXSx0Lm5vcm1hbC5zZXQoRFtxKytdLERbcSsrXSxEW3FdKSk7aWYocilmb3IoZD0wOzM+ZDtkKyspcT0zKnhbaysrXSxyPW5ldyBUSFJFRS5WZWN0b3IzKERbcSsrXSxEW3ErK10sRFtxXSksdC52ZXJ0ZXhOb3JtYWxzLnB1c2gocik7cCYmKHA9eFtrKytdLHQuY29sb3Iuc2V0SGV4KHdbcF0pKTtpZihiKWZvcihkPTA7Mz5kO2QrKylwPXhbaysrXSx0LnZlcnRleENvbG9ycy5wdXNoKG5ldyBUSFJFRS5Db2xvcih3W3BdKSk7Yy5mYWNlcy5wdXNoKHQpfX0pKGQpOyhmdW5jdGlvbigpe3ZhciBiPXZvaWQgMCE9PWEuaW5mbHVlbmNlc1BlclZlcnRleD9hLmluZmx1ZW5jZXNQZXJWZXJ0ZXg6MjtpZihhLnNraW5XZWlnaHRzKWZvcih2YXIgZD0wLGc9YS5za2luV2VpZ2h0cy5sZW5ndGg7ZDxnO2QrPWIpYy5za2luV2VpZ2h0cy5wdXNoKG5ldyBUSFJFRS5WZWN0b3I0KGEuc2tpbldlaWdodHNbZF0sXG4gICAgMTxiP2Euc2tpbldlaWdodHNbZCsxXTowLDI8Yj9hLnNraW5XZWlnaHRzW2QrMl06MCwzPGI/YS5za2luV2VpZ2h0c1tkKzNdOjApKTtpZihhLnNraW5JbmRpY2VzKWZvcihkPTAsZz1hLnNraW5JbmRpY2VzLmxlbmd0aDtkPGc7ZCs9YiljLnNraW5JbmRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjQoYS5za2luSW5kaWNlc1tkXSwxPGI/YS5za2luSW5kaWNlc1tkKzFdOjAsMjxiP2Euc2tpbkluZGljZXNbZCsyXTowLDM8Yj9hLnNraW5JbmRpY2VzW2QrM106MCkpO2MuYm9uZXM9YS5ib25lcztjLmJvbmVzJiYwPGMuYm9uZXMubGVuZ3RoJiYoYy5za2luV2VpZ2h0cy5sZW5ndGghPT1jLnNraW5JbmRpY2VzLmxlbmd0aHx8Yy5za2luSW5kaWNlcy5sZW5ndGghPT1jLnZlcnRpY2VzLmxlbmd0aCkmJlRIUkVFLndhcm4oXCJUSFJFRS5KU09OTG9hZGVyOiBXaGVuIHNraW5uaW5nLCBudW1iZXIgb2YgdmVydGljZXMgKFwiK2MudmVydGljZXMubGVuZ3RoK1wiKSwgc2tpbkluZGljZXMgKFwiK1xuICAgIGMuc2tpbkluZGljZXMubGVuZ3RoK1wiKSwgYW5kIHNraW5XZWlnaHRzIChcIitjLnNraW5XZWlnaHRzLmxlbmd0aCtcIikgc2hvdWxkIG1hdGNoLlwiKTtjLmFuaW1hdGlvbj1hLmFuaW1hdGlvbjtjLmFuaW1hdGlvbnM9YS5hbmltYXRpb25zfSkoKTsoZnVuY3Rpb24oYil7aWYodm9pZCAwIT09YS5tb3JwaFRhcmdldHMpe3ZhciBkLGcsaCxrLGwscDtkPTA7Zm9yKGc9YS5tb3JwaFRhcmdldHMubGVuZ3RoO2Q8ZztkKyspZm9yKGMubW9ycGhUYXJnZXRzW2RdPXt9LGMubW9ycGhUYXJnZXRzW2RdLm5hbWU9YS5tb3JwaFRhcmdldHNbZF0ubmFtZSxjLm1vcnBoVGFyZ2V0c1tkXS52ZXJ0aWNlcz1bXSxsPWMubW9ycGhUYXJnZXRzW2RdLnZlcnRpY2VzLHA9YS5tb3JwaFRhcmdldHNbZF0udmVydGljZXMsaD0wLGs9cC5sZW5ndGg7aDxrO2grPTMpe3ZhciBxPW5ldyBUSFJFRS5WZWN0b3IzO3EueD1wW2hdKmI7cS55PXBbaCsxXSpiO3Euej1wW2grMl0qYjtsLnB1c2gocSl9fWlmKHZvaWQgMCE9PVxuICAgIGEubW9ycGhDb2xvcnMpZm9yKGQ9MCxnPWEubW9ycGhDb2xvcnMubGVuZ3RoO2Q8ZztkKyspZm9yKGMubW9ycGhDb2xvcnNbZF09e30sYy5tb3JwaENvbG9yc1tkXS5uYW1lPWEubW9ycGhDb2xvcnNbZF0ubmFtZSxjLm1vcnBoQ29sb3JzW2RdLmNvbG9ycz1bXSxrPWMubW9ycGhDb2xvcnNbZF0uY29sb3JzLGw9YS5tb3JwaENvbG9yc1tkXS5jb2xvcnMsYj0wLGg9bC5sZW5ndGg7YjxoO2IrPTMpcD1uZXcgVEhSRUUuQ29sb3IoMTY3NTUyMDApLHAuc2V0UkdCKGxbYl0sbFtiKzFdLGxbYisyXSksay5wdXNoKHApfSkoZCk7Yy5jb21wdXRlRmFjZU5vcm1hbHMoKTtjLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO2lmKHZvaWQgMD09PWEubWF0ZXJpYWxzfHwwPT09YS5tYXRlcmlhbHMubGVuZ3RoKXJldHVybntnZW9tZXRyeTpjfTtkPXRoaXMuaW5pdE1hdGVyaWFscyhhLm1hdGVyaWFscyxiKTt0aGlzLm5lZWRzVGFuZ2VudHMoZCkmJmMuY29tcHV0ZVRhbmdlbnRzKCk7cmV0dXJue2dlb21ldHJ5OmMsXG4gICAgbWF0ZXJpYWxzOmR9fTtUSFJFRS5Mb2FkaW5nTWFuYWdlcj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcyxlPTAsZj0wO3RoaXMub25Mb2FkPWE7dGhpcy5vblByb2dyZXNzPWI7dGhpcy5vbkVycm9yPWM7dGhpcy5pdGVtU3RhcnQ9ZnVuY3Rpb24oYSl7ZisrfTt0aGlzLml0ZW1FbmQ9ZnVuY3Rpb24oYSl7ZSsrO2lmKHZvaWQgMCE9PWQub25Qcm9ncmVzcylkLm9uUHJvZ3Jlc3MoYSxlLGYpO2lmKGU9PT1mJiZ2b2lkIDAhPT1kLm9uTG9hZClkLm9uTG9hZCgpfX07VEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyPW5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcjtUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcj1mdW5jdGlvbihhKXt0aGlzLm1hbmFnZXI9dm9pZCAwIT09YT9hOlRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcn07XG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLGxvYWQ6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcyxmPW5ldyBUSFJFRS5YSFJMb2FkZXIoZS5tYW5hZ2VyKTtmLnNldENyb3NzT3JpZ2luKHRoaXMuY3Jvc3NPcmlnaW4pO2YubG9hZChhLGZ1bmN0aW9uKGEpe2IoZS5wYXJzZShKU09OLnBhcnNlKGEpKSl9LGMsZCl9LHNldENyb3NzT3JpZ2luOmZ1bmN0aW9uKGEpe3RoaXMuY3Jvc3NPcmlnaW49YX0scGFyc2U6ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5LGM9YS5kYXRhLmF0dHJpYnV0ZXMsZDtmb3IoZCBpbiBjKXt2YXIgZT1jW2RdLGY9bmV3IHNlbGZbZS50eXBlXShlLmFycmF5KTtiLmFkZEF0dHJpYnV0ZShkLG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoZixlLml0ZW1TaXplKSl9Yz1hLmRhdGEub2Zmc2V0czt2b2lkIDAhPT1jJiYoYi5vZmZzZXRzPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpKTtcbiAgICBhPWEuZGF0YS5ib3VuZGluZ1NwaGVyZTt2b2lkIDAhPT1hJiYoYz1uZXcgVEhSRUUuVmVjdG9yMyx2b2lkIDAhPT1hLmNlbnRlciYmYy5mcm9tQXJyYXkoYS5jZW50ZXIpLGIuYm91bmRpbmdTcGhlcmU9bmV3IFRIUkVFLlNwaGVyZShjLGEucmFkaXVzKSk7cmV0dXJuIGJ9fTtUSFJFRS5NYXRlcmlhbExvYWRlcj1mdW5jdGlvbihhKXt0aGlzLm1hbmFnZXI9dm9pZCAwIT09YT9hOlRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcn07XG5USFJFRS5NYXRlcmlhbExvYWRlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLk1hdGVyaWFsTG9hZGVyLGxvYWQ6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcyxmPW5ldyBUSFJFRS5YSFJMb2FkZXIoZS5tYW5hZ2VyKTtmLnNldENyb3NzT3JpZ2luKHRoaXMuY3Jvc3NPcmlnaW4pO2YubG9hZChhLGZ1bmN0aW9uKGEpe2IoZS5wYXJzZShKU09OLnBhcnNlKGEpKSl9LGMsZCl9LHNldENyb3NzT3JpZ2luOmZ1bmN0aW9uKGEpe3RoaXMuY3Jvc3NPcmlnaW49YX0scGFyc2U6ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IFRIUkVFW2EudHlwZV07dm9pZCAwIT09YS5jb2xvciYmYi5jb2xvci5zZXRIZXgoYS5jb2xvcik7dm9pZCAwIT09YS5lbWlzc2l2ZSYmYi5lbWlzc2l2ZS5zZXRIZXgoYS5lbWlzc2l2ZSk7dm9pZCAwIT09YS5zcGVjdWxhciYmYi5zcGVjdWxhci5zZXRIZXgoYS5zcGVjdWxhcik7dm9pZCAwIT09YS5zaGluaW5lc3MmJihiLnNoaW5pbmVzcz1hLnNoaW5pbmVzcyk7XG4gICAgdm9pZCAwIT09YS51bmlmb3JtcyYmKGIudW5pZm9ybXM9YS51bmlmb3Jtcyk7dm9pZCAwIT09YS52ZXJ0ZXhTaGFkZXImJihiLnZlcnRleFNoYWRlcj1hLnZlcnRleFNoYWRlcik7dm9pZCAwIT09YS5mcmFnbWVudFNoYWRlciYmKGIuZnJhZ21lbnRTaGFkZXI9YS5mcmFnbWVudFNoYWRlcik7dm9pZCAwIT09YS52ZXJ0ZXhDb2xvcnMmJihiLnZlcnRleENvbG9ycz1hLnZlcnRleENvbG9ycyk7dm9pZCAwIT09YS5zaGFkaW5nJiYoYi5zaGFkaW5nPWEuc2hhZGluZyk7dm9pZCAwIT09YS5ibGVuZGluZyYmKGIuYmxlbmRpbmc9YS5ibGVuZGluZyk7dm9pZCAwIT09YS5zaWRlJiYoYi5zaWRlPWEuc2lkZSk7dm9pZCAwIT09YS5vcGFjaXR5JiYoYi5vcGFjaXR5PWEub3BhY2l0eSk7dm9pZCAwIT09YS50cmFuc3BhcmVudCYmKGIudHJhbnNwYXJlbnQ9YS50cmFuc3BhcmVudCk7dm9pZCAwIT09YS53aXJlZnJhbWUmJihiLndpcmVmcmFtZT1hLndpcmVmcmFtZSk7dm9pZCAwIT09YS5zaXplJiZcbiAgICAoYi5zaXplPWEuc2l6ZSk7dm9pZCAwIT09YS5zaXplQXR0ZW51YXRpb24mJihiLnNpemVBdHRlbnVhdGlvbj1hLnNpemVBdHRlbnVhdGlvbik7aWYodm9pZCAwIT09YS5tYXRlcmlhbHMpZm9yKHZhciBjPTAsZD1hLm1hdGVyaWFscy5sZW5ndGg7YzxkO2MrKyliLm1hdGVyaWFscy5wdXNoKHRoaXMucGFyc2UoYS5tYXRlcmlhbHNbY10pKTtyZXR1cm4gYn19O1RIUkVFLk9iamVjdExvYWRlcj1mdW5jdGlvbihhKXt0aGlzLm1hbmFnZXI9dm9pZCAwIT09YT9hOlRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjt0aGlzLnRleHR1cmVQYXRoPVwiXCJ9O1xuVEhSRUUuT2JqZWN0TG9hZGVyLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuT2JqZWN0TG9hZGVyLGxvYWQ6ZnVuY3Rpb24oYSxiLGMsZCl7XCJcIj09PXRoaXMudGV4dHVyZVBhdGgmJih0aGlzLnRleHR1cmVQYXRoPWEuc3Vic3RyaW5nKDAsYS5sYXN0SW5kZXhPZihcIi9cIikrMSkpO3ZhciBlPXRoaXMsZj1uZXcgVEhSRUUuWEhSTG9hZGVyKGUubWFuYWdlcik7Zi5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtmLmxvYWQoYSxmdW5jdGlvbihhKXtlLnBhcnNlKEpTT04ucGFyc2UoYSksYil9LGMsZCl9LHNldFRleHR1cmVQYXRoOmZ1bmN0aW9uKGEpe3RoaXMudGV4dHVyZVBhdGg9YX0sc2V0Q3Jvc3NPcmlnaW46ZnVuY3Rpb24oYSl7dGhpcy5jcm9zc09yaWdpbj1hfSxwYXJzZTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMucGFyc2VHZW9tZXRyaWVzKGEuZ2VvbWV0cmllcyksZD10aGlzLnBhcnNlSW1hZ2VzKGEuaW1hZ2VzLGZ1bmN0aW9uKCl7dm9pZCAwIT09YiYmYihlKX0pLFxuICAgIGQ9dGhpcy5wYXJzZVRleHR1cmVzKGEudGV4dHVyZXMsZCksZD10aGlzLnBhcnNlTWF0ZXJpYWxzKGEubWF0ZXJpYWxzLGQpLGU9dGhpcy5wYXJzZU9iamVjdChhLm9iamVjdCxjLGQpO3ZvaWQgMCE9PWEuaW1hZ2VzJiYwIT09YS5pbWFnZXMubGVuZ3RofHx2b2lkIDA9PT1ifHxiKGUpO3JldHVybiBlfSxwYXJzZUdlb21ldHJpZXM6ZnVuY3Rpb24oYSl7dmFyIGI9e307aWYodm9pZCAwIT09YSlmb3IodmFyIGM9bmV3IFRIUkVFLkpTT05Mb2FkZXIsZD1uZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIsZT0wLGY9YS5sZW5ndGg7ZTxmO2UrKyl7dmFyIGcsaD1hW2VdO3N3aXRjaChoLnR5cGUpe2Nhc2UgXCJQbGFuZUdlb21ldHJ5XCI6Y2FzZSBcIlBsYW5lQnVmZmVyR2VvbWV0cnlcIjpnPW5ldyBUSFJFRVtoLnR5cGVdKGgud2lkdGgsaC5oZWlnaHQsaC53aWR0aFNlZ21lbnRzLGguaGVpZ2h0U2VnbWVudHMpO2JyZWFrO2Nhc2UgXCJCb3hHZW9tZXRyeVwiOmNhc2UgXCJDdWJlR2VvbWV0cnlcIjpnPVxuICAgIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShoLndpZHRoLGguaGVpZ2h0LGguZGVwdGgsaC53aWR0aFNlZ21lbnRzLGguaGVpZ2h0U2VnbWVudHMsaC5kZXB0aFNlZ21lbnRzKTticmVhaztjYXNlIFwiQ2lyY2xlR2VvbWV0cnlcIjpnPW5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShoLnJhZGl1cyxoLnNlZ21lbnRzKTticmVhaztjYXNlIFwiQ3lsaW5kZXJHZW9tZXRyeVwiOmc9bmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoaC5yYWRpdXNUb3AsaC5yYWRpdXNCb3R0b20saC5oZWlnaHQsaC5yYWRpYWxTZWdtZW50cyxoLmhlaWdodFNlZ21lbnRzLGgub3BlbkVuZGVkKTticmVhaztjYXNlIFwiU3BoZXJlR2VvbWV0cnlcIjpnPW5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShoLnJhZGl1cyxoLndpZHRoU2VnbWVudHMsaC5oZWlnaHRTZWdtZW50cyxoLnBoaVN0YXJ0LGgucGhpTGVuZ3RoLGgudGhldGFTdGFydCxoLnRoZXRhTGVuZ3RoKTticmVhaztjYXNlIFwiSWNvc2FoZWRyb25HZW9tZXRyeVwiOmc9bmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoaC5yYWRpdXMsXG4gICAgaC5kZXRhaWwpO2JyZWFrO2Nhc2UgXCJUb3J1c0dlb21ldHJ5XCI6Zz1uZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShoLnJhZGl1cyxoLnR1YmUsaC5yYWRpYWxTZWdtZW50cyxoLnR1YnVsYXJTZWdtZW50cyxoLmFyYyk7YnJlYWs7Y2FzZSBcIlRvcnVzS25vdEdlb21ldHJ5XCI6Zz1uZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoaC5yYWRpdXMsaC50dWJlLGgucmFkaWFsU2VnbWVudHMsaC50dWJ1bGFyU2VnbWVudHMsaC5wLGgucSxoLmhlaWdodFNjYWxlKTticmVhaztjYXNlIFwiQnVmZmVyR2VvbWV0cnlcIjpnPWQucGFyc2UoaCk7YnJlYWs7Y2FzZSBcIkdlb21ldHJ5XCI6Zz1jLnBhcnNlKGguZGF0YSkuZ2VvbWV0cnl9Zy51dWlkPWgudXVpZDt2b2lkIDAhPT1oLm5hbWUmJihnLm5hbWU9aC5uYW1lKTtiW2gudXVpZF09Z31yZXR1cm4gYn0scGFyc2VNYXRlcmlhbHM6ZnVuY3Rpb24oYSxiKXt2YXIgYz17fTtpZih2b2lkIDAhPT1hKWZvcih2YXIgZD1mdW5jdGlvbihhKXt2b2lkIDA9PT1iW2FdJiZcblRIUkVFLndhcm4oXCJUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlXCIsYSk7cmV0dXJuIGJbYV19LGU9bmV3IFRIUkVFLk1hdGVyaWFsTG9hZGVyLGY9MCxnPWEubGVuZ3RoO2Y8ZztmKyspe3ZhciBoPWFbZl0saz1lLnBhcnNlKGgpO2sudXVpZD1oLnV1aWQ7dm9pZCAwIT09aC5uYW1lJiYoay5uYW1lPWgubmFtZSk7dm9pZCAwIT09aC5tYXAmJihrLm1hcD1kKGgubWFwKSk7dm9pZCAwIT09aC5idW1wTWFwJiYoay5idW1wTWFwPWQoaC5idW1wTWFwKSxoLmJ1bXBTY2FsZSYmKGsuYnVtcFNjYWxlPW5ldyBUSFJFRS5WZWN0b3IyKGguYnVtcFNjYWxlLGguYnVtcFNjYWxlKSkpO3ZvaWQgMCE9PWguYWxwaGFNYXAmJihrLmFscGhhTWFwPWQoaC5hbHBoYU1hcCkpO3ZvaWQgMCE9PWguZW52TWFwJiYoay5lbnZNYXA9ZChoLmVudk1hcCkpO3ZvaWQgMCE9PWgubm9ybWFsTWFwJiYoay5ub3JtYWxNYXA9ZChoLm5vcm1hbE1hcCksaC5ub3JtYWxTY2FsZSYmKGsubm9ybWFsU2NhbGU9XG4gICAgbmV3IFRIUkVFLlZlY3RvcjIoaC5ub3JtYWxTY2FsZSxoLm5vcm1hbFNjYWxlKSkpO3ZvaWQgMCE9PWgubGlnaHRNYXAmJihrLmxpZ2h0TWFwPWQoaC5saWdodE1hcCkpO3ZvaWQgMCE9PWguc3BlY3VsYXJNYXAmJihrLnNwZWN1bGFyTWFwPWQoaC5zcGVjdWxhck1hcCkpO2NbaC51dWlkXT1rfXJldHVybiBjfSxwYXJzZUltYWdlczpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD17fTtpZih2b2lkIDAhPT1hJiYwPGEubGVuZ3RoKXt2YXIgZT1uZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoYiksZj1uZXcgVEhSRUUuSW1hZ2VMb2FkZXIoZSk7Zi5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtmb3IodmFyIGU9ZnVuY3Rpb24oYSl7Yy5tYW5hZ2VyLml0ZW1TdGFydChhKTtyZXR1cm4gZi5sb2FkKGEsZnVuY3Rpb24oKXtjLm1hbmFnZXIuaXRlbUVuZChhKX0pfSxnPTAsaD1hLmxlbmd0aDtnPGg7ZysrKXt2YXIgaz1hW2ddLGw9L14oXFwvXFwvKXwoW2Etel0rOihcXC9cXC8pPykvaS50ZXN0KGsudXJsKT9cbiAgICBrLnVybDpjLnRleHR1cmVQYXRoK2sudXJsO2Rbay51dWlkXT1lKGwpfX1yZXR1cm4gZH0scGFyc2VUZXh0dXJlczpmdW5jdGlvbihhLGIpe3ZhciBjPXt9O2lmKHZvaWQgMCE9PWEpZm9yKHZhciBkPTAsZT1hLmxlbmd0aDtkPGU7ZCsrKXt2YXIgZj1hW2RdO3ZvaWQgMD09PWYuaW1hZ2UmJlRIUkVFLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWZpY2llZCBmb3InLGYudXVpZCk7dm9pZCAwPT09YltmLmltYWdlXSYmVEhSRUUud2FybihcIlRIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlXCIsZi5pbWFnZSk7dmFyIGc9bmV3IFRIUkVFLlRleHR1cmUoYltmLmltYWdlXSk7Zy5uZWVkc1VwZGF0ZT0hMDtnLnV1aWQ9Zi51dWlkO3ZvaWQgMCE9PWYubmFtZSYmKGcubmFtZT1mLm5hbWUpO3ZvaWQgMCE9PWYucmVwZWF0JiYoZy5yZXBlYXQ9bmV3IFRIUkVFLlZlY3RvcjIoZi5yZXBlYXRbMF0sZi5yZXBlYXRbMV0pKTt2b2lkIDAhPT1mLm1pbkZpbHRlciYmXG4oZy5taW5GaWx0ZXI9VEhSRUVbZi5taW5GaWx0ZXJdKTt2b2lkIDAhPT1mLm1hZ0ZpbHRlciYmKGcubWFnRmlsdGVyPVRIUkVFW2YubWFnRmlsdGVyXSk7dm9pZCAwIT09Zi5hbmlzb3Ryb3B5JiYoZy5hbmlzb3Ryb3B5PWYuYW5pc290cm9weSk7Zi53cmFwIGluc3RhbmNlb2YgQXJyYXkmJihnLndyYXBTPVRIUkVFW2Yud3JhcFswXV0sZy53cmFwVD1USFJFRVtmLndyYXBbMV1dKTtjW2YudXVpZF09Z31yZXR1cm4gY30scGFyc2VPYmplY3Q6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuTWF0cml4NDtyZXR1cm4gZnVuY3Rpb24oYixjLGQpe3ZhciBlO2U9ZnVuY3Rpb24oYSl7dm9pZCAwPT09Y1thXSYmVEhSRUUud2FybihcIlRIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5XCIsYSk7cmV0dXJuIGNbYV19O3ZhciBmPWZ1bmN0aW9uKGEpe3ZvaWQgMD09PWRbYV0mJlRIUkVFLndhcm4oXCJUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbFwiLGEpO3JldHVybiBkW2FdfTtcbiAgICBzd2l0Y2goYi50eXBlKXtjYXNlIFwiU2NlbmVcIjplPW5ldyBUSFJFRS5TY2VuZTticmVhaztjYXNlIFwiUGVyc3BlY3RpdmVDYW1lcmFcIjplPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYShiLmZvdixiLmFzcGVjdCxiLm5lYXIsYi5mYXIpO2JyZWFrO2Nhc2UgXCJPcnRob2dyYXBoaWNDYW1lcmFcIjplPW5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoYi5sZWZ0LGIucmlnaHQsYi50b3AsYi5ib3R0b20sYi5uZWFyLGIuZmFyKTticmVhaztjYXNlIFwiQW1iaWVudExpZ2h0XCI6ZT1uZXcgVEhSRUUuQW1iaWVudExpZ2h0KGIuY29sb3IpO2JyZWFrO2Nhc2UgXCJEaXJlY3Rpb25hbExpZ2h0XCI6ZT1uZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodChiLmNvbG9yLGIuaW50ZW5zaXR5KTticmVhaztjYXNlIFwiUG9pbnRMaWdodFwiOmU9bmV3IFRIUkVFLlBvaW50TGlnaHQoYi5jb2xvcixiLmludGVuc2l0eSxiLmRpc3RhbmNlLGIuZGVjYXkpO2JyZWFrO2Nhc2UgXCJTcG90TGlnaHRcIjplPW5ldyBUSFJFRS5TcG90TGlnaHQoYi5jb2xvcixcbiAgICAgICAgYi5pbnRlbnNpdHksYi5kaXN0YW5jZSxiLmFuZ2xlLGIuZXhwb25lbnQsYi5kZWNheSk7YnJlYWs7Y2FzZSBcIkhlbWlzcGhlcmVMaWdodFwiOmU9bmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodChiLmNvbG9yLGIuZ3JvdW5kQ29sb3IsYi5pbnRlbnNpdHkpO2JyZWFrO2Nhc2UgXCJNZXNoXCI6ZT1uZXcgVEhSRUUuTWVzaChlKGIuZ2VvbWV0cnkpLGYoYi5tYXRlcmlhbCkpO2JyZWFrO2Nhc2UgXCJMaW5lXCI6ZT1uZXcgVEhSRUUuTGluZShlKGIuZ2VvbWV0cnkpLGYoYi5tYXRlcmlhbCksYi5tb2RlKTticmVhaztjYXNlIFwiUG9pbnRDbG91ZFwiOmU9bmV3IFRIUkVFLlBvaW50Q2xvdWQoZShiLmdlb21ldHJ5KSxmKGIubWF0ZXJpYWwpKTticmVhaztjYXNlIFwiU3ByaXRlXCI6ZT1uZXcgVEhSRUUuU3ByaXRlKGYoYi5tYXRlcmlhbCkpO2JyZWFrO2Nhc2UgXCJHcm91cFwiOmU9bmV3IFRIUkVFLkdyb3VwO2JyZWFrO2RlZmF1bHQ6ZT1uZXcgVEhSRUUuT2JqZWN0M0R9ZS51dWlkPWIudXVpZDt2b2lkIDAhPT1cbiAgICBiLm5hbWUmJihlLm5hbWU9Yi5uYW1lKTt2b2lkIDAhPT1iLm1hdHJpeD8oYS5mcm9tQXJyYXkoYi5tYXRyaXgpLGEuZGVjb21wb3NlKGUucG9zaXRpb24sZS5xdWF0ZXJuaW9uLGUuc2NhbGUpKToodm9pZCAwIT09Yi5wb3NpdGlvbiYmZS5wb3NpdGlvbi5mcm9tQXJyYXkoYi5wb3NpdGlvbiksdm9pZCAwIT09Yi5yb3RhdGlvbiYmZS5yb3RhdGlvbi5mcm9tQXJyYXkoYi5yb3RhdGlvbiksdm9pZCAwIT09Yi5zY2FsZSYmZS5zY2FsZS5mcm9tQXJyYXkoYi5zY2FsZSkpO3ZvaWQgMCE9PWIudmlzaWJsZSYmKGUudmlzaWJsZT1iLnZpc2libGUpO3ZvaWQgMCE9PWIudXNlckRhdGEmJihlLnVzZXJEYXRhPWIudXNlckRhdGEpO2lmKHZvaWQgMCE9PWIuY2hpbGRyZW4pZm9yKHZhciBnIGluIGIuY2hpbGRyZW4pZS5hZGQodGhpcy5wYXJzZU9iamVjdChiLmNoaWxkcmVuW2ddLGMsZCkpO3JldHVybiBlfX0oKX07XG5USFJFRS5UZXh0dXJlTG9hZGVyPWZ1bmN0aW9uKGEpe3RoaXMubWFuYWdlcj12b2lkIDAhPT1hP2E6VEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyfTtUSFJFRS5UZXh0dXJlTG9hZGVyLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuVGV4dHVyZUxvYWRlcixsb2FkOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBUSFJFRS5JbWFnZUxvYWRlcih0aGlzLm1hbmFnZXIpO2Uuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7ZS5sb2FkKGEsZnVuY3Rpb24oYSl7YT1uZXcgVEhSRUUuVGV4dHVyZShhKTthLm5lZWRzVXBkYXRlPSEwO3ZvaWQgMCE9PWImJmIoYSl9LGMsZCl9LHNldENyb3NzT3JpZ2luOmZ1bmN0aW9uKGEpe3RoaXMuY3Jvc3NPcmlnaW49YX19O1RIUkVFLkRhdGFUZXh0dXJlTG9hZGVyPVRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXI9ZnVuY3Rpb24oKXt0aGlzLl9wYXJzZXI9bnVsbH07XG5USFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlcixsb2FkOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMsZj1uZXcgVEhSRUUuRGF0YVRleHR1cmUsZz1uZXcgVEhSRUUuWEhSTG9hZGVyO2cuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7Zy5sb2FkKGEsZnVuY3Rpb24oYSl7aWYoYT1lLl9wYXJzZXIoYSkpdm9pZCAwIT09YS5pbWFnZT9mLmltYWdlPWEuaW1hZ2U6dm9pZCAwIT09YS5kYXRhJiYoZi5pbWFnZS53aWR0aD1hLndpZHRoLGYuaW1hZ2UuaGVpZ2h0PWEuaGVpZ2h0LGYuaW1hZ2UuZGF0YT1hLmRhdGEpLGYud3JhcFM9dm9pZCAwIT09YS53cmFwUz9hLndyYXBTOlRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcsZi53cmFwVD12b2lkIDAhPT1hLndyYXBUP2Eud3JhcFQ6VEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyxmLm1hZ0ZpbHRlcj12b2lkIDAhPT1hLm1hZ0ZpbHRlcj9hLm1hZ0ZpbHRlcjpcbiAgICBUSFJFRS5MaW5lYXJGaWx0ZXIsZi5taW5GaWx0ZXI9dm9pZCAwIT09YS5taW5GaWx0ZXI/YS5taW5GaWx0ZXI6VEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLGYuYW5pc290cm9weT12b2lkIDAhPT1hLmFuaXNvdHJvcHk/YS5hbmlzb3Ryb3B5OjEsdm9pZCAwIT09YS5mb3JtYXQmJihmLmZvcm1hdD1hLmZvcm1hdCksdm9pZCAwIT09YS50eXBlJiYoZi50eXBlPWEudHlwZSksdm9pZCAwIT09YS5taXBtYXBzJiYoZi5taXBtYXBzPWEubWlwbWFwcyksMT09PWEubWlwbWFwQ291bnQmJihmLm1pbkZpbHRlcj1USFJFRS5MaW5lYXJGaWx0ZXIpLGYubmVlZHNVcGRhdGU9ITAsYiYmYihmLGEpfSxjLGQpO3JldHVybiBmfX07VEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXI9ZnVuY3Rpb24oKXt0aGlzLl9wYXJzZXI9bnVsbH07XG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLGxvYWQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMsZT1bXSxmPW5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtmLmltYWdlPWU7dmFyIGc9bmV3IFRIUkVFLlhIUkxvYWRlcjtnLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO2lmKGEgaW5zdGFuY2VvZiBBcnJheSl7dmFyIGg9MDtjPWZ1bmN0aW9uKGMpe2cubG9hZChhW2NdLGZ1bmN0aW9uKGEpe2E9ZC5fcGFyc2VyKGEsITApO2VbY109e3dpZHRoOmEud2lkdGgsaGVpZ2h0OmEuaGVpZ2h0LGZvcm1hdDphLmZvcm1hdCxtaXBtYXBzOmEubWlwbWFwc307aCs9MTs2PT09aCYmKDE9PWEubWlwbWFwQ291bnQmJihmLm1pbkZpbHRlcj1USFJFRS5MaW5lYXJGaWx0ZXIpLGYuZm9ybWF0PWEuZm9ybWF0LGYubmVlZHNVcGRhdGU9ITAsYiYmYihmKSl9KX07Zm9yKHZhciBrPTAsbD1cbiAgICBhLmxlbmd0aDtrPGw7KytrKWMoayl9ZWxzZSBnLmxvYWQoYSxmdW5jdGlvbihhKXthPWQuX3BhcnNlcihhLCEwKTtpZihhLmlzQ3ViZW1hcClmb3IodmFyIGM9YS5taXBtYXBzLmxlbmd0aC9hLm1pcG1hcENvdW50LGc9MDtnPGM7ZysrKXtlW2ddPXttaXBtYXBzOltdfTtmb3IodmFyIGg9MDtoPGEubWlwbWFwQ291bnQ7aCsrKWVbZ10ubWlwbWFwcy5wdXNoKGEubWlwbWFwc1tnKmEubWlwbWFwQ291bnQraF0pLGVbZ10uZm9ybWF0PWEuZm9ybWF0LGVbZ10ud2lkdGg9YS53aWR0aCxlW2ddLmhlaWdodD1hLmhlaWdodH1lbHNlIGYuaW1hZ2Uud2lkdGg9YS53aWR0aCxmLmltYWdlLmhlaWdodD1hLmhlaWdodCxmLm1pcG1hcHM9YS5taXBtYXBzOzE9PT1hLm1pcG1hcENvdW50JiYoZi5taW5GaWx0ZXI9VEhSRUUuTGluZWFyRmlsdGVyKTtmLmZvcm1hdD1hLmZvcm1hdDtmLm5lZWRzVXBkYXRlPSEwO2ImJmIoZil9KTtyZXR1cm4gZn19O1xuVEhSRUUuTWF0ZXJpYWw9ZnVuY3Rpb24oKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImlkXCIse3ZhbHVlOlRIUkVFLk1hdGVyaWFsSWRDb3VudCsrfSk7dGhpcy51dWlkPVRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7dGhpcy5uYW1lPVwiXCI7dGhpcy50eXBlPVwiTWF0ZXJpYWxcIjt0aGlzLnNpZGU9VEhSRUUuRnJvbnRTaWRlO3RoaXMub3BhY2l0eT0xO3RoaXMudHJhbnNwYXJlbnQ9ITE7dGhpcy5ibGVuZGluZz1USFJFRS5Ob3JtYWxCbGVuZGluZzt0aGlzLmJsZW5kU3JjPVRIUkVFLlNyY0FscGhhRmFjdG9yO3RoaXMuYmxlbmREc3Q9VEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3Rvcjt0aGlzLmJsZW5kRXF1YXRpb249VEhSRUUuQWRkRXF1YXRpb247dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGE9dGhpcy5ibGVuZERzdEFscGhhPXRoaXMuYmxlbmRTcmNBbHBoYT1udWxsO3RoaXMuY29sb3JXcml0ZT10aGlzLmRlcHRoV3JpdGU9dGhpcy5kZXB0aFRlc3Q9ITA7dGhpcy5wb2x5Z29uT2Zmc2V0PVxuICAgICExO3RoaXMub3ZlcmRyYXc9dGhpcy5hbHBoYVRlc3Q9dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHM9dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yPTA7dGhpcy5fbmVlZHNVcGRhdGU9dGhpcy52aXNpYmxlPSEwfTtcblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuTWF0ZXJpYWwsZ2V0IG5lZWRzVXBkYXRlKCl7cmV0dXJuIHRoaXMuX25lZWRzVXBkYXRlfSxzZXQgbmVlZHNVcGRhdGUoYSl7ITA9PT1hJiZ0aGlzLnVwZGF0ZSgpO3RoaXMuX25lZWRzVXBkYXRlPWF9LHNldFZhbHVlczpmdW5jdGlvbihhKXtpZih2b2lkIDAhPT1hKWZvcih2YXIgYiBpbiBhKXt2YXIgYz1hW2JdO2lmKHZvaWQgMD09PWMpVEhSRUUud2FybihcIlRIUkVFLk1hdGVyaWFsOiAnXCIrYitcIicgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC5cIik7ZWxzZSBpZihiIGluIHRoaXMpe3ZhciBkPXRoaXNbYl07ZCBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yP2Quc2V0KGMpOmQgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzJiZjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMz9kLmNvcHkoYyk6dGhpc1tiXT1cIm92ZXJkcmF3XCI9PWI/TnVtYmVyKGMpOmN9fX0sdG9KU09OOmZ1bmN0aW9uKCl7dmFyIGE9e21ldGFkYXRhOnt2ZXJzaW9uOjQuMixcbiAgICB0eXBlOlwibWF0ZXJpYWxcIixnZW5lcmF0b3I6XCJNYXRlcmlhbEV4cG9ydGVyXCJ9LHV1aWQ6dGhpcy51dWlkLHR5cGU6dGhpcy50eXBlfTtcIlwiIT09dGhpcy5uYW1lJiYoYS5uYW1lPXRoaXMubmFtZSk7dGhpcyBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsPyhhLmNvbG9yPXRoaXMuY29sb3IuZ2V0SGV4KCksdGhpcy52ZXJ0ZXhDb2xvcnMhPT1USFJFRS5Ob0NvbG9ycyYmKGEudmVydGV4Q29sb3JzPXRoaXMudmVydGV4Q29sb3JzKSx0aGlzLmJsZW5kaW5nIT09VEhSRUUuTm9ybWFsQmxlbmRpbmcmJihhLmJsZW5kaW5nPXRoaXMuYmxlbmRpbmcpLHRoaXMuc2lkZSE9PVRIUkVFLkZyb250U2lkZSYmKGEuc2lkZT10aGlzLnNpZGUpKTp0aGlzIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbD8oYS5jb2xvcj10aGlzLmNvbG9yLmdldEhleCgpLGEuZW1pc3NpdmU9dGhpcy5lbWlzc2l2ZS5nZXRIZXgoKSx0aGlzLnZlcnRleENvbG9ycyE9PVRIUkVFLk5vQ29sb3JzJiZcbihhLnZlcnRleENvbG9ycz10aGlzLnZlcnRleENvbG9ycyksdGhpcy5zaGFkaW5nIT09VEhSRUUuU21vb3RoU2hhZGluZyYmKGEuc2hhZGluZz10aGlzLnNoYWRpbmcpLHRoaXMuYmxlbmRpbmchPT1USFJFRS5Ob3JtYWxCbGVuZGluZyYmKGEuYmxlbmRpbmc9dGhpcy5ibGVuZGluZyksdGhpcy5zaWRlIT09VEhSRUUuRnJvbnRTaWRlJiYoYS5zaWRlPXRoaXMuc2lkZSkpOnRoaXMgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbD8oYS5jb2xvcj10aGlzLmNvbG9yLmdldEhleCgpLGEuZW1pc3NpdmU9dGhpcy5lbWlzc2l2ZS5nZXRIZXgoKSxhLnNwZWN1bGFyPXRoaXMuc3BlY3VsYXIuZ2V0SGV4KCksYS5zaGluaW5lc3M9dGhpcy5zaGluaW5lc3MsdGhpcy52ZXJ0ZXhDb2xvcnMhPT1USFJFRS5Ob0NvbG9ycyYmKGEudmVydGV4Q29sb3JzPXRoaXMudmVydGV4Q29sb3JzKSx0aGlzLnNoYWRpbmchPT1USFJFRS5TbW9vdGhTaGFkaW5nJiYoYS5zaGFkaW5nPXRoaXMuc2hhZGluZyksXG50aGlzLmJsZW5kaW5nIT09VEhSRUUuTm9ybWFsQmxlbmRpbmcmJihhLmJsZW5kaW5nPXRoaXMuYmxlbmRpbmcpLHRoaXMuc2lkZSE9PVRIUkVFLkZyb250U2lkZSYmKGEuc2lkZT10aGlzLnNpZGUpKTp0aGlzIGluc3RhbmNlb2YgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsPyh0aGlzLmJsZW5kaW5nIT09VEhSRUUuTm9ybWFsQmxlbmRpbmcmJihhLmJsZW5kaW5nPXRoaXMuYmxlbmRpbmcpLHRoaXMuc2lkZSE9PVRIUkVFLkZyb250U2lkZSYmKGEuc2lkZT10aGlzLnNpZGUpKTp0aGlzIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw/KHRoaXMuYmxlbmRpbmchPT1USFJFRS5Ob3JtYWxCbGVuZGluZyYmKGEuYmxlbmRpbmc9dGhpcy5ibGVuZGluZyksdGhpcy5zaWRlIT09VEhSRUUuRnJvbnRTaWRlJiYoYS5zaWRlPXRoaXMuc2lkZSkpOnRoaXMgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWw/KGEuc2l6ZT10aGlzLnNpemUsYS5zaXplQXR0ZW51YXRpb249XG4gICAgdGhpcy5zaXplQXR0ZW51YXRpb24sYS5jb2xvcj10aGlzLmNvbG9yLmdldEhleCgpLHRoaXMudmVydGV4Q29sb3JzIT09VEhSRUUuTm9Db2xvcnMmJihhLnZlcnRleENvbG9ycz10aGlzLnZlcnRleENvbG9ycyksdGhpcy5ibGVuZGluZyE9PVRIUkVFLk5vcm1hbEJsZW5kaW5nJiYoYS5ibGVuZGluZz10aGlzLmJsZW5kaW5nKSk6dGhpcyBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsPyhhLnVuaWZvcm1zPXRoaXMudW5pZm9ybXMsYS52ZXJ0ZXhTaGFkZXI9dGhpcy52ZXJ0ZXhTaGFkZXIsYS5mcmFnbWVudFNoYWRlcj10aGlzLmZyYWdtZW50U2hhZGVyKTp0aGlzIGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlTWF0ZXJpYWwmJihhLmNvbG9yPXRoaXMuY29sb3IuZ2V0SGV4KCkpOzE+dGhpcy5vcGFjaXR5JiYoYS5vcGFjaXR5PXRoaXMub3BhY2l0eSk7ITEhPT10aGlzLnRyYW5zcGFyZW50JiYoYS50cmFuc3BhcmVudD10aGlzLnRyYW5zcGFyZW50KTshMSE9PXRoaXMud2lyZWZyYW1lJiZcbihhLndpcmVmcmFtZT10aGlzLndpcmVmcmFtZSk7cmV0dXJuIGF9LGNsb25lOmZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5NYXRlcmlhbCk7YS5uYW1lPXRoaXMubmFtZTthLnNpZGU9dGhpcy5zaWRlO2Eub3BhY2l0eT10aGlzLm9wYWNpdHk7YS50cmFuc3BhcmVudD10aGlzLnRyYW5zcGFyZW50O2EuYmxlbmRpbmc9dGhpcy5ibGVuZGluZzthLmJsZW5kU3JjPXRoaXMuYmxlbmRTcmM7YS5ibGVuZERzdD10aGlzLmJsZW5kRHN0O2EuYmxlbmRFcXVhdGlvbj10aGlzLmJsZW5kRXF1YXRpb247YS5ibGVuZFNyY0FscGhhPXRoaXMuYmxlbmRTcmNBbHBoYTthLmJsZW5kRHN0QWxwaGE9dGhpcy5ibGVuZERzdEFscGhhO2EuYmxlbmRFcXVhdGlvbkFscGhhPXRoaXMuYmxlbmRFcXVhdGlvbkFscGhhO2EuZGVwdGhUZXN0PXRoaXMuZGVwdGhUZXN0O2EuZGVwdGhXcml0ZT10aGlzLmRlcHRoV3JpdGU7YS5wb2x5Z29uT2Zmc2V0PXRoaXMucG9seWdvbk9mZnNldDthLnBvbHlnb25PZmZzZXRGYWN0b3I9XG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yO2EucG9seWdvbk9mZnNldFVuaXRzPXRoaXMucG9seWdvbk9mZnNldFVuaXRzO2EuYWxwaGFUZXN0PXRoaXMuYWxwaGFUZXN0O2Eub3ZlcmRyYXc9dGhpcy5vdmVyZHJhdzthLnZpc2libGU9dGhpcy52aXNpYmxlO3JldHVybiBhfSx1cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJ1cGRhdGVcIn0pfSxkaXNwb3NlOmZ1bmN0aW9uKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZGlzcG9zZVwifSl9fTtUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSk7VEhSRUUuTWF0ZXJpYWxJZENvdW50PTA7XG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbD1mdW5jdGlvbihhKXtUSFJFRS5NYXRlcmlhbC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIkxpbmVCYXNpY01hdGVyaWFsXCI7dGhpcy5jb2xvcj1uZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpO3RoaXMubGluZXdpZHRoPTE7dGhpcy5saW5lam9pbj10aGlzLmxpbmVjYXA9XCJyb3VuZFwiO3RoaXMudmVydGV4Q29sb3JzPVRIUkVFLk5vQ29sb3JzO3RoaXMuZm9nPSEwO3RoaXMuc2V0VmFsdWVzKGEpfTtUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUpO1RIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2EuY29sb3IuY29weSh0aGlzLmNvbG9yKTthLmxpbmV3aWR0aD10aGlzLmxpbmV3aWR0aDthLmxpbmVjYXA9dGhpcy5saW5lY2FwO2EubGluZWpvaW49dGhpcy5saW5lam9pbjthLnZlcnRleENvbG9ycz10aGlzLnZlcnRleENvbG9yczthLmZvZz10aGlzLmZvZztyZXR1cm4gYX07XG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7VEhSRUUuTWF0ZXJpYWwuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJMaW5lRGFzaGVkTWF0ZXJpYWxcIjt0aGlzLmNvbG9yPW5ldyBUSFJFRS5Db2xvcigxNjc3NzIxNSk7dGhpcy5zY2FsZT10aGlzLmxpbmV3aWR0aD0xO3RoaXMuZGFzaFNpemU9Mzt0aGlzLmdhcFNpemU9MTt0aGlzLnZlcnRleENvbG9ycz0hMTt0aGlzLmZvZz0hMDt0aGlzLnNldFZhbHVlcyhhKX07VEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSk7VEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw7XG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbDtUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2EuY29sb3IuY29weSh0aGlzLmNvbG9yKTthLmxpbmV3aWR0aD10aGlzLmxpbmV3aWR0aDthLnNjYWxlPXRoaXMuc2NhbGU7YS5kYXNoU2l6ZT10aGlzLmRhc2hTaXplO2EuZ2FwU2l6ZT10aGlzLmdhcFNpemU7YS52ZXJ0ZXhDb2xvcnM9dGhpcy52ZXJ0ZXhDb2xvcnM7YS5mb2c9dGhpcy5mb2c7cmV0dXJuIGF9O1xuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7VEhSRUUuTWF0ZXJpYWwuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJNZXNoQmFzaWNNYXRlcmlhbFwiO3RoaXMuY29sb3I9bmV3IFRIUkVFLkNvbG9yKDE2Nzc3MjE1KTt0aGlzLmVudk1hcD10aGlzLmFscGhhTWFwPXRoaXMuc3BlY3VsYXJNYXA9dGhpcy5saWdodE1hcD10aGlzLm1hcD1udWxsO3RoaXMuY29tYmluZT1USFJFRS5NdWx0aXBseU9wZXJhdGlvbjt0aGlzLnJlZmxlY3Rpdml0eT0xO3RoaXMucmVmcmFjdGlvblJhdGlvPS45ODt0aGlzLmZvZz0hMDt0aGlzLnNoYWRpbmc9VEhSRUUuU21vb3RoU2hhZGluZzt0aGlzLndpcmVmcmFtZT0hMTt0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xO3RoaXMud2lyZWZyYW1lTGluZWpvaW49dGhpcy53aXJlZnJhbWVMaW5lY2FwPVwicm91bmRcIjt0aGlzLnZlcnRleENvbG9ycz1USFJFRS5Ob0NvbG9yczt0aGlzLm1vcnBoVGFyZ2V0cz10aGlzLnNraW5uaW5nPSExO3RoaXMuc2V0VmFsdWVzKGEpfTtcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSk7VEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLk1lc2hCYXNpY01hdGVyaWFsO1xuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsO1RIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5jb2xvci5jb3B5KHRoaXMuY29sb3IpO2EubWFwPXRoaXMubWFwO2EubGlnaHRNYXA9dGhpcy5saWdodE1hcDthLnNwZWN1bGFyTWFwPXRoaXMuc3BlY3VsYXJNYXA7YS5hbHBoYU1hcD10aGlzLmFscGhhTWFwO2EuZW52TWFwPXRoaXMuZW52TWFwO2EuY29tYmluZT10aGlzLmNvbWJpbmU7YS5yZWZsZWN0aXZpdHk9dGhpcy5yZWZsZWN0aXZpdHk7YS5yZWZyYWN0aW9uUmF0aW89dGhpcy5yZWZyYWN0aW9uUmF0aW87YS5mb2c9dGhpcy5mb2c7YS5zaGFkaW5nPXRoaXMuc2hhZGluZzthLndpcmVmcmFtZT10aGlzLndpcmVmcmFtZTthLndpcmVmcmFtZUxpbmV3aWR0aD10aGlzLndpcmVmcmFtZUxpbmV3aWR0aDthLndpcmVmcmFtZUxpbmVjYXA9dGhpcy53aXJlZnJhbWVMaW5lY2FwO1xuICAgIGEud2lyZWZyYW1lTGluZWpvaW49dGhpcy53aXJlZnJhbWVMaW5lam9pbjthLnZlcnRleENvbG9ycz10aGlzLnZlcnRleENvbG9yczthLnNraW5uaW5nPXRoaXMuc2tpbm5pbmc7YS5tb3JwaFRhcmdldHM9dGhpcy5tb3JwaFRhcmdldHM7cmV0dXJuIGF9O1xuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbD1mdW5jdGlvbihhKXtUSFJFRS5NYXRlcmlhbC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIk1lc2hMYW1iZXJ0TWF0ZXJpYWxcIjt0aGlzLmNvbG9yPW5ldyBUSFJFRS5Db2xvcigxNjc3NzIxNSk7dGhpcy5lbWlzc2l2ZT1uZXcgVEhSRUUuQ29sb3IoMCk7dGhpcy53cmFwQXJvdW5kPSExO3RoaXMud3JhcFJHQj1uZXcgVEhSRUUuVmVjdG9yMygxLDEsMSk7dGhpcy5lbnZNYXA9dGhpcy5hbHBoYU1hcD10aGlzLnNwZWN1bGFyTWFwPXRoaXMubGlnaHRNYXA9dGhpcy5tYXA9bnVsbDt0aGlzLmNvbWJpbmU9VEhSRUUuTXVsdGlwbHlPcGVyYXRpb247dGhpcy5yZWZsZWN0aXZpdHk9MTt0aGlzLnJlZnJhY3Rpb25SYXRpbz0uOTg7dGhpcy5mb2c9ITA7dGhpcy5zaGFkaW5nPVRIUkVFLlNtb290aFNoYWRpbmc7dGhpcy53aXJlZnJhbWU9ITE7dGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MTt0aGlzLndpcmVmcmFtZUxpbmVqb2luPXRoaXMud2lyZWZyYW1lTGluZWNhcD1cbiAgICBcInJvdW5kXCI7dGhpcy52ZXJ0ZXhDb2xvcnM9VEhSRUUuTm9Db2xvcnM7dGhpcy5tb3JwaE5vcm1hbHM9dGhpcy5tb3JwaFRhcmdldHM9dGhpcy5za2lubmluZz0hMTt0aGlzLnNldFZhbHVlcyhhKX07VEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUpO1RIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsO1RIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5jb2xvci5jb3B5KHRoaXMuY29sb3IpO2EuZW1pc3NpdmUuY29weSh0aGlzLmVtaXNzaXZlKTthLndyYXBBcm91bmQ9dGhpcy53cmFwQXJvdW5kO2Eud3JhcFJHQi5jb3B5KHRoaXMud3JhcFJHQik7YS5tYXA9dGhpcy5tYXA7YS5saWdodE1hcD10aGlzLmxpZ2h0TWFwO2Euc3BlY3VsYXJNYXA9dGhpcy5zcGVjdWxhck1hcDthLmFscGhhTWFwPXRoaXMuYWxwaGFNYXA7YS5lbnZNYXA9dGhpcy5lbnZNYXA7YS5jb21iaW5lPXRoaXMuY29tYmluZTthLnJlZmxlY3Rpdml0eT10aGlzLnJlZmxlY3Rpdml0eTthLnJlZnJhY3Rpb25SYXRpbz10aGlzLnJlZnJhY3Rpb25SYXRpbzthLmZvZz10aGlzLmZvZzthLnNoYWRpbmc9dGhpcy5zaGFkaW5nO2Eud2lyZWZyYW1lPVxuICAgIHRoaXMud2lyZWZyYW1lO2Eud2lyZWZyYW1lTGluZXdpZHRoPXRoaXMud2lyZWZyYW1lTGluZXdpZHRoO2Eud2lyZWZyYW1lTGluZWNhcD10aGlzLndpcmVmcmFtZUxpbmVjYXA7YS53aXJlZnJhbWVMaW5lam9pbj10aGlzLndpcmVmcmFtZUxpbmVqb2luO2EudmVydGV4Q29sb3JzPXRoaXMudmVydGV4Q29sb3JzO2Euc2tpbm5pbmc9dGhpcy5za2lubmluZzthLm1vcnBoVGFyZ2V0cz10aGlzLm1vcnBoVGFyZ2V0czthLm1vcnBoTm9ybWFscz10aGlzLm1vcnBoTm9ybWFscztyZXR1cm4gYX07XG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbD1mdW5jdGlvbihhKXtUSFJFRS5NYXRlcmlhbC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIk1lc2hQaG9uZ01hdGVyaWFsXCI7dGhpcy5jb2xvcj1uZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpO3RoaXMuZW1pc3NpdmU9bmV3IFRIUkVFLkNvbG9yKDApO3RoaXMuc3BlY3VsYXI9bmV3IFRIUkVFLkNvbG9yKDExMTg0ODEpO3RoaXMuc2hpbmluZXNzPTMwO3RoaXMud3JhcEFyb3VuZD10aGlzLm1ldGFsPSExO3RoaXMud3JhcFJHQj1uZXcgVEhSRUUuVmVjdG9yMygxLDEsMSk7dGhpcy5idW1wTWFwPXRoaXMubGlnaHRNYXA9dGhpcy5tYXA9bnVsbDt0aGlzLmJ1bXBTY2FsZT0xO3RoaXMubm9ybWFsTWFwPW51bGw7dGhpcy5ub3JtYWxTY2FsZT1uZXcgVEhSRUUuVmVjdG9yMigxLDEpO3RoaXMuZW52TWFwPXRoaXMuYWxwaGFNYXA9dGhpcy5zcGVjdWxhck1hcD1udWxsO3RoaXMuY29tYmluZT1USFJFRS5NdWx0aXBseU9wZXJhdGlvbjt0aGlzLnJlZmxlY3Rpdml0eT1cbiAgICAxO3RoaXMucmVmcmFjdGlvblJhdGlvPS45ODt0aGlzLmZvZz0hMDt0aGlzLnNoYWRpbmc9VEhSRUUuU21vb3RoU2hhZGluZzt0aGlzLndpcmVmcmFtZT0hMTt0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xO3RoaXMud2lyZWZyYW1lTGluZWpvaW49dGhpcy53aXJlZnJhbWVMaW5lY2FwPVwicm91bmRcIjt0aGlzLnZlcnRleENvbG9ycz1USFJFRS5Ob0NvbG9yczt0aGlzLm1vcnBoTm9ybWFscz10aGlzLm1vcnBoVGFyZ2V0cz10aGlzLnNraW5uaW5nPSExO3RoaXMuc2V0VmFsdWVzKGEpfTtUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUpO1RIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5NZXNoUGhvbmdNYXRlcmlhbDtcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDtUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2EuY29sb3IuY29weSh0aGlzLmNvbG9yKTthLmVtaXNzaXZlLmNvcHkodGhpcy5lbWlzc2l2ZSk7YS5zcGVjdWxhci5jb3B5KHRoaXMuc3BlY3VsYXIpO2Euc2hpbmluZXNzPXRoaXMuc2hpbmluZXNzO2EubWV0YWw9dGhpcy5tZXRhbDthLndyYXBBcm91bmQ9dGhpcy53cmFwQXJvdW5kO2Eud3JhcFJHQi5jb3B5KHRoaXMud3JhcFJHQik7YS5tYXA9dGhpcy5tYXA7YS5saWdodE1hcD10aGlzLmxpZ2h0TWFwO2EuYnVtcE1hcD10aGlzLmJ1bXBNYXA7YS5idW1wU2NhbGU9dGhpcy5idW1wU2NhbGU7YS5ub3JtYWxNYXA9dGhpcy5ub3JtYWxNYXA7YS5ub3JtYWxTY2FsZS5jb3B5KHRoaXMubm9ybWFsU2NhbGUpO2Euc3BlY3VsYXJNYXA9dGhpcy5zcGVjdWxhck1hcDtcbiAgICBhLmFscGhhTWFwPXRoaXMuYWxwaGFNYXA7YS5lbnZNYXA9dGhpcy5lbnZNYXA7YS5jb21iaW5lPXRoaXMuY29tYmluZTthLnJlZmxlY3Rpdml0eT10aGlzLnJlZmxlY3Rpdml0eTthLnJlZnJhY3Rpb25SYXRpbz10aGlzLnJlZnJhY3Rpb25SYXRpbzthLmZvZz10aGlzLmZvZzthLnNoYWRpbmc9dGhpcy5zaGFkaW5nO2Eud2lyZWZyYW1lPXRoaXMud2lyZWZyYW1lO2Eud2lyZWZyYW1lTGluZXdpZHRoPXRoaXMud2lyZWZyYW1lTGluZXdpZHRoO2Eud2lyZWZyYW1lTGluZWNhcD10aGlzLndpcmVmcmFtZUxpbmVjYXA7YS53aXJlZnJhbWVMaW5lam9pbj10aGlzLndpcmVmcmFtZUxpbmVqb2luO2EudmVydGV4Q29sb3JzPXRoaXMudmVydGV4Q29sb3JzO2Euc2tpbm5pbmc9dGhpcy5za2lubmluZzthLm1vcnBoVGFyZ2V0cz10aGlzLm1vcnBoVGFyZ2V0czthLm1vcnBoTm9ybWFscz10aGlzLm1vcnBoTm9ybWFscztyZXR1cm4gYX07XG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbD1mdW5jdGlvbihhKXtUSFJFRS5NYXRlcmlhbC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIk1lc2hEZXB0aE1hdGVyaWFsXCI7dGhpcy53aXJlZnJhbWU9dGhpcy5tb3JwaFRhcmdldHM9ITE7dGhpcy53aXJlZnJhbWVMaW5ld2lkdGg9MTt0aGlzLnNldFZhbHVlcyhhKX07VEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlKTtUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw7XG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw7VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLndpcmVmcmFtZT10aGlzLndpcmVmcmFtZTthLndpcmVmcmFtZUxpbmV3aWR0aD10aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtyZXR1cm4gYX07VEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsPWZ1bmN0aW9uKGEpe1RIUkVFLk1hdGVyaWFsLmNhbGwodGhpcyxhKTt0aGlzLnR5cGU9XCJNZXNoTm9ybWFsTWF0ZXJpYWxcIjt0aGlzLndpcmVmcmFtZT0hMTt0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xO3RoaXMubW9ycGhUYXJnZXRzPSExO3RoaXMuc2V0VmFsdWVzKGEpfTtUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlKTtcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsO1RIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsO1RIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS53aXJlZnJhbWU9dGhpcy53aXJlZnJhbWU7YS53aXJlZnJhbWVMaW5ld2lkdGg9dGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7cmV0dXJuIGF9O1RIUkVFLk1lc2hGYWNlTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7dGhpcy51dWlkPVRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7dGhpcy50eXBlPVwiTWVzaEZhY2VNYXRlcmlhbFwiO3RoaXMubWF0ZXJpYWxzPWEgaW5zdGFuY2VvZiBBcnJheT9hOltdfTtcblRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5NZXNoRmFjZU1hdGVyaWFsLHRvSlNPTjpmdW5jdGlvbigpe2Zvcih2YXIgYT17bWV0YWRhdGE6e3ZlcnNpb246NC4yLHR5cGU6XCJtYXRlcmlhbFwiLGdlbmVyYXRvcjpcIk1hdGVyaWFsRXhwb3J0ZXJcIn0sdXVpZDp0aGlzLnV1aWQsdHlwZTp0aGlzLnR5cGUsbWF0ZXJpYWxzOltdfSxiPTAsYz10aGlzLm1hdGVyaWFscy5sZW5ndGg7YjxjO2IrKylhLm1hdGVyaWFscy5wdXNoKHRoaXMubWF0ZXJpYWxzW2JdLnRvSlNPTigpKTtyZXR1cm4gYX0sY2xvbmU6ZnVuY3Rpb24oKXtmb3IodmFyIGE9bmV3IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwsYj0wO2I8dGhpcy5tYXRlcmlhbHMubGVuZ3RoO2IrKylhLm1hdGVyaWFscy5wdXNoKHRoaXMubWF0ZXJpYWxzW2JdLmNsb25lKCkpO3JldHVybiBhfX07XG5USFJFRS5Qb2ludENsb3VkTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7VEhSRUUuTWF0ZXJpYWwuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJQb2ludENsb3VkTWF0ZXJpYWxcIjt0aGlzLmNvbG9yPW5ldyBUSFJFRS5Db2xvcigxNjc3NzIxNSk7dGhpcy5tYXA9bnVsbDt0aGlzLnNpemU9MTt0aGlzLnNpemVBdHRlbnVhdGlvbj0hMDt0aGlzLnZlcnRleENvbG9ycz1USFJFRS5Ob0NvbG9yczt0aGlzLmZvZz0hMDt0aGlzLnNldFZhbHVlcyhhKX07VEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSk7VEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5Qb2ludENsb3VkTWF0ZXJpYWw7XG5USFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbDtUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2EuY29sb3IuY29weSh0aGlzLmNvbG9yKTthLm1hcD10aGlzLm1hcDthLnNpemU9dGhpcy5zaXplO2Euc2l6ZUF0dGVudWF0aW9uPXRoaXMuc2l6ZUF0dGVudWF0aW9uO2EudmVydGV4Q29sb3JzPXRoaXMudmVydGV4Q29sb3JzO2EuZm9nPXRoaXMuZm9nO3JldHVybiBhfTtUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7VEhSRUUud2FybihcIlRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbC5cIik7cmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoYSl9O1xuVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbD1mdW5jdGlvbihhKXtUSFJFRS53YXJuKFwiVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbC5cIik7cmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoYSl9O1xuVEhSRUUuU2hhZGVyTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7VEhSRUUuTWF0ZXJpYWwuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJTaGFkZXJNYXRlcmlhbFwiO3RoaXMuZGVmaW5lcz17fTt0aGlzLnVuaWZvcm1zPXt9O3RoaXMuYXR0cmlidXRlcz1udWxsO3RoaXMudmVydGV4U2hhZGVyPVwidm9pZCBtYWluKCkge1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59XCI7dGhpcy5mcmFnbWVudFNoYWRlcj1cInZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59XCI7dGhpcy5zaGFkaW5nPVRIUkVFLlNtb290aFNoYWRpbmc7dGhpcy5saW5ld2lkdGg9MTt0aGlzLndpcmVmcmFtZT0hMTt0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xO3RoaXMubGlnaHRzPXRoaXMuZm9nPSExO3RoaXMudmVydGV4Q29sb3JzPVRIUkVFLk5vQ29sb3JzO3RoaXMubW9ycGhOb3JtYWxzPVxuICAgIHRoaXMubW9ycGhUYXJnZXRzPXRoaXMuc2tpbm5pbmc9ITE7dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzPXtjb2xvcjpbMSwxLDFdLHV2OlswLDBdLHV2MjpbMCwwXX07dGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lPXZvaWQgMDt0aGlzLnNldFZhbHVlcyhhKX07VEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlKTtUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuU2hhZGVyTWF0ZXJpYWw7XG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWw7VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLmZyYWdtZW50U2hhZGVyPXRoaXMuZnJhZ21lbnRTaGFkZXI7YS52ZXJ0ZXhTaGFkZXI9dGhpcy52ZXJ0ZXhTaGFkZXI7YS51bmlmb3Jtcz1USFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKHRoaXMudW5pZm9ybXMpO2EuYXR0cmlidXRlcz10aGlzLmF0dHJpYnV0ZXM7YS5kZWZpbmVzPXRoaXMuZGVmaW5lczthLnNoYWRpbmc9dGhpcy5zaGFkaW5nO2Eud2lyZWZyYW1lPXRoaXMud2lyZWZyYW1lO2Eud2lyZWZyYW1lTGluZXdpZHRoPXRoaXMud2lyZWZyYW1lTGluZXdpZHRoO2EuZm9nPXRoaXMuZm9nO2EubGlnaHRzPXRoaXMubGlnaHRzO2EudmVydGV4Q29sb3JzPXRoaXMudmVydGV4Q29sb3JzO2Euc2tpbm5pbmc9dGhpcy5za2lubmluZzthLm1vcnBoVGFyZ2V0cz1cbiAgICB0aGlzLm1vcnBoVGFyZ2V0czthLm1vcnBoTm9ybWFscz10aGlzLm1vcnBoTm9ybWFscztyZXR1cm4gYX07VEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7VEhSRUUuU2hhZGVyTWF0ZXJpYWwuY2FsbCh0aGlzLGEpO3RoaXMudHlwZT1cIlJhd1NoYWRlck1hdGVyaWFsXCJ9O1RIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSk7VEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlJhd1NoYWRlck1hdGVyaWFsO1RIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbDtUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtcblRIUkVFLlNwcml0ZU1hdGVyaWFsPWZ1bmN0aW9uKGEpe1RIUkVFLk1hdGVyaWFsLmNhbGwodGhpcyk7dGhpcy50eXBlPVwiU3ByaXRlTWF0ZXJpYWxcIjt0aGlzLmNvbG9yPW5ldyBUSFJFRS5Db2xvcigxNjc3NzIxNSk7dGhpcy5tYXA9bnVsbDt0aGlzLnJvdGF0aW9uPTA7dGhpcy5mb2c9ITE7dGhpcy5zZXRWYWx1ZXMoYSl9O1RIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSk7VEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlNwcml0ZU1hdGVyaWFsO1xuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsO1RIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5jb2xvci5jb3B5KHRoaXMuY29sb3IpO2EubWFwPXRoaXMubWFwO2Eucm90YXRpb249dGhpcy5yb3RhdGlvbjthLmZvZz10aGlzLmZvZztyZXR1cm4gYX07XG5USFJFRS5UZXh0dXJlPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImlkXCIse3ZhbHVlOlRIUkVFLlRleHR1cmVJZENvdW50Kyt9KTt0aGlzLnV1aWQ9VEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTt0aGlzLnNvdXJjZUZpbGU9dGhpcy5uYW1lPVwiXCI7dGhpcy5pbWFnZT12b2lkIDAhPT1hP2E6VEhSRUUuVGV4dHVyZS5ERUZBVUxUX0lNQUdFO3RoaXMubWlwbWFwcz1bXTt0aGlzLm1hcHBpbmc9dm9pZCAwIT09Yj9iOlRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HO3RoaXMud3JhcFM9dm9pZCAwIT09Yz9jOlRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7dGhpcy53cmFwVD12b2lkIDAhPT1kP2Q6VEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzt0aGlzLm1hZ0ZpbHRlcj12b2lkIDAhPT1lP2U6VEhSRUUuTGluZWFyRmlsdGVyO3RoaXMubWluRmlsdGVyPXZvaWQgMCE9PWY/ZjpUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG4gICAgdGhpcy5hbmlzb3Ryb3B5PXZvaWQgMCE9PWs/azoxO3RoaXMuZm9ybWF0PXZvaWQgMCE9PWc/ZzpUSFJFRS5SR0JBRm9ybWF0O3RoaXMudHlwZT12b2lkIDAhPT1oP2g6VEhSRUUuVW5zaWduZWRCeXRlVHlwZTt0aGlzLm9mZnNldD1uZXcgVEhSRUUuVmVjdG9yMigwLDApO3RoaXMucmVwZWF0PW5ldyBUSFJFRS5WZWN0b3IyKDEsMSk7dGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITA7dGhpcy5wcmVtdWx0aXBseUFscGhhPSExO3RoaXMuZmxpcFk9ITA7dGhpcy51bnBhY2tBbGlnbm1lbnQ9NDt0aGlzLl9uZWVkc1VwZGF0ZT0hMTt0aGlzLm9uVXBkYXRlPW51bGx9O1RIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRT12b2lkIDA7VEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkc9VEhSRUUuVVZNYXBwaW5nO1xuVEhSRUUuVGV4dHVyZS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLlRleHR1cmUsZ2V0IG5lZWRzVXBkYXRlKCl7cmV0dXJuIHRoaXMuX25lZWRzVXBkYXRlfSxzZXQgbmVlZHNVcGRhdGUoYSl7ITA9PT1hJiZ0aGlzLnVwZGF0ZSgpO3RoaXMuX25lZWRzVXBkYXRlPWF9LGNsb25lOmZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5UZXh0dXJlKTthLmltYWdlPXRoaXMuaW1hZ2U7YS5taXBtYXBzPXRoaXMubWlwbWFwcy5zbGljZSgwKTthLm1hcHBpbmc9dGhpcy5tYXBwaW5nO2Eud3JhcFM9dGhpcy53cmFwUzthLndyYXBUPXRoaXMud3JhcFQ7YS5tYWdGaWx0ZXI9dGhpcy5tYWdGaWx0ZXI7YS5taW5GaWx0ZXI9dGhpcy5taW5GaWx0ZXI7YS5hbmlzb3Ryb3B5PXRoaXMuYW5pc290cm9weTthLmZvcm1hdD10aGlzLmZvcm1hdDthLnR5cGU9dGhpcy50eXBlO2Eub2Zmc2V0LmNvcHkodGhpcy5vZmZzZXQpO2EucmVwZWF0LmNvcHkodGhpcy5yZXBlYXQpO2EuZ2VuZXJhdGVNaXBtYXBzPVxuICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzO2EucHJlbXVsdGlwbHlBbHBoYT10aGlzLnByZW11bHRpcGx5QWxwaGE7YS5mbGlwWT10aGlzLmZsaXBZO2EudW5wYWNrQWxpZ25tZW50PXRoaXMudW5wYWNrQWxpZ25tZW50O3JldHVybiBhfSx1cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJ1cGRhdGVcIn0pfSxkaXNwb3NlOmZ1bmN0aW9uKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZGlzcG9zZVwifSl9fTtUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KFRIUkVFLlRleHR1cmUucHJvdG90eXBlKTtUSFJFRS5UZXh0dXJlSWRDb3VudD0wO1RIUkVFLkN1YmVUZXh0dXJlPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrKXtiPXZvaWQgMCE9PWI/YjpUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc7VEhSRUUuVGV4dHVyZS5jYWxsKHRoaXMsYSxiLGMsZCxlLGYsZyxoLGspO3RoaXMuaW1hZ2VzPWF9O1xuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUpO1RIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5DdWJlVGV4dHVyZTtUSFJFRS5DdWJlVGV4dHVyZS5jbG9uZT1mdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuQ3ViZVRleHR1cmUpO1RIUkVFLlRleHR1cmUucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLmltYWdlcz10aGlzLmltYWdlcztyZXR1cm4gYX07VEhSRUUuQ29tcHJlc3NlZFRleHR1cmU9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGssbCxwKXtUSFJFRS5UZXh0dXJlLmNhbGwodGhpcyxudWxsLGYsZyxoLGssbCxkLGUscCk7dGhpcy5pbWFnZT17d2lkdGg6YixoZWlnaHQ6Y307dGhpcy5taXBtYXBzPWE7dGhpcy5nZW5lcmF0ZU1pcG1hcHM9dGhpcy5mbGlwWT0hMX07VEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUpO1xuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1RIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7cmV0dXJuIGF9O1RIUkVFLkRhdGFUZXh0dXJlPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrLGwscCl7VEhSRUUuVGV4dHVyZS5jYWxsKHRoaXMsbnVsbCxmLGcsaCxrLGwsZCxlLHApO3RoaXMuaW1hZ2U9e2RhdGE6YSx3aWR0aDpiLGhlaWdodDpjfX07VEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUpO1RIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5EYXRhVGV4dHVyZTtcblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5EYXRhVGV4dHVyZTtUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7cmV0dXJuIGF9O1RIUkVFLlZpZGVvVGV4dHVyZT1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsayl7VEhSRUUuVGV4dHVyZS5jYWxsKHRoaXMsYSxiLGMsZCxlLGYsZyxoLGspO3RoaXMuZ2VuZXJhdGVNaXBtYXBzPSExO3ZhciBsPXRoaXMscD1mdW5jdGlvbigpe3JlcXVlc3RBbmltYXRpb25GcmFtZShwKTthLnJlYWR5U3RhdGU9PT1hLkhBVkVfRU5PVUdIX0RBVEEmJihsLm5lZWRzVXBkYXRlPSEwKX07cCgpfTtUSFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUpO1RIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuVmlkZW9UZXh0dXJlO1xuVEhSRUUuR3JvdXA9ZnVuY3Rpb24oKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIkdyb3VwXCJ9O1RIUkVFLkdyb3VwLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkdyb3VwO1RIUkVFLlBvaW50Q2xvdWQ9ZnVuY3Rpb24oYSxiKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIlBvaW50Q2xvdWRcIjt0aGlzLmdlb21ldHJ5PXZvaWQgMCE9PWE/YTpuZXcgVEhSRUUuR2VvbWV0cnk7dGhpcy5tYXRlcmlhbD12b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCh7Y29sb3I6MTY3NzcyMTUqTWF0aC5yYW5kb20oKX0pfTtUSFJFRS5Qb2ludENsb3VkLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuUG9pbnRDbG91ZDtcblRIUkVFLlBvaW50Q2xvdWQucHJvdG90eXBlLnJheWNhc3Q9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuTWF0cml4NCxiPW5ldyBUSFJFRS5SYXk7cmV0dXJuIGZ1bmN0aW9uKGMsZCl7dmFyIGU9dGhpcyxmPWUuZ2VvbWV0cnksZz1jLnBhcmFtcy5Qb2ludENsb3VkLnRocmVzaG9sZDthLmdldEludmVyc2UodGhpcy5tYXRyaXhXb3JsZCk7Yi5jb3B5KGMucmF5KS5hcHBseU1hdHJpeDQoYSk7aWYobnVsbD09PWYuYm91bmRpbmdCb3h8fCExIT09Yi5pc0ludGVyc2VjdGlvbkJveChmLmJvdW5kaW5nQm94KSl7dmFyIGg9Zy8oKHRoaXMuc2NhbGUueCt0aGlzLnNjYWxlLnkrdGhpcy5zY2FsZS56KS8zKSxrPW5ldyBUSFJFRS5WZWN0b3IzLGc9ZnVuY3Rpb24oYSxmKXt2YXIgZz1iLmRpc3RhbmNlVG9Qb2ludChhKTtpZihnPGgpe3ZhciBrPWIuY2xvc2VzdFBvaW50VG9Qb2ludChhKTtrLmFwcGx5TWF0cml4NChlLm1hdHJpeFdvcmxkKTt2YXIgbj1jLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhrKTtcbiAgICBkLnB1c2goe2Rpc3RhbmNlOm4sZGlzdGFuY2VUb1JheTpnLHBvaW50OmsuY2xvbmUoKSxpbmRleDpmLGZhY2U6bnVsbCxvYmplY3Q6ZX0pfX07aWYoZiBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5KXt2YXIgbD1mLmF0dHJpYnV0ZXMscD1sLnBvc2l0aW9uLmFycmF5O2lmKHZvaWQgMCE9PWwuaW5kZXgpe3ZhciBsPWwuaW5kZXguYXJyYXkscT1mLm9mZnNldHM7MD09PXEubGVuZ3RoJiYocT1be3N0YXJ0OjAsY291bnQ6bC5sZW5ndGgsaW5kZXg6MH1dKTtmb3IodmFyIG49MCx0PXEubGVuZ3RoO248dDsrK24pZm9yKHZhciByPXFbbl0uc3RhcnQscz1xW25dLmluZGV4LGY9cixyPXIrcVtuXS5jb3VudDtmPHI7ZisrKXt2YXIgdT1zK2xbZl07ay5mcm9tQXJyYXkocCwzKnUpO2coayx1KX19ZWxzZSBmb3IobD1wLmxlbmd0aC8zLGY9MDtmPGw7ZisrKWsuc2V0KHBbMypmXSxwWzMqZisxXSxwWzMqZisyXSksZyhrLGYpfWVsc2UgZm9yKGs9dGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmPTA7ZjxrLmxlbmd0aDtmKyspZyhrW2ZdLGYpfX19KCk7VEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYSl7dm9pZCAwPT09YSYmKGE9bmV3IFRIUkVFLlBvaW50Q2xvdWQodGhpcy5nZW9tZXRyeSx0aGlzLm1hdGVyaWFsKSk7VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTtyZXR1cm4gYX07VEhSRUUuUGFydGljbGVTeXN0ZW09ZnVuY3Rpb24oYSxiKXtUSFJFRS53YXJuKFwiVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludENsb3VkLlwiKTtyZXR1cm4gbmV3IFRIUkVFLlBvaW50Q2xvdWQoYSxiKX07XG5USFJFRS5MaW5lPWZ1bmN0aW9uKGEsYixjKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIkxpbmVcIjt0aGlzLmdlb21ldHJ5PXZvaWQgMCE9PWE/YTpuZXcgVEhSRUUuR2VvbWV0cnk7dGhpcy5tYXRlcmlhbD12b2lkIDAhPT1iP2I6bmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtjb2xvcjoxNjc3NzIxNSpNYXRoLnJhbmRvbSgpfSk7dGhpcy5tb2RlPXZvaWQgMCE9PWM/YzpUSFJFRS5MaW5lU3RyaXB9O1RIUkVFLkxpbmVTdHJpcD0wO1RIUkVFLkxpbmVQaWVjZXM9MTtUSFJFRS5MaW5lLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuTGluZTtcblRIUkVFLkxpbmUucHJvdG90eXBlLnJheWNhc3Q9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuTWF0cml4NCxiPW5ldyBUSFJFRS5SYXksYz1uZXcgVEhSRUUuU3BoZXJlO3JldHVybiBmdW5jdGlvbihkLGUpe3ZhciBmPWQubGluZVByZWNpc2lvbixmPWYqZixnPXRoaXMuZ2VvbWV0cnk7bnVsbD09PWcuYm91bmRpbmdTcGhlcmUmJmcuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7Yy5jb3B5KGcuYm91bmRpbmdTcGhlcmUpO2MuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO2lmKCExIT09ZC5yYXkuaXNJbnRlcnNlY3Rpb25TcGhlcmUoYykpe2EuZ2V0SW52ZXJzZSh0aGlzLm1hdHJpeFdvcmxkKTtiLmNvcHkoZC5yYXkpLmFwcGx5TWF0cml4NChhKTt2YXIgaD1uZXcgVEhSRUUuVmVjdG9yMyxrPW5ldyBUSFJFRS5WZWN0b3IzLGw9bmV3IFRIUkVFLlZlY3RvcjMscD1uZXcgVEhSRUUuVmVjdG9yMyxxPXRoaXMubW9kZT09PVRIUkVFLkxpbmVTdHJpcD8xOjI7aWYoZyBpbnN0YW5jZW9mXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkpe3ZhciBuPWcuYXR0cmlidXRlcztpZih2b2lkIDAhPT1uLmluZGV4KXt2YXIgdD1uLmluZGV4LmFycmF5LG49bi5wb3NpdGlvbi5hcnJheSxyPWcub2Zmc2V0czswPT09ci5sZW5ndGgmJihyPVt7c3RhcnQ6MCxjb3VudDp0Lmxlbmd0aCxpbmRleDowfV0pO2Zvcih2YXIgcz0wO3M8ci5sZW5ndGg7cysrKWZvcih2YXIgdT1yW3NdLnN0YXJ0LHY9cltzXS5jb3VudCx4PXJbc10uaW5kZXgsZz11O2c8dSt2LTE7Zys9cSl7dmFyIEQ9eCt0W2crMV07aC5mcm9tQXJyYXkobiwzKih4K3RbZ10pKTtrLmZyb21BcnJheShuLDMqRCk7RD1iLmRpc3RhbmNlU3FUb1NlZ21lbnQoaCxrLHAsbCk7RD5mfHwoRD1iLm9yaWdpbi5kaXN0YW5jZVRvKHApLEQ8ZC5uZWFyfHxEPmQuZmFyfHxlLnB1c2goe2Rpc3RhbmNlOkQscG9pbnQ6bC5jbG9uZSgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxpbmRleDpnLG9mZnNldEluZGV4OnMsZmFjZTpudWxsLGZhY2VJbmRleDpudWxsLFxuICAgIG9iamVjdDp0aGlzfSkpfX1lbHNlIGZvcihuPW4ucG9zaXRpb24uYXJyYXksZz0wO2c8bi5sZW5ndGgvMy0xO2crPXEpaC5mcm9tQXJyYXkobiwzKmcpLGsuZnJvbUFycmF5KG4sMypnKzMpLEQ9Yi5kaXN0YW5jZVNxVG9TZWdtZW50KGgsayxwLGwpLEQ+Znx8KEQ9Yi5vcmlnaW4uZGlzdGFuY2VUbyhwKSxEPGQubmVhcnx8RD5kLmZhcnx8ZS5wdXNoKHtkaXN0YW5jZTpELHBvaW50OmwuY2xvbmUoKS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCksaW5kZXg6ZyxmYWNlOm51bGwsZmFjZUluZGV4Om51bGwsb2JqZWN0OnRoaXN9KSl9ZWxzZSBpZihnIGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkpZm9yKGg9Zy52ZXJ0aWNlcyxrPWgubGVuZ3RoLGc9MDtnPGstMTtnKz1xKUQ9Yi5kaXN0YW5jZVNxVG9TZWdtZW50KGhbZ10saFtnKzFdLHAsbCksRD5mfHwoRD1iLm9yaWdpbi5kaXN0YW5jZVRvKHApLEQ8ZC5uZWFyfHxEPmQuZmFyfHxlLnB1c2goe2Rpc3RhbmNlOkQscG9pbnQ6bC5jbG9uZSgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxcbiAgICBpbmRleDpnLGZhY2U6bnVsbCxmYWNlSW5kZXg6bnVsbCxvYmplY3Q6dGhpc30pKX19fSgpO1RIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5MaW5lKHRoaXMuZ2VvbWV0cnksdGhpcy5tYXRlcmlhbCx0aGlzLm1vZGUpKTtUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtUSFJFRS5NZXNoPWZ1bmN0aW9uKGEsYil7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJNZXNoXCI7dGhpcy5nZW9tZXRyeT12b2lkIDAhPT1hP2E6bmV3IFRIUkVFLkdlb21ldHJ5O3RoaXMubWF0ZXJpYWw9dm9pZCAwIT09Yj9iOm5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7Y29sb3I6MTY3NzcyMTUqTWF0aC5yYW5kb20oKX0pO3RoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCl9O1RIUkVFLk1lc2gucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtcblRIUkVFLk1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLk1lc2g7VEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzPWZ1bmN0aW9uKCl7aWYodm9pZCAwIT09dGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMmJjA8dGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoKXt0aGlzLm1vcnBoVGFyZ2V0QmFzZT0tMTt0aGlzLm1vcnBoVGFyZ2V0Rm9yY2VkT3JkZXI9W107dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM9W107dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnk9e307Zm9yKHZhciBhPTAsYj10aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7YTxiO2ErKyl0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKDApLHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3RoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzW2FdLm5hbWVdPWF9fTtcblRIUkVFLk1lc2gucHJvdG90eXBlLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU9ZnVuY3Rpb24oYSl7aWYodm9pZCAwIT09dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbYV0pcmV0dXJuIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W2FdO1RIUkVFLndhcm4oXCJUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCBcIithK1wiIGRvZXMgbm90IGV4aXN0LiBSZXR1cm5pbmcgMC5cIik7cmV0dXJuIDB9O1xuVEhSRUUuTWVzaC5wcm90b3R5cGUucmF5Y2FzdD1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5NYXRyaXg0LGI9bmV3IFRIUkVFLlJheSxjPW5ldyBUSFJFRS5TcGhlcmUsZD1uZXcgVEhSRUUuVmVjdG9yMyxlPW5ldyBUSFJFRS5WZWN0b3IzLGY9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGcsaCl7dmFyIGs9dGhpcy5nZW9tZXRyeTtudWxsPT09ay5ib3VuZGluZ1NwaGVyZSYmay5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtjLmNvcHkoay5ib3VuZGluZ1NwaGVyZSk7Yy5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCk7aWYoITEhPT1nLnJheS5pc0ludGVyc2VjdGlvblNwaGVyZShjKSYmKGEuZ2V0SW52ZXJzZSh0aGlzLm1hdHJpeFdvcmxkKSxiLmNvcHkoZy5yYXkpLmFwcGx5TWF0cml4NChhKSxudWxsPT09ay5ib3VuZGluZ0JveHx8ITEhPT1iLmlzSW50ZXJzZWN0aW9uQm94KGsuYm91bmRpbmdCb3gpKSlpZihrIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkpe3ZhciBsPVxuICAgIHRoaXMubWF0ZXJpYWw7aWYodm9pZCAwIT09bCl7dmFyIHA9ay5hdHRyaWJ1dGVzLHEsbix0PWcucHJlY2lzaW9uO2lmKHZvaWQgMCE9PXAuaW5kZXgpe3ZhciByPXAuaW5kZXguYXJyYXkscz1wLnBvc2l0aW9uLmFycmF5LHU9ay5vZmZzZXRzOzA9PT11Lmxlbmd0aCYmKHU9W3tzdGFydDowLGNvdW50OnIubGVuZ3RoLGluZGV4OjB9XSk7Zm9yKHZhciB2PTAseD11Lmxlbmd0aDt2PHg7Kyt2KWZvcih2YXIgcD11W3ZdLnN0YXJ0LEQ9dVt2XS5pbmRleCxrPXAsdz1wK3Vbdl0uY291bnQ7azx3O2srPTMpe3A9RCtyW2tdO3E9RCtyW2srMV07bj1EK3JbaysyXTtkLmZyb21BcnJheShzLDMqcCk7ZS5mcm9tQXJyYXkocywzKnEpO2YuZnJvbUFycmF5KHMsMypuKTt2YXIgeT1sLnNpZGU9PT1USFJFRS5CYWNrU2lkZT9iLmludGVyc2VjdFRyaWFuZ2xlKGYsZSxkLCEwKTpiLmludGVyc2VjdFRyaWFuZ2xlKGQsZSxmLGwuc2lkZSE9PVRIUkVFLkRvdWJsZVNpZGUpO2lmKG51bGwhPT15KXt5LmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgICB2YXIgQT1nLnJheS5vcmlnaW4uZGlzdGFuY2VUbyh5KTtBPHR8fEE8Zy5uZWFyfHxBPmcuZmFyfHxoLnB1c2goe2Rpc3RhbmNlOkEscG9pbnQ6eSxmYWNlOm5ldyBUSFJFRS5GYWNlMyhwLHEsbixUSFJFRS5UcmlhbmdsZS5ub3JtYWwoZCxlLGYpKSxmYWNlSW5kZXg6bnVsbCxvYmplY3Q6dGhpc30pfX19ZWxzZSBmb3Iocz1wLnBvc2l0aW9uLmFycmF5LHI9az0wLHc9cy5sZW5ndGg7azx3O2srPTMscis9OSlwPWsscT1rKzEsbj1rKzIsZC5mcm9tQXJyYXkocyxyKSxlLmZyb21BcnJheShzLHIrMyksZi5mcm9tQXJyYXkocyxyKzYpLHk9bC5zaWRlPT09VEhSRUUuQmFja1NpZGU/Yi5pbnRlcnNlY3RUcmlhbmdsZShmLGUsZCwhMCk6Yi5pbnRlcnNlY3RUcmlhbmdsZShkLGUsZixsLnNpZGUhPT1USFJFRS5Eb3VibGVTaWRlKSxudWxsIT09eSYmKHkuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpLEE9Zy5yYXkub3JpZ2luLmRpc3RhbmNlVG8oeSksQTx0fHxBPGcubmVhcnx8QT5cbmcuZmFyfHxoLnB1c2goe2Rpc3RhbmNlOkEscG9pbnQ6eSxmYWNlOm5ldyBUSFJFRS5GYWNlMyhwLHEsbixUSFJFRS5UcmlhbmdsZS5ub3JtYWwoZCxlLGYpKSxmYWNlSW5kZXg6bnVsbCxvYmplY3Q6dGhpc30pKX19ZWxzZSBpZihrIGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkpZm9yKHI9dGhpcy5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwscz0hMD09PXI/dGhpcy5tYXRlcmlhbC5tYXRlcmlhbHM6bnVsbCx0PWcucHJlY2lzaW9uLHU9ay52ZXJ0aWNlcyx2PTAseD1rLmZhY2VzLmxlbmd0aDt2PHg7disrKWlmKEQ9ay5mYWNlc1t2XSxsPSEwPT09cj9zW0QubWF0ZXJpYWxJbmRleF06dGhpcy5tYXRlcmlhbCx2b2lkIDAhPT1sKXtwPXVbRC5hXTtxPXVbRC5iXTtuPXVbRC5jXTtpZighMD09PWwubW9ycGhUYXJnZXRzKXt5PWsubW9ycGhUYXJnZXRzO0E9dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7ZC5zZXQoMCwwLDApO2Uuc2V0KDAsMCwwKTtmLnNldCgwLFxuICAgIDAsMCk7Zm9yKHZhciB3PTAsRT15Lmxlbmd0aDt3PEU7dysrKXt2YXIgRz1BW3ddO2lmKDAhPT1HKXt2YXIgRj15W3ddLnZlcnRpY2VzO2QueCs9KEZbRC5hXS54LXAueCkqRztkLnkrPShGW0QuYV0ueS1wLnkpKkc7ZC56Kz0oRltELmFdLnotcC56KSpHO2UueCs9KEZbRC5iXS54LXEueCkqRztlLnkrPShGW0QuYl0ueS1xLnkpKkc7ZS56Kz0oRltELmJdLnotcS56KSpHO2YueCs9KEZbRC5jXS54LW4ueCkqRztmLnkrPShGW0QuY10ueS1uLnkpKkc7Zi56Kz0oRltELmNdLnotbi56KSpHfX1kLmFkZChwKTtlLmFkZChxKTtmLmFkZChuKTtwPWQ7cT1lO249Zn15PWwuc2lkZT09PVRIUkVFLkJhY2tTaWRlP2IuaW50ZXJzZWN0VHJpYW5nbGUobixxLHAsITApOmIuaW50ZXJzZWN0VHJpYW5nbGUocCxxLG4sbC5zaWRlIT09VEhSRUUuRG91YmxlU2lkZSk7bnVsbCE9PXkmJih5LmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxBPWcucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKHkpLEE8dHx8XG5BPGcubmVhcnx8QT5nLmZhcnx8aC5wdXNoKHtkaXN0YW5jZTpBLHBvaW50OnksZmFjZTpELGZhY2VJbmRleDp2LG9iamVjdDp0aGlzfSkpfX19KCk7VEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LHRoaXMubWF0ZXJpYWwpKTtUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEsYik7cmV0dXJuIGF9O1RIUkVFLkJvbmU9ZnVuY3Rpb24oYSl7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJCb25lXCI7dGhpcy5za2luPWF9O1RIUkVFLkJvbmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5Cb25lLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5Cb25lO1xuVEhSRUUuU2tlbGV0b249ZnVuY3Rpb24oYSxiLGMpe3RoaXMudXNlVmVydGV4VGV4dHVyZT12b2lkIDAhPT1jP2M6ITA7dGhpcy5pZGVudGl0eU1hdHJpeD1uZXcgVEhSRUUuTWF0cml4NDthPWF8fFtdO3RoaXMuYm9uZXM9YS5zbGljZSgwKTt0aGlzLnVzZVZlcnRleFRleHR1cmU/KHRoaXMuYm9uZVRleHR1cmVIZWlnaHQ9dGhpcy5ib25lVGV4dHVyZVdpZHRoPWE9MjU2PHRoaXMuYm9uZXMubGVuZ3RoPzY0OjY0PHRoaXMuYm9uZXMubGVuZ3RoPzMyOjE2PHRoaXMuYm9uZXMubGVuZ3RoPzE2OjgsdGhpcy5ib25lTWF0cmljZXM9bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJvbmVUZXh0dXJlV2lkdGgqdGhpcy5ib25lVGV4dHVyZUhlaWdodCo0KSx0aGlzLmJvbmVUZXh0dXJlPW5ldyBUSFJFRS5EYXRhVGV4dHVyZSh0aGlzLmJvbmVNYXRyaWNlcyx0aGlzLmJvbmVUZXh0dXJlV2lkdGgsdGhpcy5ib25lVGV4dHVyZUhlaWdodCxUSFJFRS5SR0JBRm9ybWF0LFRIUkVFLkZsb2F0VHlwZSksXG4gICAgdGhpcy5ib25lVGV4dHVyZS5taW5GaWx0ZXI9VEhSRUUuTmVhcmVzdEZpbHRlcix0aGlzLmJvbmVUZXh0dXJlLm1hZ0ZpbHRlcj1USFJFRS5OZWFyZXN0RmlsdGVyLHRoaXMuYm9uZVRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPSExLHRoaXMuYm9uZVRleHR1cmUuZmxpcFk9ITEpOnRoaXMuYm9uZU1hdHJpY2VzPW5ldyBGbG9hdDMyQXJyYXkoMTYqdGhpcy5ib25lcy5sZW5ndGgpO2lmKHZvaWQgMD09PWIpdGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO2Vsc2UgaWYodGhpcy5ib25lcy5sZW5ndGg9PT1iLmxlbmd0aCl0aGlzLmJvbmVJbnZlcnNlcz1iLnNsaWNlKDApO2Vsc2UgZm9yKFRIUkVFLndhcm4oXCJUSFJFRS5Ta2VsZXRvbiBib25JbnZlcnNlcyBpcyB0aGUgd3JvbmcgbGVuZ3RoLlwiKSx0aGlzLmJvbmVJbnZlcnNlcz1bXSxiPTAsYT10aGlzLmJvbmVzLmxlbmd0aDtiPGE7YisrKXRoaXMuYm9uZUludmVyc2VzLnB1c2gobmV3IFRIUkVFLk1hdHJpeDQpfTtcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jYWxjdWxhdGVJbnZlcnNlcz1mdW5jdGlvbigpe3RoaXMuYm9uZUludmVyc2VzPVtdO2Zvcih2YXIgYT0wLGI9dGhpcy5ib25lcy5sZW5ndGg7YTxiO2ErKyl7dmFyIGM9bmV3IFRIUkVFLk1hdHJpeDQ7dGhpcy5ib25lc1thXSYmYy5nZXRJbnZlcnNlKHRoaXMuYm9uZXNbYV0ubWF0cml4V29ybGQpO3RoaXMuYm9uZUludmVyc2VzLnB1c2goYyl9fTtcblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5wb3NlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhLGI9MCxjPXRoaXMuYm9uZXMubGVuZ3RoO2I8YztiKyspKGE9dGhpcy5ib25lc1tiXSkmJmEubWF0cml4V29ybGQuZ2V0SW52ZXJzZSh0aGlzLmJvbmVJbnZlcnNlc1tiXSk7Yj0wO2ZvcihjPXRoaXMuYm9uZXMubGVuZ3RoO2I8YztiKyspaWYoYT10aGlzLmJvbmVzW2JdKWEucGFyZW50PyhhLm1hdHJpeC5nZXRJbnZlcnNlKGEucGFyZW50Lm1hdHJpeFdvcmxkKSxhLm1hdHJpeC5tdWx0aXBseShhLm1hdHJpeFdvcmxkKSk6YS5tYXRyaXguY29weShhLm1hdHJpeFdvcmxkKSxhLm1hdHJpeC5kZWNvbXBvc2UoYS5wb3NpdGlvbixhLnF1YXRlcm5pb24sYS5zY2FsZSl9O1xuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5NYXRyaXg0O3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgYj0wLGM9dGhpcy5ib25lcy5sZW5ndGg7YjxjO2IrKylhLm11bHRpcGx5TWF0cmljZXModGhpcy5ib25lc1tiXT90aGlzLmJvbmVzW2JdLm1hdHJpeFdvcmxkOnRoaXMuaWRlbnRpdHlNYXRyaXgsdGhpcy5ib25lSW52ZXJzZXNbYl0pLGEuZmxhdHRlblRvQXJyYXlPZmZzZXQodGhpcy5ib25lTWF0cmljZXMsMTYqYik7dGhpcy51c2VWZXJ0ZXhUZXh0dXJlJiYodGhpcy5ib25lVGV4dHVyZS5uZWVkc1VwZGF0ZT0hMCl9fSgpO1xuVEhSRUUuU2tpbm5lZE1lc2g9ZnVuY3Rpb24oYSxiLGMpe1RIUkVFLk1lc2guY2FsbCh0aGlzLGEsYik7dGhpcy50eXBlPVwiU2tpbm5lZE1lc2hcIjt0aGlzLmJpbmRNb2RlPVwiYXR0YWNoZWRcIjt0aGlzLmJpbmRNYXRyaXg9bmV3IFRIUkVFLk1hdHJpeDQ7dGhpcy5iaW5kTWF0cml4SW52ZXJzZT1uZXcgVEhSRUUuTWF0cml4NDthPVtdO2lmKHRoaXMuZ2VvbWV0cnkmJnZvaWQgMCE9PXRoaXMuZ2VvbWV0cnkuYm9uZXMpe2Zvcih2YXIgZCxlLGYsZyxoPTAsaz10aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDtoPGs7KytoKWQ9dGhpcy5nZW9tZXRyeS5ib25lc1toXSxlPWQucG9zLGY9ZC5yb3RxLGc9ZC5zY2wsYj1uZXcgVEhSRUUuQm9uZSh0aGlzKSxhLnB1c2goYiksYi5uYW1lPWQubmFtZSxiLnBvc2l0aW9uLnNldChlWzBdLGVbMV0sZVsyXSksYi5xdWF0ZXJuaW9uLnNldChmWzBdLGZbMV0sZlsyXSxmWzNdKSx2b2lkIDAhPT1nP2Iuc2NhbGUuc2V0KGdbMF0sZ1sxXSxnWzJdKTpiLnNjYWxlLnNldCgxLFxuICAgIDEsMSk7aD0wO2ZvcihrPXRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoO2g8azsrK2gpZD10aGlzLmdlb21ldHJ5LmJvbmVzW2hdLC0xIT09ZC5wYXJlbnQ/YVtkLnBhcmVudF0uYWRkKGFbaF0pOnRoaXMuYWRkKGFbaF0pfXRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTt0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCEwKTt0aGlzLmJpbmQobmV3IFRIUkVFLlNrZWxldG9uKGEsdm9pZCAwLGMpKX07VEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWVzaC5wcm90b3R5cGUpO1RIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5Ta2lubmVkTWVzaDtUSFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuYmluZD1mdW5jdGlvbihhLGIpe3RoaXMuc2tlbGV0b249YTt2b2lkIDA9PT1iJiYodGhpcy51cGRhdGVNYXRyaXhXb3JsZCghMCksYj10aGlzLm1hdHJpeFdvcmxkKTt0aGlzLmJpbmRNYXRyaXguY29weShiKTt0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoYil9O1xuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2U9ZnVuY3Rpb24oKXt0aGlzLnNrZWxldG9uLnBvc2UoKX07VEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLm5vcm1hbGl6ZVNraW5XZWlnaHRzPWZ1bmN0aW9uKCl7aWYodGhpcy5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5KWZvcih2YXIgYT0wO2E8dGhpcy5nZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGg7YSsrKXt2YXIgYj10aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzW2FdLGM9MS9iLmxlbmd0aE1hbmhhdHRhbigpO0luZmluaXR5IT09Yz9iLm11bHRpcGx5U2NhbGFyKGMpOmIuc2V0KDEpfX07XG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQ9ZnVuY3Rpb24oYSl7VEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCh0aGlzLCEwKTtcImF0dGFjaGVkXCI9PT10aGlzLmJpbmRNb2RlP3RoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSh0aGlzLm1hdHJpeFdvcmxkKTpcImRldGFjaGVkXCI9PT10aGlzLmJpbmRNb2RlP3RoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSh0aGlzLmJpbmRNYXRyaXgpOlRIUkVFLndhcm4oXCJUSFJFRS5Ta2lubmVkTWVzaCB1bnJlY2tvZ25pemVkIGJpbmRNb2RlOiBcIit0aGlzLmJpbmRNb2RlKX07XG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYSl7dm9pZCAwPT09YSYmKGE9bmV3IFRIUkVFLlNraW5uZWRNZXNoKHRoaXMuZ2VvbWV0cnksdGhpcy5tYXRlcmlhbCx0aGlzLnVzZVZlcnRleFRleHR1cmUpKTtUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7cmV0dXJuIGF9O1RIUkVFLk1vcnBoQW5pbU1lc2g9ZnVuY3Rpb24oYSxiKXtUSFJFRS5NZXNoLmNhbGwodGhpcyxhLGIpO3RoaXMudHlwZT1cIk1vcnBoQW5pbU1lc2hcIjt0aGlzLmR1cmF0aW9uPTFFMzt0aGlzLm1pcnJvcmVkTG9vcD0hMTt0aGlzLmN1cnJlbnRLZXlmcmFtZT10aGlzLmxhc3RLZXlmcmFtZT10aGlzLnRpbWU9MDt0aGlzLmRpcmVjdGlvbj0xO3RoaXMuZGlyZWN0aW9uQmFja3dhcmRzPSExO3RoaXMuc2V0RnJhbWVSYW5nZSgwLHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aC0xKX07VEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NZXNoLnByb3RvdHlwZSk7XG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5Nb3JwaEFuaW1NZXNoO1RIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldEZyYW1lUmFuZ2U9ZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXJ0S2V5ZnJhbWU9YTt0aGlzLmVuZEtleWZyYW1lPWI7dGhpcy5sZW5ndGg9dGhpcy5lbmRLZXlmcmFtZS10aGlzLnN0YXJ0S2V5ZnJhbWUrMX07VEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uRm9yd2FyZD1mdW5jdGlvbigpe3RoaXMuZGlyZWN0aW9uPTE7dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM9ITF9O1RIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldERpcmVjdGlvbkJhY2t3YXJkPWZ1bmN0aW9uKCl7dGhpcy5kaXJlY3Rpb249LTE7dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM9ITB9O1xuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGFyc2VBbmltYXRpb25zPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZW9tZXRyeTthLmFuaW1hdGlvbnN8fChhLmFuaW1hdGlvbnM9e30pO2Zvcih2YXIgYixjPWEuYW5pbWF0aW9ucyxkPS8oW2Etel0rKV8/KFxcZCspLyxlPTAsZj1hLm1vcnBoVGFyZ2V0cy5sZW5ndGg7ZTxmO2UrKyl7dmFyIGc9YS5tb3JwaFRhcmdldHNbZV0ubmFtZS5tYXRjaChkKTtpZihnJiYxPGcubGVuZ3RoKXtnPWdbMV07Y1tnXXx8KGNbZ109e3N0YXJ0OkluZmluaXR5LGVuZDotSW5maW5pdHl9KTt2YXIgaD1jW2ddO2U8aC5zdGFydCYmKGguc3RhcnQ9ZSk7ZT5oLmVuZCYmKGguZW5kPWUpO2J8fChiPWcpfX1hLmZpcnN0QW5pbWF0aW9uPWJ9O1xuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uTGFiZWw9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc3x8KHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9ucz17fSk7dGhpcy5nZW9tZXRyeS5hbmltYXRpb25zW2FdPXtzdGFydDpiLGVuZDpjfX07VEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1thXTtjPyh0aGlzLnNldEZyYW1lUmFuZ2UoYy5zdGFydCxjLmVuZCksdGhpcy5kdXJhdGlvbj0oYy5lbmQtYy5zdGFydCkvYioxRTMsdGhpcy50aW1lPTApOlRIUkVFLndhcm4oXCJUSFJFRS5Nb3JwaEFuaW1NZXNoOiBhbmltYXRpb25bXCIrYStcIl0gdW5kZWZpbmVkIGluIC5wbGF5QW5pbWF0aW9uKClcIil9O1xuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZHVyYXRpb24vdGhpcy5sZW5ndGg7dGhpcy50aW1lKz10aGlzLmRpcmVjdGlvbiphO2lmKHRoaXMubWlycm9yZWRMb29wKXtpZih0aGlzLnRpbWU+dGhpcy5kdXJhdGlvbnx8MD50aGlzLnRpbWUpdGhpcy5kaXJlY3Rpb24qPS0xLHRoaXMudGltZT50aGlzLmR1cmF0aW9uJiYodGhpcy50aW1lPXRoaXMuZHVyYXRpb24sdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM9ITApLDA+dGhpcy50aW1lJiYodGhpcy50aW1lPTAsdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM9ITEpfWVsc2UgdGhpcy50aW1lJT10aGlzLmR1cmF0aW9uLDA+dGhpcy50aW1lJiYodGhpcy50aW1lKz10aGlzLmR1cmF0aW9uKTthPXRoaXMuc3RhcnRLZXlmcmFtZStUSFJFRS5NYXRoLmNsYW1wKE1hdGguZmxvb3IodGhpcy50aW1lL2IpLDAsdGhpcy5sZW5ndGgtMSk7YSE9PXRoaXMuY3VycmVudEtleWZyYW1lJiZcbih0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t0aGlzLmxhc3RLZXlmcmFtZV09MCx0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t0aGlzLmN1cnJlbnRLZXlmcmFtZV09MSx0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1thXT0wLHRoaXMubGFzdEtleWZyYW1lPXRoaXMuY3VycmVudEtleWZyYW1lLHRoaXMuY3VycmVudEtleWZyYW1lPWEpO2I9dGhpcy50aW1lJWIvYjt0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyYmKGI9MS1iKTt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t0aGlzLmN1cnJlbnRLZXlmcmFtZV09Yjt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t0aGlzLmxhc3RLZXlmcmFtZV09MS1ifTtcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmludGVycG9sYXRlVGFyZ2V0cz1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPXRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLGU9MCxmPWQubGVuZ3RoO2U8ZjtlKyspZFtlXT0wOy0xPGEmJihkW2FdPTEtYyk7LTE8YiYmKGRbYl09Yyl9O1xuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IG5ldyBUSFJFRS5Nb3JwaEFuaW1NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpKTtcbiAgICBhLmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBhLm1pcnJvcmVkTG9vcCA9IHRoaXMubWlycm9yZWRMb29wO1xuICAgIGEudGltZSA9IHRoaXMudGltZTtcbiAgICBhLmxhc3RLZXlmcmFtZSA9IHRoaXMubGFzdEtleWZyYW1lO1xuICAgIGEuY3VycmVudEtleWZyYW1lID0gdGhpcy5jdXJyZW50S2V5ZnJhbWU7XG4gICAgYS5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICBhLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzO1xuICAgIFRIUkVFLk1lc2gucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcywgYSk7XG4gICAgcmV0dXJuIGFcbn07XG5USFJFRS5MT0QgPSBmdW5jdGlvbiAoKSB7XG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVudGl0aWVzID0gW11cbn07XG5USFJFRS5MT0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUpO1xuVEhSRUUuTE9ELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxPRDtcblRIUkVFLkxPRC5wcm90b3R5cGUuYWRkTGV2ZWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZvaWQgMCA9PT0gYiAmJiAoYiA9IDApO1xuICAgIGIgPSBNYXRoLmFicyhiKTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMuZW50aXRpZXMubGVuZ3RoICYmICEoYiA8IHRoaXMuZW50aXRpZXNbY10uZGlzdGFuY2UpOyBjKyspO1xuICAgIHRoaXMuZW50aXRpZXMuc3BsaWNlKGMsIDAsIHtkaXN0YW5jZTogYiwgb2JqZWN0OiBhfSk7XG4gICAgdGhpcy5hZGQoYSlcbn07XG5USFJFRS5MT0QucHJvdG90eXBlLmdldE9iamVjdEZvckRpc3RhbmNlID0gZnVuY3Rpb24gKGEpIHtcbiAgICBmb3IgKHZhciBiID0gMSwgYyA9IHRoaXMuZW50aXRpZXMubGVuZ3RoOyBiIDwgYyAmJiAhKGEgPCB0aGlzLmVudGl0aWVzW2JdLmRpc3RhbmNlKTsgYisrKTtcbiAgICByZXR1cm4gdGhpcy5lbnRpdGllc1tiIC0gMV0ub2JqZWN0XG59O1xuVEhSRUUuTE9ELnByb3RvdHlwZS5yYXljYXN0PWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7YS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7dmFyIGQ9Yi5yYXkub3JpZ2luLmRpc3RhbmNlVG8oYSk7dGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZShkKS5yYXljYXN0KGIsYyl9fSgpO1xuVEhSRUUuTE9ELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSBuZXcgVEhSRUUuVmVjdG9yMywgYiA9IG5ldyBUSFJFRS5WZWN0b3IzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoMSA8IHRoaXMuZW50aXRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhLnNldEZyb21NYXRyaXhQb3NpdGlvbihjLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgIGIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuICAgICAgICAgICAgYyA9IGEuZGlzdGFuY2VUbyhiKTtcbiAgICAgICAgICAgIHRoaXMuZW50aXRpZXNbMF0ub2JqZWN0LnZpc2libGUgPSAhMDtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAxLCBlID0gdGhpcy5lbnRpdGllcy5sZW5ndGg7IGQgPCBlOyBkKyspaWYgKGMgPj0gdGhpcy5lbnRpdGllc1tkXS5kaXN0YW5jZSl0aGlzLmVudGl0aWVzW2QgLSAxXS5vYmplY3QudmlzaWJsZSA9ICExLCB0aGlzLmVudGl0aWVzW2RdLm9iamVjdC52aXNpYmxlID0gITA7IGVsc2UgYnJlYWs7XG4gICAgICAgICAgICBmb3IgKDsgZCA8IGU7IGQrKyl0aGlzLmVudGl0aWVzW2RdLm9iamVjdC52aXNpYmxlID0gITFcbiAgICAgICAgfVxuICAgIH1cbn0oKTtcblRIUkVFLkxPRC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IG5ldyBUSFJFRS5MT0QpO1xuICAgIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsIGEpO1xuICAgIGZvciAodmFyIGIgPSAwLCBjID0gdGhpcy5lbnRpdGllcy5sZW5ndGg7IGIgPCBjOyBiKyspIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmVudGl0aWVzW2JdLm9iamVjdC5jbG9uZSgpO1xuICAgICAgICBkLnZpc2libGUgPSAwID09PSBiO1xuICAgICAgICBhLmFkZExldmVsKGQsIHRoaXMuZW50aXRpZXNbYl0uZGlzdGFuY2UpXG4gICAgfVxuICAgIHJldHVybiBhXG59O1xuVEhSRUUuU3ByaXRlPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFVpbnQxNkFycmF5KFswLDEsMiwwLDIsM10pLGI9bmV3IEZsb2F0MzJBcnJheShbLS41LC0uNSwwLC41LC0uNSwwLC41LC41LDAsLS41LC41LDBdKSxjPW5ldyBGbG9hdDMyQXJyYXkoWzAsMCwxLDAsMSwxLDAsMV0pLGQ9bmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5O2QuYWRkQXR0cmlidXRlKFwiaW5kZXhcIixuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGEsMSkpO2QuYWRkQXR0cmlidXRlKFwicG9zaXRpb25cIixuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGIsMykpO2QuYWRkQXR0cmlidXRlKFwidXZcIixuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGMsMikpO3JldHVybiBmdW5jdGlvbihhKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIlNwcml0ZVwiO3RoaXMuZ2VvbWV0cnk9ZDt0aGlzLm1hdGVyaWFsPXZvaWQgMCE9PWE/YTpuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWx9fSgpO1xuVEhSRUUuU3ByaXRlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5TcHJpdGU7VEhSRUUuU3ByaXRlLnByb3RvdHlwZS5yYXljYXN0PWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7YS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7dmFyIGQ9Yi5yYXkuZGlzdGFuY2VUb1BvaW50KGEpO2Q+dGhpcy5zY2FsZS54fHxjLnB1c2goe2Rpc3RhbmNlOmQscG9pbnQ6dGhpcy5wb3NpdGlvbixmYWNlOm51bGwsb2JqZWN0OnRoaXN9KX19KCk7VEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuU3ByaXRlKHRoaXMubWF0ZXJpYWwpKTtUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtcblRIUkVFLlBhcnRpY2xlPVRIUkVFLlNwcml0ZTtUSFJFRS5MZW5zRmxhcmU9ZnVuY3Rpb24oYSxiLGMsZCxlKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMubGVuc0ZsYXJlcz1bXTt0aGlzLnBvc2l0aW9uU2NyZWVuPW5ldyBUSFJFRS5WZWN0b3IzO3RoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2s9dm9pZCAwO3ZvaWQgMCE9PWEmJnRoaXMuYWRkKGEsYixjLGQsZSl9O1RIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUpO1RIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuTGVuc0ZsYXJlO1xuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZvaWQgMD09PWImJihiPS0xKTt2b2lkIDA9PT1jJiYoYz0wKTt2b2lkIDA9PT1mJiYoZj0xKTt2b2lkIDA9PT1lJiYoZT1uZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpKTt2b2lkIDA9PT1kJiYoZD1USFJFRS5Ob3JtYWxCbGVuZGluZyk7Yz1NYXRoLm1pbihjLE1hdGgubWF4KDAsYykpO3RoaXMubGVuc0ZsYXJlcy5wdXNoKHt0ZXh0dXJlOmEsc2l6ZTpiLGRpc3RhbmNlOmMseDowLHk6MCx6OjAsc2NhbGU6MSxyb3RhdGlvbjoxLG9wYWNpdHk6Zixjb2xvcjplLGJsZW5kaW5nOmR9KX07XG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLnVwZGF0ZUxlbnNGbGFyZXM9ZnVuY3Rpb24oKXt2YXIgYSxiPXRoaXMubGVuc0ZsYXJlcy5sZW5ndGgsYyxkPTIqLXRoaXMucG9zaXRpb25TY3JlZW4ueCxlPTIqLXRoaXMucG9zaXRpb25TY3JlZW4ueTtmb3IoYT0wO2E8YjthKyspYz10aGlzLmxlbnNGbGFyZXNbYV0sYy54PXRoaXMucG9zaXRpb25TY3JlZW4ueCtkKmMuZGlzdGFuY2UsYy55PXRoaXMucG9zaXRpb25TY3JlZW4ueStlKmMuZGlzdGFuY2UsYy53YW50ZWRSb3RhdGlvbj1jLngqTWF0aC5QSSouMjUsYy5yb3RhdGlvbis9LjI1KihjLndhbnRlZFJvdGF0aW9uLWMucm90YXRpb24pfTtUSFJFRS5TY2VuZT1mdW5jdGlvbigpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy50eXBlPVwiU2NlbmVcIjt0aGlzLm92ZXJyaWRlTWF0ZXJpYWw9dGhpcy5mb2c9bnVsbDt0aGlzLmF1dG9VcGRhdGU9ITB9O1RIUkVFLlNjZW5lLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7XG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuU2NlbmU7VEhSRUUuU2NlbmUucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5TY2VuZSk7VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTtudWxsIT09dGhpcy5mb2cmJihhLmZvZz10aGlzLmZvZy5jbG9uZSgpKTtudWxsIT09dGhpcy5vdmVycmlkZU1hdGVyaWFsJiYoYS5vdmVycmlkZU1hdGVyaWFsPXRoaXMub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpKTthLmF1dG9VcGRhdGU9dGhpcy5hdXRvVXBkYXRlO2EubWF0cml4QXV0b1VwZGF0ZT10aGlzLm1hdHJpeEF1dG9VcGRhdGU7cmV0dXJuIGF9O1RIUkVFLkZvZz1mdW5jdGlvbihhLGIsYyl7dGhpcy5uYW1lPVwiXCI7dGhpcy5jb2xvcj1uZXcgVEhSRUUuQ29sb3IoYSk7dGhpcy5uZWFyPXZvaWQgMCE9PWI/YjoxO3RoaXMuZmFyPXZvaWQgMCE9PWM/YzoxRTN9O1xuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgVEhSRUUuRm9nKHRoaXMuY29sb3IuZ2V0SGV4KCksdGhpcy5uZWFyLHRoaXMuZmFyKX07VEhSRUUuRm9nRXhwMj1mdW5jdGlvbihhLGIpe3RoaXMubmFtZT1cIlwiO3RoaXMuY29sb3I9bmV3IFRIUkVFLkNvbG9yKGEpO3RoaXMuZGVuc2l0eT12b2lkIDAhPT1iP2I6Mi41RS00fTtUSFJFRS5Gb2dFeHAyLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgVEhSRUUuRm9nRXhwMih0aGlzLmNvbG9yLmdldEhleCgpLHRoaXMuZGVuc2l0eSl9O1RIUkVFLlNoYWRlckNodW5rPXt9O1RIUkVFLlNoYWRlckNodW5rLmNvbW1vbj1cIiNkZWZpbmUgUEkgMy4xNDE1OVxcbiNkZWZpbmUgUEkyIDYuMjgzMThcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTRcXG4jZGVmaW5lIExPRzIgMS40NDI2OTVcXG4jZGVmaW5lIEVQU0lMT04gMWUtNlxcblxcbmZsb2F0IHNxdWFyZSggaW4gZmxvYXQgYSApIHsgcmV0dXJuIGEqYTsgfVxcbnZlYzIgIHNxdWFyZSggaW4gdmVjMiBhICkgIHsgcmV0dXJuIHZlYzIoIGEueCphLngsIGEueSphLnkgKTsgfVxcbnZlYzMgIHNxdWFyZSggaW4gdmVjMyBhICkgIHsgcmV0dXJuIHZlYzMoIGEueCphLngsIGEueSphLnksIGEueiphLnogKTsgfVxcbnZlYzQgIHNxdWFyZSggaW4gdmVjNCBhICkgIHsgcmV0dXJuIHZlYzQoIGEueCphLngsIGEueSphLnksIGEueiphLnosIGEudyphLncgKTsgfVxcbmZsb2F0IHNhdHVyYXRlKCBpbiBmbG9hdCBhICkgeyByZXR1cm4gY2xhbXAoIGEsIDAuMCwgMS4wICk7IH1cXG52ZWMyICBzYXR1cmF0ZSggaW4gdmVjMiBhICkgIHsgcmV0dXJuIGNsYW1wKCBhLCAwLjAsIDEuMCApOyB9XFxudmVjMyAgc2F0dXJhdGUoIGluIHZlYzMgYSApICB7IHJldHVybiBjbGFtcCggYSwgMC4wLCAxLjAgKTsgfVxcbnZlYzQgIHNhdHVyYXRlKCBpbiB2ZWM0IGEgKSAgeyByZXR1cm4gY2xhbXAoIGEsIDAuMCwgMS4wICk7IH1cXG5mbG9hdCBhdmVyYWdlKCBpbiBmbG9hdCBhICkgeyByZXR1cm4gYTsgfVxcbmZsb2F0IGF2ZXJhZ2UoIGluIHZlYzIgYSApICB7IHJldHVybiAoIGEueCArIGEueSkgKiAwLjU7IH1cXG5mbG9hdCBhdmVyYWdlKCBpbiB2ZWMzIGEgKSAgeyByZXR1cm4gKCBhLnggKyBhLnkgKyBhLnopIC8gMy4wOyB9XFxuZmxvYXQgYXZlcmFnZSggaW4gdmVjNCBhICkgIHsgcmV0dXJuICggYS54ICsgYS55ICsgYS56ICsgYS53KSAqIDAuMjU7IH1cXG5mbG9hdCB3aGl0ZUNvbXBsaW1lbnQoIGluIGZsb2F0IGEgKSB7IHJldHVybiBzYXR1cmF0ZSggMS4wIC0gYSApOyB9XFxudmVjMiAgd2hpdGVDb21wbGltZW50KCBpbiB2ZWMyIGEgKSAgeyByZXR1cm4gc2F0dXJhdGUoIHZlYzIoMS4wKSAtIGEgKTsgfVxcbnZlYzMgIHdoaXRlQ29tcGxpbWVudCggaW4gdmVjMyBhICkgIHsgcmV0dXJuIHNhdHVyYXRlKCB2ZWMzKDEuMCkgLSBhICk7IH1cXG52ZWM0ICB3aGl0ZUNvbXBsaW1lbnQoIGluIHZlYzQgYSApICB7IHJldHVybiBzYXR1cmF0ZSggdmVjNCgxLjApIC0gYSApOyB9XFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgbm9ybWFsLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCAoIG1hdHJpeCAqIHZlYzQoIG5vcm1hbCwgMC4wICkgKS54eXogKTtcXG59XFxuLy8gaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9HTFNMX1Byb2dyYW1taW5nL0FwcGx5aW5nX01hdHJpeF9UcmFuc2Zvcm1hdGlvbnNcXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgbm9ybWFsLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIG5vcm1hbCwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG59XFxudmVjMyBwcm9qZWN0T25QbGFuZShpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCkge1xcblxcdGZsb2F0IGRpc3RhbmNlID0gZG90KCBwbGFuZU5vcm1hbCwgcG9pbnQtcG9pbnRPblBsYW5lICk7XFxuXFx0cmV0dXJuIHBvaW50IC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbDtcXG59XFxuZmxvYXQgc2lkZU9mUGxhbmUoIGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcdHJldHVybiBzaWduKCBkb3QoIHBvaW50IC0gcG9pbnRPblBsYW5lLCBwbGFuZU5vcm1hbCApICk7XFxufVxcbnZlYzMgbGluZVBsYW5lSW50ZXJzZWN0KCBpbiB2ZWMzIHBvaW50T25MaW5lLCBpbiB2ZWMzIGxpbmVEaXJlY3Rpb24sIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcdHJldHVybiBwb2ludE9uTGluZSArIGxpbmVEaXJlY3Rpb24gKiAoIGRvdCggcGxhbmVOb3JtYWwsIHBvaW50T25QbGFuZSAtIHBvaW50T25MaW5lICkgLyBkb3QoIHBsYW5lTm9ybWFsLCBsaW5lRGlyZWN0aW9uICkgKTtcXG59XFxuZmxvYXQgY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcdGlmICggZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXG5cXHQgIHJldHVybiBwb3coIHNhdHVyYXRlKCAxLjAgLSBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSwgZGVjYXlFeHBvbmVudCApO1xcblxcdH1cXG5cXHRyZXR1cm4gMS4wO1xcbn1cXG5cXG52ZWMzIGlucHV0VG9MaW5lYXIoIGluIHZlYzMgYSApIHtcXG4jaWZkZWYgR0FNTUFfSU5QVVRcXG5cXHRyZXR1cm4gcG93KCBhLCB2ZWMzKCBmbG9hdCggR0FNTUFfRkFDVE9SICkgKSApO1xcbiNlbHNlXFxuXFx0cmV0dXJuIGE7XFxuI2VuZGlmXFxufVxcbnZlYzMgbGluZWFyVG9PdXRwdXQoIGluIHZlYzMgYSApIHtcXG4jaWZkZWYgR0FNTUFfT1VUUFVUXFxuXFx0cmV0dXJuIHBvdyggYSwgdmVjMyggMS4wIC8gZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG4jZWxzZVxcblxcdHJldHVybiBhO1xcbiNlbmRpZlxcbn1cXG5cIjtcblRIUkVFLlNoYWRlckNodW5rLmFscGhhdGVzdF9mcmFnbWVudD1cIiNpZmRlZiBBTFBIQVRFU1RcXG5cXG5cXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgQUxQSEFURVNUICkgZGlzY2FyZDtcXG5cXG4jZW5kaWZcXG5cIjtUSFJFRS5TaGFkZXJDaHVuay5saWdodHNfbGFtYmVydF92ZXJ0ZXg9XCJ2TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcblxcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cXHR2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxuXFxuI2VuZGlmXFxuXFxudHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcbmZvciggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0dmVjMyBkaXJWZWN0b3IgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgdmlld01hdHJpeCApO1xcblxcblxcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBkaXJWZWN0b3IgKTtcXG5cXHR2ZWMzIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmcgPSB2ZWMzKCBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICk7XFxuXFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdHZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0JhY2sgPSB2ZWMzKCBtYXgoIC1kb3RQcm9kdWN0LCAwLjAgKSApO1xcblxcblxcdFxcdCNpZmRlZiBXUkFQX0FST1VORFxcblxcblxcdFxcdFxcdHZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGZCYWNrID0gdmVjMyggbWF4KCAtMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcXG5cXG5cXHRcXHQjZW5kaWZcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmID0gdmVjMyggbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmcgPSBtaXgoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmcsIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmLCB3cmFwUkdCICk7XFxuXFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdFxcdGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrID0gbWl4KCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nQmFjaywgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGZCYWNrLCB3cmFwUkdCICk7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0I2VuZGlmXFxuXFxuXFx0dkxpZ2h0RnJvbnQgKz0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nO1xcblxcblxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cXHRcXHR2TGlnaHRCYWNrICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0JhY2s7XFxuXFxuXFx0I2VuZGlmXFxuXFxufVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblxcdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cXHRcXHR2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1xcblxcblxcdFxcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSwgcG9pbnRMaWdodERlY2F5WyBpIF0gKTtcXG5cXG5cXHRcXHRsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKTtcXG5cXG5cXHRcXHR2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmcgPSB2ZWMzKCBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICk7XFxuXFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdFxcdHZlYzMgcG9pbnRMaWdodFdlaWdodGluZ0JhY2sgPSB2ZWMzKCBtYXgoIC1kb3RQcm9kdWN0LCAwLjAgKSApO1xcblxcblxcdFxcdFxcdCNpZmRlZiBXUkFQX0FST1VORFxcblxcblxcdFxcdFxcdFxcdHZlYzMgcG9pbnRMaWdodFdlaWdodGluZ0hhbGZCYWNrID0gdmVjMyggbWF4KCAtMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcXG5cXG5cXHRcXHRcXHQjZW5kaWZcXG5cXG5cXHRcXHQjZW5kaWZcXG5cXG5cXHRcXHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cXHRcXHRcXHR2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmID0gdmVjMyggbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcblxcdFxcdFxcdHBvaW50TGlnaHRXZWlnaHRpbmcgPSBtaXgoIHBvaW50TGlnaHRXZWlnaHRpbmcsIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmLCB3cmFwUkdCICk7XFxuXFxuXFx0XFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdFxcdFxcdHBvaW50TGlnaHRXZWlnaHRpbmdCYWNrID0gbWl4KCBwb2ludExpZ2h0V2VpZ2h0aW5nQmFjaywgcG9pbnRMaWdodFdlaWdodGluZ0hhbGZCYWNrLCB3cmFwUkdCICk7XFxuXFxuXFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludExpZ2h0V2VpZ2h0aW5nICogYXR0ZW51YXRpb247XFxuXFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayAqIGF0dGVudWF0aW9uO1xcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblxcdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcblxcdFxcdHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcXG5cXG5cXHRcXHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBzcG90TGlnaHRQb3NpdGlvblsgaSBdIC0gd29ybGRQb3NpdGlvbi54eXogKSApO1xcblxcblxcdFxcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuXFx0XFx0XFx0c3BvdEVmZmVjdCA9IG1heCggcG93KCBtYXgoIHNwb3RFZmZlY3QsIDAuMCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICksIDAuMCApO1xcblxcblxcdFxcdFxcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBzcG90TGlnaHREaXN0YW5jZVsgaSBdLCBzcG90TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXFx0XFx0XFx0bFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblxcdFxcdFxcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBsVmVjdG9yICk7XFxuXFx0XFx0XFx0dmVjMyBzcG90TGlnaHRXZWlnaHRpbmcgPSB2ZWMzKCBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICk7XFxuXFxuXFx0XFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdFxcdFxcdHZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nQmFjayA9IHZlYzMoIG1heCggLWRvdFByb2R1Y3QsIDAuMCApICk7XFxuXFxuXFx0XFx0XFx0XFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVjMyBzcG90TGlnaHRXZWlnaHRpbmdIYWxmQmFjayA9IHZlYzMoIG1heCggLTAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XFxuXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBzcG90TGlnaHRXZWlnaHRpbmdIYWxmID0gdmVjMyggbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcblxcdFxcdFxcdFxcdHNwb3RMaWdodFdlaWdodGluZyA9IG1peCggc3BvdExpZ2h0V2VpZ2h0aW5nLCBzcG90TGlnaHRXZWlnaHRpbmdIYWxmLCB3cmFwUkdCICk7XFxuXFxuXFx0XFx0XFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdFxcdFxcdFxcdHNwb3RMaWdodFdlaWdodGluZ0JhY2sgPSBtaXgoIHNwb3RMaWdodFdlaWdodGluZ0JhY2ssIHNwb3RMaWdodFdlaWdodGluZ0hhbGZCYWNrLCB3cmFwUkdCICk7XFxuXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0dkxpZ2h0RnJvbnQgKz0gc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RMaWdodFdlaWdodGluZyAqIGF0dGVudWF0aW9uICogc3BvdEVmZmVjdDtcXG5cXG5cXHRcXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXFx0XFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdExpZ2h0V2VpZ2h0aW5nQmFjayAqIGF0dGVudWF0aW9uICogc3BvdEVmZmVjdDtcXG5cXG5cXHRcXHRcXHQjZW5kaWZcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXSwgdmlld01hdHJpeCApO1xcblxcblxcdFxcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBsVmVjdG9yICk7XFxuXFxuXFx0XFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcdFxcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0QmFjayA9IC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcblxcdFxcdHZMaWdodEZyb250ICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0QmFjayApO1xcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdH1cXG5cXG4jZW5kaWZcXG5cXG52TGlnaHRGcm9udCArPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXFx0dkxpZ2h0QmFjayArPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblRIUkVFLlNoYWRlckNodW5rLm1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PVwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcXG5cIjtUSFJFRS5TaGFkZXJDaHVuay5kZWZhdWx0X3ZlcnRleD1cIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBza2lubmVkO1xcblxcbiNlbGlmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKVxcblxcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcbiNlbHNlXFxuXFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcbiNlbmRpZlxcblxcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXCI7XG5USFJFRS5TaGFkZXJDaHVuay5tYXBfcGFyc19mcmFnbWVudD1cIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfTUFQXFxuXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlwiO1RIUkVFLlNoYWRlckNodW5rLnNraW5ub3JtYWxfdmVydGV4PVwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblxcdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7XFxuXFx0c2tpbk1hdHJpeCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblxcblxcdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXFx0dmVjNCBza2lubmVkTm9ybWFsID0gc2tpbk1hdHJpeCAqIHZlYzQoIG1vcnBoZWROb3JtYWwsIDAuMCApO1xcblxcblxcdCNlbHNlXFxuXFxuXFx0dmVjNCBza2lubmVkTm9ybWFsID0gc2tpbk1hdHJpeCAqIHZlYzQoIG5vcm1hbCwgMC4wICk7XFxuXFxuXFx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5USFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD1cIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblxcdFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuI2VuZGlmXCI7VEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfcGFyc192ZXJ0ZXg9XCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7VEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRzX3Bob25nX2ZyYWdtZW50PVwiI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdG5vcm1hbCA9IG5vcm1hbCAqICggLTEuMCArIDIuMCAqIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICk7XFxuXFxuXFx0I2VuZGlmXFxuXFxuI2Vsc2VcXG5cXG5cXHR2ZWMzIGZkeCA9IGRGZHgoIHZWaWV3UG9zaXRpb24gKTtcXG5cXHR2ZWMzIGZkeSA9IGRGZHkoIHZWaWV3UG9zaXRpb24gKTtcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIHZpZXdQb3NpdGlvbiA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwgKTtcXG5cXG4jZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXFxuXFxuXFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIHRvdGFsRGlmZnVzZUxpZ2h0ID0gdmVjMyggMC4wICk7XFxudmVjMyB0b3RhbFNwZWN1bGFyTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblxcdFxcdHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuXFxuXFx0XFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdLCBwb2ludExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblxcdFxcdGxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cXHRcXHQvLyBkaWZmdXNlXFxuXFxuXFx0XFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XFxuXFxuXFx0XFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXFx0XFx0XFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFx0XFx0XFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICk7XFxuXFxuXFx0XFx0XFx0dmVjMyBwb2ludERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XFxuXFxuXFx0XFx0I2Vsc2VcXG5cXG5cXHRcXHRcXHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IHBvaW50TGlnaHRDb2xvclsgaSBdICogcG9pbnREaWZmdXNlV2VpZ2h0ICogYXR0ZW51YXRpb247XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc3BlY3VsYXJcXG5cXG5cXHRcXHR2ZWMzIHBvaW50SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1xcblxcdFxcdGZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcXG5cXHRcXHRmbG9hdCBwb2ludFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBwb2ludERvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcXG5cXG5cXHRcXHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1xcblxcblxcdFxcdHZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGxWZWN0b3IsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XFxuXFx0XFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IHNjaGxpY2sgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBhdHRlbnVhdGlvbiAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0XFx0dmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggc3BvdExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1xcblxcblxcdFxcdGZsb2F0IGF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBzcG90TGlnaHREaXN0YW5jZVsgaSBdLCBzcG90TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXFx0XFx0bFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblxcdFxcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB2V29ybGRQb3NpdGlvbiApICk7XFxuXFxuXFx0XFx0aWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcXG5cXG5cXHRcXHRcXHRzcG90RWZmZWN0ID0gbWF4KCBwb3coIG1heCggc3BvdEVmZmVjdCwgMC4wICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSwgMC4wICk7XFxuXFxuXFx0XFx0XFx0Ly8gZGlmZnVzZVxcblxcblxcdFxcdFxcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbFZlY3RvciApO1xcblxcblxcdFxcdFxcdCNpZmRlZiBXUkFQX0FST1VORFxcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZWMzIHNwb3REaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzKCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggc3BvdERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcXG5cXG5cXHRcXHRcXHQjZWxzZVxcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG5cXG5cXHRcXHRcXHQjZW5kaWZcXG5cXG5cXHRcXHRcXHR0b3RhbERpZmZ1c2VMaWdodCArPSBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdERpZmZ1c2VXZWlnaHQgKiBhdHRlbnVhdGlvbiAqIHNwb3RFZmZlY3Q7XFxuXFxuXFx0XFx0XFx0Ly8gc3BlY3VsYXJcXG5cXG5cXHRcXHRcXHR2ZWMzIHNwb3RIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuXFx0XFx0XFx0ZmxvYXQgc3BvdERvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBzcG90SGFsZlZlY3RvciApLCAwLjAgKTtcXG5cXHRcXHRcXHRmbG9hdCBzcG90U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHNwb3REb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKSwgMC4wICk7XFxuXFxuXFx0XFx0XFx0ZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCBzaGluaW5lc3MgKyAyLjAgKSAvIDguMDtcXG5cXG5cXHRcXHRcXHR2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBsVmVjdG9yLCBzcG90SGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XFxuXFx0XFx0XFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IHNjaGxpY2sgKiBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdFNwZWN1bGFyV2VpZ2h0ICogc3BvdERpZmZ1c2VXZWlnaHQgKiBhdHRlbnVhdGlvbiAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqIHNwb3RFZmZlY3Q7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cXHRcXHR2ZWMzIGRpclZlY3RvciA9IHRyYW5zZm9ybURpcmVjdGlvbiggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCB2aWV3TWF0cml4ICk7XFxuXFxuXFx0XFx0Ly8gZGlmZnVzZVxcblxcblxcdFxcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICk7XFxuXFxuXFx0XFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXFx0XFx0XFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcblxcdFxcdFxcdGZsb2F0IGRpckRpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcXG5cXG5cXHRcXHRcXHR2ZWMzIGRpckRpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIGRpckRpZmZ1c2VXZWlnaHRGdWxsICksIHZlYzMoIGRpckRpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcXG5cXG5cXHRcXHQjZWxzZVxcblxcblxcdFxcdFxcdGZsb2F0IGRpckRpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyRGlmZnVzZVdlaWdodDtcXG5cXG5cXHRcXHQvLyBzcGVjdWxhclxcblxcblxcdFxcdHZlYzMgZGlySGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggZGlyVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuXFx0XFx0ZmxvYXQgZGlyRG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIGRpckhhbGZWZWN0b3IgKSwgMC4wICk7XFxuXFx0XFx0ZmxvYXQgZGlyU3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIGRpckRvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcXG5cXG5cXHRcXHQvKlxcblxcdFxcdC8vIGZyZXNuZWwgdGVybSBmcm9tIHNraW4gc2hhZGVyXFxuXFx0XFx0Y29uc3QgZmxvYXQgRjAgPSAwLjEyODtcXG5cXG5cXHRcXHRmbG9hdCBiYXNlID0gMS4wIC0gZG90KCB2aWV3UG9zaXRpb24sIGRpckhhbGZWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBleHBvbmVudGlhbCA9IHBvdyggYmFzZSwgNS4wICk7XFxuXFxuXFx0XFx0ZmxvYXQgZnJlc25lbCA9IGV4cG9uZW50aWFsICsgRjAgKiAoIDEuMCAtIGV4cG9uZW50aWFsICk7XFxuXFx0XFx0Ki9cXG5cXG5cXHRcXHQvKlxcblxcdFxcdC8vIGZyZXNuZWwgdGVybSBmcm9tIGZyZXNuZWwgc2hhZGVyXFxuXFx0XFx0Y29uc3QgZmxvYXQgbUZyZXNuZWxCaWFzID0gMC4wODtcXG5cXHRcXHRjb25zdCBmbG9hdCBtRnJlc25lbFNjYWxlID0gMC4zO1xcblxcdFxcdGNvbnN0IGZsb2F0IG1GcmVzbmVsUG93ZXIgPSA1LjA7XFxuXFxuXFx0XFx0ZmxvYXQgZnJlc25lbCA9IG1GcmVzbmVsQmlhcyArIG1GcmVzbmVsU2NhbGUgKiBwb3coIDEuMCArIGRvdCggbm9ybWFsaXplKCAtdmlld1Bvc2l0aW9uICksIG5vcm1hbCApLCBtRnJlc25lbFBvd2VyICk7XFxuXFx0XFx0Ki9cXG5cXG5cXHRcXHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1xcblxcblxcdFxcdC8vIFxcdFxcdGRpclNwZWN1bGFyICs9IHNwZWN1bGFyICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQgKiBzcGVjdWxhck5vcm1hbGl6YXRpb24gKiBmcmVzbmVsO1xcblxcblxcdFxcdHZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGRpclZlY3RvciwgZGlySGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XFxuXFx0XFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IHNjaGxpY2sgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcXG5cXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cXHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdLCB2aWV3TWF0cml4ICk7XFxuXFxuXFx0XFx0Ly8gZGlmZnVzZVxcblxcblxcdFxcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cXHRcXHR2ZWMzIGhlbWlDb2xvciA9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXG5cXHRcXHR0b3RhbERpZmZ1c2VMaWdodCArPSBoZW1pQ29sb3I7XFxuXFxuXFx0XFx0Ly8gc3BlY3VsYXIgKHNreSBsaWdodClcXG5cXG5cXHRcXHR2ZWMzIGhlbWlIYWxmVmVjdG9yU2t5ID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuXFx0XFx0ZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZTa3kgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JTa3kgKSArIDAuNTtcXG5cXHRcXHRmbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIG1heCggaGVtaURvdE5vcm1hbEhhbGZTa3ksIDAuMCApLCBzaGluaW5lc3MgKSwgMC4wICk7XFxuXFxuXFx0XFx0Ly8gc3BlY3VsYXIgKGdyb3VuZCBsaWdodClcXG5cXG5cXHRcXHR2ZWMzIGxWZWN0b3JHcm91bmQgPSAtbFZlY3RvcjtcXG5cXG5cXHRcXHR2ZWMzIGhlbWlIYWxmVmVjdG9yR3JvdW5kID0gbm9ybWFsaXplKCBsVmVjdG9yR3JvdW5kICsgdmlld1Bvc2l0aW9uICk7XFxuXFx0XFx0ZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZHcm91bmQgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSArIDAuNTtcXG5cXHRcXHRmbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIG1heCggaGVtaURvdE5vcm1hbEhhbGZHcm91bmQsIDAuMCApLCBzaGluaW5lc3MgKSwgMC4wICk7XFxuXFxuXFx0XFx0ZmxvYXQgZG90UHJvZHVjdEdyb3VuZCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yR3JvdW5kICk7XFxuXFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCBzaGluaW5lc3MgKyAyLjAgKSAvIDguMDtcXG5cXG5cXHRcXHR2ZWMzIHNjaGxpY2tTa3kgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBsVmVjdG9yLCBoZW1pSGFsZlZlY3RvclNreSApLCAwLjAgKSwgNS4wICk7XFxuXFx0XFx0dmVjMyBzY2hsaWNrR3JvdW5kID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3Rvckdyb3VuZCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSwgMC4wICksIDUuMCApO1xcblxcdFxcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBoZW1pQ29sb3IgKiBzcGVjdWxhck5vcm1hbGl6YXRpb24gKiAoIHNjaGxpY2tTa3kgKiBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgKiBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICsgc2NobGlja0dyb3VuZCAqIGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCAqIG1heCggZG90UHJvZHVjdEdyb3VuZCwgMC4wICkgKTtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIE1FVEFMXFxuXFxuXFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB0b3RhbERpZmZ1c2VMaWdodCArIGFtYmllbnRMaWdodENvbG9yICkgKiBzcGVjdWxhciArIHRvdGFsU3BlY3VsYXJMaWdodCArIGVtaXNzaXZlO1xcblxcbiNlbHNlXFxuXFxuXFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB0b3RhbERpZmZ1c2VMaWdodCArIGFtYmllbnRMaWdodENvbG9yICkgKyB0b3RhbFNwZWN1bGFyTGlnaHQgKyBlbWlzc2l2ZTtcXG5cXG4jZW5kaWZcXG5cIjtcblRIUkVFLlNoYWRlckNodW5rLmZvZ19wYXJzX2ZyYWdtZW50PVwiI2lmZGVmIFVTRV9GT0dcXG5cXG5cXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxuXFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dOZWFyO1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblxcdCNlbmRpZlxcblxcbiNlbmRpZlwiO1RIUkVFLlNoYWRlckNodW5rLm1vcnBobm9ybWFsX3ZlcnRleD1cIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXFx0dmVjMyBtb3JwaGVkTm9ybWFsID0gdmVjMyggMC4wICk7XFxuXFxuXFx0bW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMCAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXFx0bW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXFx0bW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMiAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXFx0bW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMyAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXFx0bW9ycGhlZE5vcm1hbCArPSBub3JtYWw7XFxuXFxuI2VuZGlmXCI7XG5USFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfcGFyc19mcmFnbWVudD1cIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFxuXFx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxuXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG5cXHQjZWxzZVxcblxcblxcdFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9mcmFnbWVudD1cIiNpZiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRikgJiYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUZfRVhUKVxcblxcblxcdGdsX0ZyYWdEZXB0aEVYVCA9IGxvZzIodkZyYWdEZXB0aCkgKiBsb2dEZXB0aEJ1ZkZDICogMC41O1xcblxcbiNlbmRpZlwiO1xuVEhSRUUuU2hhZGVyQ2h1bmsubm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ9XCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG5cXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFxuXFx0Ly8gUGVyLVBpeGVsIFRhbmdlbnQgU3BhY2UgTm9ybWFsIE1hcHBpbmdcXG5cXHQvLyBodHRwOi8vaGFja3NvZmxpZmUuYmxvZ3Nwb3QuY2gvMjAwOS8xMS9wZXItcGl4ZWwtdGFuZ2VudC1zcGFjZS1ub3JtYWwtbWFwcGluZy5odG1sXFxuXFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcXG5cXG5cXHRcXHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cXHRcXHR2ZWMzIHExID0gZEZkeSggZXllX3Bvcy54eXogKTtcXG5cXHRcXHR2ZWMyIHN0MCA9IGRGZHgoIHZVdi5zdCApO1xcblxcdFxcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFxuXFx0XFx0dmVjMyBTID0gbm9ybWFsaXplKCBxMCAqIHN0MS50IC0gcTEgKiBzdDAudCApO1xcblxcdFxcdHZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XFxuXFx0XFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXG5cXHRcXHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdFxcdG1hcE4ueHkgPSBub3JtYWxTY2FsZSAqIG1hcE4ueHk7XFxuXFx0XFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggdHNuICogbWFwTiApO1xcblxcblxcdH1cXG5cXG4jZW5kaWZcXG5cIjtcblRIUkVFLlNoYWRlckNodW5rLmxpZ2h0c19waG9uZ19wYXJzX3ZlcnRleD1cIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblwiO1RIUkVFLlNoYWRlckNodW5rLmxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ9XCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuXFxuI2VuZGlmXCI7VEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3ZlcnRleD1cIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG5cXHRcXHR2U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXCI7XG5USFJFRS5TaGFkZXJDaHVuay5saWdodHNfcGhvbmdfdmVydGV4PVwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcblxcbiNlbmRpZlwiO1RIUkVFLlNoYWRlckNodW5rLm1hcF9mcmFnbWVudD1cIiNpZmRlZiBVU0VfTUFQXFxuXFxuXFx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcblxcdHRleGVsQ29sb3IueHl6ID0gaW5wdXRUb0xpbmVhciggdGV4ZWxDb2xvci54eXogKTtcXG5cXG5cXHRkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcXG5cXG4jZW5kaWZcIjtUSFJFRS5TaGFkZXJDaHVuay5saWdodG1hcF92ZXJ0ZXg9XCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXFx0dlV2MiA9IHV2MjtcXG5cXG4jZW5kaWZcIjtUSFJFRS5TaGFkZXJDaHVuay5tYXBfcGFydGljbGVfZnJhZ21lbnQ9XCIjaWZkZWYgVVNFX01BUFxcblxcblxcdGRpZmZ1c2VDb2xvciAqPSB0ZXh0dXJlMkQoIG1hcCwgdmVjMiggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnkgKSAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eSApO1xcblxcbiNlbmRpZlxcblwiO1xuVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfcGFyc19mcmFnbWVudD1cIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcblxcbiNlbmRpZlxcblwiO1RIUkVFLlNoYWRlckNodW5rLmNvbG9yX3ZlcnRleD1cIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cXHR2Q29sb3IueHl6ID0gaW5wdXRUb0xpbmVhciggY29sb3IueHl6ICk7XFxuXFxuI2VuZGlmXCI7VEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfdmVydGV4PVwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblxcdCNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuXFx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcblxcdCNlbHNlXFxuXFxuXFx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cXHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcXG5cXG4jZW5kaWZcXG5cIjtcblRIUkVFLlNoYWRlckNodW5rLmVudm1hcF9wYXJzX3ZlcnRleD1cIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcblxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG4jZW5kaWZcXG5cIjtUSFJFRS5TaGFkZXJDaHVuay5saW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQ9XCJcXG5cXHRvdXRnb2luZ0xpZ2h0ID0gbGluZWFyVG9PdXRwdXQoIG91dGdvaW5nTGlnaHQgKTtcXG5cIjtUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX3ZlcnRleD1cIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcblxcbiNlbmRpZlwiO1RIUkVFLlNoYWRlckNodW5rLmxpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4PVwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXFx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblxcdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXFx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGVjYXlbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBXUkFQX0FST1VORFxcblxcblxcdHVuaWZvcm0gdmVjMyB3cmFwUkdCO1xcblxcbiNlbmRpZlxcblwiO1xuVEhSRUUuU2hhZGVyQ2h1bmsubWFwX3BhcnNfdmVydGV4PVwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKVxcblxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cXG4jZW5kaWZcXG5cIjtUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfZnJhZ21lbnQ9XCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXFx0XFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcblxcdFxcdC8vIFRyYW5zZm9ybWluZyBOb3JtYWwgVmVjdG9ycyB3aXRoIHRoZSBJbnZlcnNlIFRyYW5zZm9ybWF0aW9uXFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFxuXFx0XFx0I2Vsc2VcXG5cXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0dmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxuXFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXFx0XFx0dmVjMiBzYW1wbGVVVjtcXG5cXHRcXHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cXHRcXHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViApO1xcblxcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXFx0XFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoKHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSkueHl6ICsgdmVjMygwLjAsMC4wLDEuMCkpO1xcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXG5cXHQjZW5kaWZcXG5cXG5cXHRlbnZDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCBlbnZDb2xvci54eXogKTtcXG5cXG5cXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcblxcdFxcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblRIUkVFLlNoYWRlckNodW5rLnNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ9XCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XFxuXFxuI2VuZGlmXCI7VEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfdmVydGV4PVwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblxcdGdsX1Bvc2l0aW9uLnogPSBsb2cyKG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApKSAqIGxvZ0RlcHRoQnVmRkM7XFxuXFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cXHRcXHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXG4jZWxzZVxcblxcblxcdFxcdGdsX1Bvc2l0aW9uLnogPSAoZ2xfUG9zaXRpb24ueiAtIDEuMCkgKiBnbF9Qb3NpdGlvbi53O1xcblxcblxcdCNlbmRpZlxcblxcbiNlbmRpZlwiO1RIUkVFLlNoYWRlckNodW5rLm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PVwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXG5cXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcblxcblxcdCNlbHNlXFxuXFxuXFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblRIUkVFLlNoYWRlckNodW5rLnNwZWN1bGFybWFwX2ZyYWdtZW50PVwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG5cXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuXFx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG5cXG4jZWxzZVxcblxcblxcdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxuXFxuI2VuZGlmXCI7VEhSRUUuU2hhZGVyQ2h1bmsuZm9nX2ZyYWdtZW50PVwiI2lmZGVmIFVTRV9GT0dcXG5cXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblxcdFxcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gZXhwMiggLSBzcXVhcmUoIGZvZ0RlbnNpdHkgKSAqIHNxdWFyZSggZGVwdGggKSAqIExPRzIgKTtcXG5cXHRcXHRmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGZvZ0ZhY3RvciApO1xcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApO1xcblxcblxcdCNlbmRpZlxcblxcdFxcblxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXG5cXG4jZW5kaWZcIjtcblRIUkVFLlNoYWRlckNodW5rLmJ1bXBtYXBfcGFyc19mcmFnbWVudD1cIiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFxuXFx0Ly8gRGVyaXZhdGl2ZSBtYXBzIC0gYnVtcCBtYXBwaW5nIHVucGFyYW1ldHJpemVkIHN1cmZhY2VzIGJ5IE1vcnRlbiBNaWtrZWxzZW5cXG5cXHQvLyBodHRwOi8vbW1pa2tlbHNlbjNkLmJsb2dzcG90LnNrLzIwMTEvMDcvZGVyaXZhdGl2ZS1tYXBzLmh0bWxcXG5cXG5cXHQvLyBFdmFsdWF0ZSB0aGUgZGVyaXZhdGl2ZSBvZiB0aGUgaGVpZ2h0IHcuci50LiBzY3JlZW4tc3BhY2UgdXNpbmcgZm9yd2FyZCBkaWZmZXJlbmNpbmcgKGxpc3RpbmcgMilcXG5cXG5cXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXG5cXHRcXHR2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxuXFx0XFx0dmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcblxcblxcdFxcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cXHRcXHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcXG5cXHRcXHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5cXG5cXHRcXHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSApIHtcXG5cXG5cXHRcXHR2ZWMzIHZTaWdtYVggPSBkRmR4KCBzdXJmX3BvcyApO1xcblxcdFxcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxuXFx0XFx0dmVjMyB2TiA9IHN1cmZfbm9ybTtcXHRcXHQvLyBub3JtYWxpemVkXFxuXFxuXFx0XFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblxcdFxcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXG5cXHRcXHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1xcblxcblxcdFxcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXCI7XG5USFJFRS5TaGFkZXJDaHVuay5kZWZhdWx0bm9ybWFsX3ZlcnRleD1cIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cXHR2ZWMzIG9iamVjdE5vcm1hbCA9IHNraW5uZWROb3JtYWwueHl6O1xcblxcbiNlbGlmIGRlZmluZWQoIFVTRV9NT1JQSE5PUk1BTFMgKVxcblxcblxcdHZlYzMgb2JqZWN0Tm9ybWFsID0gbW9ycGhlZE5vcm1hbDtcXG5cXG4jZWxzZVxcblxcblxcdHZlYzMgb2JqZWN0Tm9ybWFsID0gbm9ybWFsO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBGTElQX1NJREVEXFxuXFxuXFx0b2JqZWN0Tm9ybWFsID0gLW9iamVjdE5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1xcblwiO1RIUkVFLlNoYWRlckNodW5rLmxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PVwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXFx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblxcdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG5cXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXFx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGVjYXlbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBXUkFQX0FST1VORFxcblxcblxcdHVuaWZvcm0gdmVjMyB3cmFwUkdCO1xcblxcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcblxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cIjtcblRIUkVFLlNoYWRlckNodW5rLnNraW5iYXNlX3ZlcnRleD1cIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cXHRtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXG5cXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG5cXHRtYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTtcXG5cXHRtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcXG5cXG4jZW5kaWZcIjtUSFJFRS5TaGFkZXJDaHVuay5tYXBfdmVydGV4PVwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKVxcblxcblxcdHZVdiA9IHV2ICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5O1xcblxcbiNlbmRpZlwiO1xuVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfZnJhZ21lbnQ9XCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXFx0b3V0Z29pbmdMaWdodCAqPSBkaWZmdXNlQ29sb3IueHl6ICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5ejtcXG5cXG4jZW5kaWZcIjtUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfcGFyc192ZXJ0ZXg9XCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblxcdHZhcnlpbmcgdmVjNCB2U2hhZG93Q29vcmRbIE1BWF9TSEFET1dTIF07XFxuXFx0dW5pZm9ybSBtYXQ0IHNoYWRvd01hdHJpeFsgTUFYX1NIQURPV1MgXTtcXG5cXG4jZW5kaWZcIjtUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9mcmFnbWVudD1cIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cXHRkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtUSFJFRS5TaGFkZXJDaHVuay5tb3JwaHRhcmdldF92ZXJ0ZXg9XCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblxcdHZlYzMgbW9ycGhlZCA9IHZlYzMoIDAuMCApO1xcblxcdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXFx0bW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cXHRtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblxcdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXFx0bW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cXHRtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblxcdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDYgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA2IF07XFxuXFx0bW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDcgXTtcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHRtb3JwaGVkICs9IHBvc2l0aW9uO1xcblxcbiNlbmRpZlwiO1xuVEhSRUUuU2hhZGVyQ2h1bmsuZW52bWFwX3ZlcnRleD1cIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcblxcdHZlYzMgd29ybGROb3JtYWwgPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIG9iamVjdE5vcm1hbCwgbW9kZWxNYXRyaXggKTtcXG5cXG5cXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFxuXFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG5cXHRcXHR2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcblxcdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX2ZyYWdtZW50PVwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cXHQjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuXFx0XFx0dmVjMyBmcnVzdHVtQ29sb3JzWzNdO1xcblxcdFxcdGZydXN0dW1Db2xvcnNbMF0gPSB2ZWMzKCAxLjAsIDAuNSwgMC4wICk7XFxuXFx0XFx0ZnJ1c3R1bUNvbG9yc1sxXSA9IHZlYzMoIDAuMCwgMS4wLCAwLjggKTtcXG5cXHRcXHRmcnVzdHVtQ29sb3JzWzJdID0gdmVjMyggMC4wLCAwLjUsIDEuMCApO1xcblxcblxcdCNlbmRpZlxcblxcblxcdCNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVxcblxcblxcdFxcdGludCBpbkZydXN0dW1Db3VudCA9IDA7XFxuXFxuXFx0I2VuZGlmXFxuXFxuXFx0ZmxvYXQgZkRlcHRoO1xcblxcdHZlYzMgc2hhZG93Q29sb3IgPSB2ZWMzKCAxLjAgKTtcXG5cXG5cXHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1xcblxcblxcdFxcdHZlYzMgc2hhZG93Q29vcmQgPSB2U2hhZG93Q29vcmRbIGkgXS54eXogLyB2U2hhZG93Q29vcmRbIGkgXS53O1xcblxcblxcdFxcdFxcdFxcdC8vIGlmICggc29tZXRoaW5nICYmIHNvbWV0aGluZyApIGJyZWFrcyBBVEkgT3BlbkdMIHNoYWRlciBjb21waWxlclxcblxcdFxcdFxcdFxcdC8vIGlmICggYWxsKCBzb21ldGhpbmcsIHNvbWV0aGluZyApICkgdXNpbmcgdGhpcyBpbnN0ZWFkXFxuXFxuXFx0XFx0YnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcblxcdFxcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBkb24ndCBzaGFkb3cgcGl4ZWxzIG91dHNpZGUgb2YgbGlnaHQgZnJ1c3R1bVxcblxcdFxcdFxcdFxcdC8vIHVzZSBqdXN0IGZpcnN0IGZydXN0dW0gKGZvciBjYXNjYWRlcylcXG5cXHRcXHRcXHRcXHQvLyBkb24ndCBzaGFkb3cgcGl4ZWxzIGJlaGluZCBmYXIgcGxhbmUgb2YgbGlnaHQgZnJ1c3R1bVxcblxcblxcdFxcdCNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVxcblxcblxcdFxcdFxcdGluRnJ1c3R1bUNvdW50ICs9IGludCggaW5GcnVzdHVtICk7XFxuXFx0XFx0XFx0YnZlYzMgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMyggaW5GcnVzdHVtLCBpbkZydXN0dW1Db3VudCA9PSAxLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcblxcdFxcdCNlbHNlXFxuXFxuXFx0XFx0XFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuXFxuXFx0XFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXG5cXG5cXHRcXHRcXHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXNbIGkgXTtcXG5cXG5cXHRcXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vICg5IHBpeGVsIGtlcm5lbClcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdQQ0YvXFxuXFxuXFx0XFx0XFx0XFx0ZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcblxcdFxcdC8qXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbmVzdGVkIGxvb3BzIGJyZWFrcyBzaGFkZXIgY29tcGlsZXIgLyB2YWxpZGF0b3Igb24gc29tZSBBVEkgY2FyZHMgd2hlbiB1c2luZyBPcGVuR0xcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBtdXN0IGVucm9sbCBsb29wIG1hbnVhbGx5XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggZmxvYXQgeSA9IC0xLjI1OyB5IDw9IDEuMjU7IHkgKz0gMS4yNSApXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggZmxvYXQgeCA9IC0xLjI1OyB4IDw9IDEuMjU7IHggKz0gMS4yNSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZG9lc24ndCBzZWVtIHRvIHByb2R1Y2UgYW55IG5vdGljZWFibGUgdmlzdWFsIGRpZmZlcmVuY2UgY29tcGFyZWQgdG8gc2ltcGxlIHRleHR1cmUyRCBsb29rdXBcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvL3ZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEUHJvaiggc2hhZG93TWFwWyBpIF0sIHZlYzQoIHZTaGFkb3dDb29yZFsgaSBdLncgKiAoIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICksIDAuMDUsIHZTaGFkb3dDb29yZFsgaSBdLncgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvdyArPSAxLjA7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHNoYWRvdyAvPSA5LjA7XFxuXFxuXFx0XFx0Ki9cXG5cXG5cXHRcXHRcXHRcXHRjb25zdCBmbG9hdCBzaGFkb3dEZWx0YSA9IDEuMCAvIDkuMDtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG5cXHRcXHRcXHRcXHRmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBkeDAgPSAtMS4yNSAqIHhQaXhlbE9mZnNldDtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkeTAgPSAtMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkeDEgPSAxLjI1ICogeFBpeGVsT2Zmc2V0O1xcblxcdFxcdFxcdFxcdGZsb2F0IGR5MSA9IDEuMjUgKiB5UGl4ZWxPZmZzZXQ7XFxuXFxuXFx0XFx0XFx0XFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblxcdFxcdFxcdFxcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1xcblxcdFxcdFxcdFxcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cXHRcXHRcXHRcXHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXFx0XFx0XFx0XFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblxcdFxcdFxcdFxcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblxcdFxcdFxcdFxcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcblxcdFxcdFxcdFxcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cXHRcXHRcXHRcXHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXFx0XFx0XFx0XFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblxcdFxcdFxcdFxcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1xcblxcdFxcdFxcdFxcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cXHRcXHRcXHRcXHRzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICogc2hhZG93ICkgKTtcXG5cXG5cXHRcXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyAoOSBwaXhlbCBrZXJuZWwpXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nUENGL1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNoYWRvdyA9IDAuMDtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG5cXHRcXHRcXHRcXHRmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBkeDAgPSAtMS4wICogeFBpeGVsT2Zmc2V0O1xcblxcdFxcdFxcdFxcdGZsb2F0IGR5MCA9IC0xLjAgKiB5UGl4ZWxPZmZzZXQ7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgZHgxID0gMS4wICogeFBpeGVsT2Zmc2V0O1xcblxcdFxcdFxcdFxcdGZsb2F0IGR5MSA9IDEuMCAqIHlQaXhlbE9mZnNldDtcXG5cXG5cXHRcXHRcXHRcXHRtYXQzIHNoYWRvd0tlcm5lbDtcXG5cXHRcXHRcXHRcXHRtYXQzIGRlcHRoS2VybmVsO1xcblxcblxcdFxcdFxcdFxcdGRlcHRoS2VybmVsWzBdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXFx0XFx0XFx0XFx0ZGVwdGhLZXJuZWxbMF1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG5cXHRcXHRcXHRcXHRkZXB0aEtlcm5lbFswXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcblxcdFxcdFxcdFxcdGRlcHRoS2VybmVsWzFdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuXFx0XFx0XFx0XFx0ZGVwdGhLZXJuZWxbMV1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblxcdFxcdFxcdFxcdGRlcHRoS2VybmVsWzFdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuXFx0XFx0XFx0XFx0ZGVwdGhLZXJuZWxbMl1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG5cXHRcXHRcXHRcXHRkZXB0aEtlcm5lbFsyXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcblxcdFxcdFxcdFxcdGRlcHRoS2VybmVsWzJdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBzaGFkb3daID0gdmVjMyggc2hhZG93Q29vcmQueiApO1xcblxcdFxcdFxcdFxcdHNoYWRvd0tlcm5lbFswXSA9IHZlYzMobGVzc1RoYW4oZGVwdGhLZXJuZWxbMF0sIHNoYWRvd1ogKSk7XFxuXFx0XFx0XFx0XFx0c2hhZG93S2VybmVsWzBdICo9IHZlYzMoMC4yNSk7XFxuXFxuXFx0XFx0XFx0XFx0c2hhZG93S2VybmVsWzFdID0gdmVjMyhsZXNzVGhhbihkZXB0aEtlcm5lbFsxXSwgc2hhZG93WiApKTtcXG5cXHRcXHRcXHRcXHRzaGFkb3dLZXJuZWxbMV0gKj0gdmVjMygwLjI1KTtcXG5cXG5cXHRcXHRcXHRcXHRzaGFkb3dLZXJuZWxbMl0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzJdLCBzaGFkb3daICkpO1xcblxcdFxcdFxcdFxcdHNoYWRvd0tlcm5lbFsyXSAqPSB2ZWMzKDAuMjUpO1xcblxcblxcdFxcdFxcdFxcdHZlYzIgZnJhY3Rpb25hbENvb3JkID0gMS4wIC0gZnJhY3QoIHNoYWRvd0Nvb3JkLnh5ICogc2hhZG93TWFwU2l6ZVtpXS54eSApO1xcblxcblxcdFxcdFxcdFxcdHNoYWRvd0tlcm5lbFswXSA9IG1peCggc2hhZG93S2VybmVsWzFdLCBzaGFkb3dLZXJuZWxbMF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXFx0XFx0XFx0XFx0c2hhZG93S2VybmVsWzFdID0gbWl4KCBzaGFkb3dLZXJuZWxbMl0sIHNoYWRvd0tlcm5lbFsxXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZWM0IHNoYWRvd1ZhbHVlcztcXG5cXHRcXHRcXHRcXHRzaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWzBdWzFdLCBzaGFkb3dLZXJuZWxbMF1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXFx0XFx0XFx0XFx0c2hhZG93VmFsdWVzLnkgPSBtaXgoIHNoYWRvd0tlcm5lbFswXVsyXSwgc2hhZG93S2VybmVsWzBdWzFdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblxcdFxcdFxcdFxcdHNoYWRvd1ZhbHVlcy56ID0gbWl4KCBzaGFkb3dLZXJuZWxbMV1bMV0sIHNoYWRvd0tlcm5lbFsxXVswXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cXHRcXHRcXHRcXHRzaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWzFdWzJdLCBzaGFkb3dLZXJuZWxbMV1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXFxuXFx0XFx0XFx0XFx0c2hhZG93ID0gZG90KCBzaGFkb3dWYWx1ZXMsIHZlYzQoIDEuMCApICk7XFxuXFxuXFx0XFx0XFx0XFx0c2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoICggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSAqIHNoYWRvdyApICk7XFxuXFxuXFx0XFx0XFx0I2Vsc2VcXG5cXG5cXHRcXHRcXHRcXHR2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICk7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuXFxuXFx0XFx0Ly8gc3BvdCB3aXRoIG11bHRpcGxlIHNoYWRvd3MgaXMgZGFya2VyXFxuXFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKTtcXG5cXG5cXHRcXHQvLyBzcG90IHdpdGggbXVsdGlwbGUgc2hhZG93cyBoYXMgdGhlIHNhbWUgY29sb3IgYXMgc2luZ2xlIHNoYWRvdyBzcG90XFxuXFxuXFx0XFx0Ly8gXFx0XFx0XFx0XFx0XFx0c2hhZG93Q29sb3IgPSBtaW4oIHNoYWRvd0NvbG9yLCB2ZWMzKCBzaGFkb3dEYXJrbmVzc1sgaSBdICkgKTtcXG5cXG5cXHRcXHRcXHQjZW5kaWZcXG5cXG5cXHRcXHR9XFxuXFxuXFxuXFx0XFx0I2lmZGVmIFNIQURPV01BUF9ERUJVR1xcblxcblxcdFxcdFxcdCNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVxcblxcblxcdFxcdFxcdFxcdGlmICggaW5GcnVzdHVtICYmIGluRnJ1c3R1bUNvdW50ID09IDEgKSBvdXRnb2luZ0xpZ2h0ICo9IGZydXN0dW1Db2xvcnNbIGkgXTtcXG5cXG5cXHRcXHRcXHQjZWxzZVxcblxcblxcdFxcdFxcdFxcdGlmICggaW5GcnVzdHVtICkgb3V0Z29pbmdMaWdodCAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XFxuXFxuXFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0fVxcblxcblxcdC8vIE5PVEU6IEkgYW0gdW5zdXJlIGlmIHRoaXMgaXMgY29ycmVjdCBpbiBsaW5lYXIgc3BhY2UuICAtYmhvdXN0b24sIERlYyAyOSwgMjAxNFxcblxcdHNoYWRvd0NvbG9yID0gaW5wdXRUb0xpbmVhciggc2hhZG93Q29sb3IgKTtcXG5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gb3V0Z29pbmdMaWdodCAqIHNoYWRvd0NvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xuVEhSRUUuU2hhZGVyQ2h1bmsud29ybGRwb3NfdmVydGV4PVwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuXFxuXFx0I2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblxcdFxcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogc2tpbm5lZDtcXG5cXG5cXHQjZWxpZiBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTIClcXG5cXG5cXHRcXHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuXFx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7VEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ9XCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd01hcFsgTUFYX1NIQURPV1MgXTtcXG5cXHR1bmlmb3JtIHZlYzIgc2hhZG93TWFwU2l6ZVsgTUFYX1NIQURPV1MgXTtcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBNQVhfU0hBRE9XUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc2hhZG93Qmlhc1sgTUFYX1NIQURPV1MgXTtcXG5cXG5cXHR2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcblxcblxcdGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXFxuXFx0XFx0Y29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1xcblxcdFxcdGZsb2F0IGRlcHRoID0gZG90KCByZ2JhX2RlcHRoLCBiaXRfc2hpZnQgKTtcXG5cXHRcXHRyZXR1cm4gZGVwdGg7XFxuXFxuXFx0fVxcblxcbiNlbmRpZlwiO1xuVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfcGFyc192ZXJ0ZXg9XCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXFx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXg7XFxuXFx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlO1xcblxcblxcdCNpZmRlZiBCT05FX1RFWFRVUkVcXG5cXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG5cXHRcXHR1bmlmb3JtIGludCBib25lVGV4dHVyZVdpZHRoO1xcblxcdFxcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlSGVpZ2h0O1xcblxcblxcdFxcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG5cXHRcXHRcXHRmbG9hdCBqID0gaSAqIDQuMDtcXG5cXHRcXHRcXHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXFx0XFx0XFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblxcblxcdFxcdFxcdGZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKTtcXG5cXHRcXHRcXHRmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZUhlaWdodCApO1xcblxcblxcdFxcdFxcdHkgPSBkeSAqICggeSArIDAuNSApO1xcblxcblxcdFxcdFxcdHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5cXG5cXHRcXHRcXHRtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblxcblxcdFxcdFxcdHJldHVybiBib25lO1xcblxcblxcdFxcdH1cXG5cXG5cXHQjZWxzZVxcblxcblxcdFxcdHVuaWZvcm0gbWF0NCBib25lR2xvYmFsTWF0cmljZXNbIE1BWF9CT05FUyBdO1xcblxcblxcdFxcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG5cXHRcXHRcXHRtYXQ0IGJvbmUgPSBib25lR2xvYmFsTWF0cmljZXNbIGludChpKSBdO1xcblxcdFxcdFxcdHJldHVybiBib25lO1xcblxcblxcdFxcdH1cXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ9XCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXFx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXFx0XFx0I2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVxcblxcdFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtUSFJFRS5TaGFkZXJDaHVuay5hbHBoYW1hcF9mcmFnbWVudD1cIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcblxcbiNlbmRpZlxcblwiO1RIUkVFLlNoYWRlckNodW5rLmFscGhhbWFwX3BhcnNfZnJhZ21lbnQ9XCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuXFxuI2VuZGlmXFxuXCI7XG5USFJFRS5Vbmlmb3Jtc1V0aWxzPXttZXJnZTpmdW5jdGlvbihhKXtmb3IodmFyIGI9e30sYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD10aGlzLmNsb25lKGFbY10pLGU7Zm9yKGUgaW4gZCliW2VdPWRbZV19cmV0dXJuIGJ9LGNsb25lOmZ1bmN0aW9uKGEpe3ZhciBiPXt9LGM7Zm9yKGMgaW4gYSl7YltjXT17fTtmb3IodmFyIGQgaW4gYVtjXSl7dmFyIGU9YVtjXVtkXTtiW2NdW2RdPWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvcnx8ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjJ8fGUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzfHxlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNHx8ZSBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDR8fGUgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlP2UuY2xvbmUoKTplIGluc3RhbmNlb2YgQXJyYXk/ZS5zbGljZSgpOmV9fXJldHVybiBifX07XG5USFJFRS5Vbmlmb3Jtc0xpYj17Y29tbW9uOntkaWZmdXNlOnt0eXBlOlwiY1wiLHZhbHVlOm5ldyBUSFJFRS5Db2xvcigxNTY1ODczNCl9LG9wYWNpdHk6e3R5cGU6XCJmXCIsdmFsdWU6MX0sbWFwOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LG9mZnNldFJlcGVhdDp7dHlwZTpcInY0XCIsdmFsdWU6bmV3IFRIUkVFLlZlY3RvcjQoMCwwLDEsMSl9LGxpZ2h0TWFwOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LHNwZWN1bGFyTWFwOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LGFscGhhTWFwOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LGVudk1hcDp7dHlwZTpcInRcIix2YWx1ZTpudWxsfSxmbGlwRW52TWFwOnt0eXBlOlwiZlwiLHZhbHVlOi0xfSxyZWZsZWN0aXZpdHk6e3R5cGU6XCJmXCIsdmFsdWU6MX0scmVmcmFjdGlvblJhdGlvOnt0eXBlOlwiZlwiLHZhbHVlOi45OH0sbW9ycGhUYXJnZXRJbmZsdWVuY2VzOnt0eXBlOlwiZlwiLHZhbHVlOjB9fSxidW1wOntidW1wTWFwOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LGJ1bXBTY2FsZTp7dHlwZTpcImZcIixcbiAgICB2YWx1ZToxfX0sbm9ybWFsbWFwOntub3JtYWxNYXA6e3R5cGU6XCJ0XCIsdmFsdWU6bnVsbH0sbm9ybWFsU2NhbGU6e3R5cGU6XCJ2MlwiLHZhbHVlOm5ldyBUSFJFRS5WZWN0b3IyKDEsMSl9fSxmb2c6e2ZvZ0RlbnNpdHk6e3R5cGU6XCJmXCIsdmFsdWU6Mi41RS00fSxmb2dOZWFyOnt0eXBlOlwiZlwiLHZhbHVlOjF9LGZvZ0Zhcjp7dHlwZTpcImZcIix2YWx1ZToyRTN9LGZvZ0NvbG9yOnt0eXBlOlwiY1wiLHZhbHVlOm5ldyBUSFJFRS5Db2xvcigxNjc3NzIxNSl9fSxsaWdodHM6e2FtYmllbnRMaWdodENvbG9yOnt0eXBlOlwiZnZcIix2YWx1ZTpbXX0sZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbjp7dHlwZTpcImZ2XCIsdmFsdWU6W119LGRpcmVjdGlvbmFsTGlnaHRDb2xvcjp7dHlwZTpcImZ2XCIsdmFsdWU6W119LGhlbWlzcGhlcmVMaWdodERpcmVjdGlvbjp7dHlwZTpcImZ2XCIsdmFsdWU6W119LGhlbWlzcGhlcmVMaWdodFNreUNvbG9yOnt0eXBlOlwiZnZcIix2YWx1ZTpbXX0saGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3I6e3R5cGU6XCJmdlwiLFxuICAgIHZhbHVlOltdfSxwb2ludExpZ2h0Q29sb3I6e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxwb2ludExpZ2h0UG9zaXRpb246e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxwb2ludExpZ2h0RGlzdGFuY2U6e3R5cGU6XCJmdjFcIix2YWx1ZTpbXX0scG9pbnRMaWdodERlY2F5Ont0eXBlOlwiZnYxXCIsdmFsdWU6W119LHNwb3RMaWdodENvbG9yOnt0eXBlOlwiZnZcIix2YWx1ZTpbXX0sc3BvdExpZ2h0UG9zaXRpb246e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxzcG90TGlnaHREaXJlY3Rpb246e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxzcG90TGlnaHREaXN0YW5jZTp7dHlwZTpcImZ2MVwiLHZhbHVlOltdfSxzcG90TGlnaHRBbmdsZUNvczp7dHlwZTpcImZ2MVwiLHZhbHVlOltdfSxzcG90TGlnaHRFeHBvbmVudDp7dHlwZTpcImZ2MVwiLHZhbHVlOltdfSxzcG90TGlnaHREZWNheTp7dHlwZTpcImZ2MVwiLHZhbHVlOltdfX0scGFydGljbGU6e3BzQ29sb3I6e3R5cGU6XCJjXCIsdmFsdWU6bmV3IFRIUkVFLkNvbG9yKDE1NjU4NzM0KX0sb3BhY2l0eTp7dHlwZTpcImZcIixcbiAgICB2YWx1ZToxfSxzaXplOnt0eXBlOlwiZlwiLHZhbHVlOjF9LHNjYWxlOnt0eXBlOlwiZlwiLHZhbHVlOjF9LG1hcDp7dHlwZTpcInRcIix2YWx1ZTpudWxsfSxvZmZzZXRSZXBlYXQ6e3R5cGU6XCJ2NFwiLHZhbHVlOm5ldyBUSFJFRS5WZWN0b3I0KDAsMCwxLDEpfSxmb2dEZW5zaXR5Ont0eXBlOlwiZlwiLHZhbHVlOjIuNUUtNH0sZm9nTmVhcjp7dHlwZTpcImZcIix2YWx1ZToxfSxmb2dGYXI6e3R5cGU6XCJmXCIsdmFsdWU6MkUzfSxmb2dDb2xvcjp7dHlwZTpcImNcIix2YWx1ZTpuZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpfX0sc2hhZG93bWFwOntzaGFkb3dNYXA6e3R5cGU6XCJ0dlwiLHZhbHVlOltdfSxzaGFkb3dNYXBTaXplOnt0eXBlOlwidjJ2XCIsdmFsdWU6W119LHNoYWRvd0JpYXM6e3R5cGU6XCJmdjFcIix2YWx1ZTpbXX0sc2hhZG93RGFya25lc3M6e3R5cGU6XCJmdjFcIix2YWx1ZTpbXX0sc2hhZG93TWF0cml4Ont0eXBlOlwibTR2XCIsdmFsdWU6W119fX07XG5USFJFRS5TaGFkZXJMaWI9e2Jhc2ljOnt1bmlmb3JtczpUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtUSFJFRS5Vbmlmb3Jtc0xpYi5jb21tb24sVEhSRUUuVW5pZm9ybXNMaWIuZm9nLFRIUkVFLlVuaWZvcm1zTGliLnNoYWRvd21hcF0pLHZlcnRleFNoYWRlcjpbVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLFRIUkVFLlNoYWRlckNodW5rLm1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5saWdodG1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4LFwidm9pZCBtYWluKCkge1wiLFxuICAgIFRIUkVFLlNoYWRlckNodW5rLm1hcF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5za2luYmFzZV92ZXJ0ZXgsXCJcXHQjaWZkZWYgVVNFX0VOVk1BUFwiLFRIUkVFLlNoYWRlckNodW5rLm1vcnBobm9ybWFsX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5za2lubm9ybWFsX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5kZWZhdWx0bm9ybWFsX3ZlcnRleCxcIlxcdCNlbmRpZlwiLFRIUkVFLlNoYWRlckNodW5rLm1vcnBodGFyZ2V0X3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5za2lubmluZ192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuZGVmYXVsdF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLndvcmxkcG9zX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF92ZXJ0ZXgsXG4gICAgXCJ9XCJdLmpvaW4oXCJcXG5cIiksZnJhZ21lbnRTaGFkZXI6W1widW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFRIUkVFLlNoYWRlckNodW5rLmNvbW1vbixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLm1hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmFscGhhbWFwX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5mb2dfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXCJ2b2lkIG1haW4oKSB7XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG4gICAgVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmFscGhhbWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmFscGhhdGVzdF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zcGVjdWxhcm1hcF9mcmFnbWVudCxcIlxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0bWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmVudm1hcF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmZvZ19mcmFnbWVudCxcIlxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxufVwiXS5qb2luKFwiXFxuXCIpfSxcbiAgICBsYW1iZXJ0Ont1bmlmb3JtczpUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtUSFJFRS5Vbmlmb3Jtc0xpYi5jb21tb24sVEhSRUUuVW5pZm9ybXNMaWIuZm9nLFRIUkVFLlVuaWZvcm1zTGliLmxpZ2h0cyxUSFJFRS5Vbmlmb3Jtc0xpYi5zaGFkb3dtYXAse2VtaXNzaXZlOnt0eXBlOlwiY1wiLHZhbHVlOm5ldyBUSFJFRS5Db2xvcigwKX0sd3JhcFJHQjp7dHlwZTpcInYzXCIsdmFsdWU6bmV3IFRIUkVFLlZlY3RvcjMoMSwxLDEpfX1dKSx2ZXJ0ZXhTaGFkZXI6W1wiI2RlZmluZSBMQU1CRVJUXFxudmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcXG4jZW5kaWZcIixUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sVEhSRUUuU2hhZGVyQ2h1bmsubWFwX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0bWFwX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmVudm1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5saWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleCxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4LFwidm9pZCBtYWluKCkge1wiLFRIUkVFLlNoYWRlckNodW5rLm1hcF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5tb3JwaG5vcm1hbF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbmJhc2VfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNraW5ub3JtYWxfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmRlZmF1bHRub3JtYWxfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLm1vcnBodGFyZ2V0X3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5za2lubmluZ192ZXJ0ZXgsXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rLmRlZmF1bHRfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay53b3JsZHBvc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuZW52bWFwX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5saWdodHNfbGFtYmVydF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3ZlcnRleCxcIn1cIl0uam9pbihcIlxcblwiKSxmcmFnbWVudFNoYWRlcjpbXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XFxuI2VuZGlmXCIsVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubWFwX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuYWxwaGFtYXBfcGFyc19mcmFnbWVudCxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5mb2dfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXCJ2b2lkIG1haW4oKSB7XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmFscGhhbWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmFscGhhdGVzdF9mcmFnbWVudCxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsuc3BlY3VsYXJtYXBfZnJhZ21lbnQsXCJcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0aWYgKCBnbF9Gcm9udEZhY2luZyApXFxuXFx0XFx0XFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogdkxpZ2h0RnJvbnQgKyBlbWlzc2l2ZTtcXG5cXHRcXHRlbHNlXFxuXFx0XFx0XFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogdkxpZ2h0QmFjayArIGVtaXNzaXZlO1xcblxcdCNlbHNlXFxuXFx0XFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogdkxpZ2h0RnJvbnQgKyBlbWlzc2l2ZTtcXG5cXHQjZW5kaWZcIixUSFJFRS5TaGFkZXJDaHVuay5saWdodG1hcF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxpbmVhcl90b19nYW1tYV9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5mb2dfZnJhZ21lbnQsXCJcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcbn1cIl0uam9pbihcIlxcblwiKX0sXG4gICAgcGhvbmc6e3VuaWZvcm1zOlRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoW1RIUkVFLlVuaWZvcm1zTGliLmNvbW1vbixUSFJFRS5Vbmlmb3Jtc0xpYi5idW1wLFRIUkVFLlVuaWZvcm1zTGliLm5vcm1hbG1hcCxUSFJFRS5Vbmlmb3Jtc0xpYi5mb2csVEhSRUUuVW5pZm9ybXNMaWIubGlnaHRzLFRIUkVFLlVuaWZvcm1zTGliLnNoYWRvd21hcCx7ZW1pc3NpdmU6e3R5cGU6XCJjXCIsdmFsdWU6bmV3IFRIUkVFLkNvbG9yKDApfSxzcGVjdWxhcjp7dHlwZTpcImNcIix2YWx1ZTpuZXcgVEhSRUUuQ29sb3IoMTExODQ4MSl9LHNoaW5pbmVzczp7dHlwZTpcImZcIix2YWx1ZTozMH0sd3JhcFJHQjp7dHlwZTpcInYzXCIsdmFsdWU6bmV3IFRIUkVFLlZlY3RvcjMoMSwxLDEpfX1dKSx2ZXJ0ZXhTaGFkZXI6W1wiI2RlZmluZSBQSE9OR1xcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcIixUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rLm1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5saWdodG1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRzX3Bob25nX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNraW5uaW5nX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcInZvaWQgbWFpbigpIHtcIixUSFJFRS5TaGFkZXJDaHVuay5tYXBfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0bWFwX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGhub3JtYWxfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNraW5iYXNlX3ZlcnRleCxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5vcm1hbF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuZGVmYXVsdG5vcm1hbF92ZXJ0ZXgsXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG4jZW5kaWZcIixUSFJFRS5TaGFkZXJDaHVuay5tb3JwaHRhcmdldF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmRlZmF1bHRfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3ZlcnRleCxcIlxcdHZWaWV3UG9zaXRpb24gPSAtbXZQb3NpdGlvbi54eXo7XCIsVEhSRUUuU2hhZGVyQ2h1bmsud29ybGRwb3NfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmVudm1hcF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRzX3Bob25nX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfdmVydGV4LFwifVwiXS5qb2luKFwiXFxuXCIpLGZyYWdtZW50U2hhZGVyOltcIiNkZWZpbmUgUEhPTkdcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1xcbnVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubWFwX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuYWxwaGFtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5saWdodG1hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmVudm1hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmZvZ19wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmJ1bXBtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5ub3JtYWxtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXG4gICAgICAgIFwidm9pZCBtYWluKCkge1xcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLm1hcF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5hbHBoYW1hcF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5hbHBoYXRlc3RfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuc3BlY3VsYXJtYXBfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRzX3Bob25nX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0bWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmVudm1hcF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50LFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVuay5mb2dfZnJhZ21lbnQsXCJcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcbn1cIl0uam9pbihcIlxcblwiKX0scGFydGljbGVfYmFzaWM6e3VuaWZvcm1zOlRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoW1RIUkVFLlVuaWZvcm1zTGliLnBhcnRpY2xlLFRIUkVFLlVuaWZvcm1zTGliLnNoYWRvd21hcF0pLHZlcnRleFNoYWRlcjpbXCJ1bmlmb3JtIGZsb2F0IHNpemU7XFxudW5pZm9ybSBmbG9hdCBzY2FsZTtcIixUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4LFwidm9pZCBtYWluKCkge1wiLFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3ZlcnRleCxcIlxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG5cXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxcblxcdFxcdGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gbGVuZ3RoKCBtdlBvc2l0aW9uLnh5eiApICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRnbF9Qb2ludFNpemUgPSBzaXplO1xcblxcdCNlbmRpZlxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay53b3JsZHBvc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3ZlcnRleCxcIn1cIl0uam9pbihcIlxcblwiKSxmcmFnbWVudFNoYWRlcjpbXCJ1bmlmb3JtIHZlYzMgcHNDb2xvcjtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuZm9nX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCxcInZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIHBzQ29sb3IsIG9wYWNpdHkgKTtcIixcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubWFwX3BhcnRpY2xlX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmFscGhhdGVzdF9mcmFnbWVudCxcIlxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5mb2dfZnJhZ21lbnQsXCJcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcbn1cIl0uam9pbihcIlxcblwiKX0sZGFzaGVkOnt1bmlmb3JtczpUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtUSFJFRS5Vbmlmb3Jtc0xpYi5jb21tb24sVEhSRUUuVW5pZm9ybXNMaWIuZm9nLHtzY2FsZTp7dHlwZTpcImZcIix2YWx1ZToxfSxkYXNoU2l6ZTp7dHlwZTpcImZcIix2YWx1ZToxfSx0b3RhbFNpemU6e3R5cGU6XCJmXCIsdmFsdWU6Mn19XSksXG4gICAgICAgIHZlcnRleFNoYWRlcjpbXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1xcbmF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFRIUkVFLlNoYWRlckNodW5rLmNvbW1vbixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcInZvaWQgbWFpbigpIHtcIixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl92ZXJ0ZXgsXCJcXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfdmVydGV4LFwifVwiXS5qb2luKFwiXFxuXCIpLGZyYWdtZW50U2hhZGVyOltcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xcbnVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rLmNvbW1vbixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmZvZ19wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXCJ2b2lkIG1haW4oKSB7XFxuXFx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XFxuXFx0XFx0ZGlzY2FyZDtcXG5cXHR9XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfZnJhZ21lbnQsXCJcXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcIixUSFJFRS5TaGFkZXJDaHVuay5mb2dfZnJhZ21lbnQsXCJcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcbn1cIl0uam9pbihcIlxcblwiKX0sXG4gICAgZGVwdGg6e3VuaWZvcm1zOnttTmVhcjp7dHlwZTpcImZcIix2YWx1ZToxfSxtRmFyOnt0eXBlOlwiZlwiLHZhbHVlOjJFM30sb3BhY2l0eTp7dHlwZTpcImZcIix2YWx1ZToxfX0sdmVydGV4U2hhZGVyOltUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXCJ2b2lkIG1haW4oKSB7XCIsVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGh0YXJnZXRfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmRlZmF1bHRfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3ZlcnRleCxcIn1cIl0uam9pbihcIlxcblwiKSxmcmFnbWVudFNoYWRlcjpbXCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1xcbnVuaWZvcm0gZmxvYXQgbUZhcjtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXG4gICAgICAgIFwidm9pZCBtYWluKCkge1wiLFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX2ZyYWdtZW50LFwiXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdEZXB0aEVYVCAvIGdsX0ZyYWdDb29yZC53O1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1xcblxcdCNlbmRpZlxcblxcdGZsb2F0IGNvbG9yID0gMS4wIC0gc21vb3Roc3RlcCggbU5lYXIsIG1GYXIsIGRlcHRoICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggY29sb3IgKSwgb3BhY2l0eSApO1xcbn1cIl0uam9pbihcIlxcblwiKX0sbm9ybWFsOnt1bmlmb3Jtczp7b3BhY2l0eTp7dHlwZTpcImZcIix2YWx1ZToxfX0sdmVydGV4U2hhZGVyOltcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFRIUkVFLlNoYWRlckNodW5rLmNvbW1vbixUSFJFRS5TaGFkZXJDaHVuay5tb3JwaHRhcmdldF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcbiAgICAgICAgXCJ2b2lkIG1haW4oKSB7XFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XCIsVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGh0YXJnZXRfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmRlZmF1bHRfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3ZlcnRleCxcIn1cIl0uam9pbihcIlxcblwiKSxmcmFnbWVudFNoYWRlcjpbXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXCJ2b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC41ICogbm9ybWFsaXplKCB2Tm9ybWFsICkgKyAwLjUsIG9wYWNpdHkgKTtcIixUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9mcmFnbWVudCxcIn1cIl0uam9pbihcIlxcblwiKX0sY3ViZTp7dW5pZm9ybXM6e3RDdWJlOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LFxuICAgICAgICB0RmxpcDp7dHlwZTpcImZcIix2YWx1ZTotMX19LHZlcnRleFNoYWRlcjpbXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4LFwidm9pZCBtYWluKCkge1xcblxcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfdmVydGV4LFwifVwiXS5qb2luKFwiXFxuXCIpLGZyYWdtZW50U2hhZGVyOltcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XFxudW5pZm9ybSBmbG9hdCB0RmxpcDtcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsVEhSRUUuU2hhZGVyQ2h1bmsuY29tbW9uLFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXG4gICAgICAgIFwidm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfZnJhZ21lbnQsXCJ9XCJdLmpvaW4oXCJcXG5cIil9LGVxdWlyZWN0Ont1bmlmb3Jtczp7dEVxdWlyZWN0Ont0eXBlOlwidFwiLHZhbHVlOm51bGx9LHRGbGlwOnt0eXBlOlwiZlwiLHZhbHVlOi0xfX0sdmVydGV4U2hhZGVyOltcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXCJ2b2lkIG1haW4oKSB7XFxuXFx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfdmVydGV4LFwifVwiXS5qb2luKFwiXFxuXCIpLGZyYWdtZW50U2hhZGVyOltcInVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcXG51bmlmb3JtIGZsb2F0IHRGbGlwO1xcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCxcInZvaWQgbWFpbigpIHtcXG52ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gKTtcXG52ZWMyIHNhbXBsZVVWO1xcbnNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggdEZsaXAgKiBkaXJlY3Rpb24ueSAqIC0wLjUgKyAwLjUgKTtcXG5zYW1wbGVVVi54ID0gYXRhbiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5nbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcIixUSFJFRS5TaGFkZXJDaHVuay5sb2dkZXB0aGJ1Zl9mcmFnbWVudCxcbiAgICAgICAgXCJ9XCJdLmpvaW4oXCJcXG5cIil9LGRlcHRoUkdCQTp7dW5pZm9ybXM6e30sdmVydGV4U2hhZGVyOltUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXCJ2b2lkIG1haW4oKSB7XCIsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbmJhc2VfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLm1vcnBodGFyZ2V0X3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5za2lubmluZ192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuZGVmYXVsdF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfdmVydGV4LFwifVwiXS5qb2luKFwiXFxuXCIpLGZyYWdtZW50U2hhZGVyOltUSFJFRS5TaGFkZXJDaHVuay5jb21tb24sVEhSRUUuU2hhZGVyQ2h1bmsubG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCxcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XFxuXFx0Y29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAyNTYuMCAqIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wLCAxLjAgKTtcXG5cXHRjb25zdCB2ZWM0IGJpdF9tYXNrID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XFxuXFx0dmVjNCByZXMgPSBtb2QoIGRlcHRoICogYml0X3NoaWZ0ICogdmVjNCggMjU1ICksIHZlYzQoIDI1NiApICkgLyB2ZWM0KCAyNTUgKTtcXG5cXHRyZXMgLT0gcmVzLnh4eXogKiBiaXRfbWFzaztcXG5cXHRyZXR1cm4gcmVzO1xcbn1cXG52b2lkIG1haW4oKSB7XCIsXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rLmxvZ2RlcHRoYnVmX2ZyYWdtZW50LFwiXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0RlcHRoRVhUICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0Nvb3JkLnogKTtcXG5cXHQjZW5kaWZcXG59XCJdLmpvaW4oXCJcXG5cIil9fTtcblRIUkVFLldlYkdMUmVuZGVyZXI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXt2YXIgYj1hLmdlb21ldHJ5O2E9YS5tYXRlcmlhbDt2YXIgYz1iLnZlcnRpY2VzLmxlbmd0aDtpZihhLmF0dHJpYnV0ZXMpe3ZvaWQgMD09PWIuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0JiYoYi5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3Q9W10pO2Zvcih2YXIgZCBpbiBhLmF0dHJpYnV0ZXMpe3ZhciBlPWEuYXR0cmlidXRlc1tkXTtpZighZS5fX3dlYmdsSW5pdGlhbGl6ZWR8fGUuY3JlYXRlVW5pcXVlQnVmZmVycyl7ZS5fX3dlYmdsSW5pdGlhbGl6ZWQ9ITA7dmFyIGY9MTtcInYyXCI9PT1lLnR5cGU/Zj0yOlwidjNcIj09PWUudHlwZT9mPTM6XCJ2NFwiPT09ZS50eXBlP2Y9NDpcImNcIj09PWUudHlwZSYmKGY9Myk7ZS5zaXplPWY7ZS5hcnJheT1uZXcgRmxvYXQzMkFycmF5KGMqZik7ZS5idWZmZXI9bS5jcmVhdGVCdWZmZXIoKTtlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGU9ZDtlLm5lZWRzVXBkYXRlPVxuICAgICEwfWIuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LnB1c2goZSl9fX1mdW5jdGlvbiBjKGEsYil7cmV0dXJuIGEubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsP2EubWF0ZXJpYWwubWF0ZXJpYWxzW2IubWF0ZXJpYWxJbmRleF06YS5tYXRlcmlhbH1mdW5jdGlvbiBkKGEsYixjLGQpe2M9Yy5hdHRyaWJ1dGVzO3ZhciBlPWIuYXR0cmlidXRlcztiPWIuYXR0cmlidXRlc0tleXM7Zm9yKHZhciBmPTAsZz1iLmxlbmd0aDtmPGc7ZisrKXt2YXIgaD1iW2ZdLGs9ZVtoXTtpZigwPD1rKXt2YXIgbj1jW2hdO3ZvaWQgMCE9PW4/KGg9bi5pdGVtU2l6ZSxtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsbi5idWZmZXIpLFcuZW5hYmxlQXR0cmlidXRlKGspLG0udmVydGV4QXR0cmliUG9pbnRlcihrLGgsbS5GTE9BVCwhMSwwLGQqaCo0KSk6dm9pZCAwIT09YS5kZWZhdWx0QXR0cmlidXRlVmFsdWVzJiYoMj09PWEuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1toXS5sZW5ndGg/XG4gICAgbS52ZXJ0ZXhBdHRyaWIyZnYoayxhLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbaF0pOjM9PT1hLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbaF0ubGVuZ3RoJiZtLnZlcnRleEF0dHJpYjNmdihrLGEuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1toXSkpfX1XLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCl9ZnVuY3Rpb24gZShhLGIpe3JldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciE9PWIub2JqZWN0LnJlbmRlck9yZGVyP2Eub2JqZWN0LnJlbmRlck9yZGVyLWIub2JqZWN0LnJlbmRlck9yZGVyOmEubWF0ZXJpYWwuaWQhPT1iLm1hdGVyaWFsLmlkP2EubWF0ZXJpYWwuaWQtYi5tYXRlcmlhbC5pZDphLnohPT1iLno/YS56LWIuejphLmlkLWIuaWR9ZnVuY3Rpb24gZihhLGIpe3JldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciE9PWIub2JqZWN0LnJlbmRlck9yZGVyP2Eub2JqZWN0LnJlbmRlck9yZGVyLWIub2JqZWN0LnJlbmRlck9yZGVyOmEueiE9PWIuej9iLnotYS56OmEuaWQtYi5pZH1mdW5jdGlvbiBnKGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIpe3JldHVybiBiWzBdLWFbMF19ZnVuY3Rpb24gaChhKXtpZighMSE9PWEudmlzaWJsZSl7aWYoIShhIGluc3RhbmNlb2YgVEhSRUUuU2NlbmV8fGEgaW5zdGFuY2VvZiBUSFJFRS5Hcm91cCkpe3ZvaWQgMD09PWEuX193ZWJnbEluaXQmJihhLl9fd2ViZ2xJbml0PSEwLGEuX21vZGVsVmlld01hdHJpeD1uZXcgVEhSRUUuTWF0cml4NCxhLl9ub3JtYWxNYXRyaXg9bmV3IFRIUkVFLk1hdHJpeDMsYS5hZGRFdmVudExpc3RlbmVyKFwicmVtb3ZlZFwiLHdiKSk7dmFyIGM9YS5nZW9tZXRyeTtpZih2b2lkIDAhPT1jJiZ2b2lkIDA9PT1jLl9fd2ViZ2xJbml0KWlmKGMuX193ZWJnbEluaXQ9ITAsYy5hZGRFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLGpiKSxjIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkpQi5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzKys7ZWxzZSBpZihhIGluc3RhbmNlb2YgVEhSRUUuTWVzaClxKGEsYyk7ZWxzZSBpZihhIGluc3RhbmNlb2YgVEhSRUUuTGluZSl7aWYodm9pZCAwPT09XG4gICAgYy5fX3dlYmdsVmVydGV4QnVmZmVyKXtjLl9fd2ViZ2xWZXJ0ZXhCdWZmZXI9bS5jcmVhdGVCdWZmZXIoKTtjLl9fd2ViZ2xDb2xvckJ1ZmZlcj1tLmNyZWF0ZUJ1ZmZlcigpO2MuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlcj1tLmNyZWF0ZUJ1ZmZlcigpO0IuaW5mby5tZW1vcnkuZ2VvbWV0cmllcysrO3ZhciBkPWMudmVydGljZXMubGVuZ3RoO2MuX192ZXJ0ZXhBcnJheT1uZXcgRmxvYXQzMkFycmF5KDMqZCk7Yy5fX2NvbG9yQXJyYXk9bmV3IEZsb2F0MzJBcnJheSgzKmQpO2MuX19saW5lRGlzdGFuY2VBcnJheT1uZXcgRmxvYXQzMkFycmF5KDEqZCk7Yy5fX3dlYmdsTGluZUNvdW50PWQ7YihhKTtjLnZlcnRpY2VzTmVlZFVwZGF0ZT0hMDtjLmNvbG9yc05lZWRVcGRhdGU9ITA7Yy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZT0hMH19ZWxzZSBhIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCYmdm9pZCAwPT09Yy5fX3dlYmdsVmVydGV4QnVmZmVyJiYoYy5fX3dlYmdsVmVydGV4QnVmZmVyPVxuICAgIG0uY3JlYXRlQnVmZmVyKCksYy5fX3dlYmdsQ29sb3JCdWZmZXI9bS5jcmVhdGVCdWZmZXIoKSxCLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMrKyxkPWMudmVydGljZXMubGVuZ3RoLGMuX192ZXJ0ZXhBcnJheT1uZXcgRmxvYXQzMkFycmF5KDMqZCksYy5fX2NvbG9yQXJyYXk9bmV3IEZsb2F0MzJBcnJheSgzKmQpLGMuX193ZWJnbFBhcnRpY2xlQ291bnQ9ZCxiKGEpLGMudmVydGljZXNOZWVkVXBkYXRlPSEwLGMuY29sb3JzTmVlZFVwZGF0ZT0hMCk7aWYodm9pZCAwPT09YS5fX3dlYmdsQWN0aXZlKWlmKGEuX193ZWJnbEFjdGl2ZT0hMCxhIGluc3RhbmNlb2YgVEhSRUUuTWVzaClpZihjIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkpbihiYSxjLGEpO2Vsc2V7aWYoYyBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5KWZvcih2YXIgYz1VYVtjLmlkXSxkPTAsZT1jLmxlbmd0aDtkPGU7ZCsrKW4oYmEsY1tkXSxhKX1lbHNlIGEgaW5zdGFuY2VvZiBUSFJFRS5MaW5lfHxhIGluc3RhbmNlb2ZcblRIUkVFLlBvaW50Q2xvdWQ/bihiYSxjLGEpOihhIGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0fHxhLmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrKSYmcWEucHVzaCh7aWQ6bnVsbCxvYmplY3Q6YSxvcGFxdWU6bnVsbCx0cmFuc3BhcmVudDpudWxsLHo6MH0pO2lmKGEgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCljYS5wdXNoKGEpO2Vsc2UgaWYoYSBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZSlYYS5wdXNoKGEpO2Vsc2UgaWYoYSBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSlZYS5wdXNoKGEpO2Vsc2UgaWYoKGM9YmFbYS5pZF0pJiYoITE9PT1hLmZydXN0dW1DdWxsZWR8fCEwPT09Y2IuaW50ZXJzZWN0c09iamVjdChhKSkpZm9yKGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspe3ZhciBmPWNbZF0sZz1mLGs9Zy5vYmplY3QsbD1nLmJ1ZmZlcixwPWsuZ2VvbWV0cnksaz1rLm1hdGVyaWFsO2sgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsPyhrPWsubWF0ZXJpYWxzW3AgaW5zdGFuY2VvZlxuVEhSRUUuQnVmZmVyR2VvbWV0cnk/MDpsLm1hdGVyaWFsSW5kZXhdLGcubWF0ZXJpYWw9ayxrLnRyYW5zcGFyZW50P1FhLnB1c2goZyk6S2EucHVzaChnKSk6ayYmKGcubWF0ZXJpYWw9ayxrLnRyYW5zcGFyZW50P1FhLnB1c2goZyk6S2EucHVzaChnKSk7Zi5yZW5kZXI9ITA7ITA9PT1CLnNvcnRPYmplY3RzJiYod2Euc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGEubWF0cml4V29ybGQpLHdhLmFwcGx5UHJvamVjdGlvbihkYiksZi56PXdhLnopfX1kPTA7Zm9yKGU9YS5jaGlsZHJlbi5sZW5ndGg7ZDxlO2QrKyloKGEuY2hpbGRyZW5bZF0pfX1mdW5jdGlvbiBrKGEsYixjLGQsZSl7Zm9yKHZhciBmLGc9MCxoPWEubGVuZ3RoO2c8aDtnKyspe2Y9YVtnXTt2YXIgaz1mLm9iamVjdCxtPWYuYnVmZmVyO3coayxiKTtpZihlKWY9ZTtlbHNle2Y9Zi5tYXRlcmlhbDtpZighZiljb250aW51ZTt1KGYpfUIuc2V0TWF0ZXJpYWxGYWNlcyhmKTttIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnk/XG4gICAgQi5yZW5kZXJCdWZmZXJEaXJlY3QoYixjLGQsZixtLGspOkIucmVuZGVyQnVmZmVyKGIsYyxkLGYsbSxrKX19ZnVuY3Rpb24gbChhLGIsYyxkLGUsZil7Zm9yKHZhciBnLGg9MCxrPWEubGVuZ3RoO2g8aztoKyspe2c9YVtoXTt2YXIgbT1nLm9iamVjdDtpZihtLnZpc2libGUpe2lmKGYpZz1mO2Vsc2V7Zz1nW2JdO2lmKCFnKWNvbnRpbnVlO3UoZyl9Qi5yZW5kZXJJbW1lZGlhdGVPYmplY3QoYyxkLGUsZyxtKX19fWZ1bmN0aW9uIHAoYSl7dmFyIGI9YS5vYmplY3QubWF0ZXJpYWw7Yi50cmFuc3BhcmVudD8oYS50cmFuc3BhcmVudD1iLGEub3BhcXVlPW51bGwpOihhLm9wYXF1ZT1iLGEudHJhbnNwYXJlbnQ9bnVsbCl9ZnVuY3Rpb24gcShhLGIpe3ZhciBkPWEubWF0ZXJpYWwsZT0hMTtpZih2b2lkIDA9PT1VYVtiLmlkXXx8ITA9PT1iLmdyb3Vwc05lZWRVcGRhdGUpe2RlbGV0ZSBiYVthLmlkXTtmb3IodmFyIGY9VWEsZz1iLmlkLGQ9ZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg9ZGEuZ2V0KFwiT0VTX2VsZW1lbnRfaW5kZXhfdWludFwiKT80Mjk0OTY3Mjk2OjY1NTM1LGssZT17fSxsPWIubW9ycGhUYXJnZXRzLmxlbmd0aCxwPWIubW9ycGhOb3JtYWxzLmxlbmd0aCxxLHM9e30sdD1bXSxyPTAsdz1iLmZhY2VzLmxlbmd0aDtyPHc7cisrKXtrPWIuZmFjZXNbcl07dmFyIHU9ZD9rLm1hdGVyaWFsSW5kZXg6MDt1IGluIGV8fChlW3VdPXtoYXNoOnUsY291bnRlcjowfSk7az1lW3VdLmhhc2grXCJfXCIrZVt1XS5jb3VudGVyO2sgaW4gc3x8KHE9e2lkOlFiKyssZmFjZXMzOltdLG1hdGVyaWFsSW5kZXg6dSx2ZXJ0aWNlczowLG51bU1vcnBoVGFyZ2V0czpsLG51bU1vcnBoTm9ybWFsczpwfSxzW2tdPXEsdC5wdXNoKHEpKTtzW2tdLnZlcnRpY2VzKzM+aCYmKGVbdV0uY291bnRlcis9MSxrPWVbdV0uaGFzaCtcIl9cIitlW3VdLmNvdW50ZXIsayBpbiBzfHwocT17aWQ6UWIrKyxmYWNlczM6W10sbWF0ZXJpYWxJbmRleDp1LHZlcnRpY2VzOjAsbnVtTW9ycGhUYXJnZXRzOmwsXG4gICAgbnVtTW9ycGhOb3JtYWxzOnB9LHNba109cSx0LnB1c2gocSkpKTtzW2tdLmZhY2VzMy5wdXNoKHIpO3Nba10udmVydGljZXMrPTN9ZltnXT10O2IuZ3JvdXBzTmVlZFVwZGF0ZT0hMX1mPVVhW2IuaWRdO2c9MDtmb3IoZD1mLmxlbmd0aDtnPGQ7ZysrKXtoPWZbZ107aWYodm9pZCAwPT09aC5fX3dlYmdsVmVydGV4QnVmZmVyKXtlPWg7ZS5fX3dlYmdsVmVydGV4QnVmZmVyPW0uY3JlYXRlQnVmZmVyKCk7ZS5fX3dlYmdsTm9ybWFsQnVmZmVyPW0uY3JlYXRlQnVmZmVyKCk7ZS5fX3dlYmdsVGFuZ2VudEJ1ZmZlcj1tLmNyZWF0ZUJ1ZmZlcigpO2UuX193ZWJnbENvbG9yQnVmZmVyPW0uY3JlYXRlQnVmZmVyKCk7ZS5fX3dlYmdsVVZCdWZmZXI9bS5jcmVhdGVCdWZmZXIoKTtlLl9fd2ViZ2xVVjJCdWZmZXI9bS5jcmVhdGVCdWZmZXIoKTtlLl9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlcj1tLmNyZWF0ZUJ1ZmZlcigpO2UuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyPW0uY3JlYXRlQnVmZmVyKCk7XG4gICAgZS5fX3dlYmdsRmFjZUJ1ZmZlcj1tLmNyZWF0ZUJ1ZmZlcigpO2UuX193ZWJnbExpbmVCdWZmZXI9bS5jcmVhdGVCdWZmZXIoKTtpZihwPWUubnVtTW9ycGhUYXJnZXRzKWZvcihlLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzPVtdLGw9MDtsPHA7bCsrKWUuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnMucHVzaChtLmNyZWF0ZUJ1ZmZlcigpKTtpZihwPWUubnVtTW9ycGhOb3JtYWxzKWZvcihlLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzPVtdLGw9MDtsPHA7bCsrKWUuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnMucHVzaChtLmNyZWF0ZUJ1ZmZlcigpKTtCLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMrKztlPWg7cj1hO3c9ci5nZW9tZXRyeTtwPWUuZmFjZXMzO2w9MypwLmxlbmd0aDtzPTEqcC5sZW5ndGg7dD0zKnAubGVuZ3RoO3A9YyhyLGUpO2UuX192ZXJ0ZXhBcnJheT1uZXcgRmxvYXQzMkFycmF5KDMqbCk7ZS5fX25vcm1hbEFycmF5PW5ldyBGbG9hdDMyQXJyYXkoMypsKTtcbiAgICBlLl9fY29sb3JBcnJheT1uZXcgRmxvYXQzMkFycmF5KDMqbCk7ZS5fX3V2QXJyYXk9bmV3IEZsb2F0MzJBcnJheSgyKmwpOzE8dy5mYWNlVmVydGV4VXZzLmxlbmd0aCYmKGUuX191djJBcnJheT1uZXcgRmxvYXQzMkFycmF5KDIqbCkpO3cuaGFzVGFuZ2VudHMmJihlLl9fdGFuZ2VudEFycmF5PW5ldyBGbG9hdDMyQXJyYXkoNCpsKSk7ci5nZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGgmJnIuZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoJiYoZS5fX3NraW5JbmRleEFycmF5PW5ldyBGbG9hdDMyQXJyYXkoNCpsKSxlLl9fc2tpbldlaWdodEFycmF5PW5ldyBGbG9hdDMyQXJyYXkoNCpsKSk7cj1udWxsIT09ZGEuZ2V0KFwiT0VTX2VsZW1lbnRfaW5kZXhfdWludFwiKSYmMjE4NDU8cz9VaW50MzJBcnJheTpVaW50MTZBcnJheTtlLl9fdHlwZUFycmF5PXI7ZS5fX2ZhY2VBcnJheT1uZXcgcigzKnMpO2UuX19saW5lQXJyYXk9bmV3IHIoMip0KTtpZih3PWUubnVtTW9ycGhUYXJnZXRzKWZvcihlLl9fbW9ycGhUYXJnZXRzQXJyYXlzPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10scj0wO3I8dztyKyspZS5fX21vcnBoVGFyZ2V0c0FycmF5cy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoMypsKSk7aWYodz1lLm51bU1vcnBoTm9ybWFscylmb3IoZS5fX21vcnBoTm9ybWFsc0FycmF5cz1bXSxyPTA7cjx3O3IrKyllLl9fbW9ycGhOb3JtYWxzQXJyYXlzLnB1c2gobmV3IEZsb2F0MzJBcnJheSgzKmwpKTtlLl9fd2ViZ2xGYWNlQ291bnQ9MypzO2UuX193ZWJnbExpbmVDb3VudD0yKnQ7aWYocC5hdHRyaWJ1dGVzKWZvcihzIGluIHZvaWQgMD09PWUuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0JiYoZS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3Q9W10pLHM9dm9pZCAwLHAuYXR0cmlidXRlcyl7dmFyIHQ9cC5hdHRyaWJ1dGVzW3NdLHI9e30sdjtmb3IodiBpbiB0KXJbdl09dFt2XTtpZighci5fX3dlYmdsSW5pdGlhbGl6ZWR8fHIuY3JlYXRlVW5pcXVlQnVmZmVycylyLl9fd2ViZ2xJbml0aWFsaXplZD0hMCx3PTEsXCJ2MlwiPT09ci50eXBlP3c9MjpcInYzXCI9PT1cbiAgICByLnR5cGU/dz0zOlwidjRcIj09PXIudHlwZT93PTQ6XCJjXCI9PT1yLnR5cGUmJih3PTMpLHIuc2l6ZT13LHIuYXJyYXk9bmV3IEZsb2F0MzJBcnJheShsKncpLHIuYnVmZmVyPW0uY3JlYXRlQnVmZmVyKCksci5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlPXMsdC5uZWVkc1VwZGF0ZT0hMCxyLl9fb3JpZ2luYWw9dDtlLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdC5wdXNoKHIpfWUuX19pbml0dGVkQXJyYXlzPSEwO2IudmVydGljZXNOZWVkVXBkYXRlPSEwO2IubW9ycGhUYXJnZXRzTmVlZFVwZGF0ZT0hMDtiLmVsZW1lbnRzTmVlZFVwZGF0ZT0hMDtiLnV2c05lZWRVcGRhdGU9ITA7Yi5ub3JtYWxzTmVlZFVwZGF0ZT0hMDtiLnRhbmdlbnRzTmVlZFVwZGF0ZT0hMDtlPWIuY29sb3JzTmVlZFVwZGF0ZT0hMH1lbHNlIGU9ITE7KGV8fHZvaWQgMD09PWEuX193ZWJnbEFjdGl2ZSkmJm4oYmEsaCxhKX1hLl9fd2ViZ2xBY3RpdmU9ITB9ZnVuY3Rpb24gbihhLGIsYyl7dmFyIGQ9Yy5pZDthW2RdPVxuICAgIGFbZF18fFtdO2FbZF0ucHVzaCh7aWQ6ZCxidWZmZXI6YixvYmplY3Q6YyxtYXRlcmlhbDpudWxsLHo6MH0pfWZ1bmN0aW9uIHQoYSl7dmFyIGI9YS5nZW9tZXRyeTtpZihiIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkpZm9yKHZhciBkPWIuYXR0cmlidXRlcyxlPWIuYXR0cmlidXRlc0tleXMsZj0wLGc9ZS5sZW5ndGg7ZjxnO2YrKyl7dmFyIGg9ZVtmXSxrPWRbaF0sbj1cImluZGV4XCI9PT1oP20uRUxFTUVOVF9BUlJBWV9CVUZGRVI6bS5BUlJBWV9CVUZGRVI7dm9pZCAwPT09ay5idWZmZXI/KGsuYnVmZmVyPW0uY3JlYXRlQnVmZmVyKCksbS5iaW5kQnVmZmVyKG4say5idWZmZXIpLG0uYnVmZmVyRGF0YShuLGsuYXJyYXksayBpbnN0YW5jZW9mIFRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGU/bS5EWU5BTUlDX0RSQVc6bS5TVEFUSUNfRFJBVyksay5uZWVkc1VwZGF0ZT0hMSk6ITA9PT1rLm5lZWRzVXBkYXRlJiYobS5iaW5kQnVmZmVyKG4say5idWZmZXIpLHZvaWQgMD09PVxuay51cGRhdGVSYW5nZXx8LTE9PT1rLnVwZGF0ZVJhbmdlLmNvdW50P20uYnVmZmVyU3ViRGF0YShuLDAsay5hcnJheSk6MD09PWsudXBkYXRlUmFuZ2UuY291bnQ/Y29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXIudXBkYXRlT2JqZWN0OiB1c2luZyB1cGRhdGVSYW5nZSBmb3IgVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSBhbmQgbWFya2VkIGFzIG5lZWRzVXBkYXRlIGJ1dCBjb3VudCBpcyAwLCBlbnN1cmUgeW91IGFyZSB1c2luZyBzZXQgbWV0aG9kcyBvciB1cGRhdGluZyBtYW51YWxseS5cIik6KG0uYnVmZmVyU3ViRGF0YShuLGsudXBkYXRlUmFuZ2Uub2Zmc2V0KmsuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsay5hcnJheS5zdWJhcnJheShrLnVwZGF0ZVJhbmdlLm9mZnNldCxrLnVwZGF0ZVJhbmdlLm9mZnNldCtrLnVwZGF0ZVJhbmdlLmNvdW50KSksay51cGRhdGVSYW5nZS5jb3VudD0wKSxrLm5lZWRzVXBkYXRlPSExKX1lbHNlIGlmKGEgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKXshMD09PVxuYi5ncm91cHNOZWVkVXBkYXRlJiZxKGEsYik7Zm9yKHZhciBsPVVhW2IuaWRdLGY9MCxwPWwubGVuZ3RoO2Y8cDtmKyspe3ZhciB0PWxbZl0sdz1jKGEsdCksdT13LmF0dHJpYnV0ZXMmJnIodyk7aWYoYi52ZXJ0aWNlc05lZWRVcGRhdGV8fGIubW9ycGhUYXJnZXRzTmVlZFVwZGF0ZXx8Yi5lbGVtZW50c05lZWRVcGRhdGV8fGIudXZzTmVlZFVwZGF0ZXx8Yi5ub3JtYWxzTmVlZFVwZGF0ZXx8Yi5jb2xvcnNOZWVkVXBkYXRlfHxiLnRhbmdlbnRzTmVlZFVwZGF0ZXx8dSl7dmFyIHY9dCx4PWEsRD1tLkRZTkFNSUNfRFJBVyxBPSFiLmR5bmFtaWMsRT13O2lmKHYuX19pbml0dGVkQXJyYXlzKXt2YXIgRz0hMT09PUUgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCYmRS5zaGFkaW5nPT09VEhSRUUuRmxhdFNoYWRpbmcseT12b2lkIDAsej12b2lkIDAsRj12b2lkIDAsQj12b2lkIDAsST12b2lkIDAsSD12b2lkIDAsTT12b2lkIDAsUj12b2lkIDAsUD12b2lkIDAsVT12b2lkIDAsXG4gICAgTz12b2lkIDAsSj12b2lkIDAsTD12b2lkIDAsTj12b2lkIDAsS2E9dm9pZCAwLFY9dm9pZCAwLFc9dm9pZCAwLFFhPXZvaWQgMCxZYT12b2lkIDAsWGE9dm9pZCAwLGRhPXZvaWQgMCxiYT12b2lkIDAsamE9dm9pZCAwLFBhPXZvaWQgMCxrYT12b2lkIDAsUT12b2lkIDAsaGE9dm9pZCAwLGlhPXZvaWQgMCxvYj12b2lkIDAsWT12b2lkIDAsdWI9dm9pZCAwLHBhPXZvaWQgMCxhYj12b2lkIDAsb2E9dm9pZCAwLGNhPXZvaWQgMCxxYT12b2lkIDAsQ2E9dm9pZCAwLHRhPXZvaWQgMCxuYT12b2lkIDAsd2E9dm9pZCAwLExhPTAsTWE9MCxrYj0wLHliPTAsemI9MCxSYT0wLEFhPTAsZWI9MCxIYT0wLGxhPTAscmE9MCxLPTAsemE9dm9pZCAwLFNhPXYuX192ZXJ0ZXhBcnJheSxBYj12Ll9fdXZBcnJheSxsYj12Ll9fdXYyQXJyYXksTmE9di5fX25vcm1hbEFycmF5LHNhPXYuX190YW5nZW50QXJyYXksRGE9di5fX2NvbG9yQXJyYXksRWE9di5fX3NraW5JbmRleEFycmF5LEZhPXYuX19za2luV2VpZ2h0QXJyYXksXG4gICAgR2I9di5fX21vcnBoVGFyZ2V0c0FycmF5cyxCYj12Ll9fbW9ycGhOb3JtYWxzQXJyYXlzLG1iPXYuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LEM9dm9pZCAwLFZhPXYuX19mYWNlQXJyYXksVGE9di5fX2xpbmVBcnJheSxlYT14Lmdlb21ldHJ5LGZiPWVhLmVsZW1lbnRzTmVlZFVwZGF0ZSx2Yj1lYS51dnNOZWVkVXBkYXRlLE1iPWVhLm5vcm1hbHNOZWVkVXBkYXRlLE9iPWVhLnRhbmdlbnRzTmVlZFVwZGF0ZSxpYj1lYS5jb2xvcnNOZWVkVXBkYXRlLHNiPWVhLm1vcnBoVGFyZ2V0c05lZWRVcGRhdGUsQ2I9ZWEudmVydGljZXMsJD12LmZhY2VzMyx4YT1lYS5mYWNlcyxIYj1lYS5mYWNlVmVydGV4VXZzWzBdLE9hPWVhLmZhY2VWZXJ0ZXhVdnNbMV0sJGE9ZWEuc2tpbkluZGljZXMsR2E9ZWEuc2tpbldlaWdodHMsbmI9ZWEubW9ycGhUYXJnZXRzLGJiPWVhLm1vcnBoTm9ybWFscztpZihlYS52ZXJ0aWNlc05lZWRVcGRhdGUpe3k9MDtmb3Ioej0kLmxlbmd0aDt5PHo7eSsrKUI9XG4gICAgeGFbJFt5XV0sSj1DYltCLmFdLEw9Q2JbQi5iXSxOPUNiW0IuY10sU2FbTWFdPUoueCxTYVtNYSsxXT1KLnksU2FbTWErMl09Si56LFNhW01hKzNdPUwueCxTYVtNYSs0XT1MLnksU2FbTWErNV09TC56LFNhW01hKzZdPU4ueCxTYVtNYSs3XT1OLnksU2FbTWErOF09Ti56LE1hKz05O20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIpO20uYnVmZmVyRGF0YShtLkFSUkFZX0JVRkZFUixTYSxEKX1pZihzYilmb3IoY2E9MCxxYT1uYi5sZW5ndGg7Y2E8cWE7Y2ErKyl7eT1yYT0wO2Zvcih6PSQubGVuZ3RoO3k8ejt5KyspbmE9JFt5XSxCPXhhW25hXSxKPW5iW2NhXS52ZXJ0aWNlc1tCLmFdLEw9bmJbY2FdLnZlcnRpY2VzW0IuYl0sTj1uYltjYV0udmVydGljZXNbQi5jXSxDYT1HYltjYV0sQ2FbcmFdPUoueCxDYVtyYSsxXT1KLnksQ2FbcmErMl09Si56LENhW3JhKzNdPUwueCxDYVtyYSs0XT1MLnksQ2FbcmErNV09TC56LENhW3JhKzZdPU4ueCxDYVtyYStcbjddPU4ueSxDYVtyYSs4XT1OLnosRS5tb3JwaE5vcm1hbHMmJihHP1hhPVlhPVFhPWJiW2NhXS5mYWNlTm9ybWFsc1tuYV06KHdhPWJiW2NhXS52ZXJ0ZXhOb3JtYWxzW25hXSxRYT13YS5hLFlhPXdhLmIsWGE9d2EuYyksdGE9QmJbY2FdLHRhW3JhXT1RYS54LHRhW3JhKzFdPVFhLnksdGFbcmErMl09UWEueix0YVtyYSszXT1ZYS54LHRhW3JhKzRdPVlhLnksdGFbcmErNV09WWEueix0YVtyYSs2XT1YYS54LHRhW3JhKzddPVhhLnksdGFbcmErOF09WGEueikscmErPTk7bS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLHYuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbY2FdKTttLmJ1ZmZlckRhdGEobS5BUlJBWV9CVUZGRVIsR2JbY2FdLEQpO0UubW9ycGhOb3JtYWxzJiYobS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLHYuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnNbY2FdKSxtLmJ1ZmZlckRhdGEobS5BUlJBWV9CVUZGRVIsQmJbY2FdLEQpKX1pZihHYS5sZW5ndGgpe3k9MDtcbiAgICBmb3Ioej0kLmxlbmd0aDt5PHo7eSsrKUI9eGFbJFt5XV0sUGE9R2FbQi5hXSxrYT1HYVtCLmJdLFE9R2FbQi5jXSxGYVtsYV09UGEueCxGYVtsYSsxXT1QYS55LEZhW2xhKzJdPVBhLnosRmFbbGErM109UGEudyxGYVtsYSs0XT1rYS54LEZhW2xhKzVdPWthLnksRmFbbGErNl09a2EueixGYVtsYSs3XT1rYS53LEZhW2xhKzhdPVEueCxGYVtsYSs5XT1RLnksRmFbbGErMTBdPVEueixGYVtsYSsxMV09US53LGhhPSRhW0IuYV0saWE9JGFbQi5iXSxvYj0kYVtCLmNdLEVhW2xhXT1oYS54LEVhW2xhKzFdPWhhLnksRWFbbGErMl09aGEueixFYVtsYSszXT1oYS53LEVhW2xhKzRdPWlhLngsRWFbbGErNV09aWEueSxFYVtsYSs2XT1pYS56LEVhW2xhKzddPWlhLncsRWFbbGErOF09b2IueCxFYVtsYSs5XT1vYi55LEVhW2xhKzEwXT1vYi56LEVhW2xhKzExXT1vYi53LGxhKz0xMjswPGxhJiYobS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLHYuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyKSxcbiAgICAgICAgbS5idWZmZXJEYXRhKG0uQVJSQVlfQlVGRkVSLEVhLEQpLG0uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciksbS5idWZmZXJEYXRhKG0uQVJSQVlfQlVGRkVSLEZhLEQpKX1pZihpYil7eT0wO2Zvcih6PSQubGVuZ3RoO3k8ejt5KyspQj14YVskW3ldXSxNPUIudmVydGV4Q29sb3JzLFI9Qi5jb2xvciwzPT09TS5sZW5ndGgmJkUudmVydGV4Q29sb3JzPT09VEhSRUUuVmVydGV4Q29sb3JzPyhkYT1NWzBdLGJhPU1bMV0samE9TVsyXSk6amE9YmE9ZGE9UixEYVtIYV09ZGEucixEYVtIYSsxXT1kYS5nLERhW0hhKzJdPWRhLmIsRGFbSGErM109YmEucixEYVtIYSs0XT1iYS5nLERhW0hhKzVdPWJhLmIsRGFbSGErNl09amEucixEYVtIYSs3XT1qYS5nLERhW0hhKzhdPWphLmIsSGErPTk7MDxIYSYmKG0uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xDb2xvckJ1ZmZlciksbS5idWZmZXJEYXRhKG0uQVJSQVlfQlVGRkVSLERhLFxuICAgIEQpKX1pZihPYiYmZWEuaGFzVGFuZ2VudHMpe3k9MDtmb3Ioej0kLmxlbmd0aDt5PHo7eSsrKUI9eGFbJFt5XV0sUD1CLnZlcnRleFRhbmdlbnRzLEthPVBbMF0sVj1QWzFdLFc9UFsyXSxzYVtBYV09S2EueCxzYVtBYSsxXT1LYS55LHNhW0FhKzJdPUthLnosc2FbQWErM109S2EudyxzYVtBYSs0XT1WLngsc2FbQWErNV09Vi55LHNhW0FhKzZdPVYueixzYVtBYSs3XT1WLncsc2FbQWErOF09Vy54LHNhW0FhKzldPVcueSxzYVtBYSsxMF09Vy56LHNhW0FhKzExXT1XLncsQWErPTEyO20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xUYW5nZW50QnVmZmVyKTttLmJ1ZmZlckRhdGEobS5BUlJBWV9CVUZGRVIsc2EsRCl9aWYoTWIpe3k9MDtmb3Ioej0kLmxlbmd0aDt5PHo7eSsrKWlmKEI9eGFbJFt5XV0sST1CLnZlcnRleE5vcm1hbHMsSD1CLm5vcm1hbCwzPT09SS5sZW5ndGgmJiExPT09Rylmb3IoWT0wOzM+WTtZKyspcGE9SVtZXSxOYVtSYV09cGEueCxOYVtSYSsxXT1cbiAgICBwYS55LE5hW1JhKzJdPXBhLnosUmErPTM7ZWxzZSBmb3IoWT0wOzM+WTtZKyspTmFbUmFdPUgueCxOYVtSYSsxXT1ILnksTmFbUmErMl09SC56LFJhKz0zO20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xOb3JtYWxCdWZmZXIpO20uYnVmZmVyRGF0YShtLkFSUkFZX0JVRkZFUixOYSxEKX1pZih2YiYmSGIpe3k9MDtmb3Ioej0kLmxlbmd0aDt5PHo7eSsrKWlmKEY9JFt5XSxVPUhiW0ZdLHZvaWQgMCE9PVUpZm9yKFk9MDszPlk7WSsrKWFiPVVbWV0sQWJba2JdPWFiLngsQWJba2IrMV09YWIueSxrYis9MjswPGtiJiYobS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLHYuX193ZWJnbFVWQnVmZmVyKSxtLmJ1ZmZlckRhdGEobS5BUlJBWV9CVUZGRVIsQWIsRCkpfWlmKHZiJiZPYSl7eT0wO2Zvcih6PSQubGVuZ3RoO3k8ejt5KyspaWYoRj0kW3ldLE89T2FbRl0sdm9pZCAwIT09Tylmb3IoWT0wOzM+WTtZKyspb2E9T1tZXSxsYlt5Yl09b2EueCxsYlt5YisxXT1vYS55LFxuICAgIHliKz0yOzA8eWImJihtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsdi5fX3dlYmdsVVYyQnVmZmVyKSxtLmJ1ZmZlckRhdGEobS5BUlJBWV9CVUZGRVIsbGIsRCkpfWlmKGZiKXt5PTA7Zm9yKHo9JC5sZW5ndGg7eTx6O3krKylWYVt6Yl09TGEsVmFbemIrMV09TGErMSxWYVt6YisyXT1MYSsyLHpiKz0zLFRhW2ViXT1MYSxUYVtlYisxXT1MYSsxLFRhW2ViKzJdPUxhLFRhW2ViKzNdPUxhKzIsVGFbZWIrNF09TGErMSxUYVtlYis1XT1MYSsyLGViKz02LExhKz0zO20uYmluZEJ1ZmZlcihtLkVMRU1FTlRfQVJSQVlfQlVGRkVSLHYuX193ZWJnbEZhY2VCdWZmZXIpO20uYnVmZmVyRGF0YShtLkVMRU1FTlRfQVJSQVlfQlVGRkVSLFZhLEQpO20uYmluZEJ1ZmZlcihtLkVMRU1FTlRfQVJSQVlfQlVGRkVSLHYuX193ZWJnbExpbmVCdWZmZXIpO20uYnVmZmVyRGF0YShtLkVMRU1FTlRfQVJSQVlfQlVGRkVSLFRhLEQpfWlmKG1iKWZvcihZPTAsdWI9bWIubGVuZ3RoO1k8dWI7WSsrKWlmKEM9XG4gICAgICAgIG1iW1ldLEMuX19vcmlnaW5hbC5uZWVkc1VwZGF0ZSl7Sz0wO2lmKDE9PT1DLnNpemUpaWYodm9pZCAwPT09Qy5ib3VuZFRvfHxcInZlcnRpY2VzXCI9PT1DLmJvdW5kVG8pZm9yKHk9MCx6PSQubGVuZ3RoO3k8ejt5KyspQj14YVskW3ldXSxDLmFycmF5W0tdPUMudmFsdWVbQi5hXSxDLmFycmF5W0srMV09Qy52YWx1ZVtCLmJdLEMuYXJyYXlbSysyXT1DLnZhbHVlW0IuY10sSys9MztlbHNle2lmKFwiZmFjZXNcIj09PUMuYm91bmRUbylmb3IoeT0wLHo9JC5sZW5ndGg7eTx6O3krKyl6YT1DLnZhbHVlWyRbeV1dLEMuYXJyYXlbS109emEsQy5hcnJheVtLKzFdPXphLEMuYXJyYXlbSysyXT16YSxLKz0zfWVsc2UgaWYoMj09PUMuc2l6ZSlpZih2b2lkIDA9PT1DLmJvdW5kVG98fFwidmVydGljZXNcIj09PUMuYm91bmRUbylmb3IoeT0wLHo9JC5sZW5ndGg7eTx6O3krKylCPXhhWyRbeV1dLEo9Qy52YWx1ZVtCLmFdLEw9Qy52YWx1ZVtCLmJdLE49Qy52YWx1ZVtCLmNdLEMuYXJyYXlbS109Si54LFxuICAgIEMuYXJyYXlbSysxXT1KLnksQy5hcnJheVtLKzJdPUwueCxDLmFycmF5W0srM109TC55LEMuYXJyYXlbSys0XT1OLngsQy5hcnJheVtLKzVdPU4ueSxLKz02O2Vsc2V7aWYoXCJmYWNlc1wiPT09Qy5ib3VuZFRvKWZvcih5PTAsej0kLmxlbmd0aDt5PHo7eSsrKU49TD1KPXphPUMudmFsdWVbJFt5XV0sQy5hcnJheVtLXT1KLngsQy5hcnJheVtLKzFdPUoueSxDLmFycmF5W0srMl09TC54LEMuYXJyYXlbSyszXT1MLnksQy5hcnJheVtLKzRdPU4ueCxDLmFycmF5W0srNV09Ti55LEsrPTZ9ZWxzZSBpZigzPT09Qy5zaXplKXt2YXIgVDtUPVwiY1wiPT09Qy50eXBlP1tcInJcIixcImdcIixcImJcIl06W1wieFwiLFwieVwiLFwielwiXTtpZih2b2lkIDA9PT1DLmJvdW5kVG98fFwidmVydGljZXNcIj09PUMuYm91bmRUbylmb3IoeT0wLHo9JC5sZW5ndGg7eTx6O3krKylCPXhhWyRbeV1dLEo9Qy52YWx1ZVtCLmFdLEw9Qy52YWx1ZVtCLmJdLE49Qy52YWx1ZVtCLmNdLEMuYXJyYXlbS109SltUWzBdXSxDLmFycmF5W0srMV09XG4gICAgSltUWzFdXSxDLmFycmF5W0srMl09SltUWzJdXSxDLmFycmF5W0srM109TFtUWzBdXSxDLmFycmF5W0srNF09TFtUWzFdXSxDLmFycmF5W0srNV09TFtUWzJdXSxDLmFycmF5W0srNl09TltUWzBdXSxDLmFycmF5W0srN109TltUWzFdXSxDLmFycmF5W0srOF09TltUWzJdXSxLKz05O2Vsc2UgaWYoXCJmYWNlc1wiPT09Qy5ib3VuZFRvKWZvcih5PTAsej0kLmxlbmd0aDt5PHo7eSsrKU49TD1KPXphPUMudmFsdWVbJFt5XV0sQy5hcnJheVtLXT1KW1RbMF1dLEMuYXJyYXlbSysxXT1KW1RbMV1dLEMuYXJyYXlbSysyXT1KW1RbMl1dLEMuYXJyYXlbSyszXT1MW1RbMF1dLEMuYXJyYXlbSys0XT1MW1RbMV1dLEMuYXJyYXlbSys1XT1MW1RbMl1dLEMuYXJyYXlbSys2XT1OW1RbMF1dLEMuYXJyYXlbSys3XT1OW1RbMV1dLEMuYXJyYXlbSys4XT1OW1RbMl1dLEsrPTk7ZWxzZSBpZihcImZhY2VWZXJ0aWNlc1wiPT09Qy5ib3VuZFRvKWZvcih5PTAsej0kLmxlbmd0aDt5PHo7eSsrKXphPUMudmFsdWVbJFt5XV0sXG4gICAgSj16YVswXSxMPXphWzFdLE49emFbMl0sQy5hcnJheVtLXT1KW1RbMF1dLEMuYXJyYXlbSysxXT1KW1RbMV1dLEMuYXJyYXlbSysyXT1KW1RbMl1dLEMuYXJyYXlbSyszXT1MW1RbMF1dLEMuYXJyYXlbSys0XT1MW1RbMV1dLEMuYXJyYXlbSys1XT1MW1RbMl1dLEMuYXJyYXlbSys2XT1OW1RbMF1dLEMuYXJyYXlbSys3XT1OW1RbMV1dLEMuYXJyYXlbSys4XT1OW1RbMl1dLEsrPTl9ZWxzZSBpZig0PT09Qy5zaXplKWlmKHZvaWQgMD09PUMuYm91bmRUb3x8XCJ2ZXJ0aWNlc1wiPT09Qy5ib3VuZFRvKWZvcih5PTAsej0kLmxlbmd0aDt5PHo7eSsrKUI9eGFbJFt5XV0sSj1DLnZhbHVlW0IuYV0sTD1DLnZhbHVlW0IuYl0sTj1DLnZhbHVlW0IuY10sQy5hcnJheVtLXT1KLngsQy5hcnJheVtLKzFdPUoueSxDLmFycmF5W0srMl09Si56LEMuYXJyYXlbSyszXT1KLncsQy5hcnJheVtLKzRdPUwueCxDLmFycmF5W0srNV09TC55LEMuYXJyYXlbSys2XT1MLnosQy5hcnJheVtLKzddPUwudyxDLmFycmF5W0srXG44XT1OLngsQy5hcnJheVtLKzldPU4ueSxDLmFycmF5W0srMTBdPU4ueixDLmFycmF5W0srMTFdPU4udyxLKz0xMjtlbHNlIGlmKFwiZmFjZXNcIj09PUMuYm91bmRUbylmb3IoeT0wLHo9JC5sZW5ndGg7eTx6O3krKylOPUw9Sj16YT1DLnZhbHVlWyRbeV1dLEMuYXJyYXlbS109Si54LEMuYXJyYXlbSysxXT1KLnksQy5hcnJheVtLKzJdPUoueixDLmFycmF5W0srM109Si53LEMuYXJyYXlbSys0XT1MLngsQy5hcnJheVtLKzVdPUwueSxDLmFycmF5W0srNl09TC56LEMuYXJyYXlbSys3XT1MLncsQy5hcnJheVtLKzhdPU4ueCxDLmFycmF5W0srOV09Ti55LEMuYXJyYXlbSysxMF09Ti56LEMuYXJyYXlbSysxMV09Ti53LEsrPTEyO2Vsc2UgaWYoXCJmYWNlVmVydGljZXNcIj09PUMuYm91bmRUbylmb3IoeT0wLHo9JC5sZW5ndGg7eTx6O3krKyl6YT1DLnZhbHVlWyRbeV1dLEo9emFbMF0sTD16YVsxXSxOPXphWzJdLEMuYXJyYXlbS109Si54LEMuYXJyYXlbSysxXT1KLnksQy5hcnJheVtLKzJdPVxuICAgIEoueixDLmFycmF5W0srM109Si53LEMuYXJyYXlbSys0XT1MLngsQy5hcnJheVtLKzVdPUwueSxDLmFycmF5W0srNl09TC56LEMuYXJyYXlbSys3XT1MLncsQy5hcnJheVtLKzhdPU4ueCxDLmFycmF5W0srOV09Ti55LEMuYXJyYXlbSysxMF09Ti56LEMuYXJyYXlbSysxMV09Ti53LEsrPTEyO20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixDLmJ1ZmZlcik7bS5idWZmZXJEYXRhKG0uQVJSQVlfQlVGRkVSLEMuYXJyYXksRCl9QSYmKGRlbGV0ZSB2Ll9faW5pdHRlZEFycmF5cyxkZWxldGUgdi5fX2NvbG9yQXJyYXksZGVsZXRlIHYuX19ub3JtYWxBcnJheSxkZWxldGUgdi5fX3RhbmdlbnRBcnJheSxkZWxldGUgdi5fX3V2QXJyYXksZGVsZXRlIHYuX191djJBcnJheSxkZWxldGUgdi5fX2ZhY2VBcnJheSxkZWxldGUgdi5fX3ZlcnRleEFycmF5LGRlbGV0ZSB2Ll9fbGluZUFycmF5LGRlbGV0ZSB2Ll9fc2tpbkluZGV4QXJyYXksZGVsZXRlIHYuX19za2luV2VpZ2h0QXJyYXkpfX19Yi52ZXJ0aWNlc05lZWRVcGRhdGU9XG4gICAgITE7Yi5tb3JwaFRhcmdldHNOZWVkVXBkYXRlPSExO2IuZWxlbWVudHNOZWVkVXBkYXRlPSExO2IudXZzTmVlZFVwZGF0ZT0hMTtiLm5vcm1hbHNOZWVkVXBkYXRlPSExO2IuY29sb3JzTmVlZFVwZGF0ZT0hMTtiLnRhbmdlbnRzTmVlZFVwZGF0ZT0hMTt3LmF0dHJpYnV0ZXMmJnModyl9ZWxzZSBpZihhIGluc3RhbmNlb2YgVEhSRUUuTGluZSl7dz1jKGEsYik7dT13LmF0dHJpYnV0ZXMmJnIodyk7aWYoYi52ZXJ0aWNlc05lZWRVcGRhdGV8fGIuY29sb3JzTmVlZFVwZGF0ZXx8Yi5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZXx8dSl7dmFyIERiPW0uRFlOQU1JQ19EUkFXLFMsYWEsWixCYSxYLEViLFJiPWIudmVydGljZXMsSWI9Yi5jb2xvcnMsZ2I9Yi5saW5lRGlzdGFuY2VzLHlhPVJiLmxlbmd0aCxwYj1JYi5sZW5ndGgscWI9Z2IubGVuZ3RoLFdhPWIuX192ZXJ0ZXhBcnJheSx0Yj1iLl9fY29sb3JBcnJheSxoYj1iLl9fbGluZURpc3RhbmNlQXJyYXksJGI9Yi5jb2xvcnNOZWVkVXBkYXRlLFxuICAgIEZiPWIubGluZURpc3RhbmNlc05lZWRVcGRhdGUsU2I9Yi5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QsSmIsY2IsdWEsS2IsSWEsZmE7aWYoYi52ZXJ0aWNlc05lZWRVcGRhdGUpe2ZvcihTPTA7Uzx5YTtTKyspQmE9UmJbU10sWD0zKlMsV2FbWF09QmEueCxXYVtYKzFdPUJhLnksV2FbWCsyXT1CYS56O20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixiLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIpO20uYnVmZmVyRGF0YShtLkFSUkFZX0JVRkZFUixXYSxEYil9aWYoJGIpe2ZvcihhYT0wO2FhPHBiO2FhKyspRWI9SWJbYWFdLFg9MyphYSx0YltYXT1FYi5yLHRiW1grMV09RWIuZyx0YltYKzJdPUViLmI7bS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLGIuX193ZWJnbENvbG9yQnVmZmVyKTttLmJ1ZmZlckRhdGEobS5BUlJBWV9CVUZGRVIsdGIsRGIpfWlmKEZiKXtmb3IoWj0wO1o8cWI7WisrKWhiW1pdPWdiW1pdO20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixiLl9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIpO1xuICAgIG0uYnVmZmVyRGF0YShtLkFSUkFZX0JVRkZFUixoYixEYil9aWYoU2IpZm9yKEpiPTAsY2I9U2IubGVuZ3RoO0piPGNiO0piKyspaWYoZmE9U2JbSmJdLGZhLm5lZWRzVXBkYXRlJiYodm9pZCAwPT09ZmEuYm91bmRUb3x8XCJ2ZXJ0aWNlc1wiPT09ZmEuYm91bmRUbykpe1g9MDtLYj1mYS52YWx1ZS5sZW5ndGg7aWYoMT09PWZhLnNpemUpZm9yKHVhPTA7dWE8S2I7dWErKylmYS5hcnJheVt1YV09ZmEudmFsdWVbdWFdO2Vsc2UgaWYoMj09PWZhLnNpemUpZm9yKHVhPTA7dWE8S2I7dWErKylJYT1mYS52YWx1ZVt1YV0sZmEuYXJyYXlbWF09SWEueCxmYS5hcnJheVtYKzFdPUlhLnksWCs9MjtlbHNlIGlmKDM9PT1mYS5zaXplKWlmKFwiY1wiPT09ZmEudHlwZSlmb3IodWE9MDt1YTxLYjt1YSsrKUlhPWZhLnZhbHVlW3VhXSxmYS5hcnJheVtYXT1JYS5yLGZhLmFycmF5W1grMV09SWEuZyxmYS5hcnJheVtYKzJdPUlhLmIsWCs9MztlbHNlIGZvcih1YT0wO3VhPEtiO3VhKyspSWE9ZmEudmFsdWVbdWFdLFxuICAgIGZhLmFycmF5W1hdPUlhLngsZmEuYXJyYXlbWCsxXT1JYS55LGZhLmFycmF5W1grMl09SWEueixYKz0zO2Vsc2UgaWYoND09PWZhLnNpemUpZm9yKHVhPTA7dWE8S2I7dWErKylJYT1mYS52YWx1ZVt1YV0sZmEuYXJyYXlbWF09SWEueCxmYS5hcnJheVtYKzFdPUlhLnksZmEuYXJyYXlbWCsyXT1JYS56LGZhLmFycmF5W1grM109SWEudyxYKz00O20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixmYS5idWZmZXIpO20uYnVmZmVyRGF0YShtLkFSUkFZX0JVRkZFUixmYS5hcnJheSxEYik7ZmEubmVlZHNVcGRhdGU9ITF9fWIudmVydGljZXNOZWVkVXBkYXRlPSExO2IuY29sb3JzTmVlZFVwZGF0ZT0hMTtiLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlPSExO3cuYXR0cmlidXRlcyYmcyh3KX1lbHNlIGlmKGEgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkKXt3PWMoYSxiKTt1PXcuYXR0cmlidXRlcyYmcih3KTtpZihiLnZlcnRpY2VzTmVlZFVwZGF0ZXx8Yi5jb2xvcnNOZWVkVXBkYXRlfHxcbiAgICB1KXt2YXIgZGI9bS5EWU5BTUlDX0RSQVcsVGIsVWIsYWMsbWEsYmMsTmI9Yi52ZXJ0aWNlcyxWYj1OYi5sZW5ndGgsUGI9Yi5jb2xvcnMscmI9UGIubGVuZ3RoLGNjPWIuX192ZXJ0ZXhBcnJheSxkYz1iLl9fY29sb3JBcnJheSx3Yj1iLmNvbG9yc05lZWRVcGRhdGUsZ2M9Yi5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QsZWMsamIsdmEsTGIsSmEsZ2E7aWYoYi52ZXJ0aWNlc05lZWRVcGRhdGUpe2ZvcihUYj0wO1RiPFZiO1RiKyspYWM9TmJbVGJdLG1hPTMqVGIsY2NbbWFdPWFjLngsY2NbbWErMV09YWMueSxjY1ttYSsyXT1hYy56O20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixiLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIpO20uYnVmZmVyRGF0YShtLkFSUkFZX0JVRkZFUixjYyxkYil9aWYod2Ipe2ZvcihVYj0wO1ViPHJiO1ViKyspYmM9UGJbVWJdLG1hPTMqVWIsZGNbbWFdPWJjLnIsZGNbbWErMV09YmMuZyxkY1ttYSsyXT1iYy5iO20uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixcbiAgICBiLl9fd2ViZ2xDb2xvckJ1ZmZlcik7bS5idWZmZXJEYXRhKG0uQVJSQVlfQlVGRkVSLGRjLGRiKX1pZihnYylmb3IoZWM9MCxqYj1nYy5sZW5ndGg7ZWM8amI7ZWMrKyl7Z2E9Z2NbZWNdO2lmKGdhLm5lZWRzVXBkYXRlJiYodm9pZCAwPT09Z2EuYm91bmRUb3x8XCJ2ZXJ0aWNlc1wiPT09Z2EuYm91bmRUbykpaWYoTGI9Z2EudmFsdWUubGVuZ3RoLG1hPTAsMT09PWdhLnNpemUpZm9yKHZhPTA7dmE8TGI7dmErKylnYS5hcnJheVt2YV09Z2EudmFsdWVbdmFdO2Vsc2UgaWYoMj09PWdhLnNpemUpZm9yKHZhPTA7dmE8TGI7dmErKylKYT1nYS52YWx1ZVt2YV0sZ2EuYXJyYXlbbWFdPUphLngsZ2EuYXJyYXlbbWErMV09SmEueSxtYSs9MjtlbHNlIGlmKDM9PT1nYS5zaXplKWlmKFwiY1wiPT09Z2EudHlwZSlmb3IodmE9MDt2YTxMYjt2YSsrKUphPWdhLnZhbHVlW3ZhXSxnYS5hcnJheVttYV09SmEucixnYS5hcnJheVttYSsxXT1KYS5nLGdhLmFycmF5W21hKzJdPUphLmIsbWErPTM7ZWxzZSBmb3IodmE9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7dmE8TGI7dmErKylKYT1nYS52YWx1ZVt2YV0sZ2EuYXJyYXlbbWFdPUphLngsZ2EuYXJyYXlbbWErMV09SmEueSxnYS5hcnJheVttYSsyXT1KYS56LG1hKz0zO2Vsc2UgaWYoND09PWdhLnNpemUpZm9yKHZhPTA7dmE8TGI7dmErKylKYT1nYS52YWx1ZVt2YV0sZ2EuYXJyYXlbbWFdPUphLngsZ2EuYXJyYXlbbWErMV09SmEueSxnYS5hcnJheVttYSsyXT1KYS56LGdhLmFycmF5W21hKzNdPUphLncsbWErPTQ7bS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLGdhLmJ1ZmZlcik7bS5idWZmZXJEYXRhKG0uQVJSQVlfQlVGRkVSLGdhLmFycmF5LGRiKTtnYS5uZWVkc1VwZGF0ZT0hMX19Yi52ZXJ0aWNlc05lZWRVcGRhdGU9ITE7Yi5jb2xvcnNOZWVkVXBkYXRlPSExO3cuYXR0cmlidXRlcyYmcyh3KX19ZnVuY3Rpb24gcihhKXtmb3IodmFyIGIgaW4gYS5hdHRyaWJ1dGVzKWlmKGEuYXR0cmlidXRlc1tiXS5uZWVkc1VwZGF0ZSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBzKGEpe2Zvcih2YXIgYiBpbiBhLmF0dHJpYnV0ZXMpYS5hdHRyaWJ1dGVzW2JdLm5lZWRzVXBkYXRlPVxuICAgICExfWZ1bmN0aW9uIHUoYSl7ITA9PT1hLnRyYW5zcGFyZW50P1cuc2V0QmxlbmRpbmcoYS5ibGVuZGluZyxhLmJsZW5kRXF1YXRpb24sYS5ibGVuZFNyYyxhLmJsZW5kRHN0LGEuYmxlbmRFcXVhdGlvbkFscGhhLGEuYmxlbmRTcmNBbHBoYSxhLmJsZW5kRHN0QWxwaGEpOlcuc2V0QmxlbmRpbmcoVEhSRUUuTm9CbGVuZGluZyk7Vy5zZXREZXB0aFRlc3QoYS5kZXB0aFRlc3QpO1cuc2V0RGVwdGhXcml0ZShhLmRlcHRoV3JpdGUpO1cuc2V0Q29sb3JXcml0ZShhLmNvbG9yV3JpdGUpO1cuc2V0UG9seWdvbk9mZnNldChhLnBvbHlnb25PZmZzZXQsYS5wb2x5Z29uT2Zmc2V0RmFjdG9yLGEucG9seWdvbk9mZnNldFVuaXRzKX1mdW5jdGlvbiB2KGEsYixjLGQsZSl7dmFyIGYsZyxoLGs7TWI9MDtpZihkLm5lZWRzVXBkYXRlKXtkLnByb2dyYW0mJmhjKGQpO2QuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixpYyk7dmFyIG49cGNbZC50eXBlXTtpZihuKXt2YXIgbD1USFJFRS5TaGFkZXJMaWJbbl07XG4gICAgZC5fX3dlYmdsU2hhZGVyPXt1bmlmb3JtczpUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKGwudW5pZm9ybXMpLHZlcnRleFNoYWRlcjpsLnZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcjpsLmZyYWdtZW50U2hhZGVyfX1lbHNlIGQuX193ZWJnbFNoYWRlcj17dW5pZm9ybXM6ZC51bmlmb3Jtcyx2ZXJ0ZXhTaGFkZXI6ZC52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6ZC5mcmFnbWVudFNoYWRlcn07Zm9yKHZhciBwPTAscT0wLHI9MCxzPTAsdD0wLHc9Yi5sZW5ndGg7dDx3O3QrKyl7dmFyIHY9Ylt0XTt2Lm9ubHlTaGFkb3d8fCExPT09di52aXNpYmxlfHwodiBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQmJnArKyx2IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCYmcSsrLHYgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQmJnIrKyx2IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0JiZzKyspfWY9cDtnPXE7aD1yO2s9cztmb3IodmFyIHUsej0wLEc9XG4gICAgMCxGPWIubGVuZ3RoO0c8RjtHKyspe3ZhciBKPWJbR107Si5jYXN0U2hhZG93JiYoSiBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCYmeisrLEogaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0JiYhSi5zaGFkb3dDYXNjYWRlJiZ6KyspfXU9ejt2YXIgSDtpZihOYiYmZSYmZS5za2VsZXRvbiYmZS5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlKUg9MTAyNDtlbHNle3ZhciBOPW0uZ2V0UGFyYW1ldGVyKG0uTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMpLE09TWF0aC5mbG9vcigoTi0yMCkvNCk7dm9pZCAwIT09ZSYmZSBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoJiYoTT1NYXRoLm1pbihlLnNrZWxldG9uLmJvbmVzLmxlbmd0aCxNKSxNPGUuc2tlbGV0b24uYm9uZXMubGVuZ3RoJiZUSFJFRS53YXJuKFwiV2ViR0xSZW5kZXJlcjogdG9vIG1hbnkgYm9uZXMgLSBcIitlLnNrZWxldG9uLmJvbmVzLmxlbmd0aCtcIiwgdGhpcyBHUFUgc3VwcG9ydHMganVzdCBcIitNK1wiICh0cnkgT3BlbkdMIGluc3RlYWQgb2YgQU5HTEUpXCIpKTtcbiAgICBIPU19dmFyIFA9e3ByZWNpc2lvbjpMLHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6VmIsbWFwOiEhZC5tYXAsZW52TWFwOiEhZC5lbnZNYXAsZW52TWFwTW9kZTpkLmVudk1hcCYmZC5lbnZNYXAubWFwcGluZyxsaWdodE1hcDohIWQubGlnaHRNYXAsYnVtcE1hcDohIWQuYnVtcE1hcCxub3JtYWxNYXA6ISFkLm5vcm1hbE1hcCxzcGVjdWxhck1hcDohIWQuc3BlY3VsYXJNYXAsYWxwaGFNYXA6ISFkLmFscGhhTWFwLGNvbWJpbmU6ZC5jb21iaW5lLHZlcnRleENvbG9yczpkLnZlcnRleENvbG9ycyxmb2c6Yyx1c2VGb2c6ZC5mb2csZm9nRXhwOmMgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyLGZsYXRTaGFkaW5nOmQuc2hhZGluZz09PVRIUkVFLkZsYXRTaGFkaW5nLHNpemVBdHRlbnVhdGlvbjpkLnNpemVBdHRlbnVhdGlvbixsb2dhcml0aG1pY0RlcHRoQnVmZmVyOmphLHNraW5uaW5nOmQuc2tpbm5pbmcsbWF4Qm9uZXM6SCx1c2VWZXJ0ZXhUZXh0dXJlOk5iJiZlJiZlLnNrZWxldG9uJiZcbmUuc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSxtb3JwaFRhcmdldHM6ZC5tb3JwaFRhcmdldHMsbW9ycGhOb3JtYWxzOmQubW9ycGhOb3JtYWxzLG1heE1vcnBoVGFyZ2V0czpCLm1heE1vcnBoVGFyZ2V0cyxtYXhNb3JwaE5vcm1hbHM6Qi5tYXhNb3JwaE5vcm1hbHMsbWF4RGlyTGlnaHRzOmYsbWF4UG9pbnRMaWdodHM6ZyxtYXhTcG90TGlnaHRzOmgsbWF4SGVtaUxpZ2h0czprLG1heFNoYWRvd3M6dSxzaGFkb3dNYXBFbmFibGVkOkIuc2hhZG93TWFwRW5hYmxlZCYmZS5yZWNlaXZlU2hhZG93JiYwPHUsc2hhZG93TWFwVHlwZTpCLnNoYWRvd01hcFR5cGUsc2hhZG93TWFwRGVidWc6Qi5zaGFkb3dNYXBEZWJ1ZyxzaGFkb3dNYXBDYXNjYWRlOkIuc2hhZG93TWFwQ2FzY2FkZSxhbHBoYVRlc3Q6ZC5hbHBoYVRlc3QsbWV0YWw6ZC5tZXRhbCx3cmFwQXJvdW5kOmQud3JhcEFyb3VuZCxkb3VibGVTaWRlZDpkLnNpZGU9PT1USFJFRS5Eb3VibGVTaWRlLGZsaXBTaWRlZDpkLnNpZGU9PT1cblRIUkVFLkJhY2tTaWRlfSxSPVtdO24/Ui5wdXNoKG4pOihSLnB1c2goZC5mcmFnbWVudFNoYWRlciksUi5wdXNoKGQudmVydGV4U2hhZGVyKSk7aWYodm9pZCAwIT09ZC5kZWZpbmVzKWZvcih2YXIgTyBpbiBkLmRlZmluZXMpUi5wdXNoKE8pLFIucHVzaChkLmRlZmluZXNbT10pO2ZvcihPIGluIFApUi5wdXNoKE8pLFIucHVzaChQW09dKTtmb3IodmFyIEthPVIuam9pbigpLFYsVz0wLFFhPVBhLmxlbmd0aDtXPFFhO1crKyl7dmFyIFlhPVBhW1ddO2lmKFlhLmNvZGU9PT1LYSl7Vj1ZYTtWLnVzZWRUaW1lcysrO2JyZWFrfX12b2lkIDA9PT1WJiYoVj1uZXcgVEhSRUUuV2ViR0xQcm9ncmFtKEIsS2EsZCxQKSxQYS5wdXNoKFYpLEIuaW5mby5tZW1vcnkucHJvZ3JhbXM9UGEubGVuZ3RoKTtkLnByb2dyYW09Vjt2YXIgWGE9Vi5hdHRyaWJ1dGVzO2lmKGQubW9ycGhUYXJnZXRzKXtkLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cz0wO2Zvcih2YXIgY2EsZGE9XCJtb3JwaFRhcmdldFwiLGJhPVxuICAgIDA7YmE8Qi5tYXhNb3JwaFRhcmdldHM7YmErKyljYT1kYStiYSwwPD1YYVtjYV0mJmQubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzKyt9aWYoZC5tb3JwaE5vcm1hbHMpZm9yKGQubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzPTAsZGE9XCJtb3JwaE5vcm1hbFwiLGJhPTA7YmE8Qi5tYXhNb3JwaE5vcm1hbHM7YmErKyljYT1kYStiYSwwPD1YYVtjYV0mJmQubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzKys7ZC51bmlmb3Jtc0xpc3Q9W107Zm9yKHZhciBoYSBpbiBkLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXMpe3ZhciB0YT1kLnByb2dyYW0udW5pZm9ybXNbaGFdO3RhJiZkLnVuaWZvcm1zTGlzdC5wdXNoKFtkLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXNbaGFdLHRhXSl9ZC5uZWVkc1VwZGF0ZT0hMX1kLm1vcnBoVGFyZ2V0cyYmIWUuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcyYmKGUuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcz1uZXcgRmxvYXQzMkFycmF5KEIubWF4TW9ycGhUYXJnZXRzKSk7XG4gICAgdmFyIGFiPSExLG9hPSExLHFhPSExLFVhPWQucHJvZ3JhbSxrYT1VYS51bmlmb3JtcyxRPWQuX193ZWJnbFNoYWRlci51bmlmb3JtcztVYS5pZCE9PW9iJiYobS51c2VQcm9ncmFtKFVhLnByb2dyYW0pLG9iPVVhLmlkLHFhPW9hPWFiPSEwKTtkLmlkIT09dWImJigtMT09PXViJiYocWE9ITApLHViPWQuaWQsb2E9ITApO2lmKGFifHxhIT09dmIpbS51bmlmb3JtTWF0cml4NGZ2KGthLnByb2plY3Rpb25NYXRyaXgsITEsYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzKSxqYSYmbS51bmlmb3JtMWYoa2EubG9nRGVwdGhCdWZGQywyLyhNYXRoLmxvZyhhLmZhcisxKS9NYXRoLkxOMikpLGEhPT12YiYmKHZiPWEpLChkIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWx8fGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbHx8ZC5lbnZNYXApJiZudWxsIT09a2EuY2FtZXJhUG9zaXRpb24mJih3YS5zZXRGcm9tTWF0cml4UG9zaXRpb24oYS5tYXRyaXhXb3JsZCksbS51bmlmb3JtM2Yoa2EuY2FtZXJhUG9zaXRpb24sXG4gICAgICAgIHdhLngsd2EueSx3YS56KSksKGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbHx8ZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWx8fGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbHx8ZCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsfHxkLnNraW5uaW5nKSYmbnVsbCE9PWthLnZpZXdNYXRyaXgmJm0udW5pZm9ybU1hdHJpeDRmdihrYS52aWV3TWF0cml4LCExLGEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzKTtpZihkLnNraW5uaW5nKWlmKGUuYmluZE1hdHJpeCYmbnVsbCE9PWthLmJpbmRNYXRyaXgmJm0udW5pZm9ybU1hdHJpeDRmdihrYS5iaW5kTWF0cml4LCExLGUuYmluZE1hdHJpeC5lbGVtZW50cyksZS5iaW5kTWF0cml4SW52ZXJzZSYmbnVsbCE9PWthLmJpbmRNYXRyaXhJbnZlcnNlJiZtLnVuaWZvcm1NYXRyaXg0ZnYoa2EuYmluZE1hdHJpeEludmVyc2UsITEsZS5iaW5kTWF0cml4SW52ZXJzZS5lbGVtZW50cyksXG4gICAgICAgIE5iJiZlLnNrZWxldG9uJiZlLnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUpe2lmKG51bGwhPT1rYS5ib25lVGV4dHVyZSl7dmFyIGRiPUQoKTttLnVuaWZvcm0xaShrYS5ib25lVGV4dHVyZSxkYik7Qi5zZXRUZXh0dXJlKGUuc2tlbGV0b24uYm9uZVRleHR1cmUsZGIpfW51bGwhPT1rYS5ib25lVGV4dHVyZVdpZHRoJiZtLnVuaWZvcm0xaShrYS5ib25lVGV4dHVyZVdpZHRoLGUuc2tlbGV0b24uYm9uZVRleHR1cmVXaWR0aCk7bnVsbCE9PWthLmJvbmVUZXh0dXJlSGVpZ2h0JiZtLnVuaWZvcm0xaShrYS5ib25lVGV4dHVyZUhlaWdodCxlLnNrZWxldG9uLmJvbmVUZXh0dXJlSGVpZ2h0KX1lbHNlIGUuc2tlbGV0b24mJmUuc2tlbGV0b24uYm9uZU1hdHJpY2VzJiZudWxsIT09a2EuYm9uZUdsb2JhbE1hdHJpY2VzJiZtLnVuaWZvcm1NYXRyaXg0ZnYoa2EuYm9uZUdsb2JhbE1hdHJpY2VzLCExLGUuc2tlbGV0b24uYm9uZU1hdHJpY2VzKTtpZihvYSl7YyYmZC5mb2cmJihRLmZvZ0NvbG9yLnZhbHVlPVxuICAgICAgICBjLmNvbG9yLGMgaW5zdGFuY2VvZiBUSFJFRS5Gb2c/KFEuZm9nTmVhci52YWx1ZT1jLm5lYXIsUS5mb2dGYXIudmFsdWU9Yy5mYXIpOmMgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyJiYoUS5mb2dEZW5zaXR5LnZhbHVlPWMuZGVuc2l0eSkpO2lmKGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbHx8ZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWx8fGQubGlnaHRzKXtpZihPYil7dmFyIHFhPSEwLGlhLFphLFksYmI9MCxjYj0wLGliPTAseGIscGIscWIsQ2EsamIsbmE9amMscmI9bmEuZGlyZWN0aW9uYWwuY29sb3JzLExhPW5hLmRpcmVjdGlvbmFsLnBvc2l0aW9ucyxNYT1uYS5wb2ludC5jb2xvcnMsa2I9bmEucG9pbnQucG9zaXRpb25zLHliPW5hLnBvaW50LmRpc3RhbmNlcyx6Yj1uYS5wb2ludC5kZWNheXMsUmE9bmEuc3BvdC5jb2xvcnMsQWE9bmEuc3BvdC5wb3NpdGlvbnMsZWI9bmEuc3BvdC5kaXN0YW5jZXMsSGE9bmEuc3BvdC5kaXJlY3Rpb25zLFxuICAgICAgICBsYT1uYS5zcG90LmFuZ2xlc0NvcyxyYT1uYS5zcG90LmV4cG9uZW50cyxLPW5hLnNwb3QuZGVjYXlzLHphPW5hLmhlbWkuc2t5Q29sb3JzLFNhPW5hLmhlbWkuZ3JvdW5kQ29sb3JzLEFiPW5hLmhlbWkucG9zaXRpb25zLGxiPTAsTmE9MCxzYT0wLERhPTAsRWE9MCxGYT0wLEdiPTAsQmI9MCxtYj0wLEM9MCxWYT0wLFRhPTA7aWE9MDtmb3IoWmE9Yi5sZW5ndGg7aWE8WmE7aWErKylZPWJbaWFdLFkub25seVNoYWRvd3x8KHhiPVkuY29sb3IsQ2E9WS5pbnRlbnNpdHksamI9WS5kaXN0YW5jZSxZIGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0P1kudmlzaWJsZSYmKGJiKz14Yi5yLGNiKz14Yi5nLGliKz14Yi5iKTpZIGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodD8oRWErPTEsWS52aXNpYmxlJiYocGEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFkubWF0cml4V29ybGQpLHdhLnNldEZyb21NYXRyaXhQb3NpdGlvbihZLnRhcmdldC5tYXRyaXhXb3JsZCkscGEuc3ViKHdhKSxcbiAgICAgICAgcGEubm9ybWFsaXplKCksbWI9MypsYixMYVttYl09cGEueCxMYVttYisxXT1wYS55LExhW21iKzJdPXBhLnoseShyYixtYix4YixDYSksbGIrPTEpKTpZIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodD8oRmErPTEsWS52aXNpYmxlJiYoQz0zKk5hLHkoTWEsQyx4YixDYSksd2Euc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFkubWF0cml4V29ybGQpLGtiW0NdPXdhLngsa2JbQysxXT13YS55LGtiW0MrMl09d2Eueix5YltOYV09amIsemJbTmFdPTA9PT1ZLmRpc3RhbmNlPzA6WS5kZWNheSxOYSs9MSkpOlkgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQ/KEdiKz0xLFkudmlzaWJsZSYmKFZhPTMqc2EseShSYSxWYSx4YixDYSkscGEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFkubWF0cml4V29ybGQpLEFhW1ZhXT1wYS54LEFhW1ZhKzFdPXBhLnksQWFbVmErMl09cGEueixlYltzYV09amIsd2Euc2V0RnJvbU1hdHJpeFBvc2l0aW9uKFkudGFyZ2V0Lm1hdHJpeFdvcmxkKSxwYS5zdWIod2EpLFxuICAgICAgICBwYS5ub3JtYWxpemUoKSxIYVtWYV09cGEueCxIYVtWYSsxXT1wYS55LEhhW1ZhKzJdPXBhLnosbGFbc2FdPU1hdGguY29zKFkuYW5nbGUpLHJhW3NhXT1ZLmV4cG9uZW50LEtbc2FdPTA9PT1ZLmRpc3RhbmNlPzA6WS5kZWNheSxzYSs9MSkpOlkgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQmJihCYis9MSxZLnZpc2libGUmJihwYS5zZXRGcm9tTWF0cml4UG9zaXRpb24oWS5tYXRyaXhXb3JsZCkscGEubm9ybWFsaXplKCksVGE9MypEYSxBYltUYV09cGEueCxBYltUYSsxXT1wYS55LEFiW1RhKzJdPXBhLnoscGI9WS5jb2xvcixxYj1ZLmdyb3VuZENvbG9yLHkoemEsVGEscGIsQ2EpLHkoU2EsVGEscWIsQ2EpLERhKz0xKSkpO2lhPTMqbGI7Zm9yKFphPU1hdGgubWF4KHJiLmxlbmd0aCwzKkVhKTtpYTxaYTtpYSsrKXJiW2lhXT0wO2lhPTMqTmE7Zm9yKFphPU1hdGgubWF4KE1hLmxlbmd0aCwzKkZhKTtpYTxaYTtpYSsrKU1hW2lhXT0wO2lhPTMqc2E7Zm9yKFphPU1hdGgubWF4KFJhLmxlbmd0aCxcbiAgICAgICAgMypHYik7aWE8WmE7aWErKylSYVtpYV09MDtpYT0zKkRhO2ZvcihaYT1NYXRoLm1heCh6YS5sZW5ndGgsMypCYik7aWE8WmE7aWErKyl6YVtpYV09MDtpYT0zKkRhO2ZvcihaYT1NYXRoLm1heChTYS5sZW5ndGgsMypCYik7aWE8WmE7aWErKylTYVtpYV09MDtuYS5kaXJlY3Rpb25hbC5sZW5ndGg9bGI7bmEucG9pbnQubGVuZ3RoPU5hO25hLnNwb3QubGVuZ3RoPXNhO25hLmhlbWkubGVuZ3RoPURhO25hLmFtYmllbnRbMF09YmI7bmEuYW1iaWVudFsxXT1jYjtuYS5hbWJpZW50WzJdPWliO09iPSExfWlmKHFhKXt2YXIgZWE9amM7US5hbWJpZW50TGlnaHRDb2xvci52YWx1ZT1lYS5hbWJpZW50O1EuZGlyZWN0aW9uYWxMaWdodENvbG9yLnZhbHVlPWVhLmRpcmVjdGlvbmFsLmNvbG9ycztRLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb24udmFsdWU9ZWEuZGlyZWN0aW9uYWwucG9zaXRpb25zO1EucG9pbnRMaWdodENvbG9yLnZhbHVlPWVhLnBvaW50LmNvbG9ycztRLnBvaW50TGlnaHRQb3NpdGlvbi52YWx1ZT1cbiAgICAgICAgZWEucG9pbnQucG9zaXRpb25zO1EucG9pbnRMaWdodERpc3RhbmNlLnZhbHVlPWVhLnBvaW50LmRpc3RhbmNlcztRLnBvaW50TGlnaHREZWNheS52YWx1ZT1lYS5wb2ludC5kZWNheXM7US5zcG90TGlnaHRDb2xvci52YWx1ZT1lYS5zcG90LmNvbG9ycztRLnNwb3RMaWdodFBvc2l0aW9uLnZhbHVlPWVhLnNwb3QucG9zaXRpb25zO1Euc3BvdExpZ2h0RGlzdGFuY2UudmFsdWU9ZWEuc3BvdC5kaXN0YW5jZXM7US5zcG90TGlnaHREaXJlY3Rpb24udmFsdWU9ZWEuc3BvdC5kaXJlY3Rpb25zO1Euc3BvdExpZ2h0QW5nbGVDb3MudmFsdWU9ZWEuc3BvdC5hbmdsZXNDb3M7US5zcG90TGlnaHRFeHBvbmVudC52YWx1ZT1lYS5zcG90LmV4cG9uZW50cztRLnNwb3RMaWdodERlY2F5LnZhbHVlPWVhLnNwb3QuZGVjYXlzO1EuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IudmFsdWU9ZWEuaGVtaS5za3lDb2xvcnM7US5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci52YWx1ZT1lYS5oZW1pLmdyb3VuZENvbG9ycztcbiAgICAgICAgUS5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24udmFsdWU9ZWEuaGVtaS5wb3NpdGlvbnM7eChRLCEwKX1lbHNlIHgoUSwhMSl9aWYoZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsfHxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbHx8ZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKXtRLm9wYWNpdHkudmFsdWU9ZC5vcGFjaXR5O1EuZGlmZnVzZS52YWx1ZT1kLmNvbG9yO1EubWFwLnZhbHVlPWQubWFwO1EubGlnaHRNYXAudmFsdWU9ZC5saWdodE1hcDtRLnNwZWN1bGFyTWFwLnZhbHVlPWQuc3BlY3VsYXJNYXA7US5hbHBoYU1hcC52YWx1ZT1kLmFscGhhTWFwO2QuYnVtcE1hcCYmKFEuYnVtcE1hcC52YWx1ZT1kLmJ1bXBNYXAsUS5idW1wU2NhbGUudmFsdWU9ZC5idW1wU2NhbGUpO2Qubm9ybWFsTWFwJiYoUS5ub3JtYWxNYXAudmFsdWU9ZC5ub3JtYWxNYXAsUS5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KGQubm9ybWFsU2NhbGUpKTtcbiAgICAgICAgdmFyIGZiO2QubWFwP2ZiPWQubWFwOmQuc3BlY3VsYXJNYXA/ZmI9ZC5zcGVjdWxhck1hcDpkLm5vcm1hbE1hcD9mYj1kLm5vcm1hbE1hcDpkLmJ1bXBNYXA/ZmI9ZC5idW1wTWFwOmQuYWxwaGFNYXAmJihmYj1kLmFscGhhTWFwKTtpZih2b2lkIDAhPT1mYil7dmFyIHdiPWZiLm9mZnNldCxRYj1mYi5yZXBlYXQ7US5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KHdiLngsd2IueSxRYi54LFFiLnkpfVEuZW52TWFwLnZhbHVlPWQuZW52TWFwO1EuZmxpcEVudk1hcC52YWx1ZT1kLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZT8xOi0xO1EucmVmbGVjdGl2aXR5LnZhbHVlPWQucmVmbGVjdGl2aXR5O1EucmVmcmFjdGlvblJhdGlvLnZhbHVlPWQucmVmcmFjdGlvblJhdGlvfWlmKGQgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbClRLmRpZmZ1c2UudmFsdWU9ZC5jb2xvcixRLm9wYWNpdHkudmFsdWU9ZC5vcGFjaXR5O2Vsc2UgaWYoZCBpbnN0YW5jZW9mXG4gICAgICAgIFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbClRLmRpZmZ1c2UudmFsdWU9ZC5jb2xvcixRLm9wYWNpdHkudmFsdWU9ZC5vcGFjaXR5LFEuZGFzaFNpemUudmFsdWU9ZC5kYXNoU2l6ZSxRLnRvdGFsU2l6ZS52YWx1ZT1kLmRhc2hTaXplK2QuZ2FwU2l6ZSxRLnNjYWxlLnZhbHVlPWQuc2NhbGU7ZWxzZSBpZihkIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsKXtpZihRLnBzQ29sb3IudmFsdWU9ZC5jb2xvcixRLm9wYWNpdHkudmFsdWU9ZC5vcGFjaXR5LFEuc2l6ZS52YWx1ZT1kLnNpemUsUS5zY2FsZS52YWx1ZT1VLmhlaWdodC8yLFEubWFwLnZhbHVlPWQubWFwLG51bGwhPT1kLm1hcCl7dmFyIFdiPWQubWFwLm9mZnNldCxYYj1kLm1hcC5yZXBlYXQ7US5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KFdiLngsV2IueSxYYi54LFhiLnkpfX1lbHNlIGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbD8oUS5zaGluaW5lc3MudmFsdWU9ZC5zaGluaW5lc3MsUS5lbWlzc2l2ZS52YWx1ZT1cbiAgICAgICAgZC5lbWlzc2l2ZSxRLnNwZWN1bGFyLnZhbHVlPWQuc3BlY3VsYXIsZC53cmFwQXJvdW5kJiZRLndyYXBSR0IudmFsdWUuY29weShkLndyYXBSR0IpKTpkIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbD8oUS5lbWlzc2l2ZS52YWx1ZT1kLmVtaXNzaXZlLGQud3JhcEFyb3VuZCYmUS53cmFwUkdCLnZhbHVlLmNvcHkoZC53cmFwUkdCKSk6ZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsPyhRLm1OZWFyLnZhbHVlPWEubmVhcixRLm1GYXIudmFsdWU9YS5mYXIsUS5vcGFjaXR5LnZhbHVlPWQub3BhY2l0eSk6ZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCYmKFEub3BhY2l0eS52YWx1ZT1kLm9wYWNpdHkpO2lmKGUucmVjZWl2ZVNoYWRvdyYmIWQuX3NoYWRvd1Bhc3MmJlEuc2hhZG93TWF0cml4KWZvcih2YXIgc2I9MCxDYj0wLCQ9Yi5sZW5ndGg7Q2I8JDtDYisrKXt2YXIgeGE9YltDYl07eGEuY2FzdFNoYWRvdyYmKHhhIGluc3RhbmNlb2ZcbiAgICBUSFJFRS5TcG90TGlnaHR8fHhhIGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCYmIXhhLnNoYWRvd0Nhc2NhZGUpJiYoUS5zaGFkb3dNYXAudmFsdWVbc2JdPXhhLnNoYWRvd01hcCxRLnNoYWRvd01hcFNpemUudmFsdWVbc2JdPXhhLnNoYWRvd01hcFNpemUsUS5zaGFkb3dNYXRyaXgudmFsdWVbc2JdPXhhLnNoYWRvd01hdHJpeCxRLnNoYWRvd0RhcmtuZXNzLnZhbHVlW3NiXT14YS5zaGFkb3dEYXJrbmVzcyxRLnNoYWRvd0JpYXMudmFsdWVbc2JdPXhhLnNoYWRvd0JpYXMsc2IrKyl9Zm9yKHZhciBIYj1kLnVuaWZvcm1zTGlzdCxPYSwkYSxHYSxuYj0wLGZjPUhiLmxlbmd0aDtuYjxmYztuYisrKXt2YXIgVD1IYltuYl1bMF07aWYoITEhPT1ULm5lZWRzVXBkYXRlKXt2YXIgRGI9VC50eXBlLFM9VC52YWx1ZSxhYT1IYltuYl1bMV07c3dpdGNoKERiKXtjYXNlIFwiMWlcIjptLnVuaWZvcm0xaShhYSxTKTticmVhaztjYXNlIFwiMWZcIjptLnVuaWZvcm0xZihhYSxTKTticmVhaztcbiAgICAgICAgY2FzZSBcIjJmXCI6bS51bmlmb3JtMmYoYWEsU1swXSxTWzFdKTticmVhaztjYXNlIFwiM2ZcIjptLnVuaWZvcm0zZihhYSxTWzBdLFNbMV0sU1syXSk7YnJlYWs7Y2FzZSBcIjRmXCI6bS51bmlmb3JtNGYoYWEsU1swXSxTWzFdLFNbMl0sU1szXSk7YnJlYWs7Y2FzZSBcIjFpdlwiOm0udW5pZm9ybTFpdihhYSxTKTticmVhaztjYXNlIFwiM2l2XCI6bS51bmlmb3JtM2l2KGFhLFMpO2JyZWFrO2Nhc2UgXCIxZnZcIjptLnVuaWZvcm0xZnYoYWEsUyk7YnJlYWs7Y2FzZSBcIjJmdlwiOm0udW5pZm9ybTJmdihhYSxTKTticmVhaztjYXNlIFwiM2Z2XCI6bS51bmlmb3JtM2Z2KGFhLFMpO2JyZWFrO2Nhc2UgXCI0ZnZcIjptLnVuaWZvcm00ZnYoYWEsUyk7YnJlYWs7Y2FzZSBcIk1hdHJpeDNmdlwiOm0udW5pZm9ybU1hdHJpeDNmdihhYSwhMSxTKTticmVhaztjYXNlIFwiTWF0cml4NGZ2XCI6bS51bmlmb3JtTWF0cml4NGZ2KGFhLCExLFMpO2JyZWFrO2Nhc2UgXCJpXCI6bS51bmlmb3JtMWkoYWEsUyk7YnJlYWs7Y2FzZSBcImZcIjptLnVuaWZvcm0xZihhYSxcbiAgICAgICAgICAgIFMpO2JyZWFrO2Nhc2UgXCJ2MlwiOm0udW5pZm9ybTJmKGFhLFMueCxTLnkpO2JyZWFrO2Nhc2UgXCJ2M1wiOm0udW5pZm9ybTNmKGFhLFMueCxTLnksUy56KTticmVhaztjYXNlIFwidjRcIjptLnVuaWZvcm00ZihhYSxTLngsUy55LFMueixTLncpO2JyZWFrO2Nhc2UgXCJjXCI6bS51bmlmb3JtM2YoYWEsUy5yLFMuZyxTLmIpO2JyZWFrO2Nhc2UgXCJpdjFcIjptLnVuaWZvcm0xaXYoYWEsUyk7YnJlYWs7Y2FzZSBcIml2XCI6bS51bmlmb3JtM2l2KGFhLFMpO2JyZWFrO2Nhc2UgXCJmdjFcIjptLnVuaWZvcm0xZnYoYWEsUyk7YnJlYWs7Y2FzZSBcImZ2XCI6bS51bmlmb3JtM2Z2KGFhLFMpO2JyZWFrO2Nhc2UgXCJ2MnZcIjp2b2lkIDA9PT1ULl9hcnJheSYmKFQuX2FycmF5PW5ldyBGbG9hdDMyQXJyYXkoMipTLmxlbmd0aCkpO2Zvcih2YXIgWj0wLEJhPVMubGVuZ3RoO1o8QmE7WisrKUdhPTIqWixULl9hcnJheVtHYV09U1taXS54LFQuX2FycmF5W0dhKzFdPVNbWl0ueTttLnVuaWZvcm0yZnYoYWEsVC5fYXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7Y2FzZSBcInYzdlwiOnZvaWQgMD09PVQuX2FycmF5JiYoVC5fYXJyYXk9bmV3IEZsb2F0MzJBcnJheSgzKlMubGVuZ3RoKSk7Wj0wO2ZvcihCYT1TLmxlbmd0aDtaPEJhO1orKylHYT0zKlosVC5fYXJyYXlbR2FdPVNbWl0ueCxULl9hcnJheVtHYSsxXT1TW1pdLnksVC5fYXJyYXlbR2ErMl09U1taXS56O20udW5pZm9ybTNmdihhYSxULl9hcnJheSk7YnJlYWs7Y2FzZSBcInY0dlwiOnZvaWQgMD09PVQuX2FycmF5JiYoVC5fYXJyYXk9bmV3IEZsb2F0MzJBcnJheSg0KlMubGVuZ3RoKSk7Wj0wO2ZvcihCYT1TLmxlbmd0aDtaPEJhO1orKylHYT00KlosVC5fYXJyYXlbR2FdPVNbWl0ueCxULl9hcnJheVtHYSsxXT1TW1pdLnksVC5fYXJyYXlbR2ErMl09U1taXS56LFQuX2FycmF5W0dhKzNdPVNbWl0udzttLnVuaWZvcm00ZnYoYWEsVC5fYXJyYXkpO2JyZWFrO2Nhc2UgXCJtM1wiOm0udW5pZm9ybU1hdHJpeDNmdihhYSwhMSxTLmVsZW1lbnRzKTticmVhaztjYXNlIFwibTN2XCI6dm9pZCAwPT09XG4gICAgICAgIFQuX2FycmF5JiYoVC5fYXJyYXk9bmV3IEZsb2F0MzJBcnJheSg5KlMubGVuZ3RoKSk7Wj0wO2ZvcihCYT1TLmxlbmd0aDtaPEJhO1orKylTW1pdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KFQuX2FycmF5LDkqWik7bS51bmlmb3JtTWF0cml4M2Z2KGFhLCExLFQuX2FycmF5KTticmVhaztjYXNlIFwibTRcIjptLnVuaWZvcm1NYXRyaXg0ZnYoYWEsITEsUy5lbGVtZW50cyk7YnJlYWs7Y2FzZSBcIm00dlwiOnZvaWQgMD09PVQuX2FycmF5JiYoVC5fYXJyYXk9bmV3IEZsb2F0MzJBcnJheSgxNipTLmxlbmd0aCkpO1o9MDtmb3IoQmE9Uy5sZW5ndGg7WjxCYTtaKyspU1taXS5mbGF0dGVuVG9BcnJheU9mZnNldChULl9hcnJheSwxNipaKTttLnVuaWZvcm1NYXRyaXg0ZnYoYWEsITEsVC5fYXJyYXkpO2JyZWFrO2Nhc2UgXCJ0XCI6T2E9UzskYT1EKCk7bS51bmlmb3JtMWkoYWEsJGEpO2lmKCFPYSljb250aW51ZTtpZihPYSBpbnN0YW5jZW9mIFRIUkVFLkN1YmVUZXh0dXJlfHxPYS5pbWFnZSBpbnN0YW5jZW9mXG4gICAgICAgICAgICBBcnJheSYmNj09PU9hLmltYWdlLmxlbmd0aCl7dmFyIFg9T2EsRWI9JGE7aWYoNj09PVguaW1hZ2UubGVuZ3RoKWlmKFgubmVlZHNVcGRhdGUpe1guaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlfHwoWC5hZGRFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLFBiKSxYLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZT1tLmNyZWF0ZVRleHR1cmUoKSxCLmluZm8ubWVtb3J5LnRleHR1cmVzKyspO20uYWN0aXZlVGV4dHVyZShtLlRFWFRVUkUwK0ViKTttLmJpbmRUZXh0dXJlKG0uVEVYVFVSRV9DVUJFX01BUCxYLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSk7bS5waXhlbFN0b3JlaShtLlVOUEFDS19GTElQX1lfV0VCR0wsWC5mbGlwWSk7Zm9yKHZhciBSYj1YIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUsSWI9WC5pbWFnZVswXWluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmUsZ2I9W10seWE9MDs2PnlhO3lhKyspZ2JbeWFdPSFCLmF1dG9TY2FsZUN1YmVtYXBzfHxSYnx8SWI/SWI/XG4gICAgICAgICAgICBYLmltYWdlW3lhXS5pbWFnZTpYLmltYWdlW3lhXTpFKFguaW1hZ2VbeWFdLHFjKTt2YXIgWWI9Z2JbMF0sWmI9VEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oWWIud2lkdGgpJiZUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byhZYi5oZWlnaHQpLFdhPUkoWC5mb3JtYXQpLHRiPUkoWC50eXBlKTtBKG0uVEVYVFVSRV9DVUJFX01BUCxYLFpiKTtmb3IoeWE9MDs2PnlhO3lhKyspaWYoUmIpZm9yKHZhciBoYiwkYj1nYlt5YV0ubWlwbWFwcyxGYj0wLFNiPSRiLmxlbmd0aDtGYjxTYjtGYisrKWhiPSRiW0ZiXSxYLmZvcm1hdCE9PVRIUkVFLlJHQkFGb3JtYXQmJlguZm9ybWF0IT09VEhSRUUuUkdCRm9ybWF0Py0xPGtjKCkuaW5kZXhPZihXYSk/bS5jb21wcmVzc2VkVGV4SW1hZ2UyRChtLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCt5YSxGYixXYSxoYi53aWR0aCxoYi5oZWlnaHQsMCxoYi5kYXRhKTpUSFJFRS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldEN1YmVUZXh0dXJlKClcIik6XG4gICAgICAgICAgICBtLnRleEltYWdlMkQobS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1greWEsRmIsV2EsaGIud2lkdGgsaGIuaGVpZ2h0LDAsV2EsdGIsaGIuZGF0YSk7ZWxzZSBJYj9tLnRleEltYWdlMkQobS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1greWEsMCxXYSxnYlt5YV0ud2lkdGgsZ2JbeWFdLmhlaWdodCwwLFdhLHRiLGdiW3lhXS5kYXRhKTptLnRleEltYWdlMkQobS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1greWEsMCxXYSxXYSx0YixnYlt5YV0pO1guZ2VuZXJhdGVNaXBtYXBzJiZaYiYmbS5nZW5lcmF0ZU1pcG1hcChtLlRFWFRVUkVfQ1VCRV9NQVApO1gubmVlZHNVcGRhdGU9ITE7aWYoWC5vblVwZGF0ZSlYLm9uVXBkYXRlKCl9ZWxzZSBtLmFjdGl2ZVRleHR1cmUobS5URVhUVVJFMCtFYiksbS5iaW5kVGV4dHVyZShtLlRFWFRVUkVfQ1VCRV9NQVAsWC5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUpfWVsc2UgaWYoT2EgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUpe3ZhciBKYj1cbiAgICAgICAgICAgIE9hO20uYWN0aXZlVGV4dHVyZShtLlRFWFRVUkUwKyRhKTttLmJpbmRUZXh0dXJlKG0uVEVYVFVSRV9DVUJFX01BUCxKYi5fX3dlYmdsVGV4dHVyZSl9ZWxzZSBCLnNldFRleHR1cmUoT2EsJGEpO2JyZWFrO2Nhc2UgXCJ0dlwiOnZvaWQgMD09PVQuX2FycmF5JiYoVC5fYXJyYXk9W10pO1o9MDtmb3IoQmE9VC52YWx1ZS5sZW5ndGg7WjxCYTtaKyspVC5fYXJyYXlbWl09RCgpO20udW5pZm9ybTFpdihhYSxULl9hcnJheSk7Wj0wO2ZvcihCYT1ULnZhbHVlLmxlbmd0aDtaPEJhO1orKylPYT1ULnZhbHVlW1pdLCRhPVQuX2FycmF5W1pdLE9hJiZCLnNldFRleHR1cmUoT2EsJGEpO2JyZWFrO2RlZmF1bHQ6VEhSRUUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFVua25vd24gdW5pZm9ybSB0eXBlOiBcIitEYil9fX19bS51bmlmb3JtTWF0cml4NGZ2KGthLm1vZGVsVmlld01hdHJpeCwhMSxlLl9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMpO2thLm5vcm1hbE1hdHJpeCYmbS51bmlmb3JtTWF0cml4M2Z2KGthLm5vcm1hbE1hdHJpeCxcbiAgICAgICAgITEsZS5fbm9ybWFsTWF0cml4LmVsZW1lbnRzKTtudWxsIT09a2EubW9kZWxNYXRyaXgmJm0udW5pZm9ybU1hdHJpeDRmdihrYS5tb2RlbE1hdHJpeCwhMSxlLm1hdHJpeFdvcmxkLmVsZW1lbnRzKTtyZXR1cm4gVWF9ZnVuY3Rpb24geChhLGIpe2EuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGU9YjthLmRpcmVjdGlvbmFsTGlnaHRDb2xvci5uZWVkc1VwZGF0ZT1iO2EuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi5uZWVkc1VwZGF0ZT1iO2EucG9pbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlPWI7YS5wb2ludExpZ2h0UG9zaXRpb24ubmVlZHNVcGRhdGU9YjthLnBvaW50TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZT1iO2EucG9pbnRMaWdodERlY2F5Lm5lZWRzVXBkYXRlPWI7YS5zcG90TGlnaHRDb2xvci5uZWVkc1VwZGF0ZT1iO2Euc3BvdExpZ2h0UG9zaXRpb24ubmVlZHNVcGRhdGU9YjthLnNwb3RMaWdodERpc3RhbmNlLm5lZWRzVXBkYXRlPWI7YS5zcG90TGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGU9XG4gICAgYjthLnNwb3RMaWdodEFuZ2xlQ29zLm5lZWRzVXBkYXRlPWI7YS5zcG90TGlnaHRFeHBvbmVudC5uZWVkc1VwZGF0ZT1iO2Euc3BvdExpZ2h0RGVjYXkubmVlZHNVcGRhdGU9YjthLmhlbWlzcGhlcmVMaWdodFNreUNvbG9yLm5lZWRzVXBkYXRlPWI7YS5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci5uZWVkc1VwZGF0ZT1iO2EuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlPWJ9ZnVuY3Rpb24gRCgpe3ZhciBhPU1iO2E+PVdiJiZUSFJFRS53YXJuKFwiV2ViR0xSZW5kZXJlcjogdHJ5aW5nIHRvIHVzZSBcIithK1wiIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSBcIitXYik7TWIrPTE7cmV0dXJuIGF9ZnVuY3Rpb24gdyhhLGIpe2EuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGIubWF0cml4V29ybGRJbnZlcnNlLGEubWF0cml4V29ybGQpO2EuX25vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoYS5fbW9kZWxWaWV3TWF0cml4KX1cbiAgICBmdW5jdGlvbiB5KGEsYixjLGQpe2FbYl09Yy5yKmQ7YVtiKzFdPWMuZypkO2FbYisyXT1jLmIqZH1mdW5jdGlvbiBBKGEsYixjKXtjPyhtLnRleFBhcmFtZXRlcmkoYSxtLlRFWFRVUkVfV1JBUF9TLEkoYi53cmFwUykpLG0udGV4UGFyYW1ldGVyaShhLG0uVEVYVFVSRV9XUkFQX1QsSShiLndyYXBUKSksbS50ZXhQYXJhbWV0ZXJpKGEsbS5URVhUVVJFX01BR19GSUxURVIsSShiLm1hZ0ZpbHRlcikpLG0udGV4UGFyYW1ldGVyaShhLG0uVEVYVFVSRV9NSU5fRklMVEVSLEkoYi5taW5GaWx0ZXIpKSk6KG0udGV4UGFyYW1ldGVyaShhLG0uVEVYVFVSRV9XUkFQX1MsbS5DTEFNUF9UT19FREdFKSxtLnRleFBhcmFtZXRlcmkoYSxtLlRFWFRVUkVfV1JBUF9ULG0uQ0xBTVBfVE9fRURHRSksYi53cmFwUz09PVRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcmJmIud3JhcFQ9PT1USFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nfHxUSFJFRS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy4gKCBcIitcbiAgICAgICAgYi5zb3VyY2VGaWxlK1wiIClcIiksbS50ZXhQYXJhbWV0ZXJpKGEsbS5URVhUVVJFX01BR19GSUxURVIseihiLm1hZ0ZpbHRlcikpLG0udGV4UGFyYW1ldGVyaShhLG0uVEVYVFVSRV9NSU5fRklMVEVSLHooYi5taW5GaWx0ZXIpKSxiLm1pbkZpbHRlciE9PVRIUkVFLk5lYXJlc3RGaWx0ZXImJmIubWluRmlsdGVyIT09VEhSRUUuTGluZWFyRmlsdGVyJiZUSFJFRS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLm1pbkZpbHRlciBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLk5lYXJlc3RGaWx0ZXIgb3IgVEhSRUUuTGluZWFyRmlsdGVyLiAoIFwiK2Iuc291cmNlRmlsZStcIiApXCIpKTsoYz1kYS5nZXQoXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikpJiZiLnR5cGUhPT1USFJFRS5GbG9hdFR5cGUmJmIudHlwZSE9PVRIUkVFLkhhbGZGbG9hdFR5cGUmJigxPGIuYW5pc290cm9weXx8Yi5fX2N1cnJlbnRBbmlzb3Ryb3B5KSYmXG4gICAgKG0udGV4UGFyYW1ldGVyZihhLGMuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsTWF0aC5taW4oYi5hbmlzb3Ryb3B5LEIuZ2V0TWF4QW5pc290cm9weSgpKSksYi5fX2N1cnJlbnRBbmlzb3Ryb3B5PWIuYW5pc290cm9weSl9ZnVuY3Rpb24gRShhLGIpe2lmKGEud2lkdGg+Ynx8YS5oZWlnaHQ+Yil7dmFyIGM9Yi9NYXRoLm1heChhLndpZHRoLGEuaGVpZ2h0KSxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7ZC53aWR0aD1NYXRoLmZsb29yKGEud2lkdGgqYyk7ZC5oZWlnaHQ9TWF0aC5mbG9vcihhLmhlaWdodCpjKTtkLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UoYSwwLDAsYS53aWR0aCxhLmhlaWdodCwwLDAsZC53aWR0aCxkLmhlaWdodCk7VEhSRUUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKFwiK2Eud2lkdGgrXCJ4XCIrYS5oZWlnaHQrXCIpLiBSZXNpemVkIHRvIFwiK2Qud2lkdGgrXCJ4XCIrZC5oZWlnaHQsYSk7cmV0dXJuIGR9cmV0dXJuIGF9XG4gICAgZnVuY3Rpb24gRyhhLGIpe20uYmluZFJlbmRlcmJ1ZmZlcihtLlJFTkRFUkJVRkZFUixhKTtiLmRlcHRoQnVmZmVyJiYhYi5zdGVuY2lsQnVmZmVyPyhtLnJlbmRlcmJ1ZmZlclN0b3JhZ2UobS5SRU5ERVJCVUZGRVIsbS5ERVBUSF9DT01QT05FTlQxNixiLndpZHRoLGIuaGVpZ2h0KSxtLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKG0uRlJBTUVCVUZGRVIsbS5ERVBUSF9BVFRBQ0hNRU5ULG0uUkVOREVSQlVGRkVSLGEpKTpiLmRlcHRoQnVmZmVyJiZiLnN0ZW5jaWxCdWZmZXI/KG0ucmVuZGVyYnVmZmVyU3RvcmFnZShtLlJFTkRFUkJVRkZFUixtLkRFUFRIX1NURU5DSUwsYi53aWR0aCxiLmhlaWdodCksbS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihtLkZSQU1FQlVGRkVSLG0uREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULG0uUkVOREVSQlVGRkVSLGEpKTptLnJlbmRlcmJ1ZmZlclN0b3JhZ2UobS5SRU5ERVJCVUZGRVIsbS5SR0JBNCxiLndpZHRoLGIuaGVpZ2h0KX1mdW5jdGlvbiBGKGEpe2EgaW5zdGFuY2VvZlxuICAgIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZT8obS5iaW5kVGV4dHVyZShtLlRFWFRVUkVfQ1VCRV9NQVAsYS5fX3dlYmdsVGV4dHVyZSksbS5nZW5lcmF0ZU1pcG1hcChtLlRFWFRVUkVfQ1VCRV9NQVApLG0uYmluZFRleHR1cmUobS5URVhUVVJFX0NVQkVfTUFQLG51bGwpKToobS5iaW5kVGV4dHVyZShtLlRFWFRVUkVfMkQsYS5fX3dlYmdsVGV4dHVyZSksbS5nZW5lcmF0ZU1pcG1hcChtLlRFWFRVUkVfMkQpLG0uYmluZFRleHR1cmUobS5URVhUVVJFXzJELG51bGwpKX1mdW5jdGlvbiB6KGEpe3JldHVybiBhPT09VEhSRUUuTmVhcmVzdEZpbHRlcnx8YT09PVRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyfHxhPT09VEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcj9tLk5FQVJFU1Q6bS5MSU5FQVJ9ZnVuY3Rpb24gSShhKXt2YXIgYjtpZihhPT09VEhSRUUuUmVwZWF0V3JhcHBpbmcpcmV0dXJuIG0uUkVQRUFUO2lmKGE9PT1USFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nKXJldHVybiBtLkNMQU1QX1RPX0VER0U7XG4gICAgICAgIGlmKGE9PT1USFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nKXJldHVybiBtLk1JUlJPUkVEX1JFUEVBVDtpZihhPT09VEhSRUUuTmVhcmVzdEZpbHRlcilyZXR1cm4gbS5ORUFSRVNUO2lmKGE9PT1USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcilyZXR1cm4gbS5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO2lmKGE9PT1USFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyKXJldHVybiBtLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjtpZihhPT09VEhSRUUuTGluZWFyRmlsdGVyKXJldHVybiBtLkxJTkVBUjtpZihhPT09VEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcilyZXR1cm4gbS5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7aWYoYT09PVRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcilyZXR1cm4gbS5MSU5FQVJfTUlQTUFQX0xJTkVBUjtpZihhPT09VEhSRUUuVW5zaWduZWRCeXRlVHlwZSlyZXR1cm4gbS5VTlNJR05FRF9CWVRFO2lmKGE9PT1USFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUpcmV0dXJuIG0uVU5TSUdORURfU0hPUlRfNF80XzRfNDtcbiAgICAgICAgaWYoYT09PVRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSlyZXR1cm4gbS5VTlNJR05FRF9TSE9SVF81XzVfNV8xO2lmKGE9PT1USFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSlyZXR1cm4gbS5VTlNJR05FRF9TSE9SVF81XzZfNTtpZihhPT09VEhSRUUuQnl0ZVR5cGUpcmV0dXJuIG0uQllURTtpZihhPT09VEhSRUUuU2hvcnRUeXBlKXJldHVybiBtLlNIT1JUO2lmKGE9PT1USFJFRS5VbnNpZ25lZFNob3J0VHlwZSlyZXR1cm4gbS5VTlNJR05FRF9TSE9SVDtpZihhPT09VEhSRUUuSW50VHlwZSlyZXR1cm4gbS5JTlQ7aWYoYT09PVRIUkVFLlVuc2lnbmVkSW50VHlwZSlyZXR1cm4gbS5VTlNJR05FRF9JTlQ7aWYoYT09PVRIUkVFLkZsb2F0VHlwZSlyZXR1cm4gbS5GTE9BVDtiPWRhLmdldChcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIik7aWYobnVsbCE9PWImJmE9PT1USFJFRS5IYWxmRmxvYXRUeXBlKXJldHVybiBiLkhBTEZfRkxPQVRfT0VTO2lmKGE9PT1USFJFRS5BbHBoYUZvcm1hdClyZXR1cm4gbS5BTFBIQTtcbiAgICAgICAgaWYoYT09PVRIUkVFLlJHQkZvcm1hdClyZXR1cm4gbS5SR0I7aWYoYT09PVRIUkVFLlJHQkFGb3JtYXQpcmV0dXJuIG0uUkdCQTtpZihhPT09VEhSRUUuTHVtaW5hbmNlRm9ybWF0KXJldHVybiBtLkxVTUlOQU5DRTtpZihhPT09VEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQpcmV0dXJuIG0uTFVNSU5BTkNFX0FMUEhBO2lmKGE9PT1USFJFRS5BZGRFcXVhdGlvbilyZXR1cm4gbS5GVU5DX0FERDtpZihhPT09VEhSRUUuU3VidHJhY3RFcXVhdGlvbilyZXR1cm4gbS5GVU5DX1NVQlRSQUNUO2lmKGE9PT1USFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbilyZXR1cm4gbS5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Q7aWYoYT09PVRIUkVFLlplcm9GYWN0b3IpcmV0dXJuIG0uWkVSTztpZihhPT09VEhSRUUuT25lRmFjdG9yKXJldHVybiBtLk9ORTtpZihhPT09VEhSRUUuU3JjQ29sb3JGYWN0b3IpcmV0dXJuIG0uU1JDX0NPTE9SO2lmKGE9PT1USFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yKXJldHVybiBtLk9ORV9NSU5VU19TUkNfQ09MT1I7XG4gICAgICAgIGlmKGE9PT1USFJFRS5TcmNBbHBoYUZhY3RvcilyZXR1cm4gbS5TUkNfQUxQSEE7aWYoYT09PVRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IpcmV0dXJuIG0uT05FX01JTlVTX1NSQ19BTFBIQTtpZihhPT09VEhSRUUuRHN0QWxwaGFGYWN0b3IpcmV0dXJuIG0uRFNUX0FMUEhBO2lmKGE9PT1USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yKXJldHVybiBtLk9ORV9NSU5VU19EU1RfQUxQSEE7aWYoYT09PVRIUkVFLkRzdENvbG9yRmFjdG9yKXJldHVybiBtLkRTVF9DT0xPUjtpZihhPT09VEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvcilyZXR1cm4gbS5PTkVfTUlOVVNfRFNUX0NPTE9SO2lmKGE9PT1USFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yKXJldHVybiBtLlNSQ19BTFBIQV9TQVRVUkFURTtiPWRhLmdldChcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpO2lmKG51bGwhPT1iKXtpZihhPT09VEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQpcmV0dXJuIGIuQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcbiAgICAgICAgICAgIGlmKGE9PT1USFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQpcmV0dXJuIGIuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7aWYoYT09PVRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdClyZXR1cm4gYi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtpZihhPT09VEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0KXJldHVybiBiLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUfWI9ZGEuZ2V0KFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpO2lmKG51bGwhPT1iKXtpZihhPT09VEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQpcmV0dXJuIGIuQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztpZihhPT09VEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQpcmV0dXJuIGIuQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztpZihhPT09VEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0KXJldHVybiBiLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xuICAgICAgICAgICAgaWYoYT09PVRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdClyZXR1cm4gYi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNR31iPWRhLmdldChcIkVYVF9ibGVuZF9taW5tYXhcIik7aWYobnVsbCE9PWIpe2lmKGE9PT1USFJFRS5NaW5FcXVhdGlvbilyZXR1cm4gYi5NSU5fRVhUO2lmKGE9PT1USFJFRS5NYXhFcXVhdGlvbilyZXR1cm4gYi5NQVhfRVhUfXJldHVybiAwfWNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xSZW5kZXJlclwiLFRIUkVFLlJFVklTSU9OKTthPWF8fHt9O3ZhciBVPXZvaWQgMCE9PWEuY2FudmFzP2EuY2FudmFzOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksTT12b2lkIDAhPT1hLmNvbnRleHQ/YS5jb250ZXh0Om51bGwsSD0xLEw9dm9pZCAwIT09YS5wcmVjaXNpb24/YS5wcmVjaXNpb246XCJoaWdocFwiLFA9dm9pZCAwIT09YS5hbHBoYT9hLmFscGhhOiExLE49dm9pZCAwIT09YS5kZXB0aD9hLmRlcHRoOiEwLFI9dm9pZCAwIT09YS5zdGVuY2lsP1xuICAgICAgICBhLnN0ZW5jaWw6ITAsVj12b2lkIDAhPT1hLmFudGlhbGlhcz9hLmFudGlhbGlhczohMSxKPXZvaWQgMCE9PWEucHJlbXVsdGlwbGllZEFscGhhP2EucHJlbXVsdGlwbGllZEFscGhhOiEwLG9hPXZvaWQgMCE9PWEucHJlc2VydmVEcmF3aW5nQnVmZmVyP2EucHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGphPXZvaWQgMCE9PWEubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcj9hLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI6ITEsaGE9bmV3IFRIUkVFLkNvbG9yKDApLE89MCxjYT1bXSxiYT17fSxxYT1bXSxLYT1bXSxRYT1bXSxYYT1bXSxZYT1bXTt0aGlzLmRvbUVsZW1lbnQ9VTt0aGlzLmNvbnRleHQ9bnVsbDt0aGlzLnNvcnRPYmplY3RzPXRoaXMuYXV0b0NsZWFyU3RlbmNpbD10aGlzLmF1dG9DbGVhckRlcHRoPXRoaXMuYXV0b0NsZWFyQ29sb3I9dGhpcy5hdXRvQ2xlYXI9ITA7dGhpcy5nYW1tYUZhY3Rvcj0yO3RoaXMuc2hhZG93TWFwRW5hYmxlZD10aGlzLmdhbW1hT3V0cHV0PXRoaXMuZ2FtbWFJbnB1dD1cbiAgICAgICAgITE7dGhpcy5zaGFkb3dNYXBUeXBlPVRIUkVFLlBDRlNoYWRvd01hcDt0aGlzLnNoYWRvd01hcEN1bGxGYWNlPVRIUkVFLkN1bGxGYWNlRnJvbnQ7dGhpcy5zaGFkb3dNYXBDYXNjYWRlPXRoaXMuc2hhZG93TWFwRGVidWc9ITE7dGhpcy5tYXhNb3JwaFRhcmdldHM9ODt0aGlzLm1heE1vcnBoTm9ybWFscz00O3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHM9ITA7dGhpcy5pbmZvPXttZW1vcnk6e3Byb2dyYW1zOjAsZ2VvbWV0cmllczowLHRleHR1cmVzOjB9LHJlbmRlcjp7Y2FsbHM6MCx2ZXJ0aWNlczowLGZhY2VzOjAscG9pbnRzOjB9fTt2YXIgQj10aGlzLFBhPVtdLG9iPW51bGwsYWI9bnVsbCx1Yj0tMSx0YT1cIlwiLHZiPW51bGwsTWI9MCxpYj0wLGJiPTAscGI9VS53aWR0aCxxYj1VLmhlaWdodCxYYj0wLGZjPTAsY2I9bmV3IFRIUkVFLkZydXN0dW0sZGI9bmV3IFRIUkVFLk1hdHJpeDQsd2E9bmV3IFRIUkVFLlZlY3RvcjMscGE9bmV3IFRIUkVFLlZlY3RvcjMsT2I9ITAsamM9e2FtYmllbnQ6WzAsXG4gICAgICAgIDAsMF0sZGlyZWN0aW9uYWw6e2xlbmd0aDowLGNvbG9yczpbXSxwb3NpdGlvbnM6W119LHBvaW50OntsZW5ndGg6MCxjb2xvcnM6W10scG9zaXRpb25zOltdLGRpc3RhbmNlczpbXSxkZWNheXM6W119LHNwb3Q6e2xlbmd0aDowLGNvbG9yczpbXSxwb3NpdGlvbnM6W10sZGlzdGFuY2VzOltdLGRpcmVjdGlvbnM6W10sYW5nbGVzQ29zOltdLGV4cG9uZW50czpbXSxkZWNheXM6W119LGhlbWk6e2xlbmd0aDowLHNreUNvbG9yczpbXSxncm91bmRDb2xvcnM6W10scG9zaXRpb25zOltdfX0sbTt0cnl7dmFyIFliPXthbHBoYTpQLGRlcHRoOk4sc3RlbmNpbDpSLGFudGlhbGlhczpWLHByZW11bHRpcGxpZWRBbHBoYTpKLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjpvYX07bT1NfHxVLmdldENvbnRleHQoXCJ3ZWJnbFwiLFliKXx8VS5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsWWIpO2lmKG51bGw9PT1tKXtpZihudWxsIT09VS5nZXRDb250ZXh0KFwid2ViZ2xcIikpdGhyb3dcIkVycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuXCI7XG4gICAgICAgIHRocm93XCJFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0LlwiO31VLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpO1piKCk7bGMoKTtiYT17fX0sITEpfWNhdGNoKHJjKXtUSFJFRS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFwiK3JjKX12YXIgVz1uZXcgVEhSRUUuV2ViR0xTdGF0ZShtLEkpO3ZvaWQgMD09PW0uZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0JiYobS5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm57cmFuZ2VNaW46MSxyYW5nZU1heDoxLHByZWNpc2lvbjoxfX0pO3ZhciBkYT1uZXcgVEhSRUUuV2ViR0xFeHRlbnNpb25zKG0pO2RhLmdldChcIk9FU190ZXh0dXJlX2Zsb2F0XCIpO2RhLmdldChcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKTtkYS5nZXQoXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpO2RhLmdldChcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpO1xuICAgIGRhLmdldChcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKTtqYSYmZGEuZ2V0KFwiRVhUX2ZyYWdfZGVwdGhcIik7dmFyIHJiPWZ1bmN0aW9uKGEsYixjLGQpeyEwPT09SiYmKGEqPWQsYio9ZCxjKj1kKTttLmNsZWFyQ29sb3IoYSxiLGMsZCl9LGxjPWZ1bmN0aW9uKCl7bS5jbGVhckNvbG9yKDAsMCwwLDEpO20uY2xlYXJEZXB0aCgxKTttLmNsZWFyU3RlbmNpbCgwKTttLmVuYWJsZShtLkRFUFRIX1RFU1QpO20uZGVwdGhGdW5jKG0uTEVRVUFMKTttLmZyb250RmFjZShtLkNDVyk7bS5jdWxsRmFjZShtLkJBQ0spO20uZW5hYmxlKG0uQ1VMTF9GQUNFKTttLmVuYWJsZShtLkJMRU5EKTttLmJsZW5kRXF1YXRpb24obS5GVU5DX0FERCk7bS5ibGVuZEZ1bmMobS5TUkNfQUxQSEEsbS5PTkVfTUlOVVNfU1JDX0FMUEhBKTttLnZpZXdwb3J0KGliLGJiLHBiLHFiKTtyYihoYS5yLGhhLmcsaGEuYixPKX0sWmI9ZnVuY3Rpb24oKXt2Yj1vYj1udWxsO3RhPVwiXCI7dWI9LTE7T2I9ITA7Vy5yZXNldCgpfTtcbiAgICBsYygpO3RoaXMuY29udGV4dD1tO3RoaXMuc3RhdGU9Vzt2YXIgV2I9bS5nZXRQYXJhbWV0ZXIobS5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksc2M9bS5nZXRQYXJhbWV0ZXIobS5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLHRjPW0uZ2V0UGFyYW1ldGVyKG0uTUFYX1RFWFRVUkVfU0laRSkscWM9bS5nZXRQYXJhbWV0ZXIobS5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFKSxWYj0wPHNjLE5iPVZiJiZkYS5nZXQoXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSx1Yz1tLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChtLlZFUlRFWF9TSEFERVIsbS5ISUdIX0ZMT0FUKSx2Yz1tLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChtLlZFUlRFWF9TSEFERVIsbS5NRURJVU1fRkxPQVQpLHdjPW0uZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KG0uRlJBR01FTlRfU0hBREVSLG0uSElHSF9GTE9BVCkseGM9bS5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQobS5GUkFHTUVOVF9TSEFERVIsbS5NRURJVU1fRkxPQVQpLFxuICAgICAgICBrYz1mdW5jdGlvbigpe3ZhciBhO3JldHVybiBmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWEpcmV0dXJuIGE7YT1bXTtpZihkYS5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIil8fGRhLmdldChcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpKWZvcih2YXIgYj1tLmdldFBhcmFtZXRlcihtLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTKSxjPTA7YzxiLmxlbmd0aDtjKyspYS5wdXNoKGJbY10pO3JldHVybiBhfX0oKSx5Yz0wPHVjLnByZWNpc2lvbiYmMDx3Yy5wcmVjaXNpb24sbWM9MDx2Yy5wcmVjaXNpb24mJjA8eGMucHJlY2lzaW9uO1wiaGlnaHBcIiE9PUx8fHljfHwobWM/KEw9XCJtZWRpdW1wXCIsVEhSRUUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IGhpZ2hwIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIG1lZGl1bXAuXCIpKTooTD1cImxvd3BcIixUSFJFRS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogaGlnaHAgYW5kIG1lZGl1bXAgbm90IHN1cHBvcnRlZCwgdXNpbmcgbG93cC5cIikpKTtcbiAgICBcIm1lZGl1bXBcIiE9PUx8fG1jfHwoTD1cImxvd3BcIixUSFJFRS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogbWVkaXVtcCBub3Qgc3VwcG9ydGVkLCB1c2luZyBsb3dwLlwiKSk7dmFyIHpjPW5ldyBUSFJFRS5TaGFkb3dNYXBQbHVnaW4odGhpcyxjYSxiYSxxYSksQWM9bmV3IFRIUkVFLlNwcml0ZVBsdWdpbih0aGlzLFhhKSxCYz1uZXcgVEhSRUUuTGVuc0ZsYXJlUGx1Z2luKHRoaXMsWWEpO3RoaXMuZ2V0Q29udGV4dD1mdW5jdGlvbigpe3JldHVybiBtfTt0aGlzLmZvcmNlQ29udGV4dExvc3M9ZnVuY3Rpb24oKXtkYS5nZXQoXCJXRUJHTF9sb3NlX2NvbnRleHRcIikubG9zZUNvbnRleHQoKX07dGhpcy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIFZifTt0aGlzLnN1cHBvcnRzRmxvYXRUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiBkYS5nZXQoXCJPRVNfdGV4dHVyZV9mbG9hdFwiKX07dGhpcy5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIGRhLmdldChcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIil9O1xuICAgIHRoaXMuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzPWZ1bmN0aW9uKCl7cmV0dXJuIGRhLmdldChcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKX07dGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQz1mdW5jdGlvbigpe3JldHVybiBkYS5nZXQoXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKX07dGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEM9ZnVuY3Rpb24oKXtyZXR1cm4gZGEuZ2V0KFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpfTt0aGlzLnN1cHBvcnRzQmxlbmRNaW5NYXg9ZnVuY3Rpb24oKXtyZXR1cm4gZGEuZ2V0KFwiRVhUX2JsZW5kX21pbm1heFwiKX07dGhpcy5nZXRNYXhBbmlzb3Ryb3B5PWZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09YSlyZXR1cm4gYTt2YXIgYj1kYS5nZXQoXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIik7cmV0dXJuIGE9bnVsbCE9PWI/bS5nZXRQYXJhbWV0ZXIoYi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpOlxuICAgICAgICAwfX0oKTt0aGlzLmdldFByZWNpc2lvbj1mdW5jdGlvbigpe3JldHVybiBMfTt0aGlzLmdldFBpeGVsUmF0aW89ZnVuY3Rpb24oKXtyZXR1cm4gSH07dGhpcy5zZXRQaXhlbFJhdGlvPWZ1bmN0aW9uKGEpe0g9YX07dGhpcy5zZXRTaXplPWZ1bmN0aW9uKGEsYixjKXtVLndpZHRoPWEqSDtVLmhlaWdodD1iKkg7ITEhPT1jJiYoVS5zdHlsZS53aWR0aD1hK1wicHhcIixVLnN0eWxlLmhlaWdodD1iK1wicHhcIik7dGhpcy5zZXRWaWV3cG9ydCgwLDAsYSxiKX07dGhpcy5zZXRWaWV3cG9ydD1mdW5jdGlvbihhLGIsYyxkKXtpYj1hKkg7YmI9YipIO3BiPWMqSDtxYj1kKkg7bS52aWV3cG9ydChpYixiYixwYixxYil9O3RoaXMuc2V0U2Npc3Nvcj1mdW5jdGlvbihhLGIsYyxkKXttLnNjaXNzb3IoYSpILGIqSCxjKkgsZCpIKX07dGhpcy5lbmFibGVTY2lzc29yVGVzdD1mdW5jdGlvbihhKXthP20uZW5hYmxlKG0uU0NJU1NPUl9URVNUKTptLmRpc2FibGUobS5TQ0lTU09SX1RFU1QpfTt0aGlzLmdldENsZWFyQ29sb3I9XG4gICAgICAgIGZ1bmN0aW9uKCl7cmV0dXJuIGhhfTt0aGlzLnNldENsZWFyQ29sb3I9ZnVuY3Rpb24oYSxiKXtoYS5zZXQoYSk7Tz12b2lkIDAhPT1iP2I6MTtyYihoYS5yLGhhLmcsaGEuYixPKX07dGhpcy5nZXRDbGVhckFscGhhPWZ1bmN0aW9uKCl7cmV0dXJuIE99O3RoaXMuc2V0Q2xlYXJBbHBoYT1mdW5jdGlvbihhKXtPPWE7cmIoaGEucixoYS5nLGhhLmIsTyl9O3RoaXMuY2xlYXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPTA7aWYodm9pZCAwPT09YXx8YSlkfD1tLkNPTE9SX0JVRkZFUl9CSVQ7aWYodm9pZCAwPT09Ynx8YilkfD1tLkRFUFRIX0JVRkZFUl9CSVQ7aWYodm9pZCAwPT09Y3x8YylkfD1tLlNURU5DSUxfQlVGRkVSX0JJVDttLmNsZWFyKGQpfTt0aGlzLmNsZWFyQ29sb3I9ZnVuY3Rpb24oKXttLmNsZWFyKG0uQ09MT1JfQlVGRkVSX0JJVCl9O3RoaXMuY2xlYXJEZXB0aD1mdW5jdGlvbigpe20uY2xlYXIobS5ERVBUSF9CVUZGRVJfQklUKX07dGhpcy5jbGVhclN0ZW5jaWw9ZnVuY3Rpb24oKXttLmNsZWFyKG0uU1RFTkNJTF9CVUZGRVJfQklUKX07XG4gICAgdGhpcy5jbGVhclRhcmdldD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLnNldFJlbmRlclRhcmdldChhKTt0aGlzLmNsZWFyKGIsYyxkKX07dGhpcy5yZXNldEdMU3RhdGU9WmI7dmFyIHdiPWZ1bmN0aW9uKGEpe2EudGFyZ2V0LnRyYXZlcnNlKGZ1bmN0aW9uKGEpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlbW92ZVwiLHdiKTtpZihhIGluc3RhbmNlb2YgVEhSRUUuTWVzaHx8YSBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWR8fGEgaW5zdGFuY2VvZiBUSFJFRS5MaW5lKWRlbGV0ZSBiYVthLmlkXTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3R8fGEuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2spZm9yKHZhciBiPXFhLGM9Yi5sZW5ndGgtMTswPD1jO2MtLSliW2NdLm9iamVjdD09PWEmJmIuc3BsaWNlKGMsMSk7ZGVsZXRlIGEuX193ZWJnbEluaXQ7ZGVsZXRlIGEuX21vZGVsVmlld01hdHJpeDtkZWxldGUgYS5fbm9ybWFsTWF0cml4O2RlbGV0ZSBhLl9fd2ViZ2xBY3RpdmV9KX0sXG4gICAgICAgIGpiPWZ1bmN0aW9uKGEpe2E9YS50YXJnZXQ7YS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLGpiKTtkZWxldGUgYS5fX3dlYmdsSW5pdDtpZihhIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkpe2Zvcih2YXIgYiBpbiBhLmF0dHJpYnV0ZXMpe3ZhciBjPWEuYXR0cmlidXRlc1tiXTt2b2lkIDAhPT1jLmJ1ZmZlciYmKG0uZGVsZXRlQnVmZmVyKGMuYnVmZmVyKSxkZWxldGUgYy5idWZmZXIpfUIuaW5mby5tZW1vcnkuZ2VvbWV0cmllcy0tfWVsc2UgaWYoYj1VYVthLmlkXSx2b2lkIDAhPT1iKXtmb3IodmFyIGM9MCxkPWIubGVuZ3RoO2M8ZDtjKyspe3ZhciBlPWJbY107aWYodm9pZCAwIT09ZS5udW1Nb3JwaFRhcmdldHMpe2Zvcih2YXIgZj0wLGc9ZS5udW1Nb3JwaFRhcmdldHM7ZjxnO2YrKyltLmRlbGV0ZUJ1ZmZlcihlLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzW2ZdKTtkZWxldGUgZS5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc31pZih2b2lkIDAhPT1lLm51bU1vcnBoTm9ybWFscyl7Zj1cbiAgICAgICAgICAgIDA7Zm9yKGc9ZS5udW1Nb3JwaE5vcm1hbHM7ZjxnO2YrKyltLmRlbGV0ZUJ1ZmZlcihlLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzW2ZdKTtkZWxldGUgZS5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc31uYyhlKX1kZWxldGUgVWFbYS5pZF19ZWxzZSBuYyhhKTt0YT1cIlwifSxQYj1mdW5jdGlvbihhKXthPWEudGFyZ2V0O2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixQYik7YS5pbWFnZSYmYS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmU/KG0uZGVsZXRlVGV4dHVyZShhLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSksZGVsZXRlIGEuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlKTp2b2lkIDAhPT1hLl9fd2ViZ2xJbml0JiYobS5kZWxldGVUZXh0dXJlKGEuX193ZWJnbFRleHR1cmUpLGRlbGV0ZSBhLl9fd2ViZ2xUZXh0dXJlLGRlbGV0ZSBhLl9fd2ViZ2xJbml0KTtCLmluZm8ubWVtb3J5LnRleHR1cmVzLS19LG9jPWZ1bmN0aW9uKGEpe2E9YS50YXJnZXQ7YS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgb2MpO2lmKGEmJnZvaWQgMCE9PWEuX193ZWJnbFRleHR1cmUpe20uZGVsZXRlVGV4dHVyZShhLl9fd2ViZ2xUZXh0dXJlKTtkZWxldGUgYS5fX3dlYmdsVGV4dHVyZTtpZihhIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlKWZvcih2YXIgYj0wOzY+YjtiKyspbS5kZWxldGVGcmFtZWJ1ZmZlcihhLl9fd2ViZ2xGcmFtZWJ1ZmZlcltiXSksbS5kZWxldGVSZW5kZXJidWZmZXIoYS5fX3dlYmdsUmVuZGVyYnVmZmVyW2JdKTtlbHNlIG0uZGVsZXRlRnJhbWVidWZmZXIoYS5fX3dlYmdsRnJhbWVidWZmZXIpLG0uZGVsZXRlUmVuZGVyYnVmZmVyKGEuX193ZWJnbFJlbmRlcmJ1ZmZlcik7ZGVsZXRlIGEuX193ZWJnbEZyYW1lYnVmZmVyO2RlbGV0ZSBhLl9fd2ViZ2xSZW5kZXJidWZmZXJ9Qi5pbmZvLm1lbW9yeS50ZXh0dXJlcy0tfSxpYz1mdW5jdGlvbihhKXthPWEudGFyZ2V0O2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixpYyk7aGMoYSl9LG5jPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1cbiAgICAgICAgICAgIFwiX193ZWJnbFZlcnRleEJ1ZmZlciBfX3dlYmdsTm9ybWFsQnVmZmVyIF9fd2ViZ2xUYW5nZW50QnVmZmVyIF9fd2ViZ2xDb2xvckJ1ZmZlciBfX3dlYmdsVVZCdWZmZXIgX193ZWJnbFVWMkJ1ZmZlciBfX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyIF9fd2ViZ2xGYWNlQnVmZmVyIF9fd2ViZ2xMaW5lQnVmZmVyIF9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXJcIi5zcGxpdChcIiBcIiksYz0wLGQ9Yi5sZW5ndGg7YzxkO2MrKyl7dmFyIGU9YltjXTt2b2lkIDAhPT1hW2VdJiYobS5kZWxldGVCdWZmZXIoYVtlXSksZGVsZXRlIGFbZV0pfWlmKHZvaWQgMCE9PWEuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0KXtmb3IoZSBpbiBhLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCltLmRlbGV0ZUJ1ZmZlcihhLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdFtlXS5idWZmZXIpO2RlbGV0ZSBhLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdH1CLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMtLX0sXG4gICAgICAgIGhjPWZ1bmN0aW9uKGEpe3ZhciBiPWEucHJvZ3JhbS5wcm9ncmFtO2lmKHZvaWQgMCE9PWIpe2EucHJvZ3JhbT12b2lkIDA7dmFyIGMsZCxlPSExO2E9MDtmb3IoYz1QYS5sZW5ndGg7YTxjO2ErKylpZihkPVBhW2FdLGQucHJvZ3JhbT09PWIpe2QudXNlZFRpbWVzLS07MD09PWQudXNlZFRpbWVzJiYoZT0hMCk7YnJlYWt9aWYoITA9PT1lKXtlPVtdO2E9MDtmb3IoYz1QYS5sZW5ndGg7YTxjO2ErKylkPVBhW2FdLGQucHJvZ3JhbSE9PWImJmUucHVzaChkKTtQYT1lO20uZGVsZXRlUHJvZ3JhbShiKTtCLmluZm8ubWVtb3J5LnByb2dyYW1zLS19fX07dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGU9ZnVuY3Rpb24oYSxiLGMpe1cuaW5pdEF0dHJpYnV0ZXMoKTthLmhhc1Bvc2l0aW9ucyYmIWEuX193ZWJnbFZlcnRleEJ1ZmZlciYmKGEuX193ZWJnbFZlcnRleEJ1ZmZlcj1tLmNyZWF0ZUJ1ZmZlcigpKTthLmhhc05vcm1hbHMmJiFhLl9fd2ViZ2xOb3JtYWxCdWZmZXImJihhLl9fd2ViZ2xOb3JtYWxCdWZmZXI9XG4gICAgICAgIG0uY3JlYXRlQnVmZmVyKCkpO2EuaGFzVXZzJiYhYS5fX3dlYmdsVXZCdWZmZXImJihhLl9fd2ViZ2xVdkJ1ZmZlcj1tLmNyZWF0ZUJ1ZmZlcigpKTthLmhhc0NvbG9ycyYmIWEuX193ZWJnbENvbG9yQnVmZmVyJiYoYS5fX3dlYmdsQ29sb3JCdWZmZXI9bS5jcmVhdGVCdWZmZXIoKSk7YS5oYXNQb3NpdGlvbnMmJihtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsYS5fX3dlYmdsVmVydGV4QnVmZmVyKSxtLmJ1ZmZlckRhdGEobS5BUlJBWV9CVUZGRVIsYS5wb3NpdGlvbkFycmF5LG0uRFlOQU1JQ19EUkFXKSxXLmVuYWJsZUF0dHJpYnV0ZShiLmF0dHJpYnV0ZXMucG9zaXRpb24pLG0udmVydGV4QXR0cmliUG9pbnRlcihiLmF0dHJpYnV0ZXMucG9zaXRpb24sMyxtLkZMT0FULCExLDAsMCkpO2lmKGEuaGFzTm9ybWFscyl7bS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLGEuX193ZWJnbE5vcm1hbEJ1ZmZlcik7aWYoITE9PT1jIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwmJlxuICAgICAgICBjLnNoYWRpbmc9PT1USFJFRS5GbGF0U2hhZGluZyl7dmFyIGQsZSxmLGcsaCxrLG4sbCxwLHEscixzPTMqYS5jb3VudDtmb3Iocj0wO3I8cztyKz05KXE9YS5ub3JtYWxBcnJheSxkPXFbcl0sZT1xW3IrMV0sZj1xW3IrMl0sZz1xW3IrM10saz1xW3IrNF0sbD1xW3IrNV0saD1xW3IrNl0sbj1xW3IrN10scD1xW3IrOF0sZD0oZCtnK2gpLzMsZT0oZStrK24pLzMsZj0oZitsK3ApLzMscVtyXT1kLHFbcisxXT1lLHFbcisyXT1mLHFbciszXT1kLHFbcis0XT1lLHFbcis1XT1mLHFbcis2XT1kLHFbcis3XT1lLHFbcis4XT1mfW0uYnVmZmVyRGF0YShtLkFSUkFZX0JVRkZFUixhLm5vcm1hbEFycmF5LG0uRFlOQU1JQ19EUkFXKTtXLmVuYWJsZUF0dHJpYnV0ZShiLmF0dHJpYnV0ZXMubm9ybWFsKTttLnZlcnRleEF0dHJpYlBvaW50ZXIoYi5hdHRyaWJ1dGVzLm5vcm1hbCwzLG0uRkxPQVQsITEsMCwwKX1hLmhhc1V2cyYmYy5tYXAmJihtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsYS5fX3dlYmdsVXZCdWZmZXIpLFxuICAgICAgICBtLmJ1ZmZlckRhdGEobS5BUlJBWV9CVUZGRVIsYS51dkFycmF5LG0uRFlOQU1JQ19EUkFXKSxXLmVuYWJsZUF0dHJpYnV0ZShiLmF0dHJpYnV0ZXMudXYpLG0udmVydGV4QXR0cmliUG9pbnRlcihiLmF0dHJpYnV0ZXMudXYsMixtLkZMT0FULCExLDAsMCkpO2EuaGFzQ29sb3JzJiZjLnZlcnRleENvbG9ycyE9PVRIUkVFLk5vQ29sb3JzJiYobS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLGEuX193ZWJnbENvbG9yQnVmZmVyKSxtLmJ1ZmZlckRhdGEobS5BUlJBWV9CVUZGRVIsYS5jb2xvckFycmF5LG0uRFlOQU1JQ19EUkFXKSxXLmVuYWJsZUF0dHJpYnV0ZShiLmF0dHJpYnV0ZXMuY29sb3IpLG0udmVydGV4QXR0cmliUG9pbnRlcihiLmF0dHJpYnV0ZXMuY29sb3IsMyxtLkZMT0FULCExLDAsMCkpO1cuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTttLmRyYXdBcnJheXMobS5UUklBTkdMRVMsMCxhLmNvdW50KTthLmNvdW50PTB9O3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0PWZ1bmN0aW9uKGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYixjLGUsZixnKXtpZighMSE9PWUudmlzaWJsZSlpZih0KGcpLGE9dihhLGIsYyxlLGcpLGI9ITEsYz1cImRpcmVjdF9cIitmLmlkK1wiX1wiK2EuaWQrXCJfXCIrKGUud2lyZWZyYW1lPzE6MCksYyE9PXRhJiYodGE9YyxiPSEwKSxiJiZXLmluaXRBdHRyaWJ1dGVzKCksZyBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpe2c9ITA9PT1lLndpcmVmcmFtZT9tLkxJTkVTOm0uVFJJQU5HTEVTO3ZhciBoPWYuYXR0cmlidXRlcy5pbmRleDtpZihoKXt2YXIgayxuO2guYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSYmZGEuZ2V0KFwiT0VTX2VsZW1lbnRfaW5kZXhfdWludFwiKT8oaz1tLlVOU0lHTkVEX0lOVCxuPTQpOihrPW0uVU5TSUdORURfU0hPUlQsbj0yKTtjPWYub2Zmc2V0cztpZigwPT09Yy5sZW5ndGgpYiYmKGQoZSxhLGYsMCksbS5iaW5kQnVmZmVyKG0uRUxFTUVOVF9BUlJBWV9CVUZGRVIsaC5idWZmZXIpKSxtLmRyYXdFbGVtZW50cyhnLGguYXJyYXkubGVuZ3RoLGssMCksQi5pbmZvLnJlbmRlci5jYWxscysrLFxuICAgICAgICBCLmluZm8ucmVuZGVyLnZlcnRpY2VzKz1oLmFycmF5Lmxlbmd0aCxCLmluZm8ucmVuZGVyLmZhY2VzKz1oLmFycmF5Lmxlbmd0aC8zO2Vsc2V7Yj0hMDtmb3IodmFyIGw9MCxwPWMubGVuZ3RoO2w8cDtsKyspe3ZhciBxPWNbbF0uaW5kZXg7YiYmKGQoZSxhLGYscSksbS5iaW5kQnVmZmVyKG0uRUxFTUVOVF9BUlJBWV9CVUZGRVIsaC5idWZmZXIpKTttLmRyYXdFbGVtZW50cyhnLGNbbF0uY291bnQsayxjW2xdLnN0YXJ0Km4pO0IuaW5mby5yZW5kZXIuY2FsbHMrKztCLmluZm8ucmVuZGVyLnZlcnRpY2VzKz1jW2xdLmNvdW50O0IuaW5mby5yZW5kZXIuZmFjZXMrPWNbbF0uY291bnQvM319fWVsc2UgYiYmZChlLGEsZiwwKSxlPWYuYXR0cmlidXRlcy5wb3NpdGlvbixtLmRyYXdBcnJheXMoZywwLGUuYXJyYXkubGVuZ3RoL2UuaXRlbVNpemUpLEIuaW5mby5yZW5kZXIuY2FsbHMrKyxCLmluZm8ucmVuZGVyLnZlcnRpY2VzKz1lLmFycmF5Lmxlbmd0aC9lLml0ZW1TaXplLEIuaW5mby5yZW5kZXIuZmFjZXMrPVxuICAgICAgICBlLmFycmF5Lmxlbmd0aC8oMyplLml0ZW1TaXplKX1lbHNlIGlmKGcgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkKWlmKGc9bS5QT0lOVFMsaD1mLmF0dHJpYnV0ZXMuaW5kZXgpaWYoaC5hcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5JiZkYS5nZXQoXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCIpPyhrPW0uVU5TSUdORURfSU5ULG49NCk6KGs9bS5VTlNJR05FRF9TSE9SVCxuPTIpLGM9Zi5vZmZzZXRzLDA9PT1jLmxlbmd0aCliJiYoZChlLGEsZiwwKSxtLmJpbmRCdWZmZXIobS5FTEVNRU5UX0FSUkFZX0JVRkZFUixoLmJ1ZmZlcikpLG0uZHJhd0VsZW1lbnRzKGcsaC5hcnJheS5sZW5ndGgsaywwKSxCLmluZm8ucmVuZGVyLmNhbGxzKyssQi5pbmZvLnJlbmRlci5wb2ludHMrPWguYXJyYXkubGVuZ3RoO2Vsc2UgZm9yKDE8Yy5sZW5ndGgmJihiPSEwKSxsPTAscD1jLmxlbmd0aDtsPHA7bCsrKXE9Y1tsXS5pbmRleCxiJiYoZChlLGEsZixxKSxtLmJpbmRCdWZmZXIobS5FTEVNRU5UX0FSUkFZX0JVRkZFUixcbiAgICAgICAgaC5idWZmZXIpKSxtLmRyYXdFbGVtZW50cyhnLGNbbF0uY291bnQsayxjW2xdLnN0YXJ0Km4pLEIuaW5mby5yZW5kZXIuY2FsbHMrKyxCLmluZm8ucmVuZGVyLnBvaW50cys9Y1tsXS5jb3VudDtlbHNlIGlmKGImJmQoZSxhLGYsMCksZT1mLmF0dHJpYnV0ZXMucG9zaXRpb24sYz1mLm9mZnNldHMsMD09PWMubGVuZ3RoKW0uZHJhd0FycmF5cyhnLDAsZS5hcnJheS5sZW5ndGgvMyksQi5pbmZvLnJlbmRlci5jYWxscysrLEIuaW5mby5yZW5kZXIucG9pbnRzKz1lLmFycmF5Lmxlbmd0aC8zO2Vsc2UgZm9yKGw9MCxwPWMubGVuZ3RoO2w8cDtsKyspbS5kcmF3QXJyYXlzKGcsY1tsXS5pbmRleCxjW2xdLmNvdW50KSxCLmluZm8ucmVuZGVyLmNhbGxzKyssQi5pbmZvLnJlbmRlci5wb2ludHMrPWNbbF0uY291bnQ7ZWxzZSBpZihnIGluc3RhbmNlb2YgVEhSRUUuTGluZSlpZihnPWcubW9kZT09PVRIUkVFLkxpbmVTdHJpcD9tLkxJTkVfU1RSSVA6bS5MSU5FUyxXLnNldExpbmVXaWR0aChlLmxpbmV3aWR0aCpcbiAgICAgICAgICAgIEgpLGg9Zi5hdHRyaWJ1dGVzLmluZGV4KWlmKGguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheT8oaz1tLlVOU0lHTkVEX0lOVCxuPTQpOihrPW0uVU5TSUdORURfU0hPUlQsbj0yKSxjPWYub2Zmc2V0cywwPT09Yy5sZW5ndGgpYiYmKGQoZSxhLGYsMCksbS5iaW5kQnVmZmVyKG0uRUxFTUVOVF9BUlJBWV9CVUZGRVIsaC5idWZmZXIpKSxtLmRyYXdFbGVtZW50cyhnLGguYXJyYXkubGVuZ3RoLGssMCksQi5pbmZvLnJlbmRlci5jYWxscysrLEIuaW5mby5yZW5kZXIudmVydGljZXMrPWguYXJyYXkubGVuZ3RoO2Vsc2UgZm9yKDE8Yy5sZW5ndGgmJihiPSEwKSxsPTAscD1jLmxlbmd0aDtsPHA7bCsrKXE9Y1tsXS5pbmRleCxiJiYoZChlLGEsZixxKSxtLmJpbmRCdWZmZXIobS5FTEVNRU5UX0FSUkFZX0JVRkZFUixoLmJ1ZmZlcikpLG0uZHJhd0VsZW1lbnRzKGcsY1tsXS5jb3VudCxrLGNbbF0uc3RhcnQqbiksQi5pbmZvLnJlbmRlci5jYWxscysrLEIuaW5mby5yZW5kZXIudmVydGljZXMrPVxuICAgICAgICBjW2xdLmNvdW50O2Vsc2UgaWYoYiYmZChlLGEsZiwwKSxlPWYuYXR0cmlidXRlcy5wb3NpdGlvbixjPWYub2Zmc2V0cywwPT09Yy5sZW5ndGgpbS5kcmF3QXJyYXlzKGcsMCxlLmFycmF5Lmxlbmd0aC8zKSxCLmluZm8ucmVuZGVyLmNhbGxzKyssQi5pbmZvLnJlbmRlci52ZXJ0aWNlcys9ZS5hcnJheS5sZW5ndGgvMztlbHNlIGZvcihsPTAscD1jLmxlbmd0aDtsPHA7bCsrKW0uZHJhd0FycmF5cyhnLGNbbF0uaW5kZXgsY1tsXS5jb3VudCksQi5pbmZvLnJlbmRlci5jYWxscysrLEIuaW5mby5yZW5kZXIudmVydGljZXMrPWNbbF0uY291bnR9O3RoaXMucmVuZGVyQnVmZmVyPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZighMSE9PWQudmlzaWJsZSl7dChmKTtjPXYoYSxiLGMsZCxmKTtiPWMuYXR0cmlidXRlczthPSExO2M9ZS5pZCtcIl9cIitjLmlkK1wiX1wiKyhkLndpcmVmcmFtZT8xOjApO2MhPT10YSYmKHRhPWMsYT0hMCk7YSYmVy5pbml0QXR0cmlidXRlcygpO2lmKCFkLm1vcnBoVGFyZ2V0cyYmXG4gICAgICAgIDA8PWIucG9zaXRpb24pYSYmKG0uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIpLFcuZW5hYmxlQXR0cmlidXRlKGIucG9zaXRpb24pLG0udmVydGV4QXR0cmliUG9pbnRlcihiLnBvc2l0aW9uLDMsbS5GTE9BVCwhMSwwLDApKTtlbHNlIGlmKGYubW9ycGhUYXJnZXRCYXNlKXtjPWQucHJvZ3JhbS5hdHRyaWJ1dGVzOy0xIT09Zi5tb3JwaFRhcmdldEJhc2UmJjA8PWMucG9zaXRpb24/KG0uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzW2YubW9ycGhUYXJnZXRCYXNlXSksVy5lbmFibGVBdHRyaWJ1dGUoYy5wb3NpdGlvbiksbS52ZXJ0ZXhBdHRyaWJQb2ludGVyKGMucG9zaXRpb24sMyxtLkZMT0FULCExLDAsMCkpOjA8PWMucG9zaXRpb24mJihtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsVmVydGV4QnVmZmVyKSxXLmVuYWJsZUF0dHJpYnV0ZShjLnBvc2l0aW9uKSxtLnZlcnRleEF0dHJpYlBvaW50ZXIoYy5wb3NpdGlvbixcbiAgICAgICAgMyxtLkZMT0FULCExLDAsMCkpO2lmKGYubW9ycGhUYXJnZXRGb3JjZWRPcmRlci5sZW5ndGgpZm9yKHZhciBoPTAsaz1mLm1vcnBoVGFyZ2V0Rm9yY2VkT3JkZXIsbj1mLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyxsO2g8ZC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMmJmg8ay5sZW5ndGg7KWw9Y1tcIm1vcnBoVGFyZ2V0XCIraF0sMDw9bCYmKG0uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzW2tbaF1dKSxXLmVuYWJsZUF0dHJpYnV0ZShsKSxtLnZlcnRleEF0dHJpYlBvaW50ZXIobCwzLG0uRkxPQVQsITEsMCwwKSksbD1jW1wibW9ycGhOb3JtYWxcIitoXSwwPD1sJiZkLm1vcnBoTm9ybWFscyYmKG0uYmluZEJ1ZmZlcihtLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzW2tbaF1dKSxXLmVuYWJsZUF0dHJpYnV0ZShsKSxtLnZlcnRleEF0dHJpYlBvaW50ZXIobCwzLG0uRkxPQVQsITEsMCwwKSksZi5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzW2hdPVxuICAgICAgICBuW2tbaF1dLGgrKztlbHNle2s9W107bj1mLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztoPWYuZ2VvbWV0cnkubW9ycGhUYXJnZXRzO24ubGVuZ3RoPmgubGVuZ3RoJiYoY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogSW5mbHVlbmNlcyBhcnJheSBpcyBiaWdnZXIgdGhhbiBtb3JwaFRhcmdldHMgYXJyYXkuXCIpLG4ubGVuZ3RoPWgubGVuZ3RoKTtoPTA7Zm9yKGw9bi5sZW5ndGg7aDxsO2grKylrLnB1c2goW25baF0saF0pO2subGVuZ3RoPmQubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzPyhrLnNvcnQoZyksay5sZW5ndGg9ZC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMpOmsubGVuZ3RoPmQubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzP2suc29ydChnKTowPT09ay5sZW5ndGgmJmsucHVzaChbMCwwXSk7Zm9yKHZhciBoPTAscD1kLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cztoPHA7aCsrKWlmKGtbaF0pe3ZhciBxPWtbaF1bMV07bD1jW1wibW9ycGhUYXJnZXRcIitoXTswPD1sJiZcbiAgICAobS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLGUuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbcV0pLFcuZW5hYmxlQXR0cmlidXRlKGwpLG0udmVydGV4QXR0cmliUG9pbnRlcihsLDMsbS5GTE9BVCwhMSwwLDApKTtsPWNbXCJtb3JwaE5vcm1hbFwiK2hdOzA8PWwmJmQubW9ycGhOb3JtYWxzJiYobS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLGUuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnNbcV0pLFcuZW5hYmxlQXR0cmlidXRlKGwpLG0udmVydGV4QXR0cmliUG9pbnRlcihsLDMsbS5GTE9BVCwhMSwwLDApKTtmLl9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXNbaF09bltxXX1lbHNlIGYuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlc1toXT0wfW51bGwhPT1kLnByb2dyYW0udW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzJiZtLnVuaWZvcm0xZnYoZC5wcm9ncmFtLnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyxmLl9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXMpfWlmKGEpe2lmKGUuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0KWZvcihjPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxuPWUuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0Lmxlbmd0aDtjPG47YysrKWs9ZS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3RbY10sMDw9YltrLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGVdJiYobS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLGsuYnVmZmVyKSxXLmVuYWJsZUF0dHJpYnV0ZShiW2suYnVmZmVyLmJlbG9uZ3NUb0F0dHJpYnV0ZV0pLG0udmVydGV4QXR0cmliUG9pbnRlcihiW2suYnVmZmVyLmJlbG9uZ3NUb0F0dHJpYnV0ZV0say5zaXplLG0uRkxPQVQsITEsMCwwKSk7MDw9Yi5jb2xvciYmKDA8Zi5nZW9tZXRyeS5jb2xvcnMubGVuZ3RofHwwPGYuZ2VvbWV0cnkuZmFjZXMubGVuZ3RoPyhtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsQ29sb3JCdWZmZXIpLFcuZW5hYmxlQXR0cmlidXRlKGIuY29sb3IpLG0udmVydGV4QXR0cmliUG9pbnRlcihiLmNvbG9yLDMsbS5GTE9BVCwhMSwwLDApKTp2b2lkIDAhPT1kLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMmJlxuICAgIG0udmVydGV4QXR0cmliM2Z2KGIuY29sb3IsZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzLmNvbG9yKSk7MDw9Yi5ub3JtYWwmJihtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsTm9ybWFsQnVmZmVyKSxXLmVuYWJsZUF0dHJpYnV0ZShiLm5vcm1hbCksbS52ZXJ0ZXhBdHRyaWJQb2ludGVyKGIubm9ybWFsLDMsbS5GTE9BVCwhMSwwLDApKTswPD1iLnRhbmdlbnQmJihtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsVGFuZ2VudEJ1ZmZlciksVy5lbmFibGVBdHRyaWJ1dGUoYi50YW5nZW50KSxtLnZlcnRleEF0dHJpYlBvaW50ZXIoYi50YW5nZW50LDQsbS5GTE9BVCwhMSwwLDApKTswPD1iLnV2JiYoZi5nZW9tZXRyeS5mYWNlVmVydGV4VXZzWzBdPyhtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsVVZCdWZmZXIpLFcuZW5hYmxlQXR0cmlidXRlKGIudXYpLG0udmVydGV4QXR0cmliUG9pbnRlcihiLnV2LDIsbS5GTE9BVCwhMSwwLFxuICAgICAgICAwKSk6dm9pZCAwIT09ZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzJiZtLnZlcnRleEF0dHJpYjJmdihiLnV2LGQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcy51dikpOzA8PWIudXYyJiYoZi5nZW9tZXRyeS5mYWNlVmVydGV4VXZzWzFdPyhtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsVVYyQnVmZmVyKSxXLmVuYWJsZUF0dHJpYnV0ZShiLnV2MiksbS52ZXJ0ZXhBdHRyaWJQb2ludGVyKGIudXYyLDIsbS5GTE9BVCwhMSwwLDApKTp2b2lkIDAhPT1kLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMmJm0udmVydGV4QXR0cmliMmZ2KGIudXYyLGQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcy51djIpKTtkLnNraW5uaW5nJiYwPD1iLnNraW5JbmRleCYmMDw9Yi5za2luV2VpZ2h0JiYobS5iaW5kQnVmZmVyKG0uQVJSQVlfQlVGRkVSLGUuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyKSxXLmVuYWJsZUF0dHJpYnV0ZShiLnNraW5JbmRleCksbS52ZXJ0ZXhBdHRyaWJQb2ludGVyKGIuc2tpbkluZGV4LFxuICAgICAgICA0LG0uRkxPQVQsITEsMCwwKSxtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIpLFcuZW5hYmxlQXR0cmlidXRlKGIuc2tpbldlaWdodCksbS52ZXJ0ZXhBdHRyaWJQb2ludGVyKGIuc2tpbldlaWdodCw0LG0uRkxPQVQsITEsMCwwKSk7MDw9Yi5saW5lRGlzdGFuY2UmJihtLmJpbmRCdWZmZXIobS5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsTGluZURpc3RhbmNlQnVmZmVyKSxXLmVuYWJsZUF0dHJpYnV0ZShiLmxpbmVEaXN0YW5jZSksbS52ZXJ0ZXhBdHRyaWJQb2ludGVyKGIubGluZURpc3RhbmNlLDEsbS5GTE9BVCwhMSwwLDApKX1XLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7ZiBpbnN0YW5jZW9mIFRIUkVFLk1lc2g/KGY9ZS5fX3R5cGVBcnJheT09PVVpbnQzMkFycmF5P20uVU5TSUdORURfSU5UOm0uVU5TSUdORURfU0hPUlQsZC53aXJlZnJhbWU/KFcuc2V0TGluZVdpZHRoKGQud2lyZWZyYW1lTGluZXdpZHRoKkgpLGEmJm0uYmluZEJ1ZmZlcihtLkVMRU1FTlRfQVJSQVlfQlVGRkVSLFxuICAgICAgICBlLl9fd2ViZ2xMaW5lQnVmZmVyKSxtLmRyYXdFbGVtZW50cyhtLkxJTkVTLGUuX193ZWJnbExpbmVDb3VudCxmLDApKTooYSYmbS5iaW5kQnVmZmVyKG0uRUxFTUVOVF9BUlJBWV9CVUZGRVIsZS5fX3dlYmdsRmFjZUJ1ZmZlciksbS5kcmF3RWxlbWVudHMobS5UUklBTkdMRVMsZS5fX3dlYmdsRmFjZUNvdW50LGYsMCkpLEIuaW5mby5yZW5kZXIuY2FsbHMrKyxCLmluZm8ucmVuZGVyLnZlcnRpY2VzKz1lLl9fd2ViZ2xGYWNlQ291bnQsQi5pbmZvLnJlbmRlci5mYWNlcys9ZS5fX3dlYmdsRmFjZUNvdW50LzMpOmYgaW5zdGFuY2VvZiBUSFJFRS5MaW5lPyhmPWYubW9kZT09PVRIUkVFLkxpbmVTdHJpcD9tLkxJTkVfU1RSSVA6bS5MSU5FUyxXLnNldExpbmVXaWR0aChkLmxpbmV3aWR0aCpIKSxtLmRyYXdBcnJheXMoZiwwLGUuX193ZWJnbExpbmVDb3VudCksQi5pbmZvLnJlbmRlci5jYWxscysrKTpmIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCYmKG0uZHJhd0FycmF5cyhtLlBPSU5UUyxcbiAgICAgICAgMCxlLl9fd2ViZ2xQYXJ0aWNsZUNvdW50KSxCLmluZm8ucmVuZGVyLmNhbGxzKyssQi5pbmZvLnJlbmRlci5wb2ludHMrPWUuX193ZWJnbFBhcnRpY2xlQ291bnQpfX07dGhpcy5yZW5kZXI9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoITE9PT1iIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhKVRIUkVFLmVycm9yKFwiVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLlwiKTtlbHNle3ZhciBnPWEuZm9nO3RhPVwiXCI7dWI9LTE7dmI9bnVsbDtPYj0hMDshMD09PWEuYXV0b1VwZGF0ZSYmYS51cGRhdGVNYXRyaXhXb3JsZCgpO3ZvaWQgMD09PWIucGFyZW50JiZiLnVwZGF0ZU1hdHJpeFdvcmxkKCk7YS50cmF2ZXJzZShmdW5jdGlvbihhKXthIGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2gmJmEuc2tlbGV0b24udXBkYXRlKCl9KTtiLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKGIubWF0cml4V29ybGQpO2RiLm11bHRpcGx5TWF0cmljZXMoYi5wcm9qZWN0aW9uTWF0cml4LFxuICAgICAgICBiLm1hdHJpeFdvcmxkSW52ZXJzZSk7Y2Iuc2V0RnJvbU1hdHJpeChkYik7Y2EubGVuZ3RoPTA7S2EubGVuZ3RoPTA7UWEubGVuZ3RoPTA7WGEubGVuZ3RoPTA7WWEubGVuZ3RoPTA7aChhKTshMD09PUIuc29ydE9iamVjdHMmJihLYS5zb3J0KGUpLFFhLnNvcnQoZikpO3pjLnJlbmRlcihhLGIpO0IuaW5mby5yZW5kZXIuY2FsbHM9MDtCLmluZm8ucmVuZGVyLnZlcnRpY2VzPTA7Qi5pbmZvLnJlbmRlci5mYWNlcz0wO0IuaW5mby5yZW5kZXIucG9pbnRzPTA7dGhpcy5zZXRSZW5kZXJUYXJnZXQoYyk7KHRoaXMuYXV0b0NsZWFyfHxkKSYmdGhpcy5jbGVhcih0aGlzLmF1dG9DbGVhckNvbG9yLHRoaXMuYXV0b0NsZWFyRGVwdGgsdGhpcy5hdXRvQ2xlYXJTdGVuY2lsKTtkPTA7Zm9yKHZhciBuPXFhLmxlbmd0aDtkPG47ZCsrKXt2YXIgbT1xYVtkXSxxPW0ub2JqZWN0O3EudmlzaWJsZSYmKHcocSxiKSxwKG0pKX1hLm92ZXJyaWRlTWF0ZXJpYWw/KGQ9YS5vdmVycmlkZU1hdGVyaWFsLHUoZCksXG4gICAgICAgIGsoS2EsYixjYSxnLGQpLGsoUWEsYixjYSxnLGQpLGwocWEsXCJcIixiLGNhLGcsZCkpOihXLnNldEJsZW5kaW5nKFRIUkVFLk5vQmxlbmRpbmcpLGsoS2EsYixjYSxnLG51bGwpLGwocWEsXCJvcGFxdWVcIixiLGNhLGcsbnVsbCksayhRYSxiLGNhLGcsbnVsbCksbChxYSxcInRyYW5zcGFyZW50XCIsYixjYSxnLG51bGwpKTtBYy5yZW5kZXIoYSxiKTtCYy5yZW5kZXIoYSxiLFhiLGZjKTtjJiZjLmdlbmVyYXRlTWlwbWFwcyYmYy5taW5GaWx0ZXIhPT1USFJFRS5OZWFyZXN0RmlsdGVyJiZjLm1pbkZpbHRlciE9PVRIUkVFLkxpbmVhckZpbHRlciYmRihjKTtXLnNldERlcHRoVGVzdCghMCk7Vy5zZXREZXB0aFdyaXRlKCEwKTtXLnNldENvbG9yV3JpdGUoITApfX07dGhpcy5yZW5kZXJJbW1lZGlhdGVPYmplY3Q9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj12KGEsYixjLGQsZSk7dGE9XCJcIjtCLnNldE1hdGVyaWFsRmFjZXMoZCk7ZS5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjaz9lLmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrKGYsXG4gICAgICAgIG0sY2IpOmUucmVuZGVyKGZ1bmN0aW9uKGEpe0IucmVuZGVyQnVmZmVySW1tZWRpYXRlKGEsZixkKX0pfTt2YXIgVWE9e30sUWI9MCxwYz17TWVzaERlcHRoTWF0ZXJpYWw6XCJkZXB0aFwiLE1lc2hOb3JtYWxNYXRlcmlhbDpcIm5vcm1hbFwiLE1lc2hCYXNpY01hdGVyaWFsOlwiYmFzaWNcIixNZXNoTGFtYmVydE1hdGVyaWFsOlwibGFtYmVydFwiLE1lc2hQaG9uZ01hdGVyaWFsOlwicGhvbmdcIixMaW5lQmFzaWNNYXRlcmlhbDpcImJhc2ljXCIsTGluZURhc2hlZE1hdGVyaWFsOlwiZGFzaGVkXCIsUG9pbnRDbG91ZE1hdGVyaWFsOlwicGFydGljbGVfYmFzaWNcIn07dGhpcy5zZXRGYWNlQ3VsbGluZz1mdW5jdGlvbihhLGIpe2E9PT1USFJFRS5DdWxsRmFjZU5vbmU/bS5kaXNhYmxlKG0uQ1VMTF9GQUNFKTooYj09PVRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXP20uZnJvbnRGYWNlKG0uQ1cpOm0uZnJvbnRGYWNlKG0uQ0NXKSxhPT09VEhSRUUuQ3VsbEZhY2VCYWNrP20uY3VsbEZhY2UobS5CQUNLKTphPT09XG4gICAgVEhSRUUuQ3VsbEZhY2VGcm9udD9tLmN1bGxGYWNlKG0uRlJPTlQpOm0uY3VsbEZhY2UobS5GUk9OVF9BTkRfQkFDSyksbS5lbmFibGUobS5DVUxMX0ZBQ0UpKX07dGhpcy5zZXRNYXRlcmlhbEZhY2VzPWZ1bmN0aW9uKGEpe1cuc2V0RG91YmxlU2lkZWQoYS5zaWRlPT09VEhSRUUuRG91YmxlU2lkZSk7Vy5zZXRGbGlwU2lkZWQoYS5zaWRlPT09VEhSRUUuQmFja1NpZGUpfTt0aGlzLnVwbG9hZFRleHR1cmU9ZnVuY3Rpb24oYSl7dm9pZCAwPT09YS5fX3dlYmdsSW5pdCYmKGEuX193ZWJnbEluaXQ9ITAsYS5hZGRFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLFBiKSxhLl9fd2ViZ2xUZXh0dXJlPW0uY3JlYXRlVGV4dHVyZSgpLEIuaW5mby5tZW1vcnkudGV4dHVyZXMrKyk7bS5iaW5kVGV4dHVyZShtLlRFWFRVUkVfMkQsYS5fX3dlYmdsVGV4dHVyZSk7bS5waXhlbFN0b3JlaShtLlVOUEFDS19GTElQX1lfV0VCR0wsYS5mbGlwWSk7bS5waXhlbFN0b3JlaShtLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCxcbiAgICAgICAgYS5wcmVtdWx0aXBseUFscGhhKTttLnBpeGVsU3RvcmVpKG0uVU5QQUNLX0FMSUdOTUVOVCxhLnVucGFja0FsaWdubWVudCk7YS5pbWFnZT1FKGEuaW1hZ2UsdGMpO3ZhciBiPWEuaW1hZ2UsYz1USFJFRS5NYXRoLmlzUG93ZXJPZlR3byhiLndpZHRoKSYmVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oYi5oZWlnaHQpLGQ9SShhLmZvcm1hdCksZT1JKGEudHlwZSk7QShtLlRFWFRVUkVfMkQsYSxjKTt2YXIgZj1hLm1pcG1hcHM7aWYoYSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlKWlmKDA8Zi5sZW5ndGgmJmMpe2Zvcih2YXIgZz0wLGg9Zi5sZW5ndGg7ZzxoO2crKyliPWZbZ10sbS50ZXhJbWFnZTJEKG0uVEVYVFVSRV8yRCxnLGQsYi53aWR0aCxiLmhlaWdodCwwLGQsZSxiLmRhdGEpO2EuZ2VuZXJhdGVNaXBtYXBzPSExfWVsc2UgbS50ZXhJbWFnZTJEKG0uVEVYVFVSRV8yRCwwLGQsYi53aWR0aCxiLmhlaWdodCwwLGQsZSxiLmRhdGEpO2Vsc2UgaWYoYSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlKWZvcihnPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLGg9Zi5sZW5ndGg7ZzxoO2crKyliPWZbZ10sYS5mb3JtYXQhPT1USFJFRS5SR0JBRm9ybWF0JiZhLmZvcm1hdCE9PVRIUkVFLlJHQkZvcm1hdD8tMTxrYygpLmluZGV4T2YoZCk/bS5jb21wcmVzc2VkVGV4SW1hZ2UyRChtLlRFWFRVUkVfMkQsZyxkLGIud2lkdGgsYi5oZWlnaHQsMCxiLmRhdGEpOlRIUkVFLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpXCIpOm0udGV4SW1hZ2UyRChtLlRFWFRVUkVfMkQsZyxkLGIud2lkdGgsYi5oZWlnaHQsMCxkLGUsYi5kYXRhKTtlbHNlIGlmKDA8Zi5sZW5ndGgmJmMpe2c9MDtmb3IoaD1mLmxlbmd0aDtnPGg7ZysrKWI9ZltnXSxtLnRleEltYWdlMkQobS5URVhUVVJFXzJELGcsZCxkLGUsYik7YS5nZW5lcmF0ZU1pcG1hcHM9ITF9ZWxzZSBtLnRleEltYWdlMkQobS5URVhUVVJFXzJELDAsZCxkLGUsYS5pbWFnZSk7XG4gICAgICAgIGEuZ2VuZXJhdGVNaXBtYXBzJiZjJiZtLmdlbmVyYXRlTWlwbWFwKG0uVEVYVFVSRV8yRCk7YS5uZWVkc1VwZGF0ZT0hMTtpZihhLm9uVXBkYXRlKWEub25VcGRhdGUoKX07dGhpcy5zZXRUZXh0dXJlPWZ1bmN0aW9uKGEsYil7bS5hY3RpdmVUZXh0dXJlKG0uVEVYVFVSRTArYik7YS5uZWVkc1VwZGF0ZT9CLnVwbG9hZFRleHR1cmUoYSk6bS5iaW5kVGV4dHVyZShtLlRFWFRVUkVfMkQsYS5fX3dlYmdsVGV4dHVyZSl9O3RoaXMuc2V0UmVuZGVyVGFyZ2V0PWZ1bmN0aW9uKGEpe3ZhciBiPWEgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU7aWYoYSYmdm9pZCAwPT09YS5fX3dlYmdsRnJhbWVidWZmZXIpe3ZvaWQgMD09PWEuZGVwdGhCdWZmZXImJihhLmRlcHRoQnVmZmVyPSEwKTt2b2lkIDA9PT1hLnN0ZW5jaWxCdWZmZXImJihhLnN0ZW5jaWxCdWZmZXI9ITApO2EuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixvYyk7YS5fX3dlYmdsVGV4dHVyZT1tLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgQi5pbmZvLm1lbW9yeS50ZXh0dXJlcysrO3ZhciBjPVRIUkVFLk1hdGguaXNQb3dlck9mVHdvKGEud2lkdGgpJiZUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byhhLmhlaWdodCksZD1JKGEuZm9ybWF0KSxlPUkoYS50eXBlKTtpZihiKXthLl9fd2ViZ2xGcmFtZWJ1ZmZlcj1bXTthLl9fd2ViZ2xSZW5kZXJidWZmZXI9W107bS5iaW5kVGV4dHVyZShtLlRFWFRVUkVfQ1VCRV9NQVAsYS5fX3dlYmdsVGV4dHVyZSk7QShtLlRFWFRVUkVfQ1VCRV9NQVAsYSxjKTtmb3IodmFyIGY9MDs2PmY7ZisrKXthLl9fd2ViZ2xGcmFtZWJ1ZmZlcltmXT1tLmNyZWF0ZUZyYW1lYnVmZmVyKCk7YS5fX3dlYmdsUmVuZGVyYnVmZmVyW2ZdPW0uY3JlYXRlUmVuZGVyYnVmZmVyKCk7bS50ZXhJbWFnZTJEKG0uVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK2YsMCxkLGEud2lkdGgsYS5oZWlnaHQsMCxkLGUsbnVsbCk7dmFyIGc9YSxoPW0uVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK2Y7bS5iaW5kRnJhbWVidWZmZXIobS5GUkFNRUJVRkZFUixcbiAgICAgICAgICAgIGEuX193ZWJnbEZyYW1lYnVmZmVyW2ZdKTttLmZyYW1lYnVmZmVyVGV4dHVyZTJEKG0uRlJBTUVCVUZGRVIsbS5DT0xPUl9BVFRBQ0hNRU5UMCxoLGcuX193ZWJnbFRleHR1cmUsMCk7RyhhLl9fd2ViZ2xSZW5kZXJidWZmZXJbZl0sYSl9YyYmbS5nZW5lcmF0ZU1pcG1hcChtLlRFWFRVUkVfQ1VCRV9NQVApfWVsc2UgYS5fX3dlYmdsRnJhbWVidWZmZXI9bS5jcmVhdGVGcmFtZWJ1ZmZlcigpLGEuX193ZWJnbFJlbmRlcmJ1ZmZlcj1hLnNoYXJlRGVwdGhGcm9tP2Euc2hhcmVEZXB0aEZyb20uX193ZWJnbFJlbmRlcmJ1ZmZlcjptLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLG0uYmluZFRleHR1cmUobS5URVhUVVJFXzJELGEuX193ZWJnbFRleHR1cmUpLEEobS5URVhUVVJFXzJELGEsYyksbS50ZXhJbWFnZTJEKG0uVEVYVFVSRV8yRCwwLGQsYS53aWR0aCxhLmhlaWdodCwwLGQsZSxudWxsKSxkPW0uVEVYVFVSRV8yRCxtLmJpbmRGcmFtZWJ1ZmZlcihtLkZSQU1FQlVGRkVSLGEuX193ZWJnbEZyYW1lYnVmZmVyKSxcbiAgICAgICAgICAgIG0uZnJhbWVidWZmZXJUZXh0dXJlMkQobS5GUkFNRUJVRkZFUixtLkNPTE9SX0FUVEFDSE1FTlQwLGQsYS5fX3dlYmdsVGV4dHVyZSwwKSxhLnNoYXJlRGVwdGhGcm9tP2EuZGVwdGhCdWZmZXImJiFhLnN0ZW5jaWxCdWZmZXI/bS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihtLkZSQU1FQlVGRkVSLG0uREVQVEhfQVRUQUNITUVOVCxtLlJFTkRFUkJVRkZFUixhLl9fd2ViZ2xSZW5kZXJidWZmZXIpOmEuZGVwdGhCdWZmZXImJmEuc3RlbmNpbEJ1ZmZlciYmbS5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihtLkZSQU1FQlVGRkVSLG0uREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULG0uUkVOREVSQlVGRkVSLGEuX193ZWJnbFJlbmRlcmJ1ZmZlcik6RyhhLl9fd2ViZ2xSZW5kZXJidWZmZXIsYSksYyYmbS5nZW5lcmF0ZU1pcG1hcChtLlRFWFRVUkVfMkQpO2I/bS5iaW5kVGV4dHVyZShtLlRFWFRVUkVfQ1VCRV9NQVAsbnVsbCk6bS5iaW5kVGV4dHVyZShtLlRFWFRVUkVfMkQsbnVsbCk7bS5iaW5kUmVuZGVyYnVmZmVyKG0uUkVOREVSQlVGRkVSLFxuICAgICAgICAgICAgbnVsbCk7bS5iaW5kRnJhbWVidWZmZXIobS5GUkFNRUJVRkZFUixudWxsKX1hPyhiPWI/YS5fX3dlYmdsRnJhbWVidWZmZXJbYS5hY3RpdmVDdWJlRmFjZV06YS5fX3dlYmdsRnJhbWVidWZmZXIsYz1hLndpZHRoLGE9YS5oZWlnaHQsZT1kPTApOihiPW51bGwsYz1wYixhPXFiLGQ9aWIsZT1iYik7YiE9PWFiJiYobS5iaW5kRnJhbWVidWZmZXIobS5GUkFNRUJVRkZFUixiKSxtLnZpZXdwb3J0KGQsZSxjLGEpLGFiPWIpO1hiPWM7ZmM9YX07dGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZighKGEgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCkpY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5cIik7ZWxzZSBpZihhLl9fd2ViZ2xGcmFtZWJ1ZmZlcilpZihhLmZvcm1hdCE9PVRIUkVFLlJHQkFGb3JtYXQpY29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIGZvcm1hdC4gcmVhZFBpeGVscyBjYW4gcmVhZCBvbmx5IFJHQkEgZm9ybWF0LlwiKTtcbiAgICBlbHNle3ZhciBnPSExO2EuX193ZWJnbEZyYW1lYnVmZmVyIT09YWImJihtLmJpbmRGcmFtZWJ1ZmZlcihtLkZSQU1FQlVGRkVSLGEuX193ZWJnbEZyYW1lYnVmZmVyKSxnPSEwKTttLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMobS5GUkFNRUJVRkZFUik9PT1tLkZSQU1FQlVGRkVSX0NPTVBMRVRFP20ucmVhZFBpeGVscyhiLGMsZCxlLG0uUkdCQSxtLlVOU0lHTkVEX0JZVEUsZik6Y29uc29sZS5lcnJvcihcIlRIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVhZFBpeGVscyBmcm9tIHJlbmRlclRhcmdldCBmYWlsZWQuIEZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZS5cIik7ZyYmbS5iaW5kRnJhbWVidWZmZXIobS5GUkFNRUJVRkZFUixhYil9fTt0aGlzLmluaXRNYXRlcmlhbD1mdW5jdGlvbigpe1RIUkVFLndhcm4oXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9O3RoaXMuYWRkUHJlUGx1Z2luPWZ1bmN0aW9uKCl7VEhSRUUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQcmVQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLlwiKX07XG4gICAgdGhpcy5hZGRQb3N0UGx1Z2luPWZ1bmN0aW9uKCl7VEhSRUUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9O3RoaXMudXBkYXRlU2hhZG93TWFwPWZ1bmN0aW9uKCl7VEhSRUUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLlwiKX19O1xuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ9ZnVuY3Rpb24oYSxiLGMpe3RoaXMud2lkdGg9YTt0aGlzLmhlaWdodD1iO2M9Y3x8e307dGhpcy53cmFwUz12b2lkIDAhPT1jLndyYXBTP2Mud3JhcFM6VEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzt0aGlzLndyYXBUPXZvaWQgMCE9PWMud3JhcFQ/Yy53cmFwVDpUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO3RoaXMubWFnRmlsdGVyPXZvaWQgMCE9PWMubWFnRmlsdGVyP2MubWFnRmlsdGVyOlRIUkVFLkxpbmVhckZpbHRlcjt0aGlzLm1pbkZpbHRlcj12b2lkIDAhPT1jLm1pbkZpbHRlcj9jLm1pbkZpbHRlcjpUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7dGhpcy5hbmlzb3Ryb3B5PXZvaWQgMCE9PWMuYW5pc290cm9weT9jLmFuaXNvdHJvcHk6MTt0aGlzLm9mZnNldD1uZXcgVEhSRUUuVmVjdG9yMigwLDApO3RoaXMucmVwZWF0PW5ldyBUSFJFRS5WZWN0b3IyKDEsMSk7dGhpcy5mb3JtYXQ9dm9pZCAwIT09Yy5mb3JtYXQ/Yy5mb3JtYXQ6XG4gICAgVEhSRUUuUkdCQUZvcm1hdDt0aGlzLnR5cGU9dm9pZCAwIT09Yy50eXBlP2MudHlwZTpUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO3RoaXMuZGVwdGhCdWZmZXI9dm9pZCAwIT09Yy5kZXB0aEJ1ZmZlcj9jLmRlcHRoQnVmZmVyOiEwO3RoaXMuc3RlbmNpbEJ1ZmZlcj12b2lkIDAhPT1jLnN0ZW5jaWxCdWZmZXI/Yy5zdGVuY2lsQnVmZmVyOiEwO3RoaXMuZ2VuZXJhdGVNaXBtYXBzPSEwO3RoaXMuc2hhcmVEZXB0aEZyb209dm9pZCAwIT09Yy5zaGFyZURlcHRoRnJvbT9jLnNoYXJlRGVwdGhGcm9tOm51bGx9O1xuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5XZWJHTFJlbmRlclRhcmdldCxzZXRTaXplOmZ1bmN0aW9uKGEsYil7dGhpcy53aWR0aD1hO3RoaXMuaGVpZ2h0PWJ9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpO2Eud3JhcFM9dGhpcy53cmFwUzthLndyYXBUPXRoaXMud3JhcFQ7YS5tYWdGaWx0ZXI9dGhpcy5tYWdGaWx0ZXI7YS5taW5GaWx0ZXI9dGhpcy5taW5GaWx0ZXI7YS5hbmlzb3Ryb3B5PXRoaXMuYW5pc290cm9weTthLm9mZnNldC5jb3B5KHRoaXMub2Zmc2V0KTthLnJlcGVhdC5jb3B5KHRoaXMucmVwZWF0KTthLmZvcm1hdD10aGlzLmZvcm1hdDthLnR5cGU9dGhpcy50eXBlO2EuZGVwdGhCdWZmZXI9dGhpcy5kZXB0aEJ1ZmZlcjthLnN0ZW5jaWxCdWZmZXI9dGhpcy5zdGVuY2lsQnVmZmVyO2EuZ2VuZXJhdGVNaXBtYXBzPXRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xuICAgIGEuc2hhcmVEZXB0aEZyb209dGhpcy5zaGFyZURlcHRoRnJvbTtyZXR1cm4gYX0sZGlzcG9zZTpmdW5jdGlvbigpe3RoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTpcImRpc3Bvc2VcIn0pfX07VEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseShUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUpO1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZT1mdW5jdGlvbihhLGIsYyl7VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuY2FsbCh0aGlzLGEsYixjKTt0aGlzLmFjdGl2ZUN1YmVGYWNlPTB9O1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUpO1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlO1xuVEhSRUUuV2ViR0xFeHRlbnNpb25zPWZ1bmN0aW9uKGEpe3ZhciBiPXt9O3RoaXMuZ2V0PWZ1bmN0aW9uKGMpe2lmKHZvaWQgMCE9PWJbY10pcmV0dXJuIGJbY107dmFyIGQ7c3dpdGNoKGMpe2Nhc2UgXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIjpkPWEuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpfHxhLmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIil8fGEuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKTticmVhaztjYXNlIFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIjpkPWEuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIil8fGEuZ2V0RXh0ZW5zaW9uKFwiTU9aX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpfHxhLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKTtcbiAgICBicmVhaztjYXNlIFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCI6ZD1hLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKXx8YS5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpO2JyZWFrO2RlZmF1bHQ6ZD1hLmdldEV4dGVuc2lvbihjKX1udWxsPT09ZCYmVEhSRUUud2FybihcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFwiK2MrXCIgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuXCIpO3JldHVybiBiW2NdPWR9fTtcblRIUkVFLldlYkdMUHJvZ3JhbT1mdW5jdGlvbigpe3ZhciBhPTA7cmV0dXJuIGZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPWIuY29udGV4dCxnPWQuZGVmaW5lcyxoPWQuX193ZWJnbFNoYWRlci51bmlmb3JtcyxrPWQuYXR0cmlidXRlcyxsPWQuX193ZWJnbFNoYWRlci52ZXJ0ZXhTaGFkZXIscD1kLl9fd2ViZ2xTaGFkZXIuZnJhZ21lbnRTaGFkZXIscT1kLmluZGV4MEF0dHJpYnV0ZU5hbWU7dm9pZCAwPT09cSYmITA9PT1lLm1vcnBoVGFyZ2V0cyYmKHE9XCJwb3NpdGlvblwiKTt2YXIgbj1cIlNIQURPV01BUF9UWVBFX0JBU0lDXCI7ZS5zaGFkb3dNYXBUeXBlPT09VEhSRUUuUENGU2hhZG93TWFwP249XCJTSEFET1dNQVBfVFlQRV9QQ0ZcIjplLnNoYWRvd01hcFR5cGU9PT1USFJFRS5QQ0ZTb2Z0U2hhZG93TWFwJiYobj1cIlNIQURPV01BUF9UWVBFX1BDRl9TT0ZUXCIpO3ZhciB0PVwiRU5WTUFQX1RZUEVfQ1VCRVwiLHI9XCJFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXCIscz1cIkVOVk1BUF9CTEVORElOR19NVUxUSVBMWVwiO1xuICAgIGlmKGUuZW52TWFwKXtzd2l0Y2goZC5lbnZNYXAubWFwcGluZyl7Y2FzZSBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc6Y2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6dD1cIkVOVk1BUF9UWVBFX0NVQkVcIjticmVhaztjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOmNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6dD1cIkVOVk1BUF9UWVBFX0VRVUlSRUNcIjticmVhaztjYXNlIFRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOnQ9XCJFTlZNQVBfVFlQRV9TUEhFUkVcIn1zd2l0Y2goZC5lbnZNYXAubWFwcGluZyl7Y2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6Y2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpyPVwiRU5WTUFQX01PREVfUkVGUkFDVElPTlwifXN3aXRjaChkLmNvbWJpbmUpe2Nhc2UgVEhSRUUuTXVsdGlwbHlPcGVyYXRpb246cz1cIkVOVk1BUF9CTEVORElOR19NVUxUSVBMWVwiO1xuICAgICAgICBicmVhaztjYXNlIFRIUkVFLk1peE9wZXJhdGlvbjpzPVwiRU5WTUFQX0JMRU5ESU5HX01JWFwiO2JyZWFrO2Nhc2UgVEhSRUUuQWRkT3BlcmF0aW9uOnM9XCJFTlZNQVBfQkxFTkRJTkdfQUREXCJ9fXZhciB1PTA8Yi5nYW1tYUZhY3Rvcj9iLmdhbW1hRmFjdG9yOjEsdix4O3Y9W107Zm9yKHZhciBEIGluIGcpeD1nW0RdLCExIT09eCYmKHg9XCIjZGVmaW5lIFwiK0QrXCIgXCIreCx2LnB1c2goeCkpO3Y9di5qb2luKFwiXFxuXCIpO2c9Zi5jcmVhdGVQcm9ncmFtKCk7ZCBpbnN0YW5jZW9mIFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsP2I9ZD1cIlwiOihkPVtcInByZWNpc2lvbiBcIitlLnByZWNpc2lvbitcIiBmbG9hdDtcIixcInByZWNpc2lvbiBcIitlLnByZWNpc2lvbitcIiBpbnQ7XCIsdixlLnN1cHBvcnRzVmVydGV4VGV4dHVyZXM/XCIjZGVmaW5lIFZFUlRFWF9URVhUVVJFU1wiOlwiXCIsYi5nYW1tYUlucHV0P1wiI2RlZmluZSBHQU1NQV9JTlBVVFwiOlwiXCIsYi5nYW1tYU91dHB1dD9cIiNkZWZpbmUgR0FNTUFfT1VUUFVUXCI6XG4gICAgICAgIFwiXCIsXCIjZGVmaW5lIEdBTU1BX0ZBQ1RPUiBcIit1LFwiI2RlZmluZSBNQVhfRElSX0xJR0hUUyBcIitlLm1heERpckxpZ2h0cyxcIiNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyBcIitlLm1heFBvaW50TGlnaHRzLFwiI2RlZmluZSBNQVhfU1BPVF9MSUdIVFMgXCIrZS5tYXhTcG90TGlnaHRzLFwiI2RlZmluZSBNQVhfSEVNSV9MSUdIVFMgXCIrZS5tYXhIZW1pTGlnaHRzLFwiI2RlZmluZSBNQVhfU0hBRE9XUyBcIitlLm1heFNoYWRvd3MsXCIjZGVmaW5lIE1BWF9CT05FUyBcIitlLm1heEJvbmVzLGUubWFwP1wiI2RlZmluZSBVU0VfTUFQXCI6XCJcIixlLmVudk1hcD9cIiNkZWZpbmUgVVNFX0VOVk1BUFwiOlwiXCIsZS5lbnZNYXA/XCIjZGVmaW5lIFwiK3I6XCJcIixlLmxpZ2h0TWFwP1wiI2RlZmluZSBVU0VfTElHSFRNQVBcIjpcIlwiLGUuYnVtcE1hcD9cIiNkZWZpbmUgVVNFX0JVTVBNQVBcIjpcIlwiLGUubm9ybWFsTWFwP1wiI2RlZmluZSBVU0VfTk9STUFMTUFQXCI6XCJcIixlLnNwZWN1bGFyTWFwP1wiI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVBcIjpcbiAgICAgICAgXCJcIixlLmFscGhhTWFwP1wiI2RlZmluZSBVU0VfQUxQSEFNQVBcIjpcIlwiLGUudmVydGV4Q29sb3JzP1wiI2RlZmluZSBVU0VfQ09MT1JcIjpcIlwiLGUuZmxhdFNoYWRpbmc/XCIjZGVmaW5lIEZMQVRfU0hBREVEXCI6XCJcIixlLnNraW5uaW5nP1wiI2RlZmluZSBVU0VfU0tJTk5JTkdcIjpcIlwiLGUudXNlVmVydGV4VGV4dHVyZT9cIiNkZWZpbmUgQk9ORV9URVhUVVJFXCI6XCJcIixlLm1vcnBoVGFyZ2V0cz9cIiNkZWZpbmUgVVNFX01PUlBIVEFSR0VUU1wiOlwiXCIsZS5tb3JwaE5vcm1hbHM/XCIjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFNcIjpcIlwiLGUud3JhcEFyb3VuZD9cIiNkZWZpbmUgV1JBUF9BUk9VTkRcIjpcIlwiLGUuZG91YmxlU2lkZWQ/XCIjZGVmaW5lIERPVUJMRV9TSURFRFwiOlwiXCIsZS5mbGlwU2lkZWQ/XCIjZGVmaW5lIEZMSVBfU0lERURcIjpcIlwiLGUuc2hhZG93TWFwRW5hYmxlZD9cIiNkZWZpbmUgVVNFX1NIQURPV01BUFwiOlwiXCIsZS5zaGFkb3dNYXBFbmFibGVkP1wiI2RlZmluZSBcIituOlwiXCIsZS5zaGFkb3dNYXBEZWJ1Zz9cbiAgICAgICAgXCIjZGVmaW5lIFNIQURPV01BUF9ERUJVR1wiOlwiXCIsZS5zaGFkb3dNYXBDYXNjYWRlP1wiI2RlZmluZSBTSEFET1dNQVBfQ0FTQ0FERVwiOlwiXCIsZS5zaXplQXR0ZW51YXRpb24/XCIjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT05cIjpcIlwiLGUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcj9cIiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGXCI6XCJcIixcInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7XFxudW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcXG5hdHRyaWJ1dGUgdmVjMiB1djtcXG5hdHRyaWJ1dGUgdmVjMiB1djI7XFxuI2lmZGVmIFVTRV9DT0xPUlxcblxcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwO1xcblxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTtcXG5cXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7XFxuXFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzO1xcblxcdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwO1xcblxcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTtcXG5cXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7XFxuXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzO1xcblxcdCNlbHNlXFxuXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0O1xcblxcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTtcXG5cXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDY7XFxuXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7XFxuXFx0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDtcXG4jZW5kaWZcXG5cIl0uam9pbihcIlxcblwiKSxcbiAgICAgICAgYj1bXCJwcmVjaXNpb24gXCIrZS5wcmVjaXNpb24rXCIgZmxvYXQ7XCIsXCJwcmVjaXNpb24gXCIrZS5wcmVjaXNpb24rXCIgaW50O1wiLGUuYnVtcE1hcHx8ZS5ub3JtYWxNYXB8fGUuZmxhdFNoYWRpbmc/XCIjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVwiOlwiXCIsdixcIiNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgXCIrZS5tYXhEaXJMaWdodHMsXCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIrZS5tYXhQb2ludExpZ2h0cyxcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiK2UubWF4U3BvdExpZ2h0cyxcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiK2UubWF4SGVtaUxpZ2h0cyxcIiNkZWZpbmUgTUFYX1NIQURPV1MgXCIrZS5tYXhTaGFkb3dzLGUuYWxwaGFUZXN0P1wiI2RlZmluZSBBTFBIQVRFU1QgXCIrZS5hbHBoYVRlc3Q6XCJcIixiLmdhbW1hSW5wdXQ/XCIjZGVmaW5lIEdBTU1BX0lOUFVUXCI6XCJcIixiLmdhbW1hT3V0cHV0P1wiI2RlZmluZSBHQU1NQV9PVVRQVVRcIjpcIlwiLFwiI2RlZmluZSBHQU1NQV9GQUNUT1IgXCIrXG4gICAgICAgIHUsZS51c2VGb2cmJmUuZm9nP1wiI2RlZmluZSBVU0VfRk9HXCI6XCJcIixlLnVzZUZvZyYmZS5mb2dFeHA/XCIjZGVmaW5lIEZPR19FWFAyXCI6XCJcIixlLm1hcD9cIiNkZWZpbmUgVVNFX01BUFwiOlwiXCIsZS5lbnZNYXA/XCIjZGVmaW5lIFVTRV9FTlZNQVBcIjpcIlwiLGUuZW52TWFwP1wiI2RlZmluZSBcIit0OlwiXCIsZS5lbnZNYXA/XCIjZGVmaW5lIFwiK3I6XCJcIixlLmVudk1hcD9cIiNkZWZpbmUgXCIrczpcIlwiLGUubGlnaHRNYXA/XCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiOlwiXCIsZS5idW1wTWFwP1wiI2RlZmluZSBVU0VfQlVNUE1BUFwiOlwiXCIsZS5ub3JtYWxNYXA/XCIjZGVmaW5lIFVTRV9OT1JNQUxNQVBcIjpcIlwiLGUuc3BlY3VsYXJNYXA/XCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiOlwiXCIsZS5hbHBoYU1hcD9cIiNkZWZpbmUgVVNFX0FMUEhBTUFQXCI6XCJcIixlLnZlcnRleENvbG9ycz9cIiNkZWZpbmUgVVNFX0NPTE9SXCI6XCJcIixlLmZsYXRTaGFkaW5nP1wiI2RlZmluZSBGTEFUX1NIQURFRFwiOlwiXCIsZS5tZXRhbD9cIiNkZWZpbmUgTUVUQUxcIjpcbiAgICAgICAgICAgIFwiXCIsZS53cmFwQXJvdW5kP1wiI2RlZmluZSBXUkFQX0FST1VORFwiOlwiXCIsZS5kb3VibGVTaWRlZD9cIiNkZWZpbmUgRE9VQkxFX1NJREVEXCI6XCJcIixlLmZsaXBTaWRlZD9cIiNkZWZpbmUgRkxJUF9TSURFRFwiOlwiXCIsZS5zaGFkb3dNYXBFbmFibGVkP1wiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCI6XCJcIixlLnNoYWRvd01hcEVuYWJsZWQ/XCIjZGVmaW5lIFwiK246XCJcIixlLnNoYWRvd01hcERlYnVnP1wiI2RlZmluZSBTSEFET1dNQVBfREVCVUdcIjpcIlwiLGUuc2hhZG93TWFwQ2FzY2FkZT9cIiNkZWZpbmUgU0hBRE9XTUFQX0NBU0NBREVcIjpcIlwiLGUubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcj9cIiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGXCI6XCJcIixcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xcbnVuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjtcXG5cIl0uam9pbihcIlxcblwiKSk7bD1uZXcgVEhSRUUuV2ViR0xTaGFkZXIoZixmLlZFUlRFWF9TSEFERVIsZCtsKTtwPW5ldyBUSFJFRS5XZWJHTFNoYWRlcihmLGYuRlJBR01FTlRfU0hBREVSLFxuICAgICAgICBiK3ApO2YuYXR0YWNoU2hhZGVyKGcsbCk7Zi5hdHRhY2hTaGFkZXIoZyxwKTt2b2lkIDAhPT1xJiZmLmJpbmRBdHRyaWJMb2NhdGlvbihnLDAscSk7Zi5saW5rUHJvZ3JhbShnKTtxPWYuZ2V0UHJvZ3JhbUluZm9Mb2coZyk7ITE9PT1mLmdldFByb2dyYW1QYXJhbWV0ZXIoZyxmLkxJTktfU1RBVFVTKSYmVEhSRUUuZXJyb3IoXCJUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogXCIrZi5nZXRFcnJvcigpLFwiZ2wuVkFMSURBVEVfU1RBVFVTXCIsZi5nZXRQcm9ncmFtUGFyYW1ldGVyKGcsZi5WQUxJREFURV9TVEFUVVMpLFwiZ2wuZ2V0UFJvZ3JhbUluZm9Mb2dcIixxKTtcIlwiIT09cSYmVEhSRUUud2FybihcIlRIUkVFLldlYkdMUHJvZ3JhbTogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKVwiK3EpO2YuZGVsZXRlU2hhZGVyKGwpO2YuZGVsZXRlU2hhZGVyKHApO3E9XCJ2aWV3TWF0cml4IG1vZGVsVmlld01hdHJpeCBwcm9qZWN0aW9uTWF0cml4IG5vcm1hbE1hdHJpeCBtb2RlbE1hdHJpeCBjYW1lcmFQb3NpdGlvbiBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmluZE1hdHJpeCBiaW5kTWF0cml4SW52ZXJzZVwiLnNwbGl0KFwiIFwiKTtcbiAgICBlLnVzZVZlcnRleFRleHR1cmU/KHEucHVzaChcImJvbmVUZXh0dXJlXCIpLHEucHVzaChcImJvbmVUZXh0dXJlV2lkdGhcIikscS5wdXNoKFwiYm9uZVRleHR1cmVIZWlnaHRcIikpOnEucHVzaChcImJvbmVHbG9iYWxNYXRyaWNlc1wiKTtlLmxvZ2FyaXRobWljRGVwdGhCdWZmZXImJnEucHVzaChcImxvZ0RlcHRoQnVmRkNcIik7Zm9yKHZhciB3IGluIGgpcS5wdXNoKHcpO2g9cTt3PXt9O3E9MDtmb3IoYj1oLmxlbmd0aDtxPGI7cSsrKW49aFtxXSx3W25dPWYuZ2V0VW5pZm9ybUxvY2F0aW9uKGcsbik7dGhpcy51bmlmb3Jtcz13O3E9XCJwb3NpdGlvbiBub3JtYWwgdXYgdXYyIHRhbmdlbnQgY29sb3Igc2tpbkluZGV4IHNraW5XZWlnaHQgbGluZURpc3RhbmNlXCIuc3BsaXQoXCIgXCIpO2ZvcihoPTA7aDxlLm1heE1vcnBoVGFyZ2V0cztoKyspcS5wdXNoKFwibW9ycGhUYXJnZXRcIitoKTtmb3IoaD0wO2g8ZS5tYXhNb3JwaE5vcm1hbHM7aCsrKXEucHVzaChcIm1vcnBoTm9ybWFsXCIraCk7Zm9yKHZhciB5IGluIGspcS5wdXNoKHkpO1xuICAgIGU9cTtrPXt9O3k9MDtmb3IoaD1lLmxlbmd0aDt5PGg7eSsrKXc9ZVt5XSxrW3ddPWYuZ2V0QXR0cmliTG9jYXRpb24oZyx3KTt0aGlzLmF0dHJpYnV0ZXM9azt0aGlzLmF0dHJpYnV0ZXNLZXlzPU9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcyk7dGhpcy5pZD1hKys7dGhpcy5jb2RlPWM7dGhpcy51c2VkVGltZXM9MTt0aGlzLnByb2dyYW09Zzt0aGlzLnZlcnRleFNoYWRlcj1sO3RoaXMuZnJhZ21lbnRTaGFkZXI9cDtyZXR1cm4gdGhpc319KCk7XG5USFJFRS5XZWJHTFNoYWRlcj1mdW5jdGlvbigpe3ZhciBhPWZ1bmN0aW9uKGEpe2E9YS5zcGxpdChcIlxcblwiKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylhW2NdPWMrMStcIjogXCIrYVtjXTtyZXR1cm4gYS5qb2luKFwiXFxuXCIpfTtyZXR1cm4gZnVuY3Rpb24oYixjLGQpe2M9Yi5jcmVhdGVTaGFkZXIoYyk7Yi5zaGFkZXJTb3VyY2UoYyxkKTtiLmNvbXBpbGVTaGFkZXIoYyk7ITE9PT1iLmdldFNoYWRlclBhcmFtZXRlcihjLGIuQ09NUElMRV9TVEFUVVMpJiZUSFJFRS5lcnJvcihcIlRIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuJ3QgY29tcGlsZS5cIik7XCJcIiE9PWIuZ2V0U2hhZGVySW5mb0xvZyhjKSYmVEhSRUUud2FybihcIlRIUkVFLldlYkdMU2hhZGVyOiBnbC5nZXRTaGFkZXJJbmZvTG9nKClcIixiLmdldFNoYWRlckluZm9Mb2coYyksYShkKSk7cmV0dXJuIGN9fSgpO1xuVEhSRUUuV2ViR0xTdGF0ZT1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBVaW50OEFycmF5KDE2KSxkPW5ldyBVaW50OEFycmF5KDE2KSxlPW51bGwsZj1udWxsLGc9bnVsbCxoPW51bGwsaz1udWxsLGw9bnVsbCxwPW51bGwscT1udWxsLG49bnVsbCx0PW51bGwscj1udWxsLHM9bnVsbCx1PW51bGwsdj1udWxsLHg9bnVsbCxEPW51bGw7dGhpcy5pbml0QXR0cmlidXRlcz1mdW5jdGlvbigpe2Zvcih2YXIgYT0wLGI9Yy5sZW5ndGg7YTxiO2ErKyljW2FdPTB9O3RoaXMuZW5hYmxlQXR0cmlidXRlPWZ1bmN0aW9uKGIpe2NbYl09MTswPT09ZFtiXSYmKGEuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYiksZFtiXT0xKX07dGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlcz1mdW5jdGlvbigpe2Zvcih2YXIgYj0wLGU9ZC5sZW5ndGg7YjxlO2IrKylkW2JdIT09Y1tiXSYmKGEuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGIpLGRbYl09MCl9O3RoaXMuc2V0QmxlbmRpbmc9ZnVuY3Rpb24oYyxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbixxLHIscyx0KXtjIT09ZSYmKGM9PT1USFJFRS5Ob0JsZW5kaW5nP2EuZGlzYWJsZShhLkJMRU5EKTpjPT09VEhSRUUuQWRkaXRpdmVCbGVuZGluZz8oYS5lbmFibGUoYS5CTEVORCksYS5ibGVuZEVxdWF0aW9uKGEuRlVOQ19BREQpLGEuYmxlbmRGdW5jKGEuU1JDX0FMUEhBLGEuT05FKSk6Yz09PVRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmc/KGEuZW5hYmxlKGEuQkxFTkQpLGEuYmxlbmRFcXVhdGlvbihhLkZVTkNfQUREKSxhLmJsZW5kRnVuYyhhLlpFUk8sYS5PTkVfTUlOVVNfU1JDX0NPTE9SKSk6Yz09PVRIUkVFLk11bHRpcGx5QmxlbmRpbmc/KGEuZW5hYmxlKGEuQkxFTkQpLGEuYmxlbmRFcXVhdGlvbihhLkZVTkNfQUREKSxhLmJsZW5kRnVuYyhhLlpFUk8sYS5TUkNfQ09MT1IpKTpjPT09VEhSRUUuQ3VzdG9tQmxlbmRpbmc/YS5lbmFibGUoYS5CTEVORCk6KGEuZW5hYmxlKGEuQkxFTkQpLGEuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGEuRlVOQ19BREQsYS5GVU5DX0FERCksXG4gICAgYS5ibGVuZEZ1bmNTZXBhcmF0ZShhLlNSQ19BTFBIQSxhLk9ORV9NSU5VU19TUkNfQUxQSEEsYS5PTkUsYS5PTkVfTUlOVVNfU1JDX0FMUEhBKSksZT1jKTtpZihjPT09VEhSRUUuQ3VzdG9tQmxlbmRpbmcpe3I9cnx8ZDtzPXN8fG47dD10fHxxO2lmKGQhPT1mfHxyIT09aylhLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShiKGQpLGIocikpLGY9ZCxrPXI7aWYobiE9PWd8fHEhPT1ofHxzIT09bHx8dCE9PXApYS5ibGVuZEZ1bmNTZXBhcmF0ZShiKG4pLGIocSksYihzKSxiKHQpKSxnPW4saD1xLGw9cyxwPXR9ZWxzZSBwPWw9az1oPWc9Zj1udWxsfTt0aGlzLnNldERlcHRoVGVzdD1mdW5jdGlvbihiKXtxIT09YiYmKGI/YS5lbmFibGUoYS5ERVBUSF9URVNUKTphLmRpc2FibGUoYS5ERVBUSF9URVNUKSxxPWIpfTt0aGlzLnNldERlcHRoV3JpdGU9ZnVuY3Rpb24oYil7biE9PWImJihhLmRlcHRoTWFzayhiKSxuPWIpfTt0aGlzLnNldENvbG9yV3JpdGU9ZnVuY3Rpb24oYil7dCE9PWImJihhLmNvbG9yTWFzayhiLFxuICAgIGIsYixiKSx0PWIpfTt0aGlzLnNldERvdWJsZVNpZGVkPWZ1bmN0aW9uKGIpe3IhPT1iJiYoYj9hLmRpc2FibGUoYS5DVUxMX0ZBQ0UpOmEuZW5hYmxlKGEuQ1VMTF9GQUNFKSxyPWIpfTt0aGlzLnNldEZsaXBTaWRlZD1mdW5jdGlvbihiKXtzIT09YiYmKGI/YS5mcm9udEZhY2UoYS5DVyk6YS5mcm9udEZhY2UoYS5DQ1cpLHM9Yil9O3RoaXMuc2V0TGluZVdpZHRoPWZ1bmN0aW9uKGIpe2IhPT11JiYoYS5saW5lV2lkdGgoYiksdT1iKX07dGhpcy5zZXRQb2x5Z29uT2Zmc2V0PWZ1bmN0aW9uKGIsYyxkKXt2IT09YiYmKGI/YS5lbmFibGUoYS5QT0xZR09OX09GRlNFVF9GSUxMKTphLmRpc2FibGUoYS5QT0xZR09OX09GRlNFVF9GSUxMKSx2PWIpOyFifHx4PT09YyYmRD09PWR8fChhLnBvbHlnb25PZmZzZXQoYyxkKSx4PWMsRD1kKX07dGhpcy5yZXNldD1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8ZC5sZW5ndGg7YSsrKWRbYV09MDtzPXI9dD1uPXE9ZT1udWxsfX07XG5USFJFRS5MZW5zRmxhcmVQbHVnaW49ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnLGgsayxsLHAscSxuPWEuY29udGV4dCx0LHIscyx1LHYseDt0aGlzLnJlbmRlcj1mdW5jdGlvbihELHcseSxBKXtpZigwIT09Yi5sZW5ndGgpe0Q9bmV3IFRIUkVFLlZlY3RvcjM7dmFyIEU9QS95LEc9LjUqeSxGPS41KkEsej0xNi9BLEk9bmV3IFRIUkVFLlZlY3RvcjIoeipFLHopLFU9bmV3IFRIUkVFLlZlY3RvcjMoMSwxLDApLE09bmV3IFRIUkVFLlZlY3RvcjIoMSwxKTtpZih2b2lkIDA9PT1zKXt2YXIgej1uZXcgRmxvYXQzMkFycmF5KFstMSwtMSwwLDAsMSwtMSwxLDAsMSwxLDEsMSwtMSwxLDAsMV0pLEg9bmV3IFVpbnQxNkFycmF5KFswLDEsMiwwLDIsM10pO3Q9bi5jcmVhdGVCdWZmZXIoKTtyPW4uY3JlYXRlQnVmZmVyKCk7bi5iaW5kQnVmZmVyKG4uQVJSQVlfQlVGRkVSLHQpO24uYnVmZmVyRGF0YShuLkFSUkFZX0JVRkZFUix6LG4uU1RBVElDX0RSQVcpO24uYmluZEJ1ZmZlcihuLkVMRU1FTlRfQVJSQVlfQlVGRkVSLFxuICAgIHIpO24uYnVmZmVyRGF0YShuLkVMRU1FTlRfQVJSQVlfQlVGRkVSLEgsbi5TVEFUSUNfRFJBVyk7dj1uLmNyZWF0ZVRleHR1cmUoKTt4PW4uY3JlYXRlVGV4dHVyZSgpO24uYmluZFRleHR1cmUobi5URVhUVVJFXzJELHYpO24udGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxuLlJHQiwxNiwxNiwwLG4uUkdCLG4uVU5TSUdORURfQllURSxudWxsKTtuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9XUkFQX1Msbi5DTEFNUF9UT19FREdFKTtuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9XUkFQX1Qsbi5DTEFNUF9UT19FREdFKTtuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9NQUdfRklMVEVSLG4uTkVBUkVTVCk7bi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUlOX0ZJTFRFUixuLk5FQVJFU1QpO24uYmluZFRleHR1cmUobi5URVhUVVJFXzJELHgpO24udGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxcbiAgICBuLlJHQkEsMTYsMTYsMCxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLG51bGwpO24udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfUyxuLkNMQU1QX1RPX0VER0UpO24udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfVCxuLkNMQU1QX1RPX0VER0UpO24udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX01BR19GSUxURVIsbi5ORUFSRVNUKTtuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9NSU5fRklMVEVSLG4uTkVBUkVTVCk7dmFyIHo9KHU9MDxuLmdldFBhcmFtZXRlcihuLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUykpP3t2ZXJ0ZXhTaGFkZXI6XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XFxudW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1xcbnVuaWZvcm0gdmVjMiBzY2FsZTtcXG51bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiB1djtcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XFxudm9pZCBtYWluKCkge1xcbnZVViA9IHV2O1xcbnZlYzIgcG9zID0gcG9zaXRpb247XFxuaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcXG52ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApO1xcbnZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApO1xcbnZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC45ICkgKTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApO1xcbnZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7XFxudlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1xcbnZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuZyAvIDkuMDtcXG52VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XFxudlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1xcbnBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XFxucG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcXG59XFxuZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XFxufVwiLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjpcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gdmVjMyBjb2xvcjtcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XFxudm9pZCBtYWluKCkge1xcbmlmKCByZW5kZXJUeXBlID09IDAgKSB7XFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDEuMCwgMC4wICk7XFxufSBlbHNlIGlmKCByZW5kZXJUeXBlID09IDEgKSB7XFxuZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1xcbn0gZWxzZSB7XFxudmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1xcbnRleHR1cmUuYSAqPSBvcGFjaXR5ICogdlZpc2liaWxpdHk7XFxuZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcXG5nbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1xcbn1cXG59XCJ9Ont2ZXJ0ZXhTaGFkZXI6XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XFxudW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1xcbnVuaWZvcm0gdmVjMiBzY2FsZTtcXG51bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudm9pZCBtYWluKCkge1xcbnZVViA9IHV2O1xcbnZlYzIgcG9zID0gcG9zaXRpb247XFxuaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcXG5wb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1xcbnBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XFxufVxcbmdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1xcbn1cIixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSB2ZWMzIGNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudm9pZCBtYWluKCkge1xcbmlmKCByZW5kZXJUeXBlID09IDAgKSB7XFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEKCBtYXAsIHZVViApLnJnYiwgMC4wICk7XFxufSBlbHNlIGlmKCByZW5kZXJUeXBlID09IDEgKSB7XFxuZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1xcbn0gZWxzZSB7XFxuZmxvYXQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICkuYTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICkuYTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICkuYTtcXG52aXNpYmlsaXR5ID0gKCAxLjAgLSB2aXNpYmlsaXR5IC8gNC4wICk7XFxudmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1xcbnRleHR1cmUuYSAqPSBvcGFjaXR5ICogdmlzaWJpbGl0eTtcXG5nbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1xcbmdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XFxufVxcbn1cIn0sXG4gICAgSD1uLmNyZWF0ZVByb2dyYW0oKSxMPW4uY3JlYXRlU2hhZGVyKG4uRlJBR01FTlRfU0hBREVSKSxQPW4uY3JlYXRlU2hhZGVyKG4uVkVSVEVYX1NIQURFUiksTj1cInByZWNpc2lvbiBcIithLmdldFByZWNpc2lvbigpK1wiIGZsb2F0O1xcblwiO24uc2hhZGVyU291cmNlKEwsTit6LmZyYWdtZW50U2hhZGVyKTtuLnNoYWRlclNvdXJjZShQLE4rei52ZXJ0ZXhTaGFkZXIpO24uY29tcGlsZVNoYWRlcihMKTtuLmNvbXBpbGVTaGFkZXIoUCk7bi5hdHRhY2hTaGFkZXIoSCxMKTtuLmF0dGFjaFNoYWRlcihILFApO24ubGlua1Byb2dyYW0oSCk7cz1IO3A9bi5nZXRBdHRyaWJMb2NhdGlvbihzLFwicG9zaXRpb25cIik7cT1uLmdldEF0dHJpYkxvY2F0aW9uKHMsXCJ1dlwiKTtjPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHMsXCJyZW5kZXJUeXBlXCIpO2Q9bi5nZXRVbmlmb3JtTG9jYXRpb24ocyxcIm1hcFwiKTtlPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHMsXCJvY2NsdXNpb25NYXBcIik7Zj1uLmdldFVuaWZvcm1Mb2NhdGlvbihzLFxuICAgIFwib3BhY2l0eVwiKTtnPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHMsXCJjb2xvclwiKTtoPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHMsXCJzY2FsZVwiKTtrPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHMsXCJyb3RhdGlvblwiKTtsPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHMsXCJzY3JlZW5Qb3NpdGlvblwiKX1uLnVzZVByb2dyYW0ocyk7bi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwKTtuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHEpO24udW5pZm9ybTFpKGUsMCk7bi51bmlmb3JtMWkoZCwxKTtuLmJpbmRCdWZmZXIobi5BUlJBWV9CVUZGRVIsdCk7bi52ZXJ0ZXhBdHRyaWJQb2ludGVyKHAsMixuLkZMT0FULCExLDE2LDApO24udmVydGV4QXR0cmliUG9pbnRlcihxLDIsbi5GTE9BVCwhMSwxNiw4KTtuLmJpbmRCdWZmZXIobi5FTEVNRU5UX0FSUkFZX0JVRkZFUixyKTtuLmRpc2FibGUobi5DVUxMX0ZBQ0UpO24uZGVwdGhNYXNrKCExKTtIPTA7Zm9yKEw9Yi5sZW5ndGg7SDxMO0grKylpZih6PTE2L0EsSS5zZXQoeipcbiAgICAgICAgRSx6KSxQPWJbSF0sRC5zZXQoUC5tYXRyaXhXb3JsZC5lbGVtZW50c1sxMl0sUC5tYXRyaXhXb3JsZC5lbGVtZW50c1sxM10sUC5tYXRyaXhXb3JsZC5lbGVtZW50c1sxNF0pLEQuYXBwbHlNYXRyaXg0KHcubWF0cml4V29ybGRJbnZlcnNlKSxELmFwcGx5UHJvamVjdGlvbih3LnByb2plY3Rpb25NYXRyaXgpLFUuY29weShEKSxNLng9VS54KkcrRyxNLnk9VS55KkYrRix1fHwwPE0ueCYmTS54PHkmJjA8TS55JiZNLnk8QSl7bi5hY3RpdmVUZXh0dXJlKG4uVEVYVFVSRTEpO24uYmluZFRleHR1cmUobi5URVhUVVJFXzJELHYpO24uY29weVRleEltYWdlMkQobi5URVhUVVJFXzJELDAsbi5SR0IsTS54LTgsTS55LTgsMTYsMTYsMCk7bi51bmlmb3JtMWkoYywwKTtuLnVuaWZvcm0yZihoLEkueCxJLnkpO24udW5pZm9ybTNmKGwsVS54LFUueSxVLnopO24uZGlzYWJsZShuLkJMRU5EKTtuLmVuYWJsZShuLkRFUFRIX1RFU1QpO24uZHJhd0VsZW1lbnRzKG4uVFJJQU5HTEVTLDYsbi5VTlNJR05FRF9TSE9SVCxcbiAgICAwKTtuLmFjdGl2ZVRleHR1cmUobi5URVhUVVJFMCk7bi5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQseCk7bi5jb3B5VGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxuLlJHQkEsTS54LTgsTS55LTgsMTYsMTYsMCk7bi51bmlmb3JtMWkoYywxKTtuLmRpc2FibGUobi5ERVBUSF9URVNUKTtuLmFjdGl2ZVRleHR1cmUobi5URVhUVVJFMSk7bi5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsdik7bi5kcmF3RWxlbWVudHMobi5UUklBTkdMRVMsNixuLlVOU0lHTkVEX1NIT1JULDApO1AucG9zaXRpb25TY3JlZW4uY29weShVKTtQLmN1c3RvbVVwZGF0ZUNhbGxiYWNrP1AuY3VzdG9tVXBkYXRlQ2FsbGJhY2soUCk6UC51cGRhdGVMZW5zRmxhcmVzKCk7bi51bmlmb3JtMWkoYywyKTtuLmVuYWJsZShuLkJMRU5EKTtmb3IodmFyIE49MCxSPVAubGVuc0ZsYXJlcy5sZW5ndGg7TjxSO04rKyl7dmFyIFY9UC5sZW5zRmxhcmVzW05dOy4wMDE8Vi5vcGFjaXR5JiYuMDAxPFYuc2NhbGUmJihVLng9Vi54LFxuICAgIFUueT1WLnksVS56PVYueix6PVYuc2l6ZSpWLnNjYWxlL0EsSS54PXoqRSxJLnk9eixuLnVuaWZvcm0zZihsLFUueCxVLnksVS56KSxuLnVuaWZvcm0yZihoLEkueCxJLnkpLG4udW5pZm9ybTFmKGssVi5yb3RhdGlvbiksbi51bmlmb3JtMWYoZixWLm9wYWNpdHkpLG4udW5pZm9ybTNmKGcsVi5jb2xvci5yLFYuY29sb3IuZyxWLmNvbG9yLmIpLGEuc3RhdGUuc2V0QmxlbmRpbmcoVi5ibGVuZGluZyxWLmJsZW5kRXF1YXRpb24sVi5ibGVuZFNyYyxWLmJsZW5kRHN0KSxhLnNldFRleHR1cmUoVi50ZXh0dXJlLDEpLG4uZHJhd0VsZW1lbnRzKG4uVFJJQU5HTEVTLDYsbi5VTlNJR05FRF9TSE9SVCwwKSl9fW4uZW5hYmxlKG4uQ1VMTF9GQUNFKTtuLmVuYWJsZShuLkRFUFRIX1RFU1QpO24uZGVwdGhNYXNrKCEwKTthLnJlc2V0R0xTdGF0ZSgpfX19O1xuVEhSRUUuU2hhZG93TWFwUGx1Z2luPWZ1bmN0aW9uKGEsYixjLGQpe2Z1bmN0aW9uIGUoYSxiLGQpe2lmKGIudmlzaWJsZSl7dmFyIGY9Y1tiLmlkXTtpZihmJiZiLmNhc3RTaGFkb3cmJighMT09PWIuZnJ1c3R1bUN1bGxlZHx8ITA9PT1wLmludGVyc2VjdHNPYmplY3QoYikpKWZvcih2YXIgZz0wLGg9Zi5sZW5ndGg7ZzxoO2crKyl7dmFyIGs9ZltnXTtiLl9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhkLm1hdHJpeFdvcmxkSW52ZXJzZSxiLm1hdHJpeFdvcmxkKTtzLnB1c2goayl9Zz0wO2ZvcihoPWIuY2hpbGRyZW4ubGVuZ3RoO2c8aDtnKyspZShhLGIuY2hpbGRyZW5bZ10sZCl9fXZhciBmPWEuY29udGV4dCxnLGgsayxsLHA9bmV3IFRIUkVFLkZydXN0dW0scT1uZXcgVEhSRUUuTWF0cml4NCxuPW5ldyBUSFJFRS5WZWN0b3IzLHQ9bmV3IFRIUkVFLlZlY3RvcjMscj1uZXcgVEhSRUUuVmVjdG9yMyxzPVtdLHU9VEhSRUUuU2hhZGVyTGliLmRlcHRoUkdCQSx2PVRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUodS51bmlmb3Jtcyk7XG4gICAgZz1uZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe3VuaWZvcm1zOnYsdmVydGV4U2hhZGVyOnUudmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyOnUuZnJhZ21lbnRTaGFkZXJ9KTtoPW5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7dW5pZm9ybXM6dix2ZXJ0ZXhTaGFkZXI6dS52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6dS5mcmFnbWVudFNoYWRlcixtb3JwaFRhcmdldHM6ITB9KTtrPW5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7dW5pZm9ybXM6dix2ZXJ0ZXhTaGFkZXI6dS52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6dS5mcmFnbWVudFNoYWRlcixza2lubmluZzohMH0pO2w9bmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHt1bmlmb3Jtczp2LHZlcnRleFNoYWRlcjp1LnZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcjp1LmZyYWdtZW50U2hhZGVyLG1vcnBoVGFyZ2V0czohMCxza2lubmluZzohMH0pO2cuX3NoYWRvd1Bhc3M9ITA7aC5fc2hhZG93UGFzcz0hMDtrLl9zaGFkb3dQYXNzPVxuICAgICAgICAhMDtsLl9zaGFkb3dQYXNzPSEwO3RoaXMucmVuZGVyPWZ1bmN0aW9uKGMsdil7aWYoITEhPT1hLnNoYWRvd01hcEVuYWJsZWQpe3ZhciB1LHksQSxFLEcsRix6LEksVT1bXTtFPTA7Zi5jbGVhckNvbG9yKDEsMSwxLDEpO2YuZGlzYWJsZShmLkJMRU5EKTtmLmVuYWJsZShmLkNVTExfRkFDRSk7Zi5mcm9udEZhY2UoZi5DQ1cpO2Euc2hhZG93TWFwQ3VsbEZhY2U9PT1USFJFRS5DdWxsRmFjZUZyb250P2YuY3VsbEZhY2UoZi5GUk9OVCk6Zi5jdWxsRmFjZShmLkJBQ0spO2Euc3RhdGUuc2V0RGVwdGhUZXN0KCEwKTt1PTA7Zm9yKHk9Yi5sZW5ndGg7dTx5O3UrKylpZihBPWJbdV0sQS5jYXN0U2hhZG93KWlmKEEgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0JiZBLnNoYWRvd0Nhc2NhZGUpZm9yKEc9MDtHPEEuc2hhZG93Q2FzY2FkZUNvdW50O0crKyl7dmFyIE07aWYoQS5zaGFkb3dDYXNjYWRlQXJyYXlbR10pTT1BLnNoYWRvd0Nhc2NhZGVBcnJheVtHXTtlbHNle3o9QTtcbiAgICAgICAgdmFyIEg9RztNPW5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0O00uaXNWaXJ0dWFsPSEwO00ub25seVNoYWRvdz0hMDtNLmNhc3RTaGFkb3c9ITA7TS5zaGFkb3dDYW1lcmFOZWFyPXouc2hhZG93Q2FtZXJhTmVhcjtNLnNoYWRvd0NhbWVyYUZhcj16LnNoYWRvd0NhbWVyYUZhcjtNLnNoYWRvd0NhbWVyYUxlZnQ9ei5zaGFkb3dDYW1lcmFMZWZ0O00uc2hhZG93Q2FtZXJhUmlnaHQ9ei5zaGFkb3dDYW1lcmFSaWdodDtNLnNoYWRvd0NhbWVyYUJvdHRvbT16LnNoYWRvd0NhbWVyYUJvdHRvbTtNLnNoYWRvd0NhbWVyYVRvcD16LnNoYWRvd0NhbWVyYVRvcDtNLnNoYWRvd0NhbWVyYVZpc2libGU9ei5zaGFkb3dDYW1lcmFWaXNpYmxlO00uc2hhZG93RGFya25lc3M9ei5zaGFkb3dEYXJrbmVzcztNLnNoYWRvd0JpYXM9ei5zaGFkb3dDYXNjYWRlQmlhc1tIXTtNLnNoYWRvd01hcFdpZHRoPXouc2hhZG93Q2FzY2FkZVdpZHRoW0hdO00uc2hhZG93TWFwSGVpZ2h0PXouc2hhZG93Q2FzY2FkZUhlaWdodFtIXTtcbiAgICAgICAgTS5wb2ludHNXb3JsZD1bXTtNLnBvaW50c0ZydXN0dW09W107ST1NLnBvaW50c1dvcmxkO0Y9TS5wb2ludHNGcnVzdHVtO2Zvcih2YXIgTD0wOzg+TDtMKyspSVtMXT1uZXcgVEhSRUUuVmVjdG9yMyxGW0xdPW5ldyBUSFJFRS5WZWN0b3IzO0k9ei5zaGFkb3dDYXNjYWRlTmVhclpbSF07ej16LnNoYWRvd0Nhc2NhZGVGYXJaW0hdO0ZbMF0uc2V0KC0xLC0xLEkpO0ZbMV0uc2V0KDEsLTEsSSk7RlsyXS5zZXQoLTEsMSxJKTtGWzNdLnNldCgxLDEsSSk7Rls0XS5zZXQoLTEsLTEseik7Rls1XS5zZXQoMSwtMSx6KTtGWzZdLnNldCgtMSwxLHopO0ZbN10uc2V0KDEsMSx6KTtNLm9yaWdpbmFsQ2FtZXJhPXY7Rj1uZXcgVEhSRUUuR3lyb3Njb3BlO0YucG9zaXRpb24uY29weShBLnNoYWRvd0Nhc2NhZGVPZmZzZXQpO0YuYWRkKE0pO0YuYWRkKE0udGFyZ2V0KTt2LmFkZChGKTtBLnNoYWRvd0Nhc2NhZGVBcnJheVtHXT1NfUg9QTtJPUc7ej1ILnNoYWRvd0Nhc2NhZGVBcnJheVtJXTt6LnBvc2l0aW9uLmNvcHkoSC5wb3NpdGlvbik7XG4gICAgICAgIHoudGFyZ2V0LnBvc2l0aW9uLmNvcHkoSC50YXJnZXQucG9zaXRpb24pO3oubG9va0F0KHoudGFyZ2V0KTt6LnNoYWRvd0NhbWVyYVZpc2libGU9SC5zaGFkb3dDYW1lcmFWaXNpYmxlO3ouc2hhZG93RGFya25lc3M9SC5zaGFkb3dEYXJrbmVzczt6LnNoYWRvd0JpYXM9SC5zaGFkb3dDYXNjYWRlQmlhc1tJXTtGPUguc2hhZG93Q2FzY2FkZU5lYXJaW0ldO0g9SC5zaGFkb3dDYXNjYWRlRmFyWltJXTt6PXoucG9pbnRzRnJ1c3R1bTt6WzBdLno9Rjt6WzFdLno9Rjt6WzJdLno9Rjt6WzNdLno9Rjt6WzRdLno9SDt6WzVdLno9SDt6WzZdLno9SDt6WzddLno9SDtVW0VdPU07RSsrfWVsc2UgVVtFXT1BLEUrKzt1PTA7Zm9yKHk9VS5sZW5ndGg7dTx5O3UrKyl7QT1VW3VdO0Euc2hhZG93TWFwfHwoRz1USFJFRS5MaW5lYXJGaWx0ZXIsYS5zaGFkb3dNYXBUeXBlPT09VEhSRUUuUENGU29mdFNoYWRvd01hcCYmKEc9VEhSRUUuTmVhcmVzdEZpbHRlciksQS5zaGFkb3dNYXA9bmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KEEuc2hhZG93TWFwV2lkdGgsXG4gICAgICAgIEEuc2hhZG93TWFwSGVpZ2h0LHttaW5GaWx0ZXI6RyxtYWdGaWx0ZXI6Ryxmb3JtYXQ6VEhSRUUuUkdCQUZvcm1hdH0pLEEuc2hhZG93TWFwU2l6ZT1uZXcgVEhSRUUuVmVjdG9yMihBLnNoYWRvd01hcFdpZHRoLEEuc2hhZG93TWFwSGVpZ2h0KSxBLnNoYWRvd01hdHJpeD1uZXcgVEhSRUUuTWF0cml4NCk7aWYoIUEuc2hhZG93Q2FtZXJhKXtpZihBIGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0KUEuc2hhZG93Q2FtZXJhPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYShBLnNoYWRvd0NhbWVyYUZvdixBLnNoYWRvd01hcFdpZHRoL0Euc2hhZG93TWFwSGVpZ2h0LEEuc2hhZG93Q2FtZXJhTmVhcixBLnNoYWRvd0NhbWVyYUZhcik7ZWxzZSBpZihBIGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodClBLnNoYWRvd0NhbWVyYT1uZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKEEuc2hhZG93Q2FtZXJhTGVmdCxBLnNoYWRvd0NhbWVyYVJpZ2h0LEEuc2hhZG93Q2FtZXJhVG9wLFxuICAgICAgICBBLnNoYWRvd0NhbWVyYUJvdHRvbSxBLnNoYWRvd0NhbWVyYU5lYXIsQS5zaGFkb3dDYW1lcmFGYXIpO2Vsc2V7VEhSRUUuZXJyb3IoXCJUSFJFRS5TaGFkb3dNYXBQbHVnaW46IFVuc3VwcG9ydGVkIGxpZ2h0IHR5cGUgZm9yIHNoYWRvd1wiLEEpO2NvbnRpbnVlfWMuYWRkKEEuc2hhZG93Q2FtZXJhKTshMD09PWMuYXV0b1VwZGF0ZSYmYy51cGRhdGVNYXRyaXhXb3JsZCgpfUEuc2hhZG93Q2FtZXJhVmlzaWJsZSYmIUEuY2FtZXJhSGVscGVyJiYoQS5jYW1lcmFIZWxwZXI9bmV3IFRIUkVFLkNhbWVyYUhlbHBlcihBLnNoYWRvd0NhbWVyYSksYy5hZGQoQS5jYW1lcmFIZWxwZXIpKTtpZihBLmlzVmlydHVhbCYmTS5vcmlnaW5hbENhbWVyYT09dil7Rz12O0U9QS5zaGFkb3dDYW1lcmE7Rj1BLnBvaW50c0ZydXN0dW07ej1BLnBvaW50c1dvcmxkO24uc2V0KEluZmluaXR5LEluZmluaXR5LEluZmluaXR5KTt0LnNldCgtSW5maW5pdHksLUluZmluaXR5LC1JbmZpbml0eSk7Zm9yKEg9MDs4PlxuICAgIEg7SCsrKUk9eltIXSxJLmNvcHkoRltIXSksSS51bnByb2plY3QoRyksSS5hcHBseU1hdHJpeDQoRS5tYXRyaXhXb3JsZEludmVyc2UpLEkueDxuLngmJihuLng9SS54KSxJLng+dC54JiYodC54PUkueCksSS55PG4ueSYmKG4ueT1JLnkpLEkueT50LnkmJih0Lnk9SS55KSxJLno8bi56JiYobi56PUkueiksSS56PnQueiYmKHQuej1JLnopO0UubGVmdD1uLng7RS5yaWdodD10Lng7RS50b3A9dC55O0UuYm90dG9tPW4ueTtFLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1FPUEuc2hhZG93TWFwO0Y9QS5zaGFkb3dNYXRyaXg7Rz1BLnNoYWRvd0NhbWVyYTtHLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihBLm1hdHJpeFdvcmxkKTtyLnNldEZyb21NYXRyaXhQb3NpdGlvbihBLnRhcmdldC5tYXRyaXhXb3JsZCk7Ry5sb29rQXQocik7Ry51cGRhdGVNYXRyaXhXb3JsZCgpO0cubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoRy5tYXRyaXhXb3JsZCk7QS5jYW1lcmFIZWxwZXImJlxuICAgIChBLmNhbWVyYUhlbHBlci52aXNpYmxlPUEuc2hhZG93Q2FtZXJhVmlzaWJsZSk7QS5zaGFkb3dDYW1lcmFWaXNpYmxlJiZBLmNhbWVyYUhlbHBlci51cGRhdGUoKTtGLnNldCguNSwwLDAsLjUsMCwuNSwwLC41LDAsMCwuNSwuNSwwLDAsMCwxKTtGLm11bHRpcGx5KEcucHJvamVjdGlvbk1hdHJpeCk7Ri5tdWx0aXBseShHLm1hdHJpeFdvcmxkSW52ZXJzZSk7cS5tdWx0aXBseU1hdHJpY2VzKEcucHJvamVjdGlvbk1hdHJpeCxHLm1hdHJpeFdvcmxkSW52ZXJzZSk7cC5zZXRGcm9tTWF0cml4KHEpO2Euc2V0UmVuZGVyVGFyZ2V0KEUpO2EuY2xlYXIoKTtzLmxlbmd0aD0wO2UoYyxjLEcpO0E9MDtmb3IoRT1zLmxlbmd0aDtBPEU7QSsrKXo9c1tBXSxGPXoub2JqZWN0LHo9ei5idWZmZXIsSD1GLm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbD9GLm1hdGVyaWFsLm1hdGVyaWFsc1swXTpGLm1hdGVyaWFsLEk9dm9pZCAwIT09Ri5nZW9tZXRyeS5tb3JwaFRhcmdldHMmJlxuICAgICAgICAwPEYuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCYmSC5tb3JwaFRhcmdldHMsTD1GIGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2gmJkguc2tpbm5pbmcsST1GLmN1c3RvbURlcHRoTWF0ZXJpYWw/Ri5jdXN0b21EZXB0aE1hdGVyaWFsOkw/ST9sOms6ST9oOmcsYS5zZXRNYXRlcmlhbEZhY2VzKEgpLHogaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeT9hLnJlbmRlckJ1ZmZlckRpcmVjdChHLGIsbnVsbCxJLHosRik6YS5yZW5kZXJCdWZmZXIoRyxiLG51bGwsSSx6LEYpO0E9MDtmb3IoRT1kLmxlbmd0aDtBPEU7QSsrKXo9ZFtBXSxGPXoub2JqZWN0LEYudmlzaWJsZSYmRi5jYXN0U2hhZG93JiYoRi5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoRy5tYXRyaXhXb3JsZEludmVyc2UsRi5tYXRyaXhXb3JsZCksYS5yZW5kZXJJbW1lZGlhdGVPYmplY3QoRyxiLG51bGwsZyxGKSl9dT1hLmdldENsZWFyQ29sb3IoKTt5PWEuZ2V0Q2xlYXJBbHBoYSgpO2YuY2xlYXJDb2xvcih1LnIsXG4gICAgICAgIHUuZyx1LmIseSk7Zi5lbmFibGUoZi5CTEVORCk7YS5zaGFkb3dNYXBDdWxsRmFjZT09PVRIUkVFLkN1bGxGYWNlRnJvbnQmJmYuY3VsbEZhY2UoZi5CQUNLKTthLnJlc2V0R0xTdGF0ZSgpfX19O1xuVEhSRUUuU3ByaXRlUGx1Z2luPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZyxoLGssbCxwLHEsbix0LHIscyx1LHYseDtmdW5jdGlvbiBEKGEsYil7cmV0dXJuIGEueiE9PWIuej9iLnotYS56OmIuaWQtYS5pZH12YXIgdz1hLmNvbnRleHQseSxBLEUsRyxGPW5ldyBUSFJFRS5WZWN0b3IzLHo9bmV3IFRIUkVFLlF1YXRlcm5pb24sST1uZXcgVEhSRUUuVmVjdG9yMzt0aGlzLnJlbmRlcj1mdW5jdGlvbihVLE0pe2lmKDAhPT1iLmxlbmd0aCl7aWYodm9pZCAwPT09RSl7dmFyIEg9bmV3IEZsb2F0MzJBcnJheShbLS41LC0uNSwwLDAsLjUsLS41LDEsMCwuNSwuNSwxLDEsLS41LC41LDAsMV0pLEw9bmV3IFVpbnQxNkFycmF5KFswLDEsMiwwLDIsM10pO3k9dy5jcmVhdGVCdWZmZXIoKTtBPXcuY3JlYXRlQnVmZmVyKCk7dy5iaW5kQnVmZmVyKHcuQVJSQVlfQlVGRkVSLHkpO3cuYnVmZmVyRGF0YSh3LkFSUkFZX0JVRkZFUixILHcuU1RBVElDX0RSQVcpO3cuYmluZEJ1ZmZlcih3LkVMRU1FTlRfQVJSQVlfQlVGRkVSLFxuICAgIEEpO3cuYnVmZmVyRGF0YSh3LkVMRU1FTlRfQVJSQVlfQlVGRkVSLEwsdy5TVEFUSUNfRFJBVyk7dmFyIEg9dy5jcmVhdGVQcm9ncmFtKCksTD13LmNyZWF0ZVNoYWRlcih3LlZFUlRFWF9TSEFERVIpLFA9dy5jcmVhdGVTaGFkZXIody5GUkFHTUVOVF9TSEFERVIpO3cuc2hhZGVyU291cmNlKEwsW1wicHJlY2lzaW9uIFwiK2EuZ2V0UHJlY2lzaW9uKCkrXCIgZmxvYXQ7XCIsXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgcm90YXRpb247XFxudW5pZm9ybSB2ZWMyIHNjYWxlO1xcbnVuaWZvcm0gdmVjMiB1dk9mZnNldDtcXG51bmlmb3JtIHZlYzIgdXZTY2FsZTtcXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiB1djtcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnZvaWQgbWFpbigpIHtcXG52VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTtcXG52ZWMyIGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uICogc2NhbGU7XFxudmVjMiByb3RhdGVkUG9zaXRpb247XFxucm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcbnJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcXG52ZWM0IGZpbmFsUG9zaXRpb247XFxuZmluYWxQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xcbmZpbmFsUG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uO1xcbmZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZmluYWxQb3NpdGlvbjtcXG5nbF9Qb3NpdGlvbiA9IGZpbmFsUG9zaXRpb247XFxufVwiXS5qb2luKFwiXFxuXCIpKTtcbiAgICB3LnNoYWRlclNvdXJjZShQLFtcInByZWNpc2lvbiBcIithLmdldFByZWNpc2lvbigpK1wiIGZsb2F0O1wiLFwidW5pZm9ybSB2ZWMzIGNvbG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBpbnQgZm9nVHlwZTtcXG51bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxudW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcbnVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG51bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcXG51bmlmb3JtIGZsb2F0IGFscGhhVGVzdDtcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnZvaWQgbWFpbigpIHtcXG52ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XFxuaWYgKCB0ZXh0dXJlLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkO1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTtcXG5pZiAoIGZvZ1R5cGUgPiAwICkge1xcbmZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcXG5mbG9hdCBmb2dGYWN0b3IgPSAwLjA7XFxuaWYgKCBmb2dUeXBlID09IDEgKSB7XFxuZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApO1xcbn0gZWxzZSB7XFxuY29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1O1xcbmZsb2F0IGZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApO1xcbmZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7XFxufVxcbmdsX0ZyYWdDb2xvciA9IG1peCggZ2xfRnJhZ0NvbG9yLCB2ZWM0KCBmb2dDb2xvciwgZ2xfRnJhZ0NvbG9yLncgKSwgZm9nRmFjdG9yICk7XFxufVxcbn1cIl0uam9pbihcIlxcblwiKSk7XG4gICAgdy5jb21waWxlU2hhZGVyKEwpO3cuY29tcGlsZVNoYWRlcihQKTt3LmF0dGFjaFNoYWRlcihILEwpO3cuYXR0YWNoU2hhZGVyKEgsUCk7dy5saW5rUHJvZ3JhbShIKTtFPUg7dj13LmdldEF0dHJpYkxvY2F0aW9uKEUsXCJwb3NpdGlvblwiKTt4PXcuZ2V0QXR0cmliTG9jYXRpb24oRSxcInV2XCIpO2M9dy5nZXRVbmlmb3JtTG9jYXRpb24oRSxcInV2T2Zmc2V0XCIpO2Q9dy5nZXRVbmlmb3JtTG9jYXRpb24oRSxcInV2U2NhbGVcIik7ZT13LmdldFVuaWZvcm1Mb2NhdGlvbihFLFwicm90YXRpb25cIik7Zj13LmdldFVuaWZvcm1Mb2NhdGlvbihFLFwic2NhbGVcIik7Zz13LmdldFVuaWZvcm1Mb2NhdGlvbihFLFwiY29sb3JcIik7aD13LmdldFVuaWZvcm1Mb2NhdGlvbihFLFwibWFwXCIpO2s9dy5nZXRVbmlmb3JtTG9jYXRpb24oRSxcIm9wYWNpdHlcIik7bD13LmdldFVuaWZvcm1Mb2NhdGlvbihFLFwibW9kZWxWaWV3TWF0cml4XCIpO3A9dy5nZXRVbmlmb3JtTG9jYXRpb24oRSxcInByb2plY3Rpb25NYXRyaXhcIik7cT1cbiAgICAgICAgdy5nZXRVbmlmb3JtTG9jYXRpb24oRSxcImZvZ1R5cGVcIik7bj13LmdldFVuaWZvcm1Mb2NhdGlvbihFLFwiZm9nRGVuc2l0eVwiKTt0PXcuZ2V0VW5pZm9ybUxvY2F0aW9uKEUsXCJmb2dOZWFyXCIpO3I9dy5nZXRVbmlmb3JtTG9jYXRpb24oRSxcImZvZ0ZhclwiKTtzPXcuZ2V0VW5pZm9ybUxvY2F0aW9uKEUsXCJmb2dDb2xvclwiKTt1PXcuZ2V0VW5pZm9ybUxvY2F0aW9uKEUsXCJhbHBoYVRlc3RcIik7SD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO0gud2lkdGg9ODtILmhlaWdodD04O0w9SC5nZXRDb250ZXh0KFwiMmRcIik7TC5maWxsU3R5bGU9XCJ3aGl0ZVwiO0wuZmlsbFJlY3QoMCwwLDgsOCk7Rz1uZXcgVEhSRUUuVGV4dHVyZShIKTtHLm5lZWRzVXBkYXRlPSEwfXcudXNlUHJvZ3JhbShFKTt3LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHYpO3cuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoeCk7dy5kaXNhYmxlKHcuQ1VMTF9GQUNFKTt3LmVuYWJsZSh3LkJMRU5EKTt3LmJpbmRCdWZmZXIody5BUlJBWV9CVUZGRVIsXG4gICAgeSk7dy52ZXJ0ZXhBdHRyaWJQb2ludGVyKHYsMix3LkZMT0FULCExLDE2LDApO3cudmVydGV4QXR0cmliUG9pbnRlcih4LDIsdy5GTE9BVCwhMSwxNiw4KTt3LmJpbmRCdWZmZXIody5FTEVNRU5UX0FSUkFZX0JVRkZFUixBKTt3LnVuaWZvcm1NYXRyaXg0ZnYocCwhMSxNLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMpO3cuYWN0aXZlVGV4dHVyZSh3LlRFWFRVUkUwKTt3LnVuaWZvcm0xaShoLDApO0w9SD0wOyhQPVUuZm9nKT8ody51bmlmb3JtM2YocyxQLmNvbG9yLnIsUC5jb2xvci5nLFAuY29sb3IuYiksUCBpbnN0YW5jZW9mIFRIUkVFLkZvZz8ody51bmlmb3JtMWYodCxQLm5lYXIpLHcudW5pZm9ybTFmKHIsUC5mYXIpLHcudW5pZm9ybTFpKHEsMSksTD1IPTEpOlAgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyJiYody51bmlmb3JtMWYobixQLmRlbnNpdHkpLHcudW5pZm9ybTFpKHEsMiksTD1IPTIpKToody51bmlmb3JtMWkocSwwKSxMPUg9MCk7Zm9yKHZhciBQPTAsTj1iLmxlbmd0aDtQPFxuTjtQKyspe3ZhciBSPWJbUF07Ui5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoTS5tYXRyaXhXb3JsZEludmVyc2UsUi5tYXRyaXhXb3JsZCk7Ui56PS1SLl9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbMTRdfWIuc29ydChEKTtmb3IodmFyIFY9W10sUD0wLE49Yi5sZW5ndGg7UDxOO1ArKyl7dmFyIFI9YltQXSxKPVIubWF0ZXJpYWw7dy51bmlmb3JtMWYodSxKLmFscGhhVGVzdCk7dy51bmlmb3JtTWF0cml4NGZ2KGwsITEsUi5fbW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzKTtSLm1hdHJpeFdvcmxkLmRlY29tcG9zZShGLHosSSk7VlswXT1JLng7VlsxXT1JLnk7Uj0wO1UuZm9nJiZKLmZvZyYmKFI9TCk7SCE9PVImJih3LnVuaWZvcm0xaShxLFIpLEg9Uik7bnVsbCE9PUoubWFwPyh3LnVuaWZvcm0yZihjLEoubWFwLm9mZnNldC54LEoubWFwLm9mZnNldC55KSx3LnVuaWZvcm0yZihkLEoubWFwLnJlcGVhdC54LEoubWFwLnJlcGVhdC55KSk6KHcudW5pZm9ybTJmKGMsXG4gICAgMCwwKSx3LnVuaWZvcm0yZihkLDEsMSkpO3cudW5pZm9ybTFmKGssSi5vcGFjaXR5KTt3LnVuaWZvcm0zZihnLEouY29sb3IucixKLmNvbG9yLmcsSi5jb2xvci5iKTt3LnVuaWZvcm0xZihlLEoucm90YXRpb24pO3cudW5pZm9ybTJmdihmLFYpO2Euc3RhdGUuc2V0QmxlbmRpbmcoSi5ibGVuZGluZyxKLmJsZW5kRXF1YXRpb24sSi5ibGVuZFNyYyxKLmJsZW5kRHN0KTthLnN0YXRlLnNldERlcHRoVGVzdChKLmRlcHRoVGVzdCk7YS5zdGF0ZS5zZXREZXB0aFdyaXRlKEouZGVwdGhXcml0ZSk7Si5tYXAmJkoubWFwLmltYWdlJiZKLm1hcC5pbWFnZS53aWR0aD9hLnNldFRleHR1cmUoSi5tYXAsMCk6YS5zZXRUZXh0dXJlKEcsMCk7dy5kcmF3RWxlbWVudHMody5UUklBTkdMRVMsNix3LlVOU0lHTkVEX1NIT1JULDApfXcuZW5hYmxlKHcuQ1VMTF9GQUNFKTthLnJlc2V0R0xTdGF0ZSgpfX19O1xuVEhSRUUuR2VvbWV0cnlVdGlscz17bWVyZ2U6ZnVuY3Rpb24oYSxiLGMpe1RIUkVFLndhcm4oXCJUSFJFRS5HZW9tZXRyeVV0aWxzOiAubWVyZ2UoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5Lm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIGluc3RlYWQuXCIpO3ZhciBkO2IgaW5zdGFuY2VvZiBUSFJFRS5NZXNoJiYoYi5tYXRyaXhBdXRvVXBkYXRlJiZiLnVwZGF0ZU1hdHJpeCgpLGQ9Yi5tYXRyaXgsYj1iLmdlb21ldHJ5KTthLm1lcmdlKGIsZCxjKX0sY2VudGVyOmZ1bmN0aW9uKGEpe1RIUkVFLndhcm4oXCJUSFJFRS5HZW9tZXRyeVV0aWxzOiAuY2VudGVyKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5jZW50ZXIoKSBpbnN0ZWFkLlwiKTtyZXR1cm4gYS5jZW50ZXIoKX19O1xuVEhSRUUuSW1hZ2VVdGlscz17Y3Jvc3NPcmlnaW46dm9pZCAwLGxvYWRUZXh0dXJlOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBUSFJFRS5JbWFnZUxvYWRlcjtlLmNyb3NzT3JpZ2luPXRoaXMuY3Jvc3NPcmlnaW47dmFyIGY9bmV3IFRIUkVFLlRleHR1cmUodm9pZCAwLGIpO2UubG9hZChhLGZ1bmN0aW9uKGEpe2YuaW1hZ2U9YTtmLm5lZWRzVXBkYXRlPSEwO2MmJmMoZil9LHZvaWQgMCxmdW5jdGlvbihhKXtkJiZkKGEpfSk7Zi5zb3VyY2VGaWxlPWE7cmV0dXJuIGZ9LGxvYWRUZXh0dXJlQ3ViZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgVEhSRUUuSW1hZ2VMb2FkZXI7ZS5jcm9zc09yaWdpbj10aGlzLmNyb3NzT3JpZ2luO3ZhciBmPW5ldyBUSFJFRS5DdWJlVGV4dHVyZShbXSxiKTtmLmZsaXBZPSExO3ZhciBnPTA7Yj1mdW5jdGlvbihiKXtlLmxvYWQoYVtiXSxmdW5jdGlvbihhKXtmLmltYWdlc1tiXT1hO2crPTE7Nj09PWcmJihmLm5lZWRzVXBkYXRlPSEwLGMmJlxuYyhmKSl9LHZvaWQgMCxkKX07Zm9yKHZhciBoPTAsaz1hLmxlbmd0aDtoPGs7KytoKWIoaCk7cmV0dXJuIGZ9LGxvYWRDb21wcmVzc2VkVGV4dHVyZTpmdW5jdGlvbigpe1RIUkVFLmVycm9yKFwiVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLlwiKX0sbG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTpmdW5jdGlvbigpe1RIUkVFLmVycm9yKFwiVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC5cIil9LGdldE5vcm1hbE1hcDpmdW5jdGlvbihhLGIpe3ZhciBjPWZ1bmN0aW9uKGEpe3ZhciBiPU1hdGguc3FydChhWzBdKmFbMF0rYVsxXSphWzFdK2FbMl0qYVsyXSk7cmV0dXJuW2FbMF0vYixhWzFdL2IsYVsyXS9iXX07Ynw9MTt2YXIgZD1hLndpZHRoLGU9YS5oZWlnaHQsZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGYud2lkdGg9ZDtmLmhlaWdodD1lO3ZhciBnPWYuZ2V0Q29udGV4dChcIjJkXCIpO2cuZHJhd0ltYWdlKGEsMCwwKTtmb3IodmFyIGg9Zy5nZXRJbWFnZURhdGEoMCwwLGQsZSkuZGF0YSxrPWcuY3JlYXRlSW1hZ2VEYXRhKGQsZSksbD1rLmRhdGEscD0wO3A8ZDtwKyspZm9yKHZhciBxPTA7cTxlO3ErKyl7dmFyIG49MD5xLTE/MDpxLTEsdD1xKzE+ZS0xP2UtMTpxKzEscj0wPnAtMT8wOnAtMSxzPXArMT5kLTE/ZC0xOnArMSx1PVtdLHY9WzAsMCxoWzQqKHEqZCtwKV0vMjU1KmJdO3UucHVzaChbLTEsMCxoWzQqKHEqZCtyKV0vMjU1KmJdKTt1LnB1c2goWy0xLC0xLGhbNCoobipkK3IpXS8yNTUqYl0pO3UucHVzaChbMCwtMSxoWzQqKG4qZCtwKV0vMjU1KmJdKTt1LnB1c2goWzEsLTEsaFs0KihuKmQrcyldLzI1NSpiXSk7dS5wdXNoKFsxLDAsaFs0KihxKmQrcyldLzI1NSpiXSk7dS5wdXNoKFsxLDEsaFs0Kih0KmQrcyldLzI1NSpiXSk7dS5wdXNoKFswLDEsaFs0Kih0KmQrcCldLzI1NSpcbiAgICBiXSk7dS5wdXNoKFstMSwxLGhbNCoodCpkK3IpXS8yNTUqYl0pO249W107cj11Lmxlbmd0aDtmb3IodD0wO3Q8cjt0Kyspe3ZhciBzPXVbdF0seD11Wyh0KzEpJXJdLHM9W3NbMF0tdlswXSxzWzFdLXZbMV0sc1syXS12WzJdXSx4PVt4WzBdLXZbMF0seFsxXS12WzFdLHhbMl0tdlsyXV07bi5wdXNoKGMoW3NbMV0qeFsyXS1zWzJdKnhbMV0sc1syXSp4WzBdLXNbMF0qeFsyXSxzWzBdKnhbMV0tc1sxXSp4WzBdXSkpfXU9WzAsMCwwXTtmb3IodD0wO3Q8bi5sZW5ndGg7dCsrKXVbMF0rPW5bdF1bMF0sdVsxXSs9blt0XVsxXSx1WzJdKz1uW3RdWzJdO3VbMF0vPW4ubGVuZ3RoO3VbMV0vPW4ubGVuZ3RoO3VbMl0vPW4ubGVuZ3RoO3Y9NCoocSpkK3ApO2xbdl09KHVbMF0rMSkvMioyNTV8MDtsW3YrMV09KHVbMV0rMSkvMioyNTV8MDtsW3YrMl09MjU1KnVbMl18MDtsW3YrM109MjU1fWcucHV0SW1hZ2VEYXRhKGssMCwwKTtyZXR1cm4gZn0sZ2VuZXJhdGVEYXRhVGV4dHVyZTpmdW5jdGlvbihhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIsYyl7dmFyIGQ9YSpiLGU9bmV3IFVpbnQ4QXJyYXkoMypkKSxmPU1hdGguZmxvb3IoMjU1KmMuciksZz1NYXRoLmZsb29yKDI1NSpjLmcpO2M9TWF0aC5mbG9vcigyNTUqYy5iKTtmb3IodmFyIGg9MDtoPGQ7aCsrKWVbMypoXT1mLGVbMypoKzFdPWcsZVszKmgrMl09YzthPW5ldyBUSFJFRS5EYXRhVGV4dHVyZShlLGEsYixUSFJFRS5SR0JGb3JtYXQpO2EubmVlZHNVcGRhdGU9ITA7cmV0dXJuIGF9fTtcblRIUkVFLlNjZW5lVXRpbHM9e2NyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9bmV3IFRIUkVFLk9iamVjdDNELGQ9MCxlPWIubGVuZ3RoO2Q8ZTtkKyspYy5hZGQobmV3IFRIUkVFLk1lc2goYSxiW2RdKSk7cmV0dXJuIGN9LGRldGFjaDpmdW5jdGlvbihhLGIsYyl7YS5hcHBseU1hdHJpeChiLm1hdHJpeFdvcmxkKTtiLnJlbW92ZShhKTtjLmFkZChhKX0sYXR0YWNoOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1uZXcgVEhSRUUuTWF0cml4NDtkLmdldEludmVyc2UoYy5tYXRyaXhXb3JsZCk7YS5hcHBseU1hdHJpeChkKTtiLnJlbW92ZShhKTtjLmFkZChhKX19O1xuVEhSRUUuRm9udFV0aWxzPXtmYWNlczp7fSxmYWNlOlwiaGVsdmV0aWtlclwiLHdlaWdodDpcIm5vcm1hbFwiLHN0eWxlOlwibm9ybWFsXCIsc2l6ZToxNTAsZGl2aXNpb25zOjEwLGdldEZhY2U6ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIHRoaXMuZmFjZXNbdGhpcy5mYWNlXVt0aGlzLndlaWdodF1bdGhpcy5zdHlsZV19Y2F0Y2goYSl7dGhyb3dcIlRoZSBmb250IFwiK3RoaXMuZmFjZStcIiB3aXRoIFwiK3RoaXMud2VpZ2h0K1wiIHdlaWdodCBhbmQgXCIrdGhpcy5zdHlsZStcIiBzdHlsZSBpcyBtaXNzaW5nLlwiO319LGxvYWRGYWNlOmZ1bmN0aW9uKGEpe3ZhciBiPWEuZmFtaWx5TmFtZS50b0xvd2VyQ2FzZSgpO3RoaXMuZmFjZXNbYl09dGhpcy5mYWNlc1tiXXx8e307dGhpcy5mYWNlc1tiXVthLmNzc0ZvbnRXZWlnaHRdPXRoaXMuZmFjZXNbYl1bYS5jc3NGb250V2VpZ2h0XXx8e307dGhpcy5mYWNlc1tiXVthLmNzc0ZvbnRXZWlnaHRdW2EuY3NzRm9udFN0eWxlXT1hO3JldHVybiB0aGlzLmZhY2VzW2JdW2EuY3NzRm9udFdlaWdodF1bYS5jc3NGb250U3R5bGVdPVxuICAgIGF9LGRyYXdUZXh0OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0RmFjZSgpLGM9dGhpcy5zaXplL2IucmVzb2x1dGlvbixkPTAsZT1TdHJpbmcoYSkuc3BsaXQoXCJcIiksZj1lLmxlbmd0aCxnPVtdO2ZvcihhPTA7YTxmO2ErKyl7dmFyIGg9bmV3IFRIUkVFLlBhdGgsaD10aGlzLmV4dHJhY3RHbHlwaFBvaW50cyhlW2FdLGIsYyxkLGgpLGQ9ZCtoLm9mZnNldDtnLnB1c2goaC5wYXRoKX1yZXR1cm57cGF0aHM6ZyxvZmZzZXQ6ZC8yfX0sZXh0cmFjdEdseXBoUG9pbnRzOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9W10sZyxoLGssbCxwLHEsbix0LHIscyx1LHY9Yi5nbHlwaHNbYV18fGIuZ2x5cGhzW1wiP1wiXTtpZih2KXtpZih2Lm8pZm9yKGI9di5fY2FjaGVkT3V0bGluZXx8KHYuX2NhY2hlZE91dGxpbmU9di5vLnNwbGl0KFwiIFwiKSksbD1iLmxlbmd0aCxhPTA7YTxsOylzd2l0Y2goaz1iW2ErK10sayl7Y2FzZSBcIm1cIjprPWJbYSsrXSpjK2Q7cD1iW2ErK10qYztlLm1vdmVUbyhrLHApO1xuICAgIGJyZWFrO2Nhc2UgXCJsXCI6az1iW2ErK10qYytkO3A9YlthKytdKmM7ZS5saW5lVG8oayxwKTticmVhaztjYXNlIFwicVwiOms9YlthKytdKmMrZDtwPWJbYSsrXSpjO3Q9YlthKytdKmMrZDtyPWJbYSsrXSpjO2UucXVhZHJhdGljQ3VydmVUbyh0LHIsayxwKTtpZihnPWZbZi5sZW5ndGgtMV0pZm9yKHE9Zy54LG49Zy55LGc9MSxoPXRoaXMuZGl2aXNpb25zO2c8PWg7ZysrKXt2YXIgeD1nL2g7VEhSRUUuU2hhcGUuVXRpbHMuYjIoeCxxLHQsayk7VEhSRUUuU2hhcGUuVXRpbHMuYjIoeCxuLHIscCl9YnJlYWs7Y2FzZSBcImJcIjppZihrPWJbYSsrXSpjK2QscD1iW2ErK10qYyx0PWJbYSsrXSpjK2Qscj1iW2ErK10qYyxzPWJbYSsrXSpjK2QsdT1iW2ErK10qYyxlLmJlemllckN1cnZlVG8odCxyLHMsdSxrLHApLGc9ZltmLmxlbmd0aC0xXSlmb3IocT1nLngsbj1nLnksZz0xLGg9dGhpcy5kaXZpc2lvbnM7Zzw9aDtnKyspeD1nL2gsVEhSRUUuU2hhcGUuVXRpbHMuYjMoeCxxLHQscyxrKSxUSFJFRS5TaGFwZS5VdGlscy5iMyh4LFxuICAgIG4scix1LHApfXJldHVybntvZmZzZXQ6di5oYSpjLHBhdGg6ZX19fX07XG5USFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXM9ZnVuY3Rpb24oYSxiKXtiPWJ8fHt9O3ZhciBjPXZvaWQgMCE9PWIuY3VydmVTZWdtZW50cz9iLmN1cnZlU2VnbWVudHM6NCxkPXZvaWQgMCE9PWIuZm9udD9iLmZvbnQ6XCJoZWx2ZXRpa2VyXCIsZT12b2lkIDAhPT1iLndlaWdodD9iLndlaWdodDpcIm5vcm1hbFwiLGY9dm9pZCAwIT09Yi5zdHlsZT9iLnN0eWxlOlwibm9ybWFsXCI7VEhSRUUuRm9udFV0aWxzLnNpemU9dm9pZCAwIT09Yi5zaXplP2Iuc2l6ZToxMDA7VEhSRUUuRm9udFV0aWxzLmRpdmlzaW9ucz1jO1RIUkVFLkZvbnRVdGlscy5mYWNlPWQ7VEhSRUUuRm9udFV0aWxzLndlaWdodD1lO1RIUkVFLkZvbnRVdGlscy5zdHlsZT1mO2M9VEhSRUUuRm9udFV0aWxzLmRyYXdUZXh0KGEpLnBhdGhzO2Q9W107ZT0wO2ZvcihmPWMubGVuZ3RoO2U8ZjtlKyspQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZCxjW2VdLnRvU2hhcGVzKCkpO3JldHVybiBkfTtcbihmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS5sZW5ndGgsZT0wLGY9Yi0xLGc9MDtnPGI7Zj1nKyspZSs9YVtmXS54KmFbZ10ueS1hW2ddLngqYVtmXS55O3JldHVybi41KmV9O2EuVHJpYW5ndWxhdGU9ZnVuY3Rpb24oYSxkKXt2YXIgZT1hLmxlbmd0aDtpZigzPmUpcmV0dXJuIG51bGw7dmFyIGY9W10sZz1bXSxoPVtdLGssbCxwO2lmKDA8YihhKSlmb3IobD0wO2w8ZTtsKyspZ1tsXT1sO2Vsc2UgZm9yKGw9MDtsPGU7bCsrKWdbbF09ZS0xLWw7dmFyIHE9MiplO2ZvcihsPWUtMTsyPGU7KXtpZigwPj1xLS0pe1RIUkVFLndhcm4oXCJUSFJFRS5Gb250VXRpbHM6IFdhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uISBpbiBUcmlhbmd1bGF0ZS5wcm9jZXNzKClcIik7YnJlYWt9az1sO2U8PWsmJihrPTApO2w9aysxO2U8PWwmJihsPTApO3A9bCsxO2U8PXAmJihwPTApO3ZhciBuO2E6e3ZhciB0PW49dm9pZCAwLHI9dm9pZCAwLHM9dm9pZCAwLFxuICAgIHU9dm9pZCAwLHY9dm9pZCAwLHg9dm9pZCAwLEQ9dm9pZCAwLHc9dm9pZCAwLHQ9YVtnW2tdXS54LHI9YVtnW2tdXS55LHM9YVtnW2xdXS54LHU9YVtnW2xdXS55LHY9YVtnW3BdXS54LHg9YVtnW3BdXS55O2lmKDFFLTEwPihzLXQpKih4LXIpLSh1LXIpKih2LXQpKW49ITE7ZWxzZXt2YXIgeT12b2lkIDAsQT12b2lkIDAsRT12b2lkIDAsRz12b2lkIDAsRj12b2lkIDAsej12b2lkIDAsST12b2lkIDAsVT12b2lkIDAsTT12b2lkIDAsSD12b2lkIDAsTT1VPUk9dz1EPXZvaWQgMCx5PXYtcyxBPXgtdSxFPXQtdixHPXIteCxGPXMtdCx6PXUtcjtmb3Iobj0wO248ZTtuKyspaWYoRD1hW2dbbl1dLngsdz1hW2dbbl1dLnksIShEPT09dCYmdz09PXJ8fEQ9PT1zJiZ3PT09dXx8RD09PXYmJnc9PT14KSYmKEk9RC10LFU9dy1yLE09RC1zLEg9dy11LEQtPXYsdy09eCxNPXkqSC1BKk0sST1GKlUteipJLFU9RSp3LUcqRCwtMUUtMTA8PU0mJi0xRS0xMDw9VSYmLTFFLTEwPD1JKSl7bj0hMTticmVhayBhfW49XG4gICAgITB9fWlmKG4pe2YucHVzaChbYVtnW2tdXSxhW2dbbF1dLGFbZ1twXV1dKTtoLnB1c2goW2dba10sZ1tsXSxnW3BdXSk7az1sO2ZvcihwPWwrMTtwPGU7aysrLHArKylnW2tdPWdbcF07ZS0tO3E9MiplfX1yZXR1cm4gZD9oOmZ9O2EuVHJpYW5ndWxhdGUuYXJlYT1iO3JldHVybiBhfSkoVEhSRUUuRm9udFV0aWxzKTtzZWxmLl90eXBlZmFjZV9qcz17ZmFjZXM6VEhSRUUuRm9udFV0aWxzLmZhY2VzLGxvYWRGYWNlOlRIUkVFLkZvbnRVdGlscy5sb2FkRmFjZX07VEhSRUUudHlwZWZhY2VfanM9c2VsZi5fdHlwZWZhY2VfanM7XG5USFJFRS5BdWRpbz1mdW5jdGlvbihhKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIkF1ZGlvXCI7dGhpcy5jb250ZXh0PWEuY29udGV4dDt0aGlzLnNvdXJjZT10aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7dGhpcy5zb3VyY2Uub25lbmRlZD10aGlzLm9uRW5kZWQuYmluZCh0aGlzKTt0aGlzLmdhaW49dGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTt0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO3RoaXMucGFubmVyPXRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTt0aGlzLnBhbm5lci5jb25uZWN0KHRoaXMuZ2Fpbik7dGhpcy5hdXRvcGxheT0hMTt0aGlzLnN0YXJ0VGltZT0wO3RoaXMuaXNQbGF5aW5nPSExfTtUSFJFRS5BdWRpby5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUpO1RIUkVFLkF1ZGlvLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5BdWRpbztcblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1uZXcgWE1MSHR0cFJlcXVlc3Q7Yy5vcGVuKFwiR0VUXCIsYSwhMCk7Yy5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO2Mub25sb2FkPWZ1bmN0aW9uKGEpe2IuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEodGhpcy5yZXNwb25zZSxmdW5jdGlvbihhKXtiLnNvdXJjZS5idWZmZXI9YTtiLmF1dG9wbGF5JiZiLnBsYXkoKX0pfTtjLnNlbmQoKTtyZXR1cm4gdGhpc307XG5USFJFRS5BdWRpby5wcm90b3R5cGUucGxheT1mdW5jdGlvbigpe2lmKCEwPT09dGhpcy5pc1BsYXlpbmcpVEhSRUUud2FybihcIlRIUkVFLkF1ZGlvOiBBdWRpbyBpcyBhbHJlYWR5IHBsYXlpbmcuXCIpO2Vsc2V7dmFyIGE9dGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO2EuYnVmZmVyPXRoaXMuc291cmNlLmJ1ZmZlcjthLmxvb3A9dGhpcy5zb3VyY2UubG9vcDthLm9uZW5kZWQ9dGhpcy5zb3VyY2Uub25lbmRlZDthLmNvbm5lY3QodGhpcy5wYW5uZXIpO2Euc3RhcnQoMCx0aGlzLnN0YXJ0VGltZSk7dGhpcy5pc1BsYXlpbmc9ITA7dGhpcy5zb3VyY2U9YX19O1RIUkVFLkF1ZGlvLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbigpe3RoaXMuc291cmNlLnN0b3AoKTt0aGlzLnN0YXJ0VGltZT10aGlzLmNvbnRleHQuY3VycmVudFRpbWV9O1RIUkVFLkF1ZGlvLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dGhpcy5zb3VyY2Uuc3RvcCgpO3RoaXMuc3RhcnRUaW1lPTB9O1xuVEhSRUUuQXVkaW8ucHJvdG90eXBlLm9uRW5kZWQ9ZnVuY3Rpb24oKXt0aGlzLmlzUGxheWluZz0hMX07VEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldExvb3A9ZnVuY3Rpb24oYSl7dGhpcy5zb3VyY2UubG9vcD1hfTtUSFJFRS5BdWRpby5wcm90b3R5cGUuc2V0UmVmRGlzdGFuY2U9ZnVuY3Rpb24oYSl7dGhpcy5wYW5uZXIucmVmRGlzdGFuY2U9YX07VEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFJvbGxvZmZGYWN0b3I9ZnVuY3Rpb24oYSl7dGhpcy5wYW5uZXIucm9sbG9mZkZhY3Rvcj1hfTtUSFJFRS5BdWRpby5wcm90b3R5cGUuc2V0Vm9sdW1lPWZ1bmN0aW9uKGEpe3RoaXMuZ2Fpbi5nYWluLnZhbHVlPWF9O1xuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIpe1RIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKHRoaXMsYik7YS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7dGhpcy5wYW5uZXIuc2V0UG9zaXRpb24oYS54LGEueSxhLnopfX0oKTtUSFJFRS5BdWRpb0xpc3RlbmVyPWZ1bmN0aW9uKCl7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJBdWRpb0xpc3RlbmVyXCI7dGhpcy5jb250ZXh0PW5ldyAod2luZG93LkF1ZGlvQ29udGV4dHx8d2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCl9O1RIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5BdWRpb0xpc3RlbmVyO1xuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQ9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5RdWF0ZXJuaW9uLGM9bmV3IFRIUkVFLlZlY3RvcjMsZD1uZXcgVEhSRUUuVmVjdG9yMyxlPW5ldyBUSFJFRS5WZWN0b3IzLGY9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGcpe1RIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKHRoaXMsZyk7Zz10aGlzLmNvbnRleHQubGlzdGVuZXI7dmFyIGg9dGhpcy51cDt0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShhLGIsYyk7ZC5zZXQoMCwwLC0xKS5hcHBseVF1YXRlcm5pb24oYik7ZS5zdWJWZWN0b3JzKGEsZik7Zy5zZXRQb3NpdGlvbihhLngsYS55LGEueik7Zy5zZXRPcmllbnRhdGlvbihkLngsZC55LGQueixoLngsaC55LGgueik7Zy5zZXRWZWxvY2l0eShlLngsZS55LGUueik7Zi5jb3B5KGEpfX0oKTtcblRIUkVFLkN1cnZlPWZ1bmN0aW9uKCl7fTtUSFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQ9ZnVuY3Rpb24oYSl7VEhSRUUud2FybihcIlRIUkVFLkN1cnZlOiBXYXJuaW5nLCBnZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZCFcIik7cmV0dXJuIG51bGx9O1RIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0PWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRVdG9UbWFwcGluZyhhKTtyZXR1cm4gdGhpcy5nZXRQb2ludChhKX07VEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50cz1mdW5jdGlvbihhKXthfHwoYT01KTt2YXIgYixjPVtdO2ZvcihiPTA7Yjw9YTtiKyspYy5wdXNoKHRoaXMuZ2V0UG9pbnQoYi9hKSk7cmV0dXJuIGN9O1RIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHM9ZnVuY3Rpb24oYSl7YXx8KGE9NSk7dmFyIGIsYz1bXTtmb3IoYj0wO2I8PWE7YisrKWMucHVzaCh0aGlzLmdldFBvaW50QXQoYi9hKSk7cmV0dXJuIGN9O1xuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldExlbmd0aD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0TGVuZ3RocygpO3JldHVybiBhW2EubGVuZ3RoLTFdfTtUSFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3Rocz1mdW5jdGlvbihhKXthfHwoYT10aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zP3RoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnM6MjAwKTtpZih0aGlzLmNhY2hlQXJjTGVuZ3RocyYmdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoPT1hKzEmJiF0aGlzLm5lZWRzVXBkYXRlKXJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3Roczt0aGlzLm5lZWRzVXBkYXRlPSExO3ZhciBiPVtdLGMsZD10aGlzLmdldFBvaW50KDApLGUsZj0wO2IucHVzaCgwKTtmb3IoZT0xO2U8PWE7ZSsrKWM9dGhpcy5nZXRQb2ludChlL2EpLGYrPWMuZGlzdGFuY2VUbyhkKSxiLnB1c2goZiksZD1jO3JldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3Rocz1ifTtcblRIUkVFLkN1cnZlLnByb3RvdHlwZS51cGRhdGVBcmNMZW5ndGhzPWZ1bmN0aW9uKCl7dGhpcy5uZWVkc1VwZGF0ZT0hMDt0aGlzLmdldExlbmd0aHMoKX07VEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFV0b1RtYXBwaW5nPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRMZW5ndGhzKCksZD0wLGU9Yy5sZW5ndGgsZjtmPWI/YjphKmNbZS0xXTtmb3IodmFyIGc9MCxoPWUtMSxrO2c8PWg7KWlmKGQ9TWF0aC5mbG9vcihnKyhoLWcpLzIpLGs9Y1tkXS1mLDA+aylnPWQrMTtlbHNlIGlmKDA8ayloPWQtMTtlbHNle2g9ZDticmVha31kPWg7aWYoY1tkXT09ZilyZXR1cm4gZC8oZS0xKTtnPWNbZF07cmV0dXJuIGM9KGQrKGYtZykvKGNbZCsxXS1nKSkvKGUtMSl9O1RIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50PWZ1bmN0aW9uKGEpe3ZhciBiPWEtMUUtNDthKz0xRS00OzA+YiYmKGI9MCk7MTxhJiYoYT0xKTtiPXRoaXMuZ2V0UG9pbnQoYik7cmV0dXJuIHRoaXMuZ2V0UG9pbnQoYSkuY2xvbmUoKS5zdWIoYikubm9ybWFsaXplKCl9O1xuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnRBdD1mdW5jdGlvbihhKXthPXRoaXMuZ2V0VXRvVG1hcHBpbmcoYSk7cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudChhKX07XG5USFJFRS5DdXJ2ZS5VdGlscz17dGFuZ2VudFF1YWRyYXRpY0JlemllcjpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gMiooMS1hKSooYy1iKSsyKmEqKGQtYyl9LHRhbmdlbnRDdWJpY0JlemllcjpmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybi0zKmIqKDEtYSkqKDEtYSkrMypjKigxLWEpKigxLWEpLTYqYSpjKigxLWEpKzYqYSpkKigxLWEpLTMqYSphKmQrMyphKmEqZX0sdGFuZ2VudFNwbGluZTpmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiA2KmEqYS02KmErKDMqYSphLTQqYSsxKSsoLTYqYSphKzYqYSkrKDMqYSphLTIqYSl9LGludGVycG9sYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7YT0uNSooYy1hKTtkPS41KihkLWIpO3ZhciBmPWUqZTtyZXR1cm4oMipiLTIqYythK2QpKmUqZisoLTMqYiszKmMtMiphLWQpKmYrYSplK2J9fTtcblRIUkVFLkN1cnZlLmNyZWF0ZT1mdW5jdGlvbihhLGIpe2EucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuQ3VydmUucHJvdG90eXBlKTthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hO2EucHJvdG90eXBlLmdldFBvaW50PWI7cmV0dXJuIGF9O1RIUkVFLkN1cnZlUGF0aD1mdW5jdGlvbigpe3RoaXMuY3VydmVzPVtdO3RoaXMuYmVuZHM9W107dGhpcy5hdXRvQ2xvc2U9ITF9O1RIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZS5wcm90b3R5cGUpO1RIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuQ3VydmVQYXRoO1RIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe3RoaXMuY3VydmVzLnB1c2goYSl9O1RIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2hlY2tDb25uZWN0aW9uPWZ1bmN0aW9uKCl7fTtcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jdXJ2ZXNbMF0uZ2V0UG9pbnQoMCksYj10aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGgtMV0uZ2V0UG9pbnQoMSk7YS5lcXVhbHMoYil8fHRoaXMuY3VydmVzLnB1c2gobmV3IFRIUkVFLkxpbmVDdXJ2ZShiLGEpKX07VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRQb2ludD1mdW5jdGlvbihhKXt2YXIgYj1hKnRoaXMuZ2V0TGVuZ3RoKCksYz10aGlzLmdldEN1cnZlTGVuZ3RocygpO2ZvcihhPTA7YTxjLmxlbmd0aDspe2lmKGNbYV0+PWIpcmV0dXJuIGI9Y1thXS1iLGE9dGhpcy5jdXJ2ZXNbYV0sYj0xLWIvYS5nZXRMZW5ndGgoKSxhLmdldFBvaW50QXQoYik7YSsrfXJldHVybiBudWxsfTtUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldExlbmd0aD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7cmV0dXJuIGFbYS5sZW5ndGgtMV19O1xuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRDdXJ2ZUxlbmd0aHM9ZnVuY3Rpb24oKXtpZih0aGlzLmNhY2hlTGVuZ3RocyYmdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoPT10aGlzLmN1cnZlcy5sZW5ndGgpcmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO3ZhciBhPVtdLGI9MCxjLGQ9dGhpcy5jdXJ2ZXMubGVuZ3RoO2ZvcihjPTA7YzxkO2MrKyliKz10aGlzLmN1cnZlc1tjXS5nZXRMZW5ndGgoKSxhLnB1c2goYik7cmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzPWF9O1xuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0UG9pbnRzKCksYixjLGQsZSxmLGc7Yj1jPU51bWJlci5ORUdBVElWRV9JTkZJTklUWTtlPWY9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO3ZhciBoLGssbCxwLHE9YVswXWluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMztwPXE/bmV3IFRIUkVFLlZlY3RvcjM6bmV3IFRIUkVFLlZlY3RvcjI7az0wO2ZvcihsPWEubGVuZ3RoO2s8bDtrKyspaD1hW2tdLGgueD5iP2I9aC54OmgueDxlJiYoZT1oLngpLGgueT5jP2M9aC55OmgueTxmJiYoZj1oLnkpLHEmJihoLno+ZD9kPWguejpoLno8ZyYmKGc9aC56KSkscC5hZGQoaCk7YT17bWluWDplLG1pblk6ZixtYXhYOmIsbWF4WTpjfTtxJiYoYS5tYXhaPWQsYS5taW5aPWcpO3JldHVybiBhfTtcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlUG9pbnRzR2VvbWV0cnk9ZnVuY3Rpb24oYSl7YT10aGlzLmdldFBvaW50cyhhLCEwKTtyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeShhKX07VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeT1mdW5jdGlvbihhKXthPXRoaXMuZ2V0U3BhY2VkUG9pbnRzKGEsITApO3JldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KGEpfTtUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZUdlb21ldHJ5PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1uZXcgVEhSRUUuR2VvbWV0cnksYz0wO2M8YS5sZW5ndGg7YysrKWIudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhhW2NdLngsYVtjXS55LGFbY10uenx8MCkpO3JldHVybiBifTtUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZFdyYXBQYXRoPWZ1bmN0aW9uKGEpe3RoaXMuYmVuZHMucHVzaChhKX07XG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnRzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRQb2ludHMoYSksZCxlO2J8fChiPXRoaXMuYmVuZHMpO2Q9MDtmb3IoZT1iLmxlbmd0aDtkPGU7ZCsrKWM9dGhpcy5nZXRXcmFwUG9pbnRzKGMsYltkXSk7cmV0dXJuIGN9O1RIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldFNwYWNlZFBvaW50cyhhKSxkLGU7Ynx8KGI9dGhpcy5iZW5kcyk7ZD0wO2ZvcihlPWIubGVuZ3RoO2Q8ZTtkKyspYz10aGlzLmdldFdyYXBQb2ludHMoYyxiW2RdKTtyZXR1cm4gY307XG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFdyYXBQb2ludHM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldEJvdW5kaW5nQm94KCksZCxlLGYsZyxoLGs7ZD0wO2ZvcihlPWEubGVuZ3RoO2Q8ZTtkKyspZj1hW2RdLGc9Zi54LGg9Zi55LGs9Zy9jLm1heFgsaz1iLmdldFV0b1RtYXBwaW5nKGssZyksZz1iLmdldFBvaW50KGspLGs9Yi5nZXRUYW5nZW50KGspLGsuc2V0KC1rLnksay54KS5tdWx0aXBseVNjYWxhcihoKSxmLng9Zy54K2sueCxmLnk9Zy55K2sueTtyZXR1cm4gYX07VEhSRUUuR3lyb3Njb3BlPWZ1bmN0aW9uKCl7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKX07VEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5HeXJvc2NvcGU7XG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuUXVhdGVybmlvbixjPW5ldyBUSFJFRS5WZWN0b3IzLGQ9bmV3IFRIUkVFLlZlY3RvcjMsZT1uZXcgVEhSRUUuUXVhdGVybmlvbixmPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihnKXt0aGlzLm1hdHJpeEF1dG9VcGRhdGUmJnRoaXMudXBkYXRlTWF0cml4KCk7aWYodGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlfHxnKXRoaXMucGFyZW50Pyh0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpLHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKGQsZSxmKSx0aGlzLm1hdHJpeC5kZWNvbXBvc2UoYSxiLGMpLHRoaXMubWF0cml4V29ybGQuY29tcG9zZShkLGIsZikpOnRoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCksdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPVxuICAgICExLGc9ITA7Zm9yKHZhciBoPTAsaz10aGlzLmNoaWxkcmVuLmxlbmd0aDtoPGs7aCsrKXRoaXMuY2hpbGRyZW5baF0udXBkYXRlTWF0cml4V29ybGQoZyl9fSgpO1RIUkVFLlBhdGg9ZnVuY3Rpb24oYSl7VEhSRUUuQ3VydmVQYXRoLmNhbGwodGhpcyk7dGhpcy5hY3Rpb25zPVtdO2EmJnRoaXMuZnJvbVBvaW50cyhhKX07VEhSRUUuUGF0aC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlKTtUSFJFRS5QYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5QYXRoO1RIUkVFLlBhdGhBY3Rpb25zPXtNT1ZFX1RPOlwibW92ZVRvXCIsTElORV9UTzpcImxpbmVUb1wiLFFVQURSQVRJQ19DVVJWRV9UTzpcInF1YWRyYXRpY0N1cnZlVG9cIixCRVpJRVJfQ1VSVkVfVE86XCJiZXppZXJDdXJ2ZVRvXCIsQ1NQTElORV9USFJVOlwic3BsaW5lVGhydVwiLEFSQzpcImFyY1wiLEVMTElQU0U6XCJlbGxpcHNlXCJ9O1xuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cz1mdW5jdGlvbihhKXt0aGlzLm1vdmVUbyhhWzBdLngsYVswXS55KTtmb3IodmFyIGI9MSxjPWEubGVuZ3RoO2I8YztiKyspdGhpcy5saW5lVG8oYVtiXS54LGFbYl0ueSl9O1RIUkVFLlBhdGgucHJvdG90eXBlLm1vdmVUbz1mdW5jdGlvbihhLGIpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7dGhpcy5hY3Rpb25zLnB1c2goe2FjdGlvbjpUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPLGFyZ3M6Y30pfTtcblRIUkVFLlBhdGgucHJvdG90eXBlLmxpbmVUbz1mdW5jdGlvbihhLGIpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksZD10aGlzLmFjdGlvbnNbdGhpcy5hY3Rpb25zLmxlbmd0aC0xXS5hcmdzLGQ9bmV3IFRIUkVFLkxpbmVDdXJ2ZShuZXcgVEhSRUUuVmVjdG9yMihkW2QubGVuZ3RoLTJdLGRbZC5sZW5ndGgtMV0pLG5ldyBUSFJFRS5WZWN0b3IyKGEsYikpO3RoaXMuY3VydmVzLnB1c2goZCk7dGhpcy5hY3Rpb25zLnB1c2goe2FjdGlvbjpUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPLGFyZ3M6Y30pfTtcblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG89ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxmPXRoaXMuYWN0aW9uc1t0aGlzLmFjdGlvbnMubGVuZ3RoLTFdLmFyZ3MsZj1uZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUobmV3IFRIUkVFLlZlY3RvcjIoZltmLmxlbmd0aC0yXSxmW2YubGVuZ3RoLTFdKSxuZXcgVEhSRUUuVmVjdG9yMihhLGIpLG5ldyBUSFJFRS5WZWN0b3IyKGMsZCkpO3RoaXMuY3VydmVzLnB1c2goZik7dGhpcy5hY3Rpb25zLnB1c2goe2FjdGlvbjpUSFJFRS5QYXRoQWN0aW9ucy5RVUFEUkFUSUNfQ1VSVkVfVE8sYXJnczplfSl9O1xuVEhSRUUuUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxoPXRoaXMuYWN0aW9uc1t0aGlzLmFjdGlvbnMubGVuZ3RoLTFdLmFyZ3MsaD1uZXcgVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZShuZXcgVEhSRUUuVmVjdG9yMihoW2gubGVuZ3RoLTJdLGhbaC5sZW5ndGgtMV0pLG5ldyBUSFJFRS5WZWN0b3IyKGEsYiksbmV3IFRIUkVFLlZlY3RvcjIoYyxkKSxuZXcgVEhSRUUuVmVjdG9yMihlLGYpKTt0aGlzLmN1cnZlcy5wdXNoKGgpO3RoaXMuYWN0aW9ucy5wdXNoKHthY3Rpb246VEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPLGFyZ3M6Z30pfTtcblRIUkVFLlBhdGgucHJvdG90eXBlLnNwbGluZVRocnU9ZnVuY3Rpb24oYSl7dmFyIGI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxjPXRoaXMuYWN0aW9uc1t0aGlzLmFjdGlvbnMubGVuZ3RoLTFdLmFyZ3MsYz1bbmV3IFRIUkVFLlZlY3RvcjIoY1tjLmxlbmd0aC0yXSxjW2MubGVuZ3RoLTFdKV07QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYyxhKTtjPW5ldyBUSFJFRS5TcGxpbmVDdXJ2ZShjKTt0aGlzLmN1cnZlcy5wdXNoKGMpO3RoaXMuYWN0aW9ucy5wdXNoKHthY3Rpb246VEhSRUUuUGF0aEFjdGlvbnMuQ1NQTElORV9USFJVLGFyZ3M6Yn0pfTtUSFJFRS5QYXRoLnByb3RvdHlwZS5hcmM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPXRoaXMuYWN0aW9uc1t0aGlzLmFjdGlvbnMubGVuZ3RoLTFdLmFyZ3M7dGhpcy5hYnNhcmMoYStnW2cubGVuZ3RoLTJdLGIrZ1tnLmxlbmd0aC0xXSxjLGQsZSxmKX07XG5USFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3RoaXMuYWJzZWxsaXBzZShhLGIsYyxjLGQsZSxmKX07VEhSRUUuUGF0aC5wcm90b3R5cGUuZWxsaXBzZT1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXt2YXIgaD10aGlzLmFjdGlvbnNbdGhpcy5hY3Rpb25zLmxlbmd0aC0xXS5hcmdzO3RoaXMuYWJzZWxsaXBzZShhK2hbaC5sZW5ndGgtMl0sYitoW2gubGVuZ3RoLTFdLGMsZCxlLGYsZyl9O1RIUkVFLlBhdGgucHJvdG90eXBlLmFic2VsbGlwc2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7dmFyIGg9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxrPW5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoYSxiLGMsZCxlLGYsZyk7dGhpcy5jdXJ2ZXMucHVzaChrKTtrPWsuZ2V0UG9pbnQoMSk7aC5wdXNoKGsueCk7aC5wdXNoKGsueSk7dGhpcy5hY3Rpb25zLnB1c2goe2FjdGlvbjpUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFLGFyZ3M6aH0pfTtcblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cz1mdW5jdGlvbihhLGIpe2F8fChhPTQwKTtmb3IodmFyIGM9W10sZD0wO2Q8YTtkKyspYy5wdXNoKHRoaXMuZ2V0UG9pbnQoZC9hKSk7cmV0dXJuIGN9O1xuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzPWZ1bmN0aW9uKGEsYil7aWYodGhpcy51c2VTcGFjZWRQb2ludHMpcmV0dXJuIGNvbnNvbGUubG9nKFwidGF0YVwiKSx0aGlzLmdldFNwYWNlZFBvaW50cyhhLGIpO2E9YXx8MTI7dmFyIGM9W10sZCxlLGYsZyxoLGssbCxwLHEsbix0LHIscztkPTA7Zm9yKGU9dGhpcy5hY3Rpb25zLmxlbmd0aDtkPGU7ZCsrKXN3aXRjaChmPXRoaXMuYWN0aW9uc1tkXSxnPWYuYWN0aW9uLGY9Zi5hcmdzLGcpe2Nhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpjLnB1c2gobmV3IFRIUkVFLlZlY3RvcjIoZlswXSxmWzFdKSk7YnJlYWs7Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOmMucHVzaChuZXcgVEhSRUUuVmVjdG9yMihmWzBdLGZbMV0pKTticmVhaztjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpoPWZbMl07az1mWzNdO3E9ZlswXTtuPWZbMV07MDxjLmxlbmd0aD8oZz1jW2MubGVuZ3RoLTFdLHQ9Zy54LFxuICAgIHI9Zy55KTooZz10aGlzLmFjdGlvbnNbZC0xXS5hcmdzLHQ9Z1tnLmxlbmd0aC0yXSxyPWdbZy5sZW5ndGgtMV0pO2ZvcihmPTE7Zjw9YTtmKyspcz1mL2EsZz1USFJFRS5TaGFwZS5VdGlscy5iMihzLHQscSxoKSxzPVRIUkVFLlNoYXBlLlV0aWxzLmIyKHMscixuLGspLGMucHVzaChuZXcgVEhSRUUuVmVjdG9yMihnLHMpKTticmVhaztjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkJFWklFUl9DVVJWRV9UTzpoPWZbNF07az1mWzVdO3E9ZlswXTtuPWZbMV07bD1mWzJdO3A9ZlszXTswPGMubGVuZ3RoPyhnPWNbYy5sZW5ndGgtMV0sdD1nLngscj1nLnkpOihnPXRoaXMuYWN0aW9uc1tkLTFdLmFyZ3MsdD1nW2cubGVuZ3RoLTJdLHI9Z1tnLmxlbmd0aC0xXSk7Zm9yKGY9MTtmPD1hO2YrKylzPWYvYSxnPVRIUkVFLlNoYXBlLlV0aWxzLmIzKHMsdCxxLGwsaCkscz1USFJFRS5TaGFwZS5VdGlscy5iMyhzLHIsbixwLGspLGMucHVzaChuZXcgVEhSRUUuVmVjdG9yMihnLHMpKTticmVhaztjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVTpnPVxuICAgIHRoaXMuYWN0aW9uc1tkLTFdLmFyZ3M7cz1bbmV3IFRIUkVFLlZlY3RvcjIoZ1tnLmxlbmd0aC0yXSxnW2cubGVuZ3RoLTFdKV07Zz1hKmZbMF0ubGVuZ3RoO3M9cy5jb25jYXQoZlswXSk7cz1uZXcgVEhSRUUuU3BsaW5lQ3VydmUocyk7Zm9yKGY9MTtmPD1nO2YrKyljLnB1c2gocy5nZXRQb2ludEF0KGYvZykpO2JyZWFrO2Nhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQVJDOmg9ZlswXTtrPWZbMV07bj1mWzJdO2w9ZlszXTtnPWZbNF07cT0hIWZbNV07dD1nLWw7cj0yKmE7Zm9yKGY9MTtmPD1yO2YrKylzPWYvcixxfHwocz0xLXMpLHM9bCtzKnQsZz1oK24qTWF0aC5jb3Mocykscz1rK24qTWF0aC5zaW4ocyksYy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IyKGcscykpO2JyZWFrO2Nhc2UgVEhSRUUuUGF0aEFjdGlvbnMuRUxMSVBTRTpmb3IoaD1mWzBdLGs9ZlsxXSxuPWZbMl0scD1mWzNdLGw9Zls0XSxnPWZbNV0scT0hIWZbNl0sdD1nLWwscj0yKmEsZj0xO2Y8PXI7ZisrKXM9Zi9yLHF8fFxuKHM9MS1zKSxzPWwrcyp0LGc9aCtuKk1hdGguY29zKHMpLHM9aytwKk1hdGguc2luKHMpLGMucHVzaChuZXcgVEhSRUUuVmVjdG9yMihnLHMpKX1kPWNbYy5sZW5ndGgtMV07MUUtMTA+TWF0aC5hYnMoZC54LWNbMF0ueCkmJjFFLTEwPk1hdGguYWJzKGQueS1jWzBdLnkpJiZjLnNwbGljZShjLmxlbmd0aC0xLDEpO2ImJmMucHVzaChjWzBdKTtyZXR1cm4gY307XG5USFJFRS5QYXRoLnByb3RvdHlwZS50b1NoYXBlcz1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7Zm9yKHZhciBiPVtdLGM9MCxkPWEubGVuZ3RoO2M8ZDtjKyspe3ZhciBlPWFbY10sZj1uZXcgVEhSRUUuU2hhcGU7Zi5hY3Rpb25zPWUuYWN0aW9ucztmLmN1cnZlcz1lLmN1cnZlcztiLnB1c2goZil9cmV0dXJuIGJ9ZnVuY3Rpb24gZChhLGIpe2Zvcih2YXIgYz1iLmxlbmd0aCxkPSExLGU9Yy0xLGY9MDtmPGM7ZT1mKyspe3ZhciBnPWJbZV0saD1iW2ZdLGs9aC54LWcueCxuPWgueS1nLnk7aWYoMUUtMTA8TWF0aC5hYnMobikpe2lmKDA+biYmKGc9YltmXSxrPS1rLGg9YltlXSxuPS1uKSwhKGEueTxnLnl8fGEueT5oLnkpKWlmKGEueT09Zy55KXtpZihhLng9PWcueClyZXR1cm4hMH1lbHNle2U9biooYS54LWcueCktayooYS55LWcueSk7aWYoMD09ZSlyZXR1cm4hMDswPmV8fChkPSFkKX19ZWxzZSBpZihhLnk9PWcueSYmKGgueDw9YS54JiZhLng8PWcueHx8Zy54PD1hLngmJmEueDw9XG4gICAgaC54KSlyZXR1cm4hMH1yZXR1cm4gZH12YXIgZT1mdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmPVtdLGc9bmV3IFRIUkVFLlBhdGg7Yj0wO2ZvcihjPWEubGVuZ3RoO2I8YztiKyspZD1hW2JdLGU9ZC5hcmdzLGQ9ZC5hY3Rpb24sZD09VEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTyYmMCE9Zy5hY3Rpb25zLmxlbmd0aCYmKGYucHVzaChnKSxnPW5ldyBUSFJFRS5QYXRoKSxnW2RdLmFwcGx5KGcsZSk7MCE9Zy5hY3Rpb25zLmxlbmd0aCYmZi5wdXNoKGcpO3JldHVybiBmfSh0aGlzLmFjdGlvbnMpO2lmKDA9PWUubGVuZ3RoKXJldHVybltdO2lmKCEwPT09YilyZXR1cm4gYyhlKTt2YXIgZixnLGgsaz1bXTtpZigxPT1lLmxlbmd0aClyZXR1cm4gZz1lWzBdLGg9bmV3IFRIUkVFLlNoYXBlLGguYWN0aW9ucz1nLmFjdGlvbnMsaC5jdXJ2ZXM9Zy5jdXJ2ZXMsay5wdXNoKGgpLGs7dmFyIGw9IVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKGVbMF0uZ2V0UG9pbnRzKCkpLGw9YT8hbDpsO1xuICAgIGg9W107dmFyIHA9W10scT1bXSxuPTAsdDtwW25dPXZvaWQgMDtxW25dPVtdO3ZhciByLHM7cj0wO2ZvcihzPWUubGVuZ3RoO3I8cztyKyspZz1lW3JdLHQ9Zy5nZXRQb2ludHMoKSxmPVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKHQpLChmPWE/IWY6Zik/KCFsJiZwW25dJiZuKysscFtuXT17czpuZXcgVEhSRUUuU2hhcGUscDp0fSxwW25dLnMuYWN0aW9ucz1nLmFjdGlvbnMscFtuXS5zLmN1cnZlcz1nLmN1cnZlcyxsJiZuKysscVtuXT1bXSk6cVtuXS5wdXNoKHtoOmcscDp0WzBdfSk7aWYoIXBbMF0pcmV0dXJuIGMoZSk7aWYoMTxwLmxlbmd0aCl7cj0hMTtzPVtdO2c9MDtmb3IoZT1wLmxlbmd0aDtnPGU7ZysrKWhbZ109W107Zz0wO2ZvcihlPXAubGVuZ3RoO2c8ZTtnKyspZm9yKGY9cVtnXSxsPTA7bDxmLmxlbmd0aDtsKyspe249ZltsXTt0PSEwO2Zvcih2YXIgdT0wO3U8cC5sZW5ndGg7dSsrKWQobi5wLHBbdV0ucCkmJihnIT11JiZzLnB1c2goe2Zyb21zOmcsdG9zOnUsXG4gICAgICAgIGhvbGU6bH0pLHQ/KHQ9ITEsaFt1XS5wdXNoKG4pKTpyPSEwKTt0JiZoW2ddLnB1c2gobil9MDxzLmxlbmd0aCYmKHJ8fChxPWgpKX1yPTA7Zm9yKHM9cC5sZW5ndGg7cjxzO3IrKylmb3IoaD1wW3JdLnMsay5wdXNoKGgpLGc9cVtyXSxlPTAsZj1nLmxlbmd0aDtlPGY7ZSsrKWguaG9sZXMucHVzaChnW2VdLmgpO3JldHVybiBrfTtUSFJFRS5TaGFwZT1mdW5jdGlvbigpe1RIUkVFLlBhdGguYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuaG9sZXM9W119O1RIUkVFLlNoYXBlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLlBhdGgucHJvdG90eXBlKTtUSFJFRS5TaGFwZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuU2hhcGU7VEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJ1ZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkodGhpcyxhKX07XG5USFJFRS5TaGFwZS5wcm90b3R5cGUubWFrZUdlb21ldHJ5PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeSh0aGlzLGEpfTtUSFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0UG9pbnRzSG9sZXM9ZnVuY3Rpb24oYSl7dmFyIGIsYz10aGlzLmhvbGVzLmxlbmd0aCxkPVtdO2ZvcihiPTA7YjxjO2IrKylkW2JdPXRoaXMuaG9sZXNbYl0uZ2V0VHJhbnNmb3JtZWRQb2ludHMoYSx0aGlzLmJlbmRzKTtyZXR1cm4gZH07VEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFNwYWNlZFBvaW50c0hvbGVzPWZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcy5ob2xlcy5sZW5ndGgsZD1bXTtmb3IoYj0wO2I8YztiKyspZFtiXT10aGlzLmhvbGVzW2JdLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKGEsdGhpcy5iZW5kcyk7cmV0dXJuIGR9O1xuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHM9ZnVuY3Rpb24oYSl7cmV0dXJue3NoYXBlOnRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoYSksaG9sZXM6dGhpcy5nZXRQb2ludHNIb2xlcyhhKX19O1RIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0UG9pbnRzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnVzZVNwYWNlZFBvaW50cz90aGlzLmV4dHJhY3RBbGxTcGFjZWRQb2ludHMoYSk6dGhpcy5leHRyYWN0QWxsUG9pbnRzKGEpfTtUSFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFNwYWNlZFBvaW50cz1mdW5jdGlvbihhKXtyZXR1cm57c2hhcGU6dGhpcy5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyhhKSxob2xlczp0aGlzLmdldFNwYWNlZFBvaW50c0hvbGVzKGEpfX07XG5USFJFRS5TaGFwZS5VdGlscz17dHJpYW5ndWxhdGVTaGFwZTpmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGMpe3JldHVybiBhLnghPWIueD9hLng8Yi54P2EueDw9Yy54JiZjLng8PWIueDpiLng8PWMueCYmYy54PD1hLng6YS55PGIueT9hLnk8PWMueSYmYy55PD1iLnk6Yi55PD1jLnkmJmMueTw9YS55fWZ1bmN0aW9uIGQoYSxiLGQsZSxmKXt2YXIgZz1iLngtYS54LGg9Yi55LWEueSxrPWUueC1kLngsbD1lLnktZC55LHA9YS54LWQueCxxPWEueS1kLnksRT1oKmstZypsLEc9aCpwLWcqcTtpZigxRS0xMDxNYXRoLmFicyhFKSl7aWYoMDxFKXtpZigwPkd8fEc+RSlyZXR1cm5bXTtrPWwqcC1rKnE7aWYoMD5rfHxrPkUpcmV0dXJuW119ZWxzZXtpZigwPEd8fEc8RSlyZXR1cm5bXTtrPWwqcC1rKnE7aWYoMDxrfHxrPEUpcmV0dXJuW119aWYoMD09aylyZXR1cm4hZnx8MCE9RyYmRyE9RT9bYV06W107aWYoaz09RSlyZXR1cm4hZnx8MCE9RyYmRyE9RT9bYl06W107aWYoMD09RylyZXR1cm5bZF07XG4gICAgaWYoRz09RSlyZXR1cm5bZV07Zj1rL0U7cmV0dXJuW3t4OmEueCtmKmcseTphLnkrZipofV19aWYoMCE9R3x8bCpwIT1rKnEpcmV0dXJuW107aD0wPT1nJiYwPT1oO2s9MD09ayYmMD09bDtpZihoJiZrKXJldHVybiBhLnghPWQueHx8YS55IT1kLnk/W106W2FdO2lmKGgpcmV0dXJuIGMoZCxlLGEpP1thXTpbXTtpZihrKXJldHVybiBjKGEsYixkKT9bZF06W107MCE9Zz8oYS54PGIueD8oZz1hLGs9YS54LGg9YixhPWIueCk6KGc9YixrPWIueCxoPWEsYT1hLngpLGQueDxlLng/KGI9ZCxFPWQueCxsPWUsZD1lLngpOihiPWUsRT1lLngsbD1kLGQ9ZC54KSk6KGEueTxiLnk/KGc9YSxrPWEueSxoPWIsYT1iLnkpOihnPWIsaz1iLnksaD1hLGE9YS55KSxkLnk8ZS55PyhiPWQsRT1kLnksbD1lLGQ9ZS55KTooYj1lLEU9ZS55LGw9ZCxkPWQueSkpO3JldHVybiBrPD1FP2E8RT9bXTphPT1FP2Y/W106W2JdOmE8PWQ/W2IsaF06W2IsbF06az5kP1tdOms9PWQ/Zj9bXTpbZ106YTw9ZD9bZyxoXTpcbiAgICBbZyxsXX1mdW5jdGlvbiBlKGEsYixjLGQpe3ZhciBlPWIueC1hLngsZj1iLnktYS55O2I9Yy54LWEueDtjPWMueS1hLnk7dmFyIGc9ZC54LWEueDtkPWQueS1hLnk7YT1lKmMtZipiO2U9ZSpkLWYqZztyZXR1cm4gMUUtMTA8TWF0aC5hYnMoYSk/KGI9ZypjLWQqYiwwPGE/MDw9ZSYmMDw9YjowPD1lfHwwPD1iKTowPGV9dmFyIGYsZyxoLGssbCxwPXt9O2g9YS5jb25jYXQoKTtmPTA7Zm9yKGc9Yi5sZW5ndGg7ZjxnO2YrKylBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShoLGJbZl0pO2Y9MDtmb3IoZz1oLmxlbmd0aDtmPGc7ZisrKWw9aFtmXS54K1wiOlwiK2hbZl0ueSx2b2lkIDAhPT1wW2xdJiZUSFJFRS53YXJuKFwiVEhSRUUuU2hhcGU6IER1cGxpY2F0ZSBwb2ludFwiLGwpLHBbbF09ZjtmPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIpe3ZhciBkPWgubGVuZ3RoLTEsZj1hLTE7MD5mJiYoZj1kKTt2YXIgZz1hKzE7Zz5kJiYoZz0wKTtkPWUoaFthXSxoW2ZdLGhbZ10sa1tiXSk7XG4gICAgaWYoIWQpcmV0dXJuITE7ZD1rLmxlbmd0aC0xO2Y9Yi0xOzA+ZiYmKGY9ZCk7Zz1iKzE7Zz5kJiYoZz0wKTtyZXR1cm4oZD1lKGtbYl0sa1tmXSxrW2ddLGhbYV0pKT8hMDohMX1mdW5jdGlvbiBmKGEsYil7dmFyIGMsZTtmb3IoYz0wO2M8aC5sZW5ndGg7YysrKWlmKGU9YysxLGUlPWgubGVuZ3RoLGU9ZChhLGIsaFtjXSxoW2VdLCEwKSwwPGUubGVuZ3RoKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGcoYSxjKXt2YXIgZSxmLGgsaztmb3IoZT0wO2U8bC5sZW5ndGg7ZSsrKWZvcihmPWJbbFtlXV0saD0wO2g8Zi5sZW5ndGg7aCsrKWlmKGs9aCsxLGslPWYubGVuZ3RoLGs9ZChhLGMsZltoXSxmW2tdLCEwKSwwPGsubGVuZ3RoKXJldHVybiEwO3JldHVybiExfXZhciBoPWEuY29uY2F0KCksayxsPVtdLHAscSxBLEUsRyxGPVtdLHosSSxVLE09MDtmb3IocD1iLmxlbmd0aDtNPHA7TSsrKWwucHVzaChNKTt6PTA7Zm9yKHZhciBIPTIqbC5sZW5ndGg7MDxsLmxlbmd0aDspe0gtLTtpZigwPlxuICAgIEgpe2NvbnNvbGUubG9nKFwiSW5maW5pdGUgTG9vcCEgSG9sZXMgbGVmdDpcIitsLmxlbmd0aCtcIiwgUHJvYmFibHkgSG9sZSBvdXRzaWRlIFNoYXBlIVwiKTticmVha31mb3IocT16O3E8aC5sZW5ndGg7cSsrKXtBPWhbcV07cD0tMTtmb3IoTT0wO008bC5sZW5ndGg7TSsrKWlmKEU9bFtNXSxHPUEueCtcIjpcIitBLnkrXCI6XCIrRSx2b2lkIDA9PT1GW0ddKXtrPWJbRV07Zm9yKEk9MDtJPGsubGVuZ3RoO0krKylpZihFPWtbSV0sYyhxLEkpJiYhZihBLEUpJiYhZyhBLEUpKXtwPUk7bC5zcGxpY2UoTSwxKTt6PWguc2xpY2UoMCxxKzEpO0U9aC5zbGljZShxKTtJPWsuc2xpY2UocCk7VT1rLnNsaWNlKDAscCsxKTtoPXouY29uY2F0KEkpLmNvbmNhdChVKS5jb25jYXQoRSk7ej1xO2JyZWFrfWlmKDA8PXApYnJlYWs7RltHXT0hMH1pZigwPD1wKWJyZWFrfX1yZXR1cm4gaH0oYSxiKTt2YXIgcT1USFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUoZiwhMSk7Zj0wO2ZvcihnPXEubGVuZ3RoO2Y8ZztmKyspZm9yKGs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxW2ZdLGg9MDszPmg7aCsrKWw9a1toXS54K1wiOlwiK2tbaF0ueSxsPXBbbF0sdm9pZCAwIT09bCYmKGtbaF09bCk7cmV0dXJuIHEuY29uY2F0KCl9LGlzQ2xvY2tXaXNlOmZ1bmN0aW9uKGEpe3JldHVybiAwPlRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKGEpfSxiMnAwOmZ1bmN0aW9uKGEsYil7dmFyIGM9MS1hO3JldHVybiBjKmMqYn0sYjJwMTpmdW5jdGlvbihhLGIpe3JldHVybiAyKigxLWEpKmEqYn0sYjJwMjpmdW5jdGlvbihhLGIpe3JldHVybiBhKmEqYn0sYjI6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuYjJwMChhLGIpK3RoaXMuYjJwMShhLGMpK3RoaXMuYjJwMihhLGQpfSxiM3AwOmZ1bmN0aW9uKGEsYil7dmFyIGM9MS1hO3JldHVybiBjKmMqYypifSxiM3AxOmZ1bmN0aW9uKGEsYil7dmFyIGM9MS1hO3JldHVybiAzKmMqYyphKmJ9LGIzcDI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMyooMS1hKSphKmEqYn0sYjNwMzpmdW5jdGlvbihhLGIpe3JldHVybiBhKlxuICAgIGEqYSpifSxiMzpmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiB0aGlzLmIzcDAoYSxiKSt0aGlzLmIzcDEoYSxjKSt0aGlzLmIzcDIoYSxkKSt0aGlzLmIzcDMoYSxlKX19O1RIUkVFLkxpbmVDdXJ2ZT1mdW5jdGlvbihhLGIpe3RoaXMudjE9YTt0aGlzLnYyPWJ9O1RIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZS5wcm90b3R5cGUpO1RIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuTGluZUN1cnZlO1RIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy52Mi5jbG9uZSgpLnN1Yih0aGlzLnYxKTtiLm11bHRpcGx5U2NhbGFyKGEpLmFkZCh0aGlzLnYxKTtyZXR1cm4gYn07VEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldFBvaW50KGEpfTtcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy52Mi5jbG9uZSgpLnN1Yih0aGlzLnYxKS5ub3JtYWxpemUoKX07VEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmU9ZnVuY3Rpb24oYSxiLGMpe3RoaXMudjA9YTt0aGlzLnYxPWI7dGhpcy52Mj1jfTtUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZS5wcm90b3R5cGUpO1RIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTtcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgVEhSRUUuVmVjdG9yMjtiLng9VEhSRUUuU2hhcGUuVXRpbHMuYjIoYSx0aGlzLnYwLngsdGhpcy52MS54LHRoaXMudjIueCk7Yi55PVRIUkVFLlNoYXBlLlV0aWxzLmIyKGEsdGhpcy52MC55LHRoaXMudjEueSx0aGlzLnYyLnkpO3JldHVybiBifTtUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgVEhSRUUuVmVjdG9yMjtiLng9VEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllcihhLHRoaXMudjAueCx0aGlzLnYxLngsdGhpcy52Mi54KTtiLnk9VEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllcihhLHRoaXMudjAueSx0aGlzLnYxLnksdGhpcy52Mi55KTtyZXR1cm4gYi5ub3JtYWxpemUoKX07XG5USFJFRS5DdWJpY0JlemllckN1cnZlPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMudjA9YTt0aGlzLnYxPWI7dGhpcy52Mj1jO3RoaXMudjM9ZH07VEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZS5wcm90b3R5cGUpO1RIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkN1YmljQmV6aWVyQ3VydmU7VEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQ9ZnVuY3Rpb24oYSl7dmFyIGI7Yj1USFJFRS5TaGFwZS5VdGlscy5iMyhhLHRoaXMudjAueCx0aGlzLnYxLngsdGhpcy52Mi54LHRoaXMudjMueCk7YT1USFJFRS5TaGFwZS5VdGlscy5iMyhhLHRoaXMudjAueSx0aGlzLnYxLnksdGhpcy52Mi55LHRoaXMudjMueSk7cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKGIsYSl9O1xuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudD1mdW5jdGlvbihhKXt2YXIgYjtiPVRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllcihhLHRoaXMudjAueCx0aGlzLnYxLngsdGhpcy52Mi54LHRoaXMudjMueCk7YT1USFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoYSx0aGlzLnYwLnksdGhpcy52MS55LHRoaXMudjIueSx0aGlzLnYzLnkpO2I9bmV3IFRIUkVFLlZlY3RvcjIoYixhKTtiLm5vcm1hbGl6ZSgpO3JldHVybiBifTtUSFJFRS5TcGxpbmVDdXJ2ZT1mdW5jdGlvbihhKXt0aGlzLnBvaW50cz12b2lkIDA9PWE/W106YX07VEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuQ3VydmUucHJvdG90eXBlKTtUSFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuU3BsaW5lQ3VydmU7XG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5wb2ludHM7YSo9Yi5sZW5ndGgtMTt2YXIgYz1NYXRoLmZsb29yKGEpO2EtPWM7dmFyIGQ9YlswPT1jP2M6Yy0xXSxlPWJbY10sZj1iW2M+Yi5sZW5ndGgtMj9iLmxlbmd0aC0xOmMrMV0sYj1iW2M+Yi5sZW5ndGgtMz9iLmxlbmd0aC0xOmMrMl0sYz1uZXcgVEhSRUUuVmVjdG9yMjtjLng9VEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoZC54LGUueCxmLngsYi54LGEpO2MueT1USFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZShkLnksZS55LGYueSxiLnksYSk7cmV0dXJuIGN9O1RIUkVFLkVsbGlwc2VDdXJ2ZT1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXt0aGlzLmFYPWE7dGhpcy5hWT1iO3RoaXMueFJhZGl1cz1jO3RoaXMueVJhZGl1cz1kO3RoaXMuYVN0YXJ0QW5nbGU9ZTt0aGlzLmFFbmRBbmdsZT1mO3RoaXMuYUNsb2Nrd2lzZT1nfTtcblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZS5wcm90b3R5cGUpO1RIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuRWxsaXBzZUN1cnZlO1RIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hRW5kQW5nbGUtdGhpcy5hU3RhcnRBbmdsZTswPmImJihiKz0yKk1hdGguUEkpO2I+MipNYXRoLlBJJiYoYi09MipNYXRoLlBJKTthPSEwPT09dGhpcy5hQ2xvY2t3aXNlP3RoaXMuYUVuZEFuZ2xlKygxLWEpKigyKk1hdGguUEktYik6dGhpcy5hU3RhcnRBbmdsZSthKmI7Yj1uZXcgVEhSRUUuVmVjdG9yMjtiLng9dGhpcy5hWCt0aGlzLnhSYWRpdXMqTWF0aC5jb3MoYSk7Yi55PXRoaXMuYVkrdGhpcy55UmFkaXVzKk1hdGguc2luKGEpO3JldHVybiBifTtcblRIUkVFLkFyY0N1cnZlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtUSFJFRS5FbGxpcHNlQ3VydmUuY2FsbCh0aGlzLGEsYixjLGMsZCxlLGYpfTtUSFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlKTtUSFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuQXJjQ3VydmU7VEhSRUUuTGluZUN1cnZlMz1USFJFRS5DdXJ2ZS5jcmVhdGUoZnVuY3Rpb24oYSxiKXt0aGlzLnYxPWE7dGhpcy52Mj1ifSxmdW5jdGlvbihhKXt2YXIgYj1uZXcgVEhSRUUuVmVjdG9yMztiLnN1YlZlY3RvcnModGhpcy52Mix0aGlzLnYxKTtiLm11bHRpcGx5U2NhbGFyKGEpO2IuYWRkKHRoaXMudjEpO3JldHVybiBifSk7XG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTM9VEhSRUUuQ3VydmUuY3JlYXRlKGZ1bmN0aW9uKGEsYixjKXt0aGlzLnYwPWE7dGhpcy52MT1iO3RoaXMudjI9Y30sZnVuY3Rpb24oYSl7dmFyIGI9bmV3IFRIUkVFLlZlY3RvcjM7Yi54PVRIUkVFLlNoYXBlLlV0aWxzLmIyKGEsdGhpcy52MC54LHRoaXMudjEueCx0aGlzLnYyLngpO2IueT1USFJFRS5TaGFwZS5VdGlscy5iMihhLHRoaXMudjAueSx0aGlzLnYxLnksdGhpcy52Mi55KTtiLno9VEhSRUUuU2hhcGUuVXRpbHMuYjIoYSx0aGlzLnYwLnosdGhpcy52MS56LHRoaXMudjIueik7cmV0dXJuIGJ9KTtcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUzPVRIUkVFLkN1cnZlLmNyZWF0ZShmdW5jdGlvbihhLGIsYyxkKXt0aGlzLnYwPWE7dGhpcy52MT1iO3RoaXMudjI9Yzt0aGlzLnYzPWR9LGZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBUSFJFRS5WZWN0b3IzO2IueD1USFJFRS5TaGFwZS5VdGlscy5iMyhhLHRoaXMudjAueCx0aGlzLnYxLngsdGhpcy52Mi54LHRoaXMudjMueCk7Yi55PVRIUkVFLlNoYXBlLlV0aWxzLmIzKGEsdGhpcy52MC55LHRoaXMudjEueSx0aGlzLnYyLnksdGhpcy52My55KTtiLno9VEhSRUUuU2hhcGUuVXRpbHMuYjMoYSx0aGlzLnYwLnosdGhpcy52MS56LHRoaXMudjIueix0aGlzLnYzLnopO3JldHVybiBifSk7XG5USFJFRS5TcGxpbmVDdXJ2ZTM9VEhSRUUuQ3VydmUuY3JlYXRlKGZ1bmN0aW9uKGEpe3RoaXMucG9pbnRzPXZvaWQgMD09YT9bXTphfSxmdW5jdGlvbihhKXt2YXIgYj10aGlzLnBvaW50czthKj1iLmxlbmd0aC0xO3ZhciBjPU1hdGguZmxvb3IoYSk7YS09Yzt2YXIgZD1iWzA9PWM/YzpjLTFdLGU9YltjXSxmPWJbYz5iLmxlbmd0aC0yP2IubGVuZ3RoLTE6YysxXSxiPWJbYz5iLmxlbmd0aC0zP2IubGVuZ3RoLTE6YysyXSxjPW5ldyBUSFJFRS5WZWN0b3IzO2MueD1USFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZShkLngsZS54LGYueCxiLngsYSk7Yy55PVRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKGQueSxlLnksZi55LGIueSxhKTtjLno9VEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoZC56LGUueixmLnosYi56LGEpO3JldHVybiBjfSk7XG5USFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTM9VEhSRUUuQ3VydmUuY3JlYXRlKGZ1bmN0aW9uKGEpe3RoaXMucG9pbnRzPXZvaWQgMD09YT9bXTphfSxmdW5jdGlvbihhKXt2YXIgYj10aGlzLnBvaW50czthKj1iLmxlbmd0aC0wO3ZhciBjPU1hdGguZmxvb3IoYSk7YS09Yzt2YXIgYz1jKygwPGM/MDooTWF0aC5mbG9vcihNYXRoLmFicyhjKS9iLmxlbmd0aCkrMSkqYi5sZW5ndGgpLGQ9YlsoYy0xKSViLmxlbmd0aF0sZT1iW2MlYi5sZW5ndGhdLGY9YlsoYysxKSViLmxlbmd0aF0sYj1iWyhjKzIpJWIubGVuZ3RoXSxjPW5ldyBUSFJFRS5WZWN0b3IzO2MueD1USFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZShkLngsZS54LGYueCxiLngsYSk7Yy55PVRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKGQueSxlLnksZi55LGIueSxhKTtjLno9VEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoZC56LGUueixmLnosYi56LGEpO3JldHVybiBjfSk7XG5USFJFRS5BbmltYXRpb25IYW5kbGVyPXtMSU5FQVI6MCxDQVRNVUxMUk9NOjEsQ0FUTVVMTFJPTV9GT1JXQVJEOjIsYWRkOmZ1bmN0aW9uKCl7VEhSRUUud2FybihcIlRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC5cIil9LGdldDpmdW5jdGlvbigpe1RIUkVFLndhcm4oXCJUSFJFRS5BbmltYXRpb25IYW5kbGVyLmdldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXCIpfSxyZW1vdmU6ZnVuY3Rpb24oKXtUSFJFRS53YXJuKFwiVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5yZW1vdmUoKSBoYXMgYmVlbiBkZXByZWNhdGVkLlwiKX0sYW5pbWF0aW9uczpbXSxpbml0OmZ1bmN0aW9uKGEpe2lmKCEwPT09YS5pbml0aWFsaXplZClyZXR1cm4gYTtmb3IodmFyIGI9MDtiPGEuaGllcmFyY2h5Lmxlbmd0aDtiKyspe2Zvcih2YXIgYz0wO2M8YS5oaWVyYXJjaHlbYl0ua2V5cy5sZW5ndGg7YysrKWlmKDA+YS5oaWVyYXJjaHlbYl0ua2V5c1tjXS50aW1lJiYoYS5oaWVyYXJjaHlbYl0ua2V5c1tjXS50aW1lPVxuICAgICAgICAwKSx2b2lkIDAhPT1hLmhpZXJhcmNoeVtiXS5rZXlzW2NdLnJvdCYmIShhLmhpZXJhcmNoeVtiXS5rZXlzW2NdLnJvdCBpbnN0YW5jZW9mIFRIUkVFLlF1YXRlcm5pb24pKXt2YXIgZD1hLmhpZXJhcmNoeVtiXS5rZXlzW2NdLnJvdDthLmhpZXJhcmNoeVtiXS5rZXlzW2NdLnJvdD0obmV3IFRIUkVFLlF1YXRlcm5pb24pLmZyb21BcnJheShkKX1pZihhLmhpZXJhcmNoeVtiXS5rZXlzLmxlbmd0aCYmdm9pZCAwIT09YS5oaWVyYXJjaHlbYl0ua2V5c1swXS5tb3JwaFRhcmdldHMpe2Q9e307Zm9yKGM9MDtjPGEuaGllcmFyY2h5W2JdLmtleXMubGVuZ3RoO2MrKylmb3IodmFyIGU9MDtlPGEuaGllcmFyY2h5W2JdLmtleXNbY10ubW9ycGhUYXJnZXRzLmxlbmd0aDtlKyspe3ZhciBmPWEuaGllcmFyY2h5W2JdLmtleXNbY10ubW9ycGhUYXJnZXRzW2VdO2RbZl09LTF9YS5oaWVyYXJjaHlbYl0udXNlZE1vcnBoVGFyZ2V0cz1kO2ZvcihjPTA7YzxhLmhpZXJhcmNoeVtiXS5rZXlzLmxlbmd0aDtjKyspe3ZhciBnPVxue307Zm9yKGYgaW4gZCl7Zm9yKGU9MDtlPGEuaGllcmFyY2h5W2JdLmtleXNbY10ubW9ycGhUYXJnZXRzLmxlbmd0aDtlKyspaWYoYS5oaWVyYXJjaHlbYl0ua2V5c1tjXS5tb3JwaFRhcmdldHNbZV09PT1mKXtnW2ZdPWEuaGllcmFyY2h5W2JdLmtleXNbY10ubW9ycGhUYXJnZXRzSW5mbHVlbmNlc1tlXTticmVha31lPT09YS5oaWVyYXJjaHlbYl0ua2V5c1tjXS5tb3JwaFRhcmdldHMubGVuZ3RoJiYoZ1tmXT0wKX1hLmhpZXJhcmNoeVtiXS5rZXlzW2NdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXM9Z319Zm9yKGM9MTtjPGEuaGllcmFyY2h5W2JdLmtleXMubGVuZ3RoO2MrKylhLmhpZXJhcmNoeVtiXS5rZXlzW2NdLnRpbWU9PT1hLmhpZXJhcmNoeVtiXS5rZXlzW2MtMV0udGltZSYmKGEuaGllcmFyY2h5W2JdLmtleXMuc3BsaWNlKGMsMSksYy0tKTtmb3IoYz0wO2M8YS5oaWVyYXJjaHlbYl0ua2V5cy5sZW5ndGg7YysrKWEuaGllcmFyY2h5W2JdLmtleXNbY10uaW5kZXg9Y31hLmluaXRpYWxpemVkPVxuICAgICEwO3JldHVybiBhfSxwYXJzZTpmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihhLGMpe2MucHVzaChhKTtmb3IodmFyIGQ9MDtkPGEuY2hpbGRyZW4ubGVuZ3RoO2QrKyliKGEuY2hpbGRyZW5bZF0sYyl9LGM9W107aWYoYSBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoKWZvcih2YXIgZD0wO2Q8YS5za2VsZXRvbi5ib25lcy5sZW5ndGg7ZCsrKWMucHVzaChhLnNrZWxldG9uLmJvbmVzW2RdKTtlbHNlIGIoYSxjKTtyZXR1cm4gY30scGxheTpmdW5jdGlvbihhKXstMT09PXRoaXMuYW5pbWF0aW9ucy5pbmRleE9mKGEpJiZ0aGlzLmFuaW1hdGlvbnMucHVzaChhKX0sc3RvcDpmdW5jdGlvbihhKXthPXRoaXMuYW5pbWF0aW9ucy5pbmRleE9mKGEpOy0xIT09YSYmdGhpcy5hbmltYXRpb25zLnNwbGljZShhLDEpfSx1cGRhdGU6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLmFuaW1hdGlvbnMubGVuZ3RoO2IrKyl0aGlzLmFuaW1hdGlvbnNbYl0ucmVzZXRCbGVuZFdlaWdodHMoKTtcbiAgICBmb3IoYj0wO2I8dGhpcy5hbmltYXRpb25zLmxlbmd0aDtiKyspdGhpcy5hbmltYXRpb25zW2JdLnVwZGF0ZShhKX19O1RIUkVFLkFuaW1hdGlvbj1mdW5jdGlvbihhLGIpe3RoaXMucm9vdD1hO3RoaXMuZGF0YT1USFJFRS5BbmltYXRpb25IYW5kbGVyLmluaXQoYik7dGhpcy5oaWVyYXJjaHk9VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wYXJzZShhKTt0aGlzLmN1cnJlbnRUaW1lPTA7dGhpcy50aW1lU2NhbGU9MTt0aGlzLmlzUGxheWluZz0hMTt0aGlzLmxvb3A9ITA7dGhpcy53ZWlnaHQ9MDt0aGlzLmludGVycG9sYXRpb25UeXBlPVRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSfTtcblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkFuaW1hdGlvbixrZXlUeXBlczpbXCJwb3NcIixcInJvdFwiLFwic2NsXCJdLHBsYXk6ZnVuY3Rpb24oYSxiKXt0aGlzLmN1cnJlbnRUaW1lPXZvaWQgMCE9PWE/YTowO3RoaXMud2VpZ2h0PXZvaWQgMCE9PWI/YjoxO3RoaXMuaXNQbGF5aW5nPSEwO3RoaXMucmVzZXQoKTtUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBsYXkodGhpcyl9LHN0b3A6ZnVuY3Rpb24oKXt0aGlzLmlzUGxheWluZz0hMTtUSFJFRS5BbmltYXRpb25IYW5kbGVyLnN0b3AodGhpcyl9LHJlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBhPTAsYj10aGlzLmhpZXJhcmNoeS5sZW5ndGg7YTxiO2ErKyl7dmFyIGM9dGhpcy5oaWVyYXJjaHlbYV07dm9pZCAwPT09Yy5hbmltYXRpb25DYWNoZSYmKGMuYW5pbWF0aW9uQ2FjaGU9e2FuaW1hdGlvbnM6e30sYmxlbmRpbmc6e3Bvc2l0aW9uV2VpZ2h0OjAscXVhdGVybmlvbldlaWdodDowLHNjYWxlV2VpZ2h0OjB9fSk7XG4gICAgdmFyIGQ9dGhpcy5kYXRhLm5hbWUsZT1jLmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnMsZj1lW2RdO3ZvaWQgMD09PWYmJihmPXtwcmV2S2V5Ontwb3M6MCxyb3Q6MCxzY2w6MH0sbmV4dEtleTp7cG9zOjAscm90OjAsc2NsOjB9LG9yaWdpbmFsTWF0cml4OmMubWF0cml4fSxlW2RdPWYpO2ZvcihjPTA7Mz5jO2MrKyl7Zm9yKHZhciBkPXRoaXMua2V5VHlwZXNbY10sZT10aGlzLmRhdGEuaGllcmFyY2h5W2FdLmtleXNbMF0sZz10aGlzLmdldE5leHRLZXlXaXRoKGQsYSwxKTtnLnRpbWU8dGhpcy5jdXJyZW50VGltZSYmZy5pbmRleD5lLmluZGV4OyllPWcsZz10aGlzLmdldE5leHRLZXlXaXRoKGQsYSxnLmluZGV4KzEpO2YucHJldktleVtkXT1lO2YubmV4dEtleVtkXT1nfX19LHJlc2V0QmxlbmRXZWlnaHRzOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPTAsYj10aGlzLmhpZXJhcmNoeS5sZW5ndGg7YTxiO2ErKyl7dmFyIGM9dGhpcy5oaWVyYXJjaHlbYV0uYW5pbWF0aW9uQ2FjaGU7dm9pZCAwIT09XG5jJiYoYz1jLmJsZW5kaW5nLGMucG9zaXRpb25XZWlnaHQ9MCxjLnF1YXRlcm5pb25XZWlnaHQ9MCxjLnNjYWxlV2VpZ2h0PTApfX0sdXBkYXRlOmZ1bmN0aW9uKCl7dmFyIGE9W10sYj1uZXcgVEhSRUUuVmVjdG9yMyxjPW5ldyBUSFJFRS5WZWN0b3IzLGQ9bmV3IFRIUkVFLlF1YXRlcm5pb24sZT1mdW5jdGlvbihhLGIpe3ZhciBjPVtdLGQ9W10sZSxxLG4sdCxyLHM7ZT0oYS5sZW5ndGgtMSkqYjtxPU1hdGguZmxvb3IoZSk7ZS09cTtjWzBdPTA9PT1xP3E6cS0xO2NbMV09cTtjWzJdPXE+YS5sZW5ndGgtMj9xOnErMTtjWzNdPXE+YS5sZW5ndGgtMz9xOnErMjtxPWFbY1swXV07dD1hW2NbMV1dO3I9YVtjWzJdXTtzPWFbY1szXV07Yz1lKmU7bj1lKmM7ZFswXT1mKHFbMF0sdFswXSxyWzBdLHNbMF0sZSxjLG4pO2RbMV09ZihxWzFdLHRbMV0sclsxXSxzWzFdLGUsYyxuKTtkWzJdPWYocVsyXSx0WzJdLHJbMl0sc1syXSxlLGMsbik7cmV0dXJuIGR9LGY9ZnVuY3Rpb24oYSxiLGMsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLGYsbil7YT0uNSooYy1hKTtkPS41KihkLWIpO3JldHVybigyKihiLWMpK2ErZCkqbisoLTMqKGItYyktMiphLWQpKmYrYSplK2J9O3JldHVybiBmdW5jdGlvbihmKXtpZighMSE9PXRoaXMuaXNQbGF5aW5nJiYodGhpcy5jdXJyZW50VGltZSs9Zip0aGlzLnRpbWVTY2FsZSwwIT09dGhpcy53ZWlnaHQpKXtmPXRoaXMuZGF0YS5sZW5ndGg7aWYodGhpcy5jdXJyZW50VGltZT5mfHwwPnRoaXMuY3VycmVudFRpbWUpdGhpcy5sb29wPyh0aGlzLmN1cnJlbnRUaW1lJT1mLDA+dGhpcy5jdXJyZW50VGltZSYmKHRoaXMuY3VycmVudFRpbWUrPWYpLHRoaXMucmVzZXQoKSk6dGhpcy5zdG9wKCk7Zj0wO2Zvcih2YXIgaD10aGlzLmhpZXJhcmNoeS5sZW5ndGg7ZjxoO2YrKylmb3IodmFyIGs9dGhpcy5oaWVyYXJjaHlbZl0sbD1rLmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnNbdGhpcy5kYXRhLm5hbWVdLHA9ay5hbmltYXRpb25DYWNoZS5ibGVuZGluZyxxPTA7Mz5xO3ErKyl7dmFyIG49dGhpcy5rZXlUeXBlc1txXSxcbiAgICB0PWwucHJldktleVtuXSxyPWwubmV4dEtleVtuXTtpZigwPHRoaXMudGltZVNjYWxlJiZyLnRpbWU8PXRoaXMuY3VycmVudFRpbWV8fDA+dGhpcy50aW1lU2NhbGUmJnQudGltZT49dGhpcy5jdXJyZW50VGltZSl7dD10aGlzLmRhdGEuaGllcmFyY2h5W2ZdLmtleXNbMF07Zm9yKHI9dGhpcy5nZXROZXh0S2V5V2l0aChuLGYsMSk7ci50aW1lPHRoaXMuY3VycmVudFRpbWUmJnIuaW5kZXg+dC5pbmRleDspdD1yLHI9dGhpcy5nZXROZXh0S2V5V2l0aChuLGYsci5pbmRleCsxKTtsLnByZXZLZXlbbl09dDtsLm5leHRLZXlbbl09cn12YXIgcz0odGhpcy5jdXJyZW50VGltZS10LnRpbWUpLyhyLnRpbWUtdC50aW1lKSx1PXRbbl0sdj1yW25dOzA+cyYmKHM9MCk7MTxzJiYocz0xKTtpZihcInBvc1wiPT09bilpZih0aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5MSU5FQVIpYy54PXVbMF0rKHZbMF0tdVswXSkqcyxjLnk9dVsxXSsodlsxXS11WzFdKSpzLFxuICAgIGMuej11WzJdKyh2WzJdLXVbMl0pKnMsdD10aGlzLndlaWdodC8odGhpcy53ZWlnaHQrcC5wb3NpdGlvbldlaWdodCksay5wb3NpdGlvbi5sZXJwKGMsdCkscC5wb3NpdGlvbldlaWdodCs9dGhpcy53ZWlnaHQ7ZWxzZXtpZih0aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NfHx0aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQpYVswXT10aGlzLmdldFByZXZLZXlXaXRoKFwicG9zXCIsZix0LmluZGV4LTEpLnBvcyxhWzFdPXUsYVsyXT12LGFbM109dGhpcy5nZXROZXh0S2V5V2l0aChcInBvc1wiLGYsci5pbmRleCsxKS5wb3Mscz0uMzMqcysuMzMscj1lKGEscyksdD10aGlzLndlaWdodC8odGhpcy53ZWlnaHQrcC5wb3NpdGlvbldlaWdodCkscC5wb3NpdGlvbldlaWdodCs9dGhpcy53ZWlnaHQsbj1rLnBvc2l0aW9uLG4ueCs9KHJbMF0tbi54KSp0LG4ueSs9KHJbMV0tXG4gICAgbi55KSp0LG4ueis9KHJbMl0tbi56KSp0LHRoaXMuaW50ZXJwb2xhdGlvblR5cGU9PT1USFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCYmKHM9ZShhLDEuMDEqcyksYi5zZXQoc1swXSxzWzFdLHNbMl0pLGIuc3ViKG4pLGIueT0wLGIubm9ybWFsaXplKCkscz1NYXRoLmF0YW4yKGIueCxiLnopLGsucm90YXRpb24uc2V0KDAscywwKSl9ZWxzZVwicm90XCI9PT1uPyhUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwKHUsdixkLHMpLDA9PT1wLnF1YXRlcm5pb25XZWlnaHQ/KGsucXVhdGVybmlvbi5jb3B5KGQpLHAucXVhdGVybmlvbldlaWdodD10aGlzLndlaWdodCk6KHQ9dGhpcy53ZWlnaHQvKHRoaXMud2VpZ2h0K3AucXVhdGVybmlvbldlaWdodCksVEhSRUUuUXVhdGVybmlvbi5zbGVycChrLnF1YXRlcm5pb24sZCxrLnF1YXRlcm5pb24sdCkscC5xdWF0ZXJuaW9uV2VpZ2h0Kz10aGlzLndlaWdodCkpOlwic2NsXCI9PT1uJiYoYy54PXVbMF0rKHZbMF0tdVswXSkqcyxjLnk9XG4gICAgdVsxXSsodlsxXS11WzFdKSpzLGMuej11WzJdKyh2WzJdLXVbMl0pKnMsdD10aGlzLndlaWdodC8odGhpcy53ZWlnaHQrcC5zY2FsZVdlaWdodCksay5zY2FsZS5sZXJwKGMsdCkscC5zY2FsZVdlaWdodCs9dGhpcy53ZWlnaHQpfXJldHVybiEwfX19KCksZ2V0TmV4dEtleVdpdGg6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZGF0YS5oaWVyYXJjaHlbYl0ua2V5cztmb3IoYz10aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NfHx0aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQ/YzxkLmxlbmd0aC0xP2M6ZC5sZW5ndGgtMTpjJWQubGVuZ3RoO2M8ZC5sZW5ndGg7YysrKWlmKHZvaWQgMCE9PWRbY11bYV0pcmV0dXJuIGRbY107cmV0dXJuIHRoaXMuZGF0YS5oaWVyYXJjaHlbYl0ua2V5c1swXX0sZ2V0UHJldktleVdpdGg6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVxuICAgIHRoaXMuZGF0YS5oaWVyYXJjaHlbYl0ua2V5cztmb3IoYz10aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NfHx0aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQ/MDxjP2M6MDowPD1jP2M6YytkLmxlbmd0aDswPD1jO2MtLSlpZih2b2lkIDAhPT1kW2NdW2FdKXJldHVybiBkW2NdO3JldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5W2JdLmtleXNbZC5sZW5ndGgtMV19fTtcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uPWZ1bmN0aW9uKGEpe3RoaXMucm9vdD1hLm5vZGU7dGhpcy5kYXRhPVRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuaW5pdChhKTt0aGlzLmhpZXJhcmNoeT1USFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKHRoaXMucm9vdCk7dGhpcy5jdXJyZW50VGltZT0wO3RoaXMudGltZVNjYWxlPS4wMDE7dGhpcy5pc1BsYXlpbmc9ITE7dGhpcy5sb29wPXRoaXMuaXNQYXVzZWQ9ITA7YT0wO2Zvcih2YXIgYj10aGlzLmhpZXJhcmNoeS5sZW5ndGg7YTxiO2ErKyl7dmFyIGM9dGhpcy5kYXRhLmhpZXJhcmNoeVthXS5zaWRzLGQ9dGhpcy5oaWVyYXJjaHlbYV07aWYodGhpcy5kYXRhLmhpZXJhcmNoeVthXS5rZXlzLmxlbmd0aCYmYyl7Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV0sZz10aGlzLmdldE5leHRLZXlXaXRoKGYsYSwwKTtnJiZnLmFwcGx5KGYpfWQubWF0cml4QXV0b1VwZGF0ZT0hMTt0aGlzLmRhdGEuaGllcmFyY2h5W2FdLm5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgZC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwfX19O1xuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5LZXlGcmFtZUFuaW1hdGlvbixwbGF5OmZ1bmN0aW9uKGEpe3RoaXMuY3VycmVudFRpbWU9dm9pZCAwIT09YT9hOjA7aWYoITE9PT10aGlzLmlzUGxheWluZyl7dGhpcy5pc1BsYXlpbmc9ITA7dmFyIGI9dGhpcy5oaWVyYXJjaHkubGVuZ3RoLGMsZDtmb3IoYT0wO2E8YjthKyspYz10aGlzLmhpZXJhcmNoeVthXSxkPXRoaXMuZGF0YS5oaWVyYXJjaHlbYV0sdm9pZCAwPT09ZC5hbmltYXRpb25DYWNoZSYmKGQuYW5pbWF0aW9uQ2FjaGU9e30sZC5hbmltYXRpb25DYWNoZS5wcmV2S2V5PW51bGwsZC5hbmltYXRpb25DYWNoZS5uZXh0S2V5PW51bGwsZC5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeD1jLm1hdHJpeCksYz10aGlzLmRhdGEuaGllcmFyY2h5W2FdLmtleXMsYy5sZW5ndGgmJihkLmFuaW1hdGlvbkNhY2hlLnByZXZLZXk9Y1swXSxkLmFuaW1hdGlvbkNhY2hlLm5leHRLZXk9XG4gICAgY1sxXSx0aGlzLnN0YXJ0VGltZT1NYXRoLm1pbihjWzBdLnRpbWUsdGhpcy5zdGFydFRpbWUpLHRoaXMuZW5kVGltZT1NYXRoLm1heChjW2MubGVuZ3RoLTFdLnRpbWUsdGhpcy5lbmRUaW1lKSk7dGhpcy51cGRhdGUoMCl9dGhpcy5pc1BhdXNlZD0hMTtUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBsYXkodGhpcyl9LHN0b3A6ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPXRoaXMuaXNQbGF5aW5nPSExO1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCh0aGlzKTtmb3IodmFyIGE9MDthPHRoaXMuZGF0YS5oaWVyYXJjaHkubGVuZ3RoO2ErKyl7dmFyIGI9dGhpcy5oaWVyYXJjaHlbYV0sYz10aGlzLmRhdGEuaGllcmFyY2h5W2FdO2lmKHZvaWQgMCE9PWMuYW5pbWF0aW9uQ2FjaGUpe3ZhciBkPWMuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg7ZC5jb3B5KGIubWF0cml4KTtiLm1hdHJpeD1kO2RlbGV0ZSBjLmFuaW1hdGlvbkNhY2hlfX19LHVwZGF0ZTpmdW5jdGlvbihhKXtpZighMSE9PVxuICAgIHRoaXMuaXNQbGF5aW5nKXt0aGlzLmN1cnJlbnRUaW1lKz1hKnRoaXMudGltZVNjYWxlO2E9dGhpcy5kYXRhLmxlbmd0aDshMD09PXRoaXMubG9vcCYmdGhpcy5jdXJyZW50VGltZT5hJiYodGhpcy5jdXJyZW50VGltZSU9YSk7dGhpcy5jdXJyZW50VGltZT1NYXRoLm1pbih0aGlzLmN1cnJlbnRUaW1lLGEpO2E9MDtmb3IodmFyIGI9dGhpcy5oaWVyYXJjaHkubGVuZ3RoO2E8YjthKyspe3ZhciBjPXRoaXMuaGllcmFyY2h5W2FdLGQ9dGhpcy5kYXRhLmhpZXJhcmNoeVthXSxlPWQua2V5cyxkPWQuYW5pbWF0aW9uQ2FjaGU7aWYoZS5sZW5ndGgpe3ZhciBmPWQucHJldktleSxnPWQubmV4dEtleTtpZihnLnRpbWU8PXRoaXMuY3VycmVudFRpbWUpe2Zvcig7Zy50aW1lPHRoaXMuY3VycmVudFRpbWUmJmcuaW5kZXg+Zi5pbmRleDspZj1nLGc9ZVtmLmluZGV4KzFdO2QucHJldktleT1mO2QubmV4dEtleT1nfWcudGltZT49dGhpcy5jdXJyZW50VGltZT9mLmludGVycG9sYXRlKGcsdGhpcy5jdXJyZW50VGltZSk6XG4gICAgZi5pbnRlcnBvbGF0ZShnLGcudGltZSk7dGhpcy5kYXRhLmhpZXJhcmNoeVthXS5ub2RlLnVwZGF0ZU1hdHJpeCgpO2MubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH19fX0sZ2V0TmV4dEtleVdpdGg6ZnVuY3Rpb24oYSxiLGMpe2I9dGhpcy5kYXRhLmhpZXJhcmNoeVtiXS5rZXlzO2ZvcihjJT1iLmxlbmd0aDtjPGIubGVuZ3RoO2MrKylpZihiW2NdLmhhc1RhcmdldChhKSlyZXR1cm4gYltjXTtyZXR1cm4gYlswXX0sZ2V0UHJldktleVdpdGg6ZnVuY3Rpb24oYSxiLGMpe2I9dGhpcy5kYXRhLmhpZXJhcmNoeVtiXS5rZXlzO2ZvcihjPTA8PWM/YzpjK2IubGVuZ3RoOzA8PWM7Yy0tKWlmKGJbY10uaGFzVGFyZ2V0KGEpKXJldHVybiBiW2NdO3JldHVybiBiW2IubGVuZ3RoLTFdfX07XG5USFJFRS5Nb3JwaEFuaW1hdGlvbj1mdW5jdGlvbihhKXt0aGlzLm1lc2g9YTt0aGlzLmZyYW1lcz1hLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7dGhpcy5jdXJyZW50VGltZT0wO3RoaXMuZHVyYXRpb249MUUzO3RoaXMubG9vcD0hMDt0aGlzLmN1cnJlbnRGcmFtZT10aGlzLmxhc3RGcmFtZT0wO3RoaXMuaXNQbGF5aW5nPSExfTtcblRIUkVFLk1vcnBoQW5pbWF0aW9uLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuTW9ycGhBbmltYXRpb24scGxheTpmdW5jdGlvbigpe3RoaXMuaXNQbGF5aW5nPSEwfSxwYXVzZTpmdW5jdGlvbigpe3RoaXMuaXNQbGF5aW5nPSExfSx1cGRhdGU6ZnVuY3Rpb24oYSl7aWYoITEhPT10aGlzLmlzUGxheWluZyl7dGhpcy5jdXJyZW50VGltZSs9YTshMD09PXRoaXMubG9vcCYmdGhpcy5jdXJyZW50VGltZT50aGlzLmR1cmF0aW9uJiYodGhpcy5jdXJyZW50VGltZSU9dGhpcy5kdXJhdGlvbik7dGhpcy5jdXJyZW50VGltZT1NYXRoLm1pbih0aGlzLmN1cnJlbnRUaW1lLHRoaXMuZHVyYXRpb24pO2E9dGhpcy5kdXJhdGlvbi90aGlzLmZyYW1lczt2YXIgYj1NYXRoLmZsb29yKHRoaXMuY3VycmVudFRpbWUvYSksYz10aGlzLm1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzO2IhPXRoaXMuY3VycmVudEZyYW1lJiYoY1t0aGlzLmxhc3RGcmFtZV09MCxjW3RoaXMuY3VycmVudEZyYW1lXT1cbiAgICAxLGNbYl09MCx0aGlzLmxhc3RGcmFtZT10aGlzLmN1cnJlbnRGcmFtZSx0aGlzLmN1cnJlbnRGcmFtZT1iKTtjW2JdPXRoaXMuY3VycmVudFRpbWUlYS9hO2NbdGhpcy5sYXN0RnJhbWVdPTEtY1tiXX19fTtcblRIUkVFLkJveEdlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtmdW5jdGlvbiBnKGEsYixjLGQsZSxmLGcscyl7dmFyIHUsdj1oLndpZHRoU2VnbWVudHMseD1oLmhlaWdodFNlZ21lbnRzLEQ9ZS8yLHc9Zi8yLHk9aC52ZXJ0aWNlcy5sZW5ndGg7aWYoXCJ4XCI9PT1hJiZcInlcIj09PWJ8fFwieVwiPT09YSYmXCJ4XCI9PT1iKXU9XCJ6XCI7ZWxzZSBpZihcInhcIj09PWEmJlwielwiPT09Ynx8XCJ6XCI9PT1hJiZcInhcIj09PWIpdT1cInlcIix4PWguZGVwdGhTZWdtZW50cztlbHNlIGlmKFwielwiPT09YSYmXCJ5XCI9PT1ifHxcInlcIj09PWEmJlwielwiPT09Yil1PVwieFwiLHY9aC5kZXB0aFNlZ21lbnRzO3ZhciBBPXYrMSxFPXgrMSxHPWUvdixGPWYveCx6PW5ldyBUSFJFRS5WZWN0b3IzO3pbdV09MDxnPzE6LTE7Zm9yKGU9MDtlPEU7ZSsrKWZvcihmPTA7ZjxBO2YrKyl7dmFyIEk9bmV3IFRIUkVFLlZlY3RvcjM7SVthXT0oZipHLUQpKmM7SVtiXT0oZSpGLXcpKmQ7SVt1XT1nO2gudmVydGljZXMucHVzaChJKX1mb3IoZT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7ZTx4O2UrKylmb3IoZj0wO2Y8djtmKyspdz1mK0EqZSxhPWYrQSooZSsxKSxiPWYrMStBKihlKzEpLGM9ZisxK0EqZSxkPW5ldyBUSFJFRS5WZWN0b3IyKGYvdiwxLWUveCksZz1uZXcgVEhSRUUuVmVjdG9yMihmL3YsMS0oZSsxKS94KSx1PW5ldyBUSFJFRS5WZWN0b3IyKChmKzEpL3YsMS0oZSsxKS94KSxEPW5ldyBUSFJFRS5WZWN0b3IyKChmKzEpL3YsMS1lL3gpLHc9bmV3IFRIUkVFLkZhY2UzKHcreSxhK3ksYyt5KSx3Lm5vcm1hbC5jb3B5KHopLHcudmVydGV4Tm9ybWFscy5wdXNoKHouY2xvbmUoKSx6LmNsb25lKCksei5jbG9uZSgpKSx3Lm1hdGVyaWFsSW5kZXg9cyxoLmZhY2VzLnB1c2godyksaC5mYWNlVmVydGV4VXZzWzBdLnB1c2goW2QsZyxEXSksdz1uZXcgVEhSRUUuRmFjZTMoYSt5LGIreSxjK3kpLHcubm9ybWFsLmNvcHkoeiksdy52ZXJ0ZXhOb3JtYWxzLnB1c2goei5jbG9uZSgpLHouY2xvbmUoKSx6LmNsb25lKCkpLHcubWF0ZXJpYWxJbmRleD1zLGguZmFjZXMucHVzaCh3KSxcbiAgICBoLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbZy5jbG9uZSgpLHUsRC5jbG9uZSgpXSl9VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJCb3hHZW9tZXRyeVwiO3RoaXMucGFyYW1ldGVycz17d2lkdGg6YSxoZWlnaHQ6YixkZXB0aDpjLHdpZHRoU2VnbWVudHM6ZCxoZWlnaHRTZWdtZW50czplLGRlcHRoU2VnbWVudHM6Zn07dGhpcy53aWR0aFNlZ21lbnRzPWR8fDE7dGhpcy5oZWlnaHRTZWdtZW50cz1lfHwxO3RoaXMuZGVwdGhTZWdtZW50cz1mfHwxO3ZhciBoPXRoaXM7ZD1hLzI7ZT1iLzI7Zj1jLzI7ZyhcInpcIixcInlcIiwtMSwtMSxjLGIsZCwwKTtnKFwielwiLFwieVwiLDEsLTEsYyxiLC1kLDEpO2coXCJ4XCIsXCJ6XCIsMSwxLGEsYyxlLDIpO2coXCJ4XCIsXCJ6XCIsMSwtMSxhLGMsLWUsMyk7ZyhcInhcIixcInlcIiwxLC0xLGEsYixmLDQpO2coXCJ4XCIsXCJ5XCIsLTEsLTEsYSxiLC1mLDUpO3RoaXMubWVyZ2VWZXJ0aWNlcygpfTtUSFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1xuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkJveEdlb21ldHJ5O1xuVEhSRUUuQ2lyY2xlR2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMsZCl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJDaXJjbGVHZW9tZXRyeVwiO3RoaXMucGFyYW1ldGVycz17cmFkaXVzOmEsc2VnbWVudHM6Yix0aGV0YVN0YXJ0OmMsdGhldGFMZW5ndGg6ZH07YT1hfHw1MDtiPXZvaWQgMCE9PWI/TWF0aC5tYXgoMyxiKTo4O2M9dm9pZCAwIT09Yz9jOjA7ZD12b2lkIDAhPT1kP2Q6MipNYXRoLlBJO3ZhciBlLGY9W107ZT1uZXcgVEhSRUUuVmVjdG9yMzt2YXIgZz1uZXcgVEhSRUUuVmVjdG9yMiguNSwuNSk7dGhpcy52ZXJ0aWNlcy5wdXNoKGUpO2YucHVzaChnKTtmb3IoZT0wO2U8PWI7ZSsrKXt2YXIgaD1uZXcgVEhSRUUuVmVjdG9yMyxrPWMrZS9iKmQ7aC54PWEqTWF0aC5jb3Moayk7aC55PWEqTWF0aC5zaW4oayk7dGhpcy52ZXJ0aWNlcy5wdXNoKGgpO2YucHVzaChuZXcgVEhSRUUuVmVjdG9yMigoaC54L2ErMSkvMiwoaC55L2ErMSkvMikpfWM9bmV3IFRIUkVFLlZlY3RvcjMoMCxcbiAgICAwLDEpO2ZvcihlPTE7ZTw9YjtlKyspdGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhlLGUrMSwwLFtjLmNsb25lKCksYy5jbG9uZSgpLGMuY2xvbmUoKV0pKSx0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbZltlXS5jbG9uZSgpLGZbZSsxXS5jbG9uZSgpLGcuY2xvbmUoKV0pO3RoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7dGhpcy5ib3VuZGluZ1NwaGVyZT1uZXcgVEhSRUUuU3BoZXJlKG5ldyBUSFJFRS5WZWN0b3IzLGEpfTtUSFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5DaXJjbGVHZW9tZXRyeTtcblRIUkVFLkN1YmVHZW9tZXRyeT1mdW5jdGlvbihhLGIsYyxkLGUsZil7VEhSRUUud2FybihcIlRIUkVFLkN1YmVHZW9tZXRyeSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkJveEdlb21ldHJ5LlwiKTtyZXR1cm4gbmV3IFRIUkVFLkJveEdlb21ldHJ5KGEsYixjLGQsZSxmKX07XG5USFJFRS5DeWxpbmRlckdlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJDeWxpbmRlckdlb21ldHJ5XCI7dGhpcy5wYXJhbWV0ZXJzPXtyYWRpdXNUb3A6YSxyYWRpdXNCb3R0b206YixoZWlnaHQ6YyxyYWRpYWxTZWdtZW50czpkLGhlaWdodFNlZ21lbnRzOmUsb3BlbkVuZGVkOmYsdGhldGFTdGFydDpnLHRoZXRhTGVuZ3RoOmh9O2E9dm9pZCAwIT09YT9hOjIwO2I9dm9pZCAwIT09Yj9iOjIwO2M9dm9pZCAwIT09Yz9jOjEwMDtkPWR8fDg7ZT1lfHwxO2Y9dm9pZCAwIT09Zj9mOiExO2c9dm9pZCAwIT09Zz9nOjA7aD12b2lkIDAhPT1oP2g6MipNYXRoLlBJO3ZhciBrPWMvMixsLHAscT1bXSxuPVtdO2ZvcihwPTA7cDw9ZTtwKyspe3ZhciB0PVtdLHI9W10scz1wL2UsdT1zKihiLWEpK2E7Zm9yKGw9MDtsPD1kO2wrKyl7dmFyIHY9bC9kLHg9bmV3IFRIUkVFLlZlY3RvcjM7eC54PXUqTWF0aC5zaW4odipoK1xuICAgICAgICBnKTt4Lnk9LXMqYytrO3guej11Kk1hdGguY29zKHYqaCtnKTt0aGlzLnZlcnRpY2VzLnB1c2goeCk7dC5wdXNoKHRoaXMudmVydGljZXMubGVuZ3RoLTEpO3IucHVzaChuZXcgVEhSRUUuVmVjdG9yMih2LDEtcykpfXEucHVzaCh0KTtuLnB1c2gocil9Yz0oYi1hKS9jO2ZvcihsPTA7bDxkO2wrKylmb3IoMCE9PWE/KGc9dGhpcy52ZXJ0aWNlc1txWzBdW2xdXS5jbG9uZSgpLGg9dGhpcy52ZXJ0aWNlc1txWzBdW2wrMV1dLmNsb25lKCkpOihnPXRoaXMudmVydGljZXNbcVsxXVtsXV0uY2xvbmUoKSxoPXRoaXMudmVydGljZXNbcVsxXVtsKzFdXS5jbG9uZSgpKSxnLnNldFkoTWF0aC5zcXJ0KGcueCpnLngrZy56KmcueikqYykubm9ybWFsaXplKCksaC5zZXRZKE1hdGguc3FydChoLngqaC54K2gueipoLnopKmMpLm5vcm1hbGl6ZSgpLHA9MDtwPGU7cCsrKXt2YXIgdD1xW3BdW2xdLHI9cVtwKzFdW2xdLHM9cVtwKzFdW2wrMV0sdT1xW3BdW2wrMV0sdj1nLmNsb25lKCkseD1nLmNsb25lKCksXG4gICAgRD1oLmNsb25lKCksdz1oLmNsb25lKCkseT1uW3BdW2xdLmNsb25lKCksQT1uW3ArMV1bbF0uY2xvbmUoKSxFPW5bcCsxXVtsKzFdLmNsb25lKCksRz1uW3BdW2wrMV0uY2xvbmUoKTt0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKHQscix1LFt2LHgsd10pKTt0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbeSxBLEddKTt0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKHIscyx1LFt4LmNsb25lKCksRCx3LmNsb25lKCldKSk7dGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW0EuY2xvbmUoKSxFLEcuY2xvbmUoKV0pfWlmKCExPT09ZiYmMDxhKWZvcih0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCxrLDApKSxsPTA7bDxkO2wrKyl0PXFbMF1bbF0scj1xWzBdW2wrMV0scz10aGlzLnZlcnRpY2VzLmxlbmd0aC0xLHY9bmV3IFRIUkVFLlZlY3RvcjMoMCwxLDApLHg9bmV3IFRIUkVFLlZlY3RvcjMoMCwxLDApLEQ9bmV3IFRIUkVFLlZlY3RvcjMoMCxcbiAgICAxLDApLHk9blswXVtsXS5jbG9uZSgpLEE9blswXVtsKzFdLmNsb25lKCksRT1uZXcgVEhSRUUuVmVjdG9yMihBLngsMCksdGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyh0LHIscyxbdix4LERdKSksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW3ksQSxFXSk7aWYoITE9PT1mJiYwPGIpZm9yKHRoaXMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLC1rLDApKSxsPTA7bDxkO2wrKyl0PXFbZV1bbCsxXSxyPXFbZV1bbF0scz10aGlzLnZlcnRpY2VzLmxlbmd0aC0xLHY9bmV3IFRIUkVFLlZlY3RvcjMoMCwtMSwwKSx4PW5ldyBUSFJFRS5WZWN0b3IzKDAsLTEsMCksRD1uZXcgVEhSRUUuVmVjdG9yMygwLC0xLDApLHk9bltlXVtsKzFdLmNsb25lKCksQT1uW2VdW2xdLmNsb25lKCksRT1uZXcgVEhSRUUuVmVjdG9yMihBLngsMSksdGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyh0LHIscyxbdix4LERdKSksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW3ksXG4gICAgQSxFXSk7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKX07VEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkN5bGluZGVyR2VvbWV0cnk7VEhSRUUuRXh0cnVkZUdlb21ldHJ5PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiYoVEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKSx0aGlzLnR5cGU9XCJFeHRydWRlR2VvbWV0cnlcIixhPWEgaW5zdGFuY2VvZiBBcnJheT9hOlthXSx0aGlzLmFkZFNoYXBlTGlzdChhLGIpLHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCkpfTtUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTtcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9MDtkPGM7ZCsrKXRoaXMuYWRkU2hhcGUoYVtkXSxiKX07XG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsYyl7Ynx8VEhSRUUuZXJyb3IoXCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdFwiKTtyZXR1cm4gYi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGMpLmFkZChhKX1mdW5jdGlvbiBkKGEsYixjKXt2YXIgZD0xLGQ9YS54LWIueCxlPWEueS1iLnksZj1jLngtYS54LGc9Yy55LWEueSxoPWQqZCtlKmU7aWYoMUUtMTA8TWF0aC5hYnMoZCpnLWUqZikpe3ZhciBrPU1hdGguc3FydChoKSxsPU1hdGguc3FydChmKmYrZypnKSxoPWIueC1lL2s7Yj1iLnkrZC9rO2Y9KChjLngtZy9sLWgpKmctKGMueStmL2wtYikqZikvKGQqZy1lKmYpO2M9aCtkKmYtYS54O2E9YitlKmYtYS55O2Q9YypjK2EqYTtpZigyPj1kKXJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihjLGEpO2Q9TWF0aC5zcXJ0KGQvMil9ZWxzZSBhPSExLDFFLTEwPGQ/MUUtMTA8ZiYmKGE9ITApOlxuICAgIC0xRS0xMD5kPy0xRS0xMD5mJiYoYT0hMCk6TWF0aC5zaWduKGUpPT1NYXRoLnNpZ24oZykmJihhPSEwKSxhPyhjPS1lLGE9ZCxkPU1hdGguc3FydChoKSk6KGM9ZCxhPWUsZD1NYXRoLnNxcnQoaC8yKSk7cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKGMvZCxhL2QpfWZ1bmN0aW9uIGUoYSxiKXt2YXIgYyxkO2ZvcihPPWEubGVuZ3RoOzA8PS0tTzspe2M9TztkPU8tMTswPmQmJihkPWEubGVuZ3RoLTEpO2Zvcih2YXIgZT0wLGY9dCsyKnAsZT0wO2U8ZjtlKyspe3ZhciBnPW9hKmUsaD1vYSooZSsxKSxrPWIrYytnLGc9YitkK2csbD1iK2QraCxoPWIrYytoLGs9aytVLGc9ZytVLGw9bCtVLGg9aCtVO0kuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoayxnLGgsbnVsbCxudWxsLHgpKTtJLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGcsbCxoLG51bGwsbnVsbCx4KSk7az1ELmdlbmVyYXRlU2lkZVdhbGxVVihJLGssZyxsLGgpO0kuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtrWzBdLFxuICAgIGtbMV0sa1szXV0pO0kuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtrWzFdLGtbMl0sa1szXV0pfX19ZnVuY3Rpb24gZihhLGIsYyl7SS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGEsYixjKSl9ZnVuY3Rpb24gZyhhLGIsYyl7YSs9VTtiKz1VO2MrPVU7SS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhhLGIsYyxudWxsLG51bGwsdikpO2E9RC5nZW5lcmF0ZVRvcFVWKEksYSxiLGMpO0kuZmFjZVZlcnRleFV2c1swXS5wdXNoKGEpfXZhciBoPXZvaWQgMCE9PWIuYW1vdW50P2IuYW1vdW50OjEwMCxrPXZvaWQgMCE9PWIuYmV2ZWxUaGlja25lc3M/Yi5iZXZlbFRoaWNrbmVzczo2LGw9dm9pZCAwIT09Yi5iZXZlbFNpemU/Yi5iZXZlbFNpemU6ay0yLHA9dm9pZCAwIT09Yi5iZXZlbFNlZ21lbnRzP2IuYmV2ZWxTZWdtZW50czozLHE9dm9pZCAwIT09Yi5iZXZlbEVuYWJsZWQ/Yi5iZXZlbEVuYWJsZWQ6ITAsbj12b2lkIDAhPT1iLmN1cnZlU2VnbWVudHM/Yi5jdXJ2ZVNlZ21lbnRzOlxuICAgIDEyLHQ9dm9pZCAwIT09Yi5zdGVwcz9iLnN0ZXBzOjEscj1iLmV4dHJ1ZGVQYXRoLHMsdT0hMSx2PWIubWF0ZXJpYWwseD1iLmV4dHJ1ZGVNYXRlcmlhbCxEPXZvaWQgMCE9PWIuVVZHZW5lcmF0b3I/Yi5VVkdlbmVyYXRvcjpUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcix3LHksQSxFO3ImJihzPXIuZ2V0U3BhY2VkUG9pbnRzKHQpLHU9ITAscT0hMSx3PXZvaWQgMCE9PWIuZnJhbWVzP2IuZnJhbWVzOm5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKHIsdCwhMSkseT1uZXcgVEhSRUUuVmVjdG9yMyxBPW5ldyBUSFJFRS5WZWN0b3IzLEU9bmV3IFRIUkVFLlZlY3RvcjMpO3F8fChsPWs9cD0wKTt2YXIgRyxGLHosST10aGlzLFU9dGhpcy52ZXJ0aWNlcy5sZW5ndGgscj1hLmV4dHJhY3RQb2ludHMobiksbj1yLnNoYXBlLE09ci5ob2xlcztpZihyPSFUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZShuKSl7bj1uLnJldmVyc2UoKTtGPTA7Zm9yKHo9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0ubGVuZ3RoO0Y8ejtGKyspRz1NW0ZdLFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKEcpJiYoTVtGXT1HLnJldmVyc2UoKSk7cj0hMX12YXIgSD1USFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlKG4sTSksTD1uO0Y9MDtmb3Ioej1NLmxlbmd0aDtGPHo7RisrKUc9TVtGXSxuPW4uY29uY2F0KEcpO3ZhciBQLE4sUixWLEosb2E9bi5sZW5ndGgsamEsaGE9SC5sZW5ndGgscj1bXSxPPTA7Uj1MLmxlbmd0aDtQPVItMTtmb3IoTj1PKzE7TzxSO08rKyxQKyssTisrKVA9PT1SJiYoUD0wKSxOPT09UiYmKE49MCkscltPXT1kKExbT10sTFtQXSxMW05dKTt2YXIgY2E9W10sYmEscWE9ci5jb25jYXQoKTtGPTA7Zm9yKHo9TS5sZW5ndGg7Rjx6O0YrKyl7Rz1NW0ZdO2JhPVtdO089MDtSPUcubGVuZ3RoO1A9Ui0xO2ZvcihOPU8rMTtPPFI7TysrLFArKyxOKyspUD09PVImJihQPTApLE49PT1SJiYoTj0wKSxiYVtPXT1kKEdbT10sR1tQXSxHW05dKTtjYS5wdXNoKGJhKTtxYT1cbiAgICBxYS5jb25jYXQoYmEpfWZvcihQPTA7UDxwO1ArKyl7Uj1QL3A7Vj1rKigxLVIpO049bCpNYXRoLnNpbihSKk1hdGguUEkvMik7Tz0wO2ZvcihSPUwubGVuZ3RoO088UjtPKyspSj1jKExbT10scltPXSxOKSxmKEoueCxKLnksLVYpO0Y9MDtmb3Ioej1NLmxlbmd0aDtGPHo7RisrKWZvcihHPU1bRl0sYmE9Y2FbRl0sTz0wLFI9Ry5sZW5ndGg7TzxSO08rKylKPWMoR1tPXSxiYVtPXSxOKSxmKEoueCxKLnksLVYpfU49bDtmb3IoTz0wO088b2E7TysrKUo9cT9jKG5bT10scWFbT10sTik6bltPXSx1PyhBLmNvcHkody5ub3JtYWxzWzBdKS5tdWx0aXBseVNjYWxhcihKLngpLHkuY29weSh3LmJpbm9ybWFsc1swXSkubXVsdGlwbHlTY2FsYXIoSi55KSxFLmNvcHkoc1swXSkuYWRkKEEpLmFkZCh5KSxmKEUueCxFLnksRS56KSk6ZihKLngsSi55LDApO2ZvcihSPTE7Ujw9dDtSKyspZm9yKE89MDtPPG9hO08rKylKPXE/YyhuW09dLHFhW09dLE4pOm5bT10sdT8oQS5jb3B5KHcubm9ybWFsc1tSXSkubXVsdGlwbHlTY2FsYXIoSi54KSxcbiAgICB5LmNvcHkody5iaW5vcm1hbHNbUl0pLm11bHRpcGx5U2NhbGFyKEoueSksRS5jb3B5KHNbUl0pLmFkZChBKS5hZGQoeSksZihFLngsRS55LEUueikpOmYoSi54LEoueSxoL3QqUik7Zm9yKFA9cC0xOzA8PVA7UC0tKXtSPVAvcDtWPWsqKDEtUik7Tj1sKk1hdGguc2luKFIqTWF0aC5QSS8yKTtPPTA7Zm9yKFI9TC5sZW5ndGg7TzxSO08rKylKPWMoTFtPXSxyW09dLE4pLGYoSi54LEoueSxoK1YpO0Y9MDtmb3Ioej1NLmxlbmd0aDtGPHo7RisrKWZvcihHPU1bRl0sYmE9Y2FbRl0sTz0wLFI9Ry5sZW5ndGg7TzxSO08rKylKPWMoR1tPXSxiYVtPXSxOKSx1P2YoSi54LEoueStzW3QtMV0ueSxzW3QtMV0ueCtWKTpmKEoueCxKLnksaCtWKX0oZnVuY3Rpb24oKXtpZihxKXt2YXIgYTthPTAqb2E7Zm9yKE89MDtPPGhhO08rKylqYT1IW09dLGcoamFbMl0rYSxqYVsxXSthLGphWzBdK2EpO2E9dCsyKnA7YSo9b2E7Zm9yKE89MDtPPGhhO08rKylqYT1IW09dLGcoamFbMF0rYSxqYVsxXSthLGphWzJdK1xuICAgIGEpfWVsc2V7Zm9yKE89MDtPPGhhO08rKylqYT1IW09dLGcoamFbMl0samFbMV0samFbMF0pO2ZvcihPPTA7TzxoYTtPKyspamE9SFtPXSxnKGphWzBdK29hKnQsamFbMV0rb2EqdCxqYVsyXStvYSp0KX19KSgpOyhmdW5jdGlvbigpe3ZhciBhPTA7ZShMLGEpO2ErPUwubGVuZ3RoO0Y9MDtmb3Ioej1NLmxlbmd0aDtGPHo7RisrKUc9TVtGXSxlKEcsYSksYSs9Ry5sZW5ndGh9KSgpfTtcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yPXtnZW5lcmF0ZVRvcFVWOmZ1bmN0aW9uKGEsYixjLGQpe2E9YS52ZXJ0aWNlcztiPWFbYl07Yz1hW2NdO2Q9YVtkXTtyZXR1cm5bbmV3IFRIUkVFLlZlY3RvcjIoYi54LGIueSksbmV3IFRIUkVFLlZlY3RvcjIoYy54LGMueSksbmV3IFRIUkVFLlZlY3RvcjIoZC54LGQueSldfSxnZW5lcmF0ZVNpZGVXYWxsVVY6ZnVuY3Rpb24oYSxiLGMsZCxlKXthPWEudmVydGljZXM7Yj1hW2JdO2M9YVtjXTtkPWFbZF07ZT1hW2VdO3JldHVybi4wMT5NYXRoLmFicyhiLnktYy55KT9bbmV3IFRIUkVFLlZlY3RvcjIoYi54LDEtYi56KSxuZXcgVEhSRUUuVmVjdG9yMihjLngsMS1jLnopLG5ldyBUSFJFRS5WZWN0b3IyKGQueCwxLWQueiksbmV3IFRIUkVFLlZlY3RvcjIoZS54LDEtZS56KV06W25ldyBUSFJFRS5WZWN0b3IyKGIueSwxLWIueiksbmV3IFRIUkVFLlZlY3RvcjIoYy55LDEtYy56KSxuZXcgVEhSRUUuVmVjdG9yMihkLnksXG4gICAgMS1kLnopLG5ldyBUSFJFRS5WZWN0b3IyKGUueSwxLWUueildfX07VEhSRUUuU2hhcGVHZW9tZXRyeT1mdW5jdGlvbihhLGIpe1RIUkVFLkdlb21ldHJ5LmNhbGwodGhpcyk7dGhpcy50eXBlPVwiU2hhcGVHZW9tZXRyeVwiOyExPT09YSBpbnN0YW5jZW9mIEFycmF5JiYoYT1bYV0pO3RoaXMuYWRkU2hhcGVMaXN0KGEsYik7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKX07VEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlNoYXBlR2VvbWV0cnk7VEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTAsZD1hLmxlbmd0aDtjPGQ7YysrKXRoaXMuYWRkU2hhcGUoYVtjXSxiKTtyZXR1cm4gdGhpc307XG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZT1mdW5jdGlvbihhLGIpe3ZvaWQgMD09PWImJihiPXt9KTt2YXIgYz1iLm1hdGVyaWFsLGQ9dm9pZCAwPT09Yi5VVkdlbmVyYXRvcj9USFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjpiLlVWR2VuZXJhdG9yLGUsZixnLGg9dGhpcy52ZXJ0aWNlcy5sZW5ndGg7ZT1hLmV4dHJhY3RQb2ludHModm9pZCAwIT09Yi5jdXJ2ZVNlZ21lbnRzP2IuY3VydmVTZWdtZW50czoxMik7dmFyIGs9ZS5zaGFwZSxsPWUuaG9sZXM7aWYoIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKGspKWZvcihrPWsucmV2ZXJzZSgpLGU9MCxmPWwubGVuZ3RoO2U8ZjtlKyspZz1sW2VdLFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKGcpJiYobFtlXT1nLnJldmVyc2UoKSk7dmFyIHA9VEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZShrLGwpO2U9MDtmb3IoZj1sLmxlbmd0aDtlPGY7ZSsrKWc9bFtlXSxcbiAgICBrPWsuY29uY2F0KGcpO2w9ay5sZW5ndGg7Zj1wLmxlbmd0aDtmb3IoZT0wO2U8bDtlKyspZz1rW2VdLHRoaXMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhnLngsZy55LDApKTtmb3IoZT0wO2U8ZjtlKyspbD1wW2VdLGs9bFswXStoLGc9bFsxXStoLGw9bFsyXStoLHRoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoayxnLGwsbnVsbCxudWxsLGMpKSx0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChkLmdlbmVyYXRlVG9wVVYodGhpcyxrLGcsbCkpfTtcblRIUkVFLkxhdGhlR2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMsZCl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJMYXRoZUdlb21ldHJ5XCI7dGhpcy5wYXJhbWV0ZXJzPXtwb2ludHM6YSxzZWdtZW50czpiLHBoaVN0YXJ0OmMscGhpTGVuZ3RoOmR9O2I9Ynx8MTI7Yz1jfHwwO2Q9ZHx8MipNYXRoLlBJO2Zvcih2YXIgZT0xLyhhLmxlbmd0aC0xKSxmPTEvYixnPTAsaD1iO2c8PWg7ZysrKWZvcih2YXIgaz1jK2cqZipkLGw9TWF0aC5jb3MoaykscD1NYXRoLnNpbihrKSxrPTAscT1hLmxlbmd0aDtrPHE7aysrKXt2YXIgbj1hW2tdLHQ9bmV3IFRIUkVFLlZlY3RvcjM7dC54PWwqbi54LXAqbi55O3QueT1wKm4ueCtsKm4ueTt0Lno9bi56O3RoaXMudmVydGljZXMucHVzaCh0KX1jPWEubGVuZ3RoO2c9MDtmb3IoaD1iO2c8aDtnKyspZm9yKGs9MCxxPWEubGVuZ3RoLTE7azxxO2srKyl7Yj1wPWsrYypnO2Q9cCtjO3ZhciBsPXArMStjLHA9cCsxLG49ZypmLHQ9ayplLHI9XG4gICAgbitmLHM9dCtlO3RoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoYixkLHApKTt0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbbmV3IFRIUkVFLlZlY3RvcjIobix0KSxuZXcgVEhSRUUuVmVjdG9yMihyLHQpLG5ldyBUSFJFRS5WZWN0b3IyKG4scyldKTt0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGQsbCxwKSk7dGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW25ldyBUSFJFRS5WZWN0b3IyKHIsdCksbmV3IFRIUkVFLlZlY3RvcjIocixzKSxuZXcgVEhSRUUuVmVjdG9yMihuLHMpXSl9dGhpcy5tZXJnZVZlcnRpY2VzKCk7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTt0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCl9O1RIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5MYXRoZUdlb21ldHJ5O1xuVEhSRUUuUGxhbmVHZW9tZXRyeT1mdW5jdGlvbihhLGIsYyxkKXtjb25zb2xlLmluZm8oXCJUSFJFRS5QbGFuZUdlb21ldHJ5OiBDb25zaWRlciB1c2luZyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5IGZvciBsb3dlciBtZW1vcnkgZm9vdHByaW50LlwiKTtUSFJFRS5HZW9tZXRyeS5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIlBsYW5lR2VvbWV0cnlcIjt0aGlzLnBhcmFtZXRlcnM9e3dpZHRoOmEsaGVpZ2h0OmIsd2lkdGhTZWdtZW50czpjLGhlaWdodFNlZ21lbnRzOmR9O3RoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KGEsYixjLGQpKX07VEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlBsYW5lR2VvbWV0cnk7XG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQpe1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwodGhpcyk7dGhpcy50eXBlPVwiUGxhbmVCdWZmZXJHZW9tZXRyeVwiO3RoaXMucGFyYW1ldGVycz17d2lkdGg6YSxoZWlnaHQ6Yix3aWR0aFNlZ21lbnRzOmMsaGVpZ2h0U2VnbWVudHM6ZH07dmFyIGU9YS8yLGY9Yi8yO2M9Y3x8MTtkPWR8fDE7dmFyIGc9YysxLGg9ZCsxLGs9YS9jLGw9Yi9kO2I9bmV3IEZsb2F0MzJBcnJheShnKmgqMyk7YT1uZXcgRmxvYXQzMkFycmF5KGcqaCozKTtmb3IodmFyIHA9bmV3IEZsb2F0MzJBcnJheShnKmgqMikscT0wLG49MCx0PTA7dDxoO3QrKylmb3IodmFyIHI9dCpsLWYscz0wO3M8ZztzKyspYltxXT1zKmstZSxiW3ErMV09LXIsYVtxKzJdPTEscFtuXT1zL2MscFtuKzFdPTEtdC9kLHErPTMsbis9MjtxPTA7ZT1uZXcgKDY1NTM1PGIubGVuZ3RoLzM/VWludDMyQXJyYXk6VWludDE2QXJyYXkpKGMqZCo2KTtmb3IodD0wO3Q8ZDt0KyspZm9yKHM9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtzPGM7cysrKWY9cytnKih0KzEpLGg9cysxK2cqKHQrMSksaz1zKzErZyp0LGVbcV09cytnKnQsZVtxKzFdPWYsZVtxKzJdPWssZVtxKzNdPWYsZVtxKzRdPWgsZVtxKzVdPWsscSs9Njt0aGlzLmFkZEF0dHJpYnV0ZShcImluZGV4XCIsbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShlLDEpKTt0aGlzLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShiLDMpKTt0aGlzLmFkZEF0dHJpYnV0ZShcIm5vcm1hbFwiLG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoYSwzKSk7dGhpcy5hZGRBdHRyaWJ1dGUoXCJ1dlwiLG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUocCwyKSl9O1RIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5O1xuVEhSRUUuUmluZ0dlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtUSFJFRS5HZW9tZXRyeS5jYWxsKHRoaXMpO3RoaXMudHlwZT1cIlJpbmdHZW9tZXRyeVwiO3RoaXMucGFyYW1ldGVycz17aW5uZXJSYWRpdXM6YSxvdXRlclJhZGl1czpiLHRoZXRhU2VnbWVudHM6YyxwaGlTZWdtZW50czpkLHRoZXRhU3RhcnQ6ZSx0aGV0YUxlbmd0aDpmfTthPWF8fDA7Yj1ifHw1MDtlPXZvaWQgMCE9PWU/ZTowO2Y9dm9pZCAwIT09Zj9mOjIqTWF0aC5QSTtjPXZvaWQgMCE9PWM/TWF0aC5tYXgoMyxjKTo4O2Q9dm9pZCAwIT09ZD9NYXRoLm1heCgxLGQpOjg7dmFyIGcsaD1bXSxrPWEsbD0oYi1hKS9kO2ZvcihhPTA7YTxkKzE7YSsrKXtmb3IoZz0wO2c8YysxO2crKyl7dmFyIHA9bmV3IFRIUkVFLlZlY3RvcjMscT1lK2cvYypmO3AueD1rKk1hdGguY29zKHEpO3AueT1rKk1hdGguc2luKHEpO3RoaXMudmVydGljZXMucHVzaChwKTtoLnB1c2gobmV3IFRIUkVFLlZlY3RvcjIoKHAueC9iKzEpLzIsXG4gICAgKHAueS9iKzEpLzIpKX1rKz1sfWI9bmV3IFRIUkVFLlZlY3RvcjMoMCwwLDEpO2ZvcihhPTA7YTxkO2ErKylmb3IoZT1hKihjKzEpLGc9MDtnPGM7ZysrKWY9cT1nK2UsbD1xK2MrMSxwPXErYysyLHRoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoZixsLHAsW2IuY2xvbmUoKSxiLmNsb25lKCksYi5jbG9uZSgpXSkpLHRoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtoW2ZdLmNsb25lKCksaFtsXS5jbG9uZSgpLGhbcF0uY2xvbmUoKV0pLGY9cSxsPXErYysyLHA9cSsxLHRoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoZixsLHAsW2IuY2xvbmUoKSxiLmNsb25lKCksYi5jbG9uZSgpXSkpLHRoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtoW2ZdLmNsb25lKCksaFtsXS5jbG9uZSgpLGhbcF0uY2xvbmUoKV0pO3RoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7dGhpcy5ib3VuZGluZ1NwaGVyZT1uZXcgVEhSRUUuU3BoZXJlKG5ldyBUSFJFRS5WZWN0b3IzLGspfTtcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuUmluZ0dlb21ldHJ5O1xuVEhSRUUuU3BoZXJlR2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJTcGhlcmVHZW9tZXRyeVwiO3RoaXMucGFyYW1ldGVycz17cmFkaXVzOmEsd2lkdGhTZWdtZW50czpiLGhlaWdodFNlZ21lbnRzOmMscGhpU3RhcnQ6ZCxwaGlMZW5ndGg6ZSx0aGV0YVN0YXJ0OmYsdGhldGFMZW5ndGg6Z307YT1hfHw1MDtiPU1hdGgubWF4KDMsTWF0aC5mbG9vcihiKXx8OCk7Yz1NYXRoLm1heCgyLE1hdGguZmxvb3IoYyl8fDYpO2Q9dm9pZCAwIT09ZD9kOjA7ZT12b2lkIDAhPT1lP2U6MipNYXRoLlBJO2Y9dm9pZCAwIT09Zj9mOjA7Zz12b2lkIDAhPT1nP2c6TWF0aC5QSTt2YXIgaCxrLGw9W10scD1bXTtmb3Ioaz0wO2s8PWM7aysrKXt2YXIgcT1bXSxuPVtdO2ZvcihoPTA7aDw9YjtoKyspe3ZhciB0PWgvYixyPWsvYyxzPW5ldyBUSFJFRS5WZWN0b3IzO3MueD0tYSpNYXRoLmNvcyhkK3QqZSkqTWF0aC5zaW4oZityKmcpO1xuICAgIHMueT1hKk1hdGguY29zKGYrcipnKTtzLno9YSpNYXRoLnNpbihkK3QqZSkqTWF0aC5zaW4oZityKmcpO3RoaXMudmVydGljZXMucHVzaChzKTtxLnB1c2godGhpcy52ZXJ0aWNlcy5sZW5ndGgtMSk7bi5wdXNoKG5ldyBUSFJFRS5WZWN0b3IyKHQsMS1yKSl9bC5wdXNoKHEpO3AucHVzaChuKX1mb3Ioaz0wO2s8YztrKyspZm9yKGg9MDtoPGI7aCsrKXtkPWxba11baCsxXTtlPWxba11baF07Zj1sW2srMV1baF07Zz1sW2srMV1baCsxXTt2YXIgcT10aGlzLnZlcnRpY2VzW2RdLmNsb25lKCkubm9ybWFsaXplKCksbj10aGlzLnZlcnRpY2VzW2VdLmNsb25lKCkubm9ybWFsaXplKCksdD10aGlzLnZlcnRpY2VzW2ZdLmNsb25lKCkubm9ybWFsaXplKCkscj10aGlzLnZlcnRpY2VzW2ddLmNsb25lKCkubm9ybWFsaXplKCkscz1wW2tdW2grMV0uY2xvbmUoKSx1PXBba11baF0uY2xvbmUoKSx2PXBbaysxXVtoXS5jbG9uZSgpLHg9cFtrKzFdW2grMV0uY2xvbmUoKTtNYXRoLmFicyh0aGlzLnZlcnRpY2VzW2RdLnkpPT09XG5hPyhzLng9KHMueCt1LngpLzIsdGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhkLGYsZyxbcSx0LHJdKSksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW3Msdix4XSkpOk1hdGguYWJzKHRoaXMudmVydGljZXNbZl0ueSk9PT1hPyh2Lng9KHYueCt4LngpLzIsdGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhkLGUsZixbcSxuLHRdKSksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW3MsdSx2XSkpOih0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGQsZSxnLFtxLG4scl0pKSx0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbcyx1LHhdKSx0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGUsZixnLFtuLmNsb25lKCksdCxyLmNsb25lKCldKSksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW3UuY2xvbmUoKSx2LHguY2xvbmUoKV0pKX10aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO3RoaXMuYm91bmRpbmdTcGhlcmU9bmV3IFRIUkVFLlNwaGVyZShuZXcgVEhSRUUuVmVjdG9yMyxcbiAgICBhKX07VEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuU3BoZXJlR2VvbWV0cnk7VEhSRUUuVGV4dEdlb21ldHJ5PWZ1bmN0aW9uKGEsYil7Yj1ifHx7fTt2YXIgYz1USFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMoYSxiKTtiLmFtb3VudD12b2lkIDAhPT1iLmhlaWdodD9iLmhlaWdodDo1MDt2b2lkIDA9PT1iLmJldmVsVGhpY2tuZXNzJiYoYi5iZXZlbFRoaWNrbmVzcz0xMCk7dm9pZCAwPT09Yi5iZXZlbFNpemUmJihiLmJldmVsU2l6ZT04KTt2b2lkIDA9PT1iLmJldmVsRW5hYmxlZCYmKGIuYmV2ZWxFbmFibGVkPSExKTtUSFJFRS5FeHRydWRlR2VvbWV0cnkuY2FsbCh0aGlzLGMsYik7dGhpcy50eXBlPVwiVGV4dEdlb21ldHJ5XCJ9O1RIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlKTtcblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuVGV4dEdlb21ldHJ5O1xuVEhSRUUuVG9ydXNHZW9tZXRyeT1mdW5jdGlvbihhLGIsYyxkLGUpe1RIUkVFLkdlb21ldHJ5LmNhbGwodGhpcyk7dGhpcy50eXBlPVwiVG9ydXNHZW9tZXRyeVwiO3RoaXMucGFyYW1ldGVycz17cmFkaXVzOmEsdHViZTpiLHJhZGlhbFNlZ21lbnRzOmMsdHVidWxhclNlZ21lbnRzOmQsYXJjOmV9O2E9YXx8MTAwO2I9Ynx8NDA7Yz1jfHw4O2Q9ZHx8NjtlPWV8fDIqTWF0aC5QSTtmb3IodmFyIGY9bmV3IFRIUkVFLlZlY3RvcjMsZz1bXSxoPVtdLGs9MDtrPD1jO2srKylmb3IodmFyIGw9MDtsPD1kO2wrKyl7dmFyIHA9bC9kKmUscT1rL2MqTWF0aC5QSSoyO2YueD1hKk1hdGguY29zKHApO2YueT1hKk1hdGguc2luKHApO3ZhciBuPW5ldyBUSFJFRS5WZWN0b3IzO24ueD0oYStiKk1hdGguY29zKHEpKSpNYXRoLmNvcyhwKTtuLnk9KGErYipNYXRoLmNvcyhxKSkqTWF0aC5zaW4ocCk7bi56PWIqTWF0aC5zaW4ocSk7dGhpcy52ZXJ0aWNlcy5wdXNoKG4pO2cucHVzaChuZXcgVEhSRUUuVmVjdG9yMihsL1xuICAgIGQsay9jKSk7aC5wdXNoKG4uY2xvbmUoKS5zdWIoZikubm9ybWFsaXplKCkpfWZvcihrPTE7azw9YztrKyspZm9yKGw9MTtsPD1kO2wrKylhPShkKzEpKmsrbC0xLGI9KGQrMSkqKGstMSkrbC0xLGU9KGQrMSkqKGstMSkrbCxmPShkKzEpKmsrbCxwPW5ldyBUSFJFRS5GYWNlMyhhLGIsZixbaFthXS5jbG9uZSgpLGhbYl0uY2xvbmUoKSxoW2ZdLmNsb25lKCldKSx0aGlzLmZhY2VzLnB1c2gocCksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW2dbYV0uY2xvbmUoKSxnW2JdLmNsb25lKCksZ1tmXS5jbG9uZSgpXSkscD1uZXcgVEhSRUUuRmFjZTMoYixlLGYsW2hbYl0uY2xvbmUoKSxoW2VdLmNsb25lKCksaFtmXS5jbG9uZSgpXSksdGhpcy5mYWNlcy5wdXNoKHApLHRoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtnW2JdLmNsb25lKCksZ1tlXS5jbG9uZSgpLGdbZl0uY2xvbmUoKV0pO3RoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCl9O1xuVEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlRvcnVzR2VvbWV0cnk7XG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeT1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtmdW5jdGlvbiBoKGEsYixjLGQsZSl7dmFyIGY9TWF0aC5jb3MoYSksZz1NYXRoLnNpbihhKTthKj1iL2M7Yj1NYXRoLmNvcyhhKTtmKj1kKigyK2IpKi41O2c9ZCooMitiKSpnKi41O2Q9ZSpkKk1hdGguc2luKGEpKi41O3JldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhmLGcsZCl9VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJUb3J1c0tub3RHZW9tZXRyeVwiO3RoaXMucGFyYW1ldGVycz17cmFkaXVzOmEsdHViZTpiLHJhZGlhbFNlZ21lbnRzOmMsdHVidWxhclNlZ21lbnRzOmQscDplLHE6ZixoZWlnaHRTY2FsZTpnfTthPWF8fDEwMDtiPWJ8fDQwO2M9Y3x8NjQ7ZD1kfHw4O2U9ZXx8MjtmPWZ8fDM7Zz1nfHwxO2Zvcih2YXIgaz1BcnJheShjKSxsPW5ldyBUSFJFRS5WZWN0b3IzLHA9bmV3IFRIUkVFLlZlY3RvcjMscT1uZXcgVEhSRUUuVmVjdG9yMyxuPTA7bjxjOysrbil7a1tuXT1cbiAgICBBcnJheShkKTt2YXIgdD1uL2MqMiplKk1hdGguUEkscj1oKHQsZixlLGEsZyksdD1oKHQrLjAxLGYsZSxhLGcpO2wuc3ViVmVjdG9ycyh0LHIpO3AuYWRkVmVjdG9ycyh0LHIpO3EuY3Jvc3NWZWN0b3JzKGwscCk7cC5jcm9zc1ZlY3RvcnMocSxsKTtxLm5vcm1hbGl6ZSgpO3Aubm9ybWFsaXplKCk7Zm9yKHQ9MDt0PGQ7Kyt0KXt2YXIgcz10L2QqMipNYXRoLlBJLHU9LWIqTWF0aC5jb3Mocykscz1iKk1hdGguc2luKHMpLHY9bmV3IFRIUkVFLlZlY3RvcjM7di54PXIueCt1KnAueCtzKnEueDt2Lnk9ci55K3UqcC55K3MqcS55O3Yuej1yLnordSpwLnorcypxLno7a1tuXVt0XT10aGlzLnZlcnRpY2VzLnB1c2godiktMX19Zm9yKG49MDtuPGM7KytuKWZvcih0PTA7dDxkOysrdCllPShuKzEpJWMsZj0odCsxKSVkLGE9a1tuXVt0XSxiPWtbZV1bdF0sZT1rW2VdW2ZdLGY9a1tuXVtmXSxnPW5ldyBUSFJFRS5WZWN0b3IyKG4vYyx0L2QpLGw9bmV3IFRIUkVFLlZlY3RvcjIoKG4rMSkvYyxcbiAgICB0L2QpLHA9bmV3IFRIUkVFLlZlY3RvcjIoKG4rMSkvYywodCsxKS9kKSxxPW5ldyBUSFJFRS5WZWN0b3IyKG4vYywodCsxKS9kKSx0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGEsYixmKSksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW2csbCxxXSksdGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhiLGUsZikpLHRoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtsLmNsb25lKCkscCxxLmNsb25lKCldKTt0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKX07VEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuVG9ydXNLbm90R2VvbWV0cnk7XG5USFJFRS5UdWJlR2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe1RIUkVFLkdlb21ldHJ5LmNhbGwodGhpcyk7dGhpcy50eXBlPVwiVHViZUdlb21ldHJ5XCI7dGhpcy5wYXJhbWV0ZXJzPXtwYXRoOmEsc2VnbWVudHM6YixyYWRpdXM6YyxyYWRpYWxTZWdtZW50czpkLGNsb3NlZDplfTtiPWJ8fDY0O2M9Y3x8MTtkPWR8fDg7ZT1lfHwhMTtmPWZ8fFRIUkVFLlR1YmVHZW9tZXRyeS5Ob1RhcGVyO3ZhciBnPVtdLGgsayxsPWIrMSxwLHEsbix0LHIscz1uZXcgVEhSRUUuVmVjdG9yMyx1LHYseDt1PW5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKGEsYixlKTt2PXUubm9ybWFsczt4PXUuYmlub3JtYWxzO3RoaXMudGFuZ2VudHM9dS50YW5nZW50czt0aGlzLm5vcm1hbHM9djt0aGlzLmJpbm9ybWFscz14O2Zvcih1PTA7dTxsO3UrKylmb3IoZ1t1XT1bXSxwPXUvKGwtMSkscj1hLmdldFBvaW50QXQocCksaD12W3VdLGs9eFt1XSxuPWMqZihwKSxwPTA7cDxkO3ArKylxPVxuICAgIHAvZCoyKk1hdGguUEksdD0tbipNYXRoLmNvcyhxKSxxPW4qTWF0aC5zaW4ocSkscy5jb3B5KHIpLHMueCs9dCpoLngrcSprLngscy55Kz10KmgueStxKmsueSxzLnorPXQqaC56K3Eqay56LGdbdV1bcF09dGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHMueCxzLnkscy56KSktMTtmb3IodT0wO3U8Yjt1KyspZm9yKHA9MDtwPGQ7cCsrKWY9ZT8odSsxKSViOnUrMSxsPShwKzEpJWQsYT1nW3VdW3BdLGM9Z1tmXVtwXSxmPWdbZl1bbF0sbD1nW3VdW2xdLHM9bmV3IFRIUkVFLlZlY3RvcjIodS9iLHAvZCksdj1uZXcgVEhSRUUuVmVjdG9yMigodSsxKS9iLHAvZCkseD1uZXcgVEhSRUUuVmVjdG9yMigodSsxKS9iLChwKzEpL2QpLGg9bmV3IFRIUkVFLlZlY3RvcjIodS9iLChwKzEpL2QpLHRoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoYSxjLGwpKSx0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbcyx2LGhdKSx0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGMsXG4gICAgZixsKSksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW3YuY2xvbmUoKSx4LGguY2xvbmUoKV0pO3RoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpfTtUSFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlR1YmVHZW9tZXRyeTtUSFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlcj1mdW5jdGlvbihhKXtyZXR1cm4gMX07VEhSRUUuVHViZUdlb21ldHJ5LlNpbnVzb2lkYWxUYXBlcj1mdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5zaW4oTWF0aC5QSSphKX07XG5USFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1uZXcgVEhSRUUuVmVjdG9yMyxlPVtdLGY9W10sZz1bXSxoPW5ldyBUSFJFRS5WZWN0b3IzLGs9bmV3IFRIUkVFLk1hdHJpeDQ7Yis9MTt2YXIgbCxwLHE7dGhpcy50YW5nZW50cz1lO3RoaXMubm9ybWFscz1mO3RoaXMuYmlub3JtYWxzPWc7Zm9yKGw9MDtsPGI7bCsrKXA9bC8oYi0xKSxlW2xdPWEuZ2V0VGFuZ2VudEF0KHApLGVbbF0ubm9ybWFsaXplKCk7ZlswXT1uZXcgVEhSRUUuVmVjdG9yMztnWzBdPW5ldyBUSFJFRS5WZWN0b3IzO2E9TnVtYmVyLk1BWF9WQUxVRTtsPU1hdGguYWJzKGVbMF0ueCk7cD1NYXRoLmFicyhlWzBdLnkpO3E9TWF0aC5hYnMoZVswXS56KTtsPD1hJiYoYT1sLGQuc2V0KDEsMCwwKSk7cDw9YSYmKGE9cCxkLnNldCgwLDEsMCkpO3E8PWEmJmQuc2V0KDAsMCwxKTtoLmNyb3NzVmVjdG9ycyhlWzBdLGQpLm5vcm1hbGl6ZSgpO2ZbMF0uY3Jvc3NWZWN0b3JzKGVbMF0sXG4gICAgaCk7Z1swXS5jcm9zc1ZlY3RvcnMoZVswXSxmWzBdKTtmb3IobD0xO2w8YjtsKyspZltsXT1mW2wtMV0uY2xvbmUoKSxnW2xdPWdbbC0xXS5jbG9uZSgpLGguY3Jvc3NWZWN0b3JzKGVbbC0xXSxlW2xdKSwxRS00PGgubGVuZ3RoKCkmJihoLm5vcm1hbGl6ZSgpLGQ9TWF0aC5hY29zKFRIUkVFLk1hdGguY2xhbXAoZVtsLTFdLmRvdChlW2xdKSwtMSwxKSksZltsXS5hcHBseU1hdHJpeDQoay5tYWtlUm90YXRpb25BeGlzKGgsZCkpKSxnW2xdLmNyb3NzVmVjdG9ycyhlW2xdLGZbbF0pO2lmKGMpZm9yKGQ9TWF0aC5hY29zKFRIUkVFLk1hdGguY2xhbXAoZlswXS5kb3QoZltiLTFdKSwtMSwxKSksZC89Yi0xLDA8ZVswXS5kb3QoaC5jcm9zc1ZlY3RvcnMoZlswXSxmW2ItMV0pKSYmKGQ9LWQpLGw9MTtsPGI7bCsrKWZbbF0uYXBwbHlNYXRyaXg0KGsubWFrZVJvdGF0aW9uQXhpcyhlW2xdLGQqbCkpLGdbbF0uY3Jvc3NWZWN0b3JzKGVbbF0sZltsXSl9O1xuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQpe2Z1bmN0aW9uIGUoYSl7dmFyIGI9YS5ub3JtYWxpemUoKS5jbG9uZSgpO2IuaW5kZXg9ay52ZXJ0aWNlcy5wdXNoKGIpLTE7dmFyIGM9TWF0aC5hdGFuMihhLnosLWEueCkvMi9NYXRoLlBJKy41O2E9TWF0aC5hdGFuMigtYS55LE1hdGguc3FydChhLngqYS54K2EueiphLnopKS9NYXRoLlBJKy41O2IudXY9bmV3IFRIUkVFLlZlY3RvcjIoYywxLWEpO3JldHVybiBifWZ1bmN0aW9uIGYoYSxiLGMpe3ZhciBkPW5ldyBUSFJFRS5GYWNlMyhhLmluZGV4LGIuaW5kZXgsYy5pbmRleCxbYS5jbG9uZSgpLGIuY2xvbmUoKSxjLmNsb25lKCldKTtrLmZhY2VzLnB1c2goZCk7dS5jb3B5KGEpLmFkZChiKS5hZGQoYykuZGl2aWRlU2NhbGFyKDMpO2Q9TWF0aC5hdGFuMih1LnosLXUueCk7ay5mYWNlVmVydGV4VXZzWzBdLnB1c2goW2goYS51dixhLGQpLGgoYi51dixiLGQpLGgoYy51dixjLGQpXSl9ZnVuY3Rpb24gZyhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiKXtmb3IodmFyIGM9TWF0aC5wb3coMixiKSxkPWUoay52ZXJ0aWNlc1thLmFdKSxnPWUoay52ZXJ0aWNlc1thLmJdKSxoPWUoay52ZXJ0aWNlc1thLmNdKSxsPVtdLG49MDtuPD1jO24rKyl7bFtuXT1bXTtmb3IodmFyIHA9ZShkLmNsb25lKCkubGVycChoLG4vYykpLHE9ZShnLmNsb25lKCkubGVycChoLG4vYykpLHM9Yy1uLHI9MDtyPD1zO3IrKylsW25dW3JdPTA9PXImJm49PWM/cDplKHAuY2xvbmUoKS5sZXJwKHEsci9zKSl9Zm9yKG49MDtuPGM7bisrKWZvcihyPTA7cjwyKihjLW4pLTE7cisrKWQ9TWF0aC5mbG9vcihyLzIpLDA9PXIlMj9mKGxbbl1bZCsxXSxsW24rMV1bZF0sbFtuXVtkXSk6ZihsW25dW2QrMV0sbFtuKzFdW2QrMV0sbFtuKzFdW2RdKX1mdW5jdGlvbiBoKGEsYixjKXswPmMmJjE9PT1hLngmJihhPW5ldyBUSFJFRS5WZWN0b3IyKGEueC0xLGEueSkpOzA9PT1iLngmJjA9PT1iLnomJihhPW5ldyBUSFJFRS5WZWN0b3IyKGMvMi9NYXRoLlBJKy41LGEueSkpO3JldHVybiBhLmNsb25lKCl9XG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJQb2x5aGVkcm9uR2VvbWV0cnlcIjt0aGlzLnBhcmFtZXRlcnM9e3ZlcnRpY2VzOmEsaW5kaWNlczpiLHJhZGl1czpjLGRldGFpbDpkfTtjPWN8fDE7ZD1kfHwwO2Zvcih2YXIgaz10aGlzLGw9MCxwPWEubGVuZ3RoO2w8cDtsKz0zKWUobmV3IFRIUkVFLlZlY3RvcjMoYVtsXSxhW2wrMV0sYVtsKzJdKSk7YT10aGlzLnZlcnRpY2VzO2Zvcih2YXIgcT1bXSxuPWw9MCxwPWIubGVuZ3RoO2w8cDtsKz0zLG4rKyl7dmFyIHQ9YVtiW2xdXSxyPWFbYltsKzFdXSxzPWFbYltsKzJdXTtxW25dPW5ldyBUSFJFRS5GYWNlMyh0LmluZGV4LHIuaW5kZXgscy5pbmRleCxbdC5jbG9uZSgpLHIuY2xvbmUoKSxzLmNsb25lKCldKX1mb3IodmFyIHU9bmV3IFRIUkVFLlZlY3RvcjMsbD0wLHA9cS5sZW5ndGg7bDxwO2wrKylnKHFbbF0sZCk7bD0wO2ZvcihwPXRoaXMuZmFjZVZlcnRleFV2c1swXS5sZW5ndGg7bDxwO2wrKyliPXRoaXMuZmFjZVZlcnRleFV2c1swXVtsXSxcbiAgICAgICAgZD1iWzBdLngsYT1iWzFdLngscT1iWzJdLngsbj1NYXRoLm1heChkLE1hdGgubWF4KGEscSkpLHQ9TWF0aC5taW4oZCxNYXRoLm1pbihhLHEpKSwuOTxuJiYuMT50JiYoLjI+ZCYmKGJbMF0ueCs9MSksLjI+YSYmKGJbMV0ueCs9MSksLjI+cSYmKGJbMl0ueCs9MSkpO2w9MDtmb3IocD10aGlzLnZlcnRpY2VzLmxlbmd0aDtsPHA7bCsrKXRoaXMudmVydGljZXNbbF0ubXVsdGlwbHlTY2FsYXIoYyk7dGhpcy5tZXJnZVZlcnRpY2VzKCk7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTt0aGlzLmJvdW5kaW5nU3BoZXJlPW5ldyBUSFJFRS5TcGhlcmUobmV3IFRIUkVFLlZlY3RvcjMsYyl9O1RIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5O1xuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnk9ZnVuY3Rpb24oYSxiKXt0aGlzLnBhcmFtZXRlcnM9e3JhZGl1czphLGRldGFpbDpifTt2YXIgYz0oMStNYXRoLnNxcnQoNSkpLzIsZD0xL2M7VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwodGhpcyxbLTEsLTEsLTEsLTEsLTEsMSwtMSwxLC0xLC0xLDEsMSwxLC0xLC0xLDEsLTEsMSwxLDEsLTEsMSwxLDEsMCwtZCwtYywwLC1kLGMsMCxkLC1jLDAsZCxjLC1kLC1jLDAsLWQsYywwLGQsLWMsMCxkLGMsMCwtYywwLC1kLGMsMCwtZCwtYywwLGQsYywwLGRdLFszLDExLDcsMyw3LDE1LDMsMTUsMTMsNywxOSwxNyw3LDE3LDYsNyw2LDE1LDE3LDQsOCwxNyw4LDEwLDE3LDEwLDYsOCwwLDE2LDgsMTYsMiw4LDIsMTAsMCwxMiwxLDAsMSwxOCwwLDE4LDE2LDYsMTAsMiw2LDIsMTMsNiwxMywxNSwyLDE2LDE4LDIsMTgsMywyLDMsMTMsMTgsMSw5LDE4LDksMTEsMTgsMTEsMyw0LDE0LDEyLDQsMTIsMCw0LDAsOCwxMSw5LDUsMTEsNSwxOSxcbiAgICAxMSwxOSw3LDE5LDUsMTQsMTksMTQsNCwxOSw0LDE3LDEsMTIsMTQsMSwxNCw1LDEsNSw5XSxhLGIpfTtUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeTtcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnk9ZnVuY3Rpb24oYSxiKXt2YXIgYz0oMStNYXRoLnNxcnQoNSkpLzI7VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwodGhpcyxbLTEsYywwLDEsYywwLC0xLC1jLDAsMSwtYywwLDAsLTEsYywwLDEsYywwLC0xLC1jLDAsMSwtYyxjLDAsLTEsYywwLDEsLWMsMCwtMSwtYywwLDFdLFswLDExLDUsMCw1LDEsMCwxLDcsMCw3LDEwLDAsMTAsMTEsMSw1LDksNSwxMSw0LDExLDEwLDIsMTAsNyw2LDcsMSw4LDMsOSw0LDMsNCwyLDMsMiw2LDMsNiw4LDMsOCw5LDQsOSw1LDIsNCwxMSw2LDIsMTAsOCw2LDcsOSw4LDFdLGEsYik7dGhpcy50eXBlPVwiSWNvc2FoZWRyb25HZW9tZXRyeVwiO3RoaXMucGFyYW1ldGVycz17cmFkaXVzOmEsZGV0YWlsOmJ9fTtUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSk7XG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5O1RIUkVFLk9jdGFoZWRyb25HZW9tZXRyeT1mdW5jdGlvbihhLGIpe3RoaXMucGFyYW1ldGVycz17cmFkaXVzOmEsZGV0YWlsOmJ9O1RIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKHRoaXMsWzEsMCwwLC0xLDAsMCwwLDEsMCwwLC0xLDAsMCwwLDEsMCwwLC0xXSxbMCwyLDQsMCw0LDMsMCwzLDUsMCw1LDIsMSwyLDUsMSw1LDMsMSwzLDQsMSw0LDJdLGEsYik7dGhpcy50eXBlPVwiT2N0YWhlZHJvbkdlb21ldHJ5XCI7dGhpcy5wYXJhbWV0ZXJzPXtyYWRpdXM6YSxkZXRhaWw6Yn19O1RIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5O1xuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeT1mdW5jdGlvbihhLGIpe1RIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKHRoaXMsWzEsMSwxLC0xLC0xLDEsLTEsMSwtMSwxLC0xLC0xXSxbMiwxLDAsMCwzLDIsMSwzLDAsMiwzLDFdLGEsYik7dGhpcy50eXBlPVwiVGV0cmFoZWRyb25HZW9tZXRyeVwiO3RoaXMucGFyYW1ldGVycz17cmFkaXVzOmEsZGV0YWlsOmJ9fTtUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSk7VEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeTtcblRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeT1mdW5jdGlvbihhLGIsYyl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnR5cGU9XCJQYXJhbWV0cmljR2VvbWV0cnlcIjt0aGlzLnBhcmFtZXRlcnM9e2Z1bmM6YSxzbGljZXM6YixzdGFja3M6Y307dmFyIGQ9dGhpcy52ZXJ0aWNlcyxlPXRoaXMuZmFjZXMsZj10aGlzLmZhY2VWZXJ0ZXhVdnNbMF0sZyxoLGssbCxwPWIrMTtmb3IoZz0wO2c8PWM7ZysrKWZvcihsPWcvYyxoPTA7aDw9YjtoKyspaz1oL2Isaz1hKGssbCksZC5wdXNoKGspO3ZhciBxLG4sdCxyO2ZvcihnPTA7ZzxjO2crKylmb3IoaD0wO2g8YjtoKyspYT1nKnAraCxkPWcqcCtoKzEsbD0oZysxKSpwK2grMSxrPShnKzEpKnAraCxxPW5ldyBUSFJFRS5WZWN0b3IyKGgvYixnL2MpLG49bmV3IFRIUkVFLlZlY3RvcjIoKGgrMSkvYixnL2MpLHQ9bmV3IFRIUkVFLlZlY3RvcjIoKGgrMSkvYiwoZysxKS9jKSxyPW5ldyBUSFJFRS5WZWN0b3IyKGgvYiwoZysxKS9jKSxlLnB1c2gobmV3IFRIUkVFLkZhY2UzKGEsXG4gICAgZCxrKSksZi5wdXNoKFtxLG4scl0pLGUucHVzaChuZXcgVEhSRUUuRmFjZTMoZCxsLGspKSxmLnB1c2goW24uY2xvbmUoKSx0LHIuY2xvbmUoKV0pO3RoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpfTtUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeTtcblRIUkVFLkF4aXNIZWxwZXI9ZnVuY3Rpb24oYSl7YT1hfHwxO3ZhciBiPW5ldyBGbG9hdDMyQXJyYXkoWzAsMCwwLGEsMCwwLDAsMCwwLDAsYSwwLDAsMCwwLDAsMCxhXSksYz1uZXcgRmxvYXQzMkFycmF5KFsxLDAsMCwxLC42LDAsMCwxLDAsLjYsMSwwLDAsMCwxLDAsLjYsMV0pO2E9bmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5O2EuYWRkQXR0cmlidXRlKFwicG9zaXRpb25cIixuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGIsMykpO2EuYWRkQXR0cmlidXRlKFwiY29sb3JcIixuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGMsMykpO2I9bmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHt2ZXJ0ZXhDb2xvcnM6VEhSRUUuVmVydGV4Q29sb3JzfSk7VEhSRUUuTGluZS5jYWxsKHRoaXMsYSxiLFRIUkVFLkxpbmVQaWVjZXMpfTtUSFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpbmUucHJvdG90eXBlKTtcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkF4aXNIZWxwZXI7XG5USFJFRS5BcnJvd0hlbHBlcj1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5HZW9tZXRyeTthLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCwwLDApLG5ldyBUSFJFRS5WZWN0b3IzKDAsMSwwKSk7dmFyIGI9bmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoMCwuNSwxLDUsMSk7Yi5hcHBseU1hdHJpeCgobmV3IFRIUkVFLk1hdHJpeDQpLm1ha2VUcmFuc2xhdGlvbigwLC0uNSwwKSk7cmV0dXJuIGZ1bmN0aW9uKGMsZCxlLGYsZyxoKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3ZvaWQgMD09PWYmJihmPTE2Nzc2OTYwKTt2b2lkIDA9PT1lJiYoZT0xKTt2b2lkIDA9PT1nJiYoZz0uMiplKTt2b2lkIDA9PT1oJiYoaD0uMipnKTt0aGlzLnBvc2l0aW9uLmNvcHkoZCk7dGhpcy5saW5lPW5ldyBUSFJFRS5MaW5lKGEsbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtjb2xvcjpmfSkpO3RoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlPSExO3RoaXMuYWRkKHRoaXMubGluZSk7XG4gICAgdGhpcy5jb25lPW5ldyBUSFJFRS5NZXNoKGIsbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtjb2xvcjpmfSkpO3RoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlPSExO3RoaXMuYWRkKHRoaXMuY29uZSk7dGhpcy5zZXREaXJlY3Rpb24oYyk7dGhpcy5zZXRMZW5ndGgoZSxnLGgpfX0oKTtUSFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUpO1RIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5BcnJvd0hlbHBlcjtcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb249ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiO3JldHVybiBmdW5jdGlvbihjKXsuOTk5OTk8Yy55P3RoaXMucXVhdGVybmlvbi5zZXQoMCwwLDAsMSk6LS45OTk5OT5jLnk/dGhpcy5xdWF0ZXJuaW9uLnNldCgxLDAsMCwwKTooYS5zZXQoYy56LDAsLWMueCkubm9ybWFsaXplKCksYj1NYXRoLmFjb3MoYy55KSx0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShhLGIpKX19KCk7VEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldExlbmd0aD1mdW5jdGlvbihhLGIsYyl7dm9pZCAwPT09YiYmKGI9LjIqYSk7dm9pZCAwPT09YyYmKGM9LjIqYik7dGhpcy5saW5lLnNjYWxlLnNldCgxLGEtYiwxKTt0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7dGhpcy5jb25lLnNjYWxlLnNldChjLGIsYyk7dGhpcy5jb25lLnBvc2l0aW9uLnk9YTt0aGlzLmNvbmUudXBkYXRlTWF0cml4KCl9O1xuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yPWZ1bmN0aW9uKGEpe3RoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoYSk7dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldChhKX07VEhSRUUuQm94SGVscGVyPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeTtiLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KDcyKSwzKSk7VEhSRUUuTGluZS5jYWxsKHRoaXMsYixuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe2NvbG9yOjE2Nzc2OTYwfSksVEhSRUUuTGluZVBpZWNlcyk7dm9pZCAwIT09YSYmdGhpcy51cGRhdGUoYSl9O1RIUkVFLkJveEhlbHBlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5MaW5lLnByb3RvdHlwZSk7VEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5Cb3hIZWxwZXI7XG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhKXt2YXIgYj1hLmdlb21ldHJ5O251bGw9PT1iLmJvdW5kaW5nQm94JiZiLmNvbXB1dGVCb3VuZGluZ0JveCgpO3ZhciBjPWIuYm91bmRpbmdCb3gubWluLGI9Yi5ib3VuZGluZ0JveC5tYXgsZD10aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7ZFswXT1iLng7ZFsxXT1iLnk7ZFsyXT1iLno7ZFszXT1jLng7ZFs0XT1iLnk7ZFs1XT1iLno7ZFs2XT1jLng7ZFs3XT1iLnk7ZFs4XT1iLno7ZFs5XT1jLng7ZFsxMF09Yy55O2RbMTFdPWIuejtkWzEyXT1jLng7ZFsxM109Yy55O2RbMTRdPWIuejtkWzE1XT1iLng7ZFsxNl09Yy55O2RbMTddPWIuejtkWzE4XT1iLng7ZFsxOV09Yy55O2RbMjBdPWIuejtkWzIxXT1iLng7ZFsyMl09Yi55O2RbMjNdPWIuejtkWzI0XT1iLng7ZFsyNV09Yi55O2RbMjZdPWMuejtkWzI3XT1jLng7ZFsyOF09Yi55O2RbMjldPWMuejtkWzMwXT1jLng7ZFszMV09Yi55O1xuICAgIGRbMzJdPWMuejtkWzMzXT1jLng7ZFszNF09Yy55O2RbMzVdPWMuejtkWzM2XT1jLng7ZFszN109Yy55O2RbMzhdPWMuejtkWzM5XT1iLng7ZFs0MF09Yy55O2RbNDFdPWMuejtkWzQyXT1iLng7ZFs0M109Yy55O2RbNDRdPWMuejtkWzQ1XT1iLng7ZFs0Nl09Yi55O2RbNDddPWMuejtkWzQ4XT1iLng7ZFs0OV09Yi55O2RbNTBdPWIuejtkWzUxXT1iLng7ZFs1Ml09Yi55O2RbNTNdPWMuejtkWzU0XT1jLng7ZFs1NV09Yi55O2RbNTZdPWIuejtkWzU3XT1jLng7ZFs1OF09Yi55O2RbNTldPWMuejtkWzYwXT1jLng7ZFs2MV09Yy55O2RbNjJdPWIuejtkWzYzXT1jLng7ZFs2NF09Yy55O2RbNjVdPWMuejtkWzY2XT1iLng7ZFs2N109Yy55O2RbNjhdPWIuejtkWzY5XT1iLng7ZFs3MF09Yy55O2RbNzFdPWMuejt0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGU9ITA7dGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTt0aGlzLm1hdHJpeD1hLm1hdHJpeFdvcmxkO1xuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZT0hMX07VEhSRUUuQm91bmRpbmdCb3hIZWxwZXI9ZnVuY3Rpb24oYSxiKXt2YXIgYz12b2lkIDAhPT1iP2I6ODk0Nzg0ODt0aGlzLm9iamVjdD1hO3RoaXMuYm94PW5ldyBUSFJFRS5Cb3gzO1RIUkVFLk1lc2guY2FsbCh0aGlzLG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgxLDEsMSksbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtjb2xvcjpjLHdpcmVmcmFtZTohMH0pKX07VEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWVzaC5wcm90b3R5cGUpO1RIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5Cb3VuZGluZ0JveEhlbHBlcjtUSFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5ib3guc2V0RnJvbU9iamVjdCh0aGlzLm9iamVjdCk7dGhpcy5ib3guc2l6ZSh0aGlzLnNjYWxlKTt0aGlzLmJveC5jZW50ZXIodGhpcy5wb3NpdGlvbil9O1xuVEhSRUUuQ2FtZXJhSGVscGVyPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxiLGQpe2MoYSxkKTtjKGIsZCl9ZnVuY3Rpb24gYyhhLGIpe2QudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyk7ZC5jb2xvcnMucHVzaChuZXcgVEhSRUUuQ29sb3IoYikpO3ZvaWQgMD09PWZbYV0mJihmW2FdPVtdKTtmW2FdLnB1c2goZC52ZXJ0aWNlcy5sZW5ndGgtMSl9dmFyIGQ9bmV3IFRIUkVFLkdlb21ldHJ5LGU9bmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtjb2xvcjoxNjc3NzIxNSx2ZXJ0ZXhDb2xvcnM6VEhSRUUuRmFjZUNvbG9yc30pLGY9e307YihcIm4xXCIsXCJuMlwiLDE2NzU1MjAwKTtiKFwibjJcIixcIm40XCIsMTY3NTUyMDApO2IoXCJuNFwiLFwibjNcIiwxNjc1NTIwMCk7YihcIm4zXCIsXCJuMVwiLDE2NzU1MjAwKTtiKFwiZjFcIixcImYyXCIsMTY3NTUyMDApO2IoXCJmMlwiLFwiZjRcIiwxNjc1NTIwMCk7YihcImY0XCIsXCJmM1wiLDE2NzU1MjAwKTtiKFwiZjNcIixcImYxXCIsMTY3NTUyMDApO2IoXCJuMVwiLFwiZjFcIiwxNjc1NTIwMCk7XG4gICAgYihcIm4yXCIsXCJmMlwiLDE2NzU1MjAwKTtiKFwibjNcIixcImYzXCIsMTY3NTUyMDApO2IoXCJuNFwiLFwiZjRcIiwxNjc1NTIwMCk7YihcInBcIixcIm4xXCIsMTY3MTE2ODApO2IoXCJwXCIsXCJuMlwiLDE2NzExNjgwKTtiKFwicFwiLFwibjNcIiwxNjcxMTY4MCk7YihcInBcIixcIm40XCIsMTY3MTE2ODApO2IoXCJ1MVwiLFwidTJcIiw0Mzc3NSk7YihcInUyXCIsXCJ1M1wiLDQzNzc1KTtiKFwidTNcIixcInUxXCIsNDM3NzUpO2IoXCJjXCIsXCJ0XCIsMTY3NzcyMTUpO2IoXCJwXCIsXCJjXCIsMzM1NTQ0Myk7YihcImNuMVwiLFwiY24yXCIsMzM1NTQ0Myk7YihcImNuM1wiLFwiY240XCIsMzM1NTQ0Myk7YihcImNmMVwiLFwiY2YyXCIsMzM1NTQ0Myk7YihcImNmM1wiLFwiY2Y0XCIsMzM1NTQ0Myk7VEhSRUUuTGluZS5jYWxsKHRoaXMsZCxlLFRIUkVFLkxpbmVQaWVjZXMpO3RoaXMuY2FtZXJhPWE7dGhpcy5tYXRyaXg9YS5tYXRyaXhXb3JsZDt0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ITE7dGhpcy5wb2ludE1hcD1mO3RoaXMudXBkYXRlKCl9O1xuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpbmUucHJvdG90eXBlKTtUSFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLkNhbWVyYUhlbHBlcjtcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGEsYixjPW5ldyBUSFJFRS5WZWN0b3IzLGQ9bmV3IFRIUkVFLkNhbWVyYSxlPWZ1bmN0aW9uKGUsZyxoLGspe2Muc2V0KGcsaCxrKS51bnByb2plY3QoZCk7ZT1iW2VdO2lmKHZvaWQgMCE9PWUpZm9yKGc9MCxoPWUubGVuZ3RoO2c8aDtnKyspYS52ZXJ0aWNlc1tlW2ddXS5jb3B5KGMpfTtyZXR1cm4gZnVuY3Rpb24oKXthPXRoaXMuZ2VvbWV0cnk7Yj10aGlzLnBvaW50TWFwO2QucHJvamVjdGlvbk1hdHJpeC5jb3B5KHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO2UoXCJjXCIsMCwwLC0xKTtlKFwidFwiLDAsMCwxKTtlKFwibjFcIiwtMSwtMSwtMSk7ZShcIm4yXCIsMSwtMSwtMSk7ZShcIm4zXCIsLTEsMSwtMSk7ZShcIm40XCIsMSwxLC0xKTtlKFwiZjFcIiwtMSwtMSwxKTtlKFwiZjJcIiwxLC0xLDEpO2UoXCJmM1wiLC0xLDEsMSk7ZShcImY0XCIsMSwxLDEpO2UoXCJ1MVwiLC43LDEuMSwtMSk7ZShcInUyXCIsLS43LDEuMSxcbiAgICAtMSk7ZShcInUzXCIsMCwyLC0xKTtlKFwiY2YxXCIsLTEsMCwxKTtlKFwiY2YyXCIsMSwwLDEpO2UoXCJjZjNcIiwwLC0xLDEpO2UoXCJjZjRcIiwwLDEsMSk7ZShcImNuMVwiLC0xLDAsLTEpO2UoXCJjbjJcIiwxLDAsLTEpO2UoXCJjbjNcIiwwLC0xLC0xKTtlKFwiY240XCIsMCwxLC0xKTthLnZlcnRpY2VzTmVlZFVwZGF0ZT0hMH19KCk7XG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyPWZ1bmN0aW9uKGEsYil7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKTt0aGlzLmxpZ2h0PWE7dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO3RoaXMubWF0cml4PWEubWF0cml4V29ybGQ7dGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExO2I9Ynx8MTt2YXIgYz1uZXcgVEhSRUUuR2VvbWV0cnk7Yy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKC1iLGIsMCksbmV3IFRIUkVFLlZlY3RvcjMoYixiLDApLG5ldyBUSFJFRS5WZWN0b3IzKGIsLWIsMCksbmV3IFRIUkVFLlZlY3RvcjMoLWIsLWIsMCksbmV3IFRIUkVFLlZlY3RvcjMoLWIsYiwwKSk7dmFyIGQ9bmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtmb2c6ITF9KTtkLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcikubXVsdGlwbHlTY2FsYXIodGhpcy5saWdodC5pbnRlbnNpdHkpO3RoaXMubGlnaHRQbGFuZT1uZXcgVEhSRUUuTGluZShjLGQpO3RoaXMuYWRkKHRoaXMubGlnaHRQbGFuZSk7XG4gICAgYz1uZXcgVEhSRUUuR2VvbWV0cnk7Yy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzKTtkPW5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7Zm9nOiExfSk7ZC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KTt0aGlzLnRhcmdldExpbmU9bmV3IFRIUkVFLkxpbmUoYyxkKTt0aGlzLmFkZCh0aGlzLnRhcmdldExpbmUpO3RoaXMudXBkYXRlKCl9O1RIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMubGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTt0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO3RoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCl9O1xuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuVmVjdG9yMyxjPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbigpe2Euc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQubWF0cml4V29ybGQpO2Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtjLnN1YlZlY3RvcnMoYixhKTt0aGlzLmxpZ2h0UGxhbmUubG9va0F0KGMpO3RoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KTt0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbMV0uY29weShjKTt0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlPSEwO3RoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvcil9fSgpO1xuVEhSRUUuRWRnZXNIZWxwZXI9ZnVuY3Rpb24oYSxiLGMpe2I9dm9pZCAwIT09Yj9iOjE2Nzc3MjE1O2M9TWF0aC5jb3MoVEhSRUUuTWF0aC5kZWdUb1JhZCh2b2lkIDAhPT1jP2M6MSkpO3ZhciBkPVswLDBdLGU9e30sZj1mdW5jdGlvbihhLGIpe3JldHVybiBhLWJ9LGc9W1wiYVwiLFwiYlwiLFwiY1wiXSxoPW5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSxrO2EuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeT8oaz1uZXcgVEhSRUUuR2VvbWV0cnksay5mcm9tQnVmZmVyR2VvbWV0cnkoYS5nZW9tZXRyeSkpOms9YS5nZW9tZXRyeS5jbG9uZSgpO2subWVyZ2VWZXJ0aWNlcygpO2suY29tcHV0ZUZhY2VOb3JtYWxzKCk7dmFyIGw9ay52ZXJ0aWNlcztrPWsuZmFjZXM7Zm9yKHZhciBwPTAscT0wLG49ay5sZW5ndGg7cTxuO3ErKylmb3IodmFyIHQ9a1txXSxyPTA7Mz5yO3IrKyl7ZFswXT10W2dbcl1dO2RbMV09dFtnWyhyKzEpJTNdXTtkLnNvcnQoZik7dmFyIHM9ZC50b1N0cmluZygpO1xuICAgIHZvaWQgMD09PWVbc10/KGVbc109e3ZlcnQxOmRbMF0sdmVydDI6ZFsxXSxmYWNlMTpxLGZhY2UyOnZvaWQgMH0scCsrKTplW3NdLmZhY2UyPXF9ZD1uZXcgRmxvYXQzMkFycmF5KDYqcCk7Zj0wO2ZvcihzIGluIGUpaWYoZz1lW3NdLHZvaWQgMD09PWcuZmFjZTJ8fGtbZy5mYWNlMV0ubm9ybWFsLmRvdChrW2cuZmFjZTJdLm5vcm1hbCk8PWMpcD1sW2cudmVydDFdLGRbZisrXT1wLngsZFtmKytdPXAueSxkW2YrK109cC56LHA9bFtnLnZlcnQyXSxkW2YrK109cC54LGRbZisrXT1wLnksZFtmKytdPXAuejtoLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShkLDMpKTtUSFJFRS5MaW5lLmNhbGwodGhpcyxoLG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7Y29sb3I6Yn0pLFRIUkVFLkxpbmVQaWVjZXMpO3RoaXMubWF0cml4PWEubWF0cml4V29ybGQ7dGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExfTtcblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpbmUucHJvdG90eXBlKTtUSFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuRWRnZXNIZWxwZXI7XG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlcj1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLm9iamVjdD1hO3RoaXMuc2l6ZT12b2lkIDAhPT1iP2I6MTthPXZvaWQgMCE9PWM/YzoxNjc3Njk2MDtkPXZvaWQgMCE9PWQ/ZDoxO2I9bmV3IFRIUkVFLkdlb21ldHJ5O2M9MDtmb3IodmFyIGU9dGhpcy5vYmplY3QuZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO2M8ZTtjKyspYi52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzKTtUSFJFRS5MaW5lLmNhbGwodGhpcyxiLG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7Y29sb3I6YSxsaW5ld2lkdGg6ZH0pLFRIUkVFLkxpbmVQaWVjZXMpO3RoaXMubWF0cml4QXV0b1VwZGF0ZT0hMTt0aGlzLm5vcm1hbE1hdHJpeD1uZXcgVEhSRUUuTWF0cml4Mzt0aGlzLnVwZGF0ZSgpfTtUSFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5MaW5lLnByb3RvdHlwZSk7XG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuRmFjZU5vcm1hbHNIZWxwZXI7XG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyxiPXRoaXMub2JqZWN0LGM9Yi5nZW9tZXRyeS52ZXJ0aWNlcyxkPWIuZ2VvbWV0cnkuZmFjZXMsZT1iLm1hdHJpeFdvcmxkO2IudXBkYXRlTWF0cml4V29ybGQoITApO3RoaXMubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeChlKTtmb3IodmFyIGY9Yj0wLGc9ZC5sZW5ndGg7YjxnO2IrKyxmKz0yKXt2YXIgaD1kW2JdO2FbZl0uY29weShjW2guYV0pLmFkZChjW2guYl0pLmFkZChjW2guY10pLmRpdmlkZVNjYWxhcigzKS5hcHBseU1hdHJpeDQoZSk7YVtmKzFdLmNvcHkoaC5ub3JtYWwpLmFwcGx5TWF0cml4Myh0aGlzLm5vcm1hbE1hdHJpeCkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zaXplKS5hZGQoYVtmXSl9dGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU9ITA7cmV0dXJuIHRoaXN9O1xuVEhSRUUuR3JpZEhlbHBlcj1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBUSFJFRS5HZW9tZXRyeSxkPW5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7dmVydGV4Q29sb3JzOlRIUkVFLlZlcnRleENvbG9yc30pO3RoaXMuY29sb3IxPW5ldyBUSFJFRS5Db2xvcig0NDczOTI0KTt0aGlzLmNvbG9yMj1uZXcgVEhSRUUuQ29sb3IoODk0Nzg0OCk7Zm9yKHZhciBlPS1hO2U8PWE7ZSs9Yil7Yy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKC1hLDAsZSksbmV3IFRIUkVFLlZlY3RvcjMoYSwwLGUpLG5ldyBUSFJFRS5WZWN0b3IzKGUsMCwtYSksbmV3IFRIUkVFLlZlY3RvcjMoZSwwLGEpKTt2YXIgZj0wPT09ZT90aGlzLmNvbG9yMTp0aGlzLmNvbG9yMjtjLmNvbG9ycy5wdXNoKGYsZixmLGYpfVRIUkVFLkxpbmUuY2FsbCh0aGlzLGMsZCxUSFJFRS5MaW5lUGllY2VzKX07VEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5MaW5lLnByb3RvdHlwZSk7XG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5HcmlkSGVscGVyO1RIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLnNldENvbG9ycz1mdW5jdGlvbihhLGIpe3RoaXMuY29sb3IxLnNldChhKTt0aGlzLmNvbG9yMi5zZXQoYik7dGhpcy5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlPSEwfTtcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlcj1mdW5jdGlvbihhLGIpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy5saWdodD1hO3RoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTt0aGlzLm1hdHJpeD1hLm1hdHJpeFdvcmxkO3RoaXMubWF0cml4QXV0b1VwZGF0ZT0hMTt0aGlzLmNvbG9ycz1bbmV3IFRIUkVFLkNvbG9yLG5ldyBUSFJFRS5Db2xvcl07dmFyIGM9bmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KGIsNCwyKTtjLmFwcGx5TWF0cml4KChuZXcgVEhSRUUuTWF0cml4NCkubWFrZVJvdGF0aW9uWCgtTWF0aC5QSS8yKSk7Zm9yKHZhciBkPTA7OD5kO2QrKyljLmZhY2VzW2RdLmNvbG9yPXRoaXMuY29sb3JzWzQ+ZD8wOjFdO2Q9bmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHt2ZXJ0ZXhDb2xvcnM6VEhSRUUuRmFjZUNvbG9ycyx3aXJlZnJhbWU6ITB9KTt0aGlzLmxpZ2h0U3BoZXJlPW5ldyBUSFJFRS5NZXNoKGMsZCk7dGhpcy5hZGQodGhpcy5saWdodFNwaGVyZSk7XG4gICAgdGhpcy51cGRhdGUoKX07VEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXI7VEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5kaXNwb3NlKCk7dGhpcy5saWdodFNwaGVyZS5tYXRlcmlhbC5kaXNwb3NlKCl9O1xuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLmNvbG9yc1swXS5jb3B5KHRoaXMubGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KTt0aGlzLmNvbG9yc1sxXS5jb3B5KHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KTt0aGlzLmxpZ2h0U3BoZXJlLmxvb2tBdChhLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkKS5uZWdhdGUoKSk7dGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlPSEwfX0oKTtcblRIUkVFLlBvaW50TGlnaHRIZWxwZXI9ZnVuY3Rpb24oYSxiKXt0aGlzLmxpZ2h0PWE7dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO3ZhciBjPW5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShiLDQsMiksZD1uZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe3dpcmVmcmFtZTohMCxmb2c6ITF9KTtkLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcikubXVsdGlwbHlTY2FsYXIodGhpcy5saWdodC5pbnRlbnNpdHkpO1RIUkVFLk1lc2guY2FsbCh0aGlzLGMsZCk7dGhpcy5tYXRyaXg9dGhpcy5saWdodC5tYXRyaXhXb3JsZDt0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ITF9O1RIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWVzaC5wcm90b3R5cGUpO1RIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlBvaW50TGlnaHRIZWxwZXI7XG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCl9O1RIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe3RoaXMubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSl9O1xuVEhSRUUuU2tlbGV0b25IZWxwZXI9ZnVuY3Rpb24oYSl7dGhpcy5ib25lcz10aGlzLmdldEJvbmVMaXN0KGEpO2Zvcih2YXIgYj1uZXcgVEhSRUUuR2VvbWV0cnksYz0wO2M8dGhpcy5ib25lcy5sZW5ndGg7YysrKXRoaXMuYm9uZXNbY10ucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSYmKGIudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyksYi52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKSxiLmNvbG9ycy5wdXNoKG5ldyBUSFJFRS5Db2xvcigwLDAsMSkpLGIuY29sb3JzLnB1c2gobmV3IFRIUkVFLkNvbG9yKDAsMSwwKSkpO2M9bmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHt2ZXJ0ZXhDb2xvcnM6VEhSRUUuVmVydGV4Q29sb3JzLGRlcHRoVGVzdDohMSxkZXB0aFdyaXRlOiExLHRyYW5zcGFyZW50OiEwfSk7VEhSRUUuTGluZS5jYWxsKHRoaXMsYixjLFRIUkVFLkxpbmVQaWVjZXMpO3RoaXMucm9vdD1hO3RoaXMubWF0cml4PWEubWF0cml4V29ybGQ7XG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExO3RoaXMudXBkYXRlKCl9O1RIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpbmUucHJvdG90eXBlKTtUSFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuU2tlbGV0b25IZWxwZXI7VEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmdldEJvbmVMaXN0PWZ1bmN0aW9uKGEpe3ZhciBiPVtdO2EgaW5zdGFuY2VvZiBUSFJFRS5Cb25lJiZiLnB1c2goYSk7Zm9yKHZhciBjPTA7YzxhLmNoaWxkcmVuLmxlbmd0aDtjKyspYi5wdXNoLmFwcGx5KGIsdGhpcy5nZXRCb25lTGlzdChhLmNoaWxkcmVuW2NdKSk7cmV0dXJuIGJ9O1xuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLmdlb21ldHJ5LGI9KG5ldyBUSFJFRS5NYXRyaXg0KS5nZXRJbnZlcnNlKHRoaXMucm9vdC5tYXRyaXhXb3JsZCksYz1uZXcgVEhSRUUuTWF0cml4NCxkPTAsZT0wO2U8dGhpcy5ib25lcy5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLmJvbmVzW2VdO2YucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSYmKGMubXVsdGlwbHlNYXRyaWNlcyhiLGYubWF0cml4V29ybGQpLGEudmVydGljZXNbZF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGMpLGMubXVsdGlwbHlNYXRyaWNlcyhiLGYucGFyZW50Lm1hdHJpeFdvcmxkKSxhLnZlcnRpY2VzW2QrMV0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGMpLGQrPTIpfWEudmVydGljZXNOZWVkVXBkYXRlPSEwO2EuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCl9O1xuVEhSRUUuU3BvdExpZ2h0SGVscGVyPWZ1bmN0aW9uKGEpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy5saWdodD1hO3RoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTt0aGlzLm1hdHJpeD1hLm1hdHJpeFdvcmxkO3RoaXMubWF0cml4QXV0b1VwZGF0ZT0hMTthPW5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KDAsMSwxLDgsMSwhMCk7YS5hcHBseU1hdHJpeCgobmV3IFRIUkVFLk1hdHJpeDQpLm1ha2VUcmFuc2xhdGlvbigwLC0uNSwwKSk7YS5hcHBseU1hdHJpeCgobmV3IFRIUkVFLk1hdHJpeDQpLm1ha2VSb3RhdGlvblgoLU1hdGguUEkvMikpO3ZhciBiPW5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7d2lyZWZyYW1lOiEwLGZvZzohMX0pO3RoaXMuY29uZT1uZXcgVEhSRUUuTWVzaChhLGIpO3RoaXMuYWRkKHRoaXMuY29uZSk7dGhpcy51cGRhdGUoKX07VEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7XG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlNwb3RMaWdodEhlbHBlcjtUSFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO3RoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCl9O1xuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPXRoaXMubGlnaHQuZGlzdGFuY2U/dGhpcy5saWdodC5kaXN0YW5jZToxRTQsZD1jKk1hdGgudGFuKHRoaXMubGlnaHQuYW5nbGUpO3RoaXMuY29uZS5zY2FsZS5zZXQoZCxkLGMpO2Euc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQubWF0cml4V29ybGQpO2Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTt0aGlzLmNvbmUubG9va0F0KGIuc3ViKGEpKTt0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSl9fSgpO1xuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlcj1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLm9iamVjdD1hO3RoaXMuc2l6ZT12b2lkIDAhPT1iP2I6MTtiPXZvaWQgMCE9PWM/YzoxNjcxMTY4MDtkPXZvaWQgMCE9PWQ/ZDoxO2M9bmV3IFRIUkVFLkdlb21ldHJ5O2E9YS5nZW9tZXRyeS5mYWNlcztmb3IodmFyIGU9MCxmPWEubGVuZ3RoO2U8ZjtlKyspZm9yKHZhciBnPTAsaD1hW2VdLnZlcnRleE5vcm1hbHMubGVuZ3RoO2c8aDtnKyspYy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzKTtUSFJFRS5MaW5lLmNhbGwodGhpcyxjLG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7Y29sb3I6YixsaW5ld2lkdGg6ZH0pLFRIUkVFLkxpbmVQaWVjZXMpO3RoaXMubWF0cml4QXV0b1VwZGF0ZT0hMTt0aGlzLm5vcm1hbE1hdHJpeD1uZXcgVEhSRUUuTWF0cml4Mzt0aGlzLnVwZGF0ZSgpfTtUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpbmUucHJvdG90eXBlKTtcblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXI7XG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGEpe2E9W1wiYVwiLFwiYlwiLFwiY1wiLFwiZFwiXTt0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCghMCk7dGhpcy5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkKTtmb3IodmFyIGQ9dGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyxlPXRoaXMub2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzLGY9dGhpcy5vYmplY3QuZ2VvbWV0cnkuZmFjZXMsZz10aGlzLm9iamVjdC5tYXRyaXhXb3JsZCxoPTAsaz0wLGw9Zi5sZW5ndGg7azxsO2srKylmb3IodmFyIHA9ZltrXSxxPTAsbj1wLnZlcnRleE5vcm1hbHMubGVuZ3RoO3E8bjtxKyspe3ZhciB0PXAudmVydGV4Tm9ybWFsc1txXTtkW2hdLmNvcHkoZVtwW2FbcV1dXSkuYXBwbHlNYXRyaXg0KGcpO2IuY29weSh0KS5hcHBseU1hdHJpeDModGhpcy5ub3JtYWxNYXRyaXgpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuc2l6ZSk7XG4gICAgYi5hZGQoZFtoXSk7aCs9MTtkW2hdLmNvcHkoYik7aCs9MX10aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZT0hMDtyZXR1cm4gdGhpc319KCk7XG5USFJFRS5WZXJ0ZXhUYW5nZW50c0hlbHBlcj1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLm9iamVjdD1hO3RoaXMuc2l6ZT12b2lkIDAhPT1iP2I6MTtiPXZvaWQgMCE9PWM/YzoyNTU7ZD12b2lkIDAhPT1kP2Q6MTtjPW5ldyBUSFJFRS5HZW9tZXRyeTthPWEuZ2VvbWV0cnkuZmFjZXM7Zm9yKHZhciBlPTAsZj1hLmxlbmd0aDtlPGY7ZSsrKWZvcih2YXIgZz0wLGg9YVtlXS52ZXJ0ZXhUYW5nZW50cy5sZW5ndGg7ZzxoO2crKyljLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMpLGMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyk7VEhSRUUuTGluZS5jYWxsKHRoaXMsYyxuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe2NvbG9yOmIsbGluZXdpZHRoOmR9KSxUSFJFRS5MaW5lUGllY2VzKTt0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ITE7dGhpcy51cGRhdGUoKX07VEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTGluZS5wcm90b3R5cGUpO1xuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyO1xuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYSl7YT1bXCJhXCIsXCJiXCIsXCJjXCIsXCJkXCJdO3RoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCEwKTtmb3IodmFyIGQ9dGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyxlPXRoaXMub2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzLGY9dGhpcy5vYmplY3QuZ2VvbWV0cnkuZmFjZXMsZz10aGlzLm9iamVjdC5tYXRyaXhXb3JsZCxoPTAsaz0wLGw9Zi5sZW5ndGg7azxsO2srKylmb3IodmFyIHA9ZltrXSxxPTAsbj1wLnZlcnRleFRhbmdlbnRzLmxlbmd0aDtxPG47cSsrKXt2YXIgdD1wLnZlcnRleFRhbmdlbnRzW3FdO2RbaF0uY29weShlW3BbYVtxXV1dKS5hcHBseU1hdHJpeDQoZyk7Yi5jb3B5KHQpLnRyYW5zZm9ybURpcmVjdGlvbihnKS5tdWx0aXBseVNjYWxhcih0aGlzLnNpemUpO2IuYWRkKGRbaF0pO2grPTE7ZFtoXS5jb3B5KGIpO1xuICAgIGgrPTF9dGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU9ITA7cmV0dXJuIHRoaXN9fSgpO1xuVEhSRUUuV2lyZWZyYW1lSGVscGVyPWZ1bmN0aW9uKGEsYil7dmFyIGM9dm9pZCAwIT09Yj9iOjE2Nzc3MjE1LGQ9WzAsMF0sZT17fSxmPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0sZz1bXCJhXCIsXCJiXCIsXCJjXCJdLGg9bmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5O2lmKGEuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSl7Zm9yKHZhciBrPWEuZ2VvbWV0cnkudmVydGljZXMsbD1hLmdlb21ldHJ5LmZhY2VzLHA9MCxxPW5ldyBVaW50MzJBcnJheSg2KmwubGVuZ3RoKSxuPTAsdD1sLmxlbmd0aDtuPHQ7bisrKWZvcih2YXIgcj1sW25dLHM9MDszPnM7cysrKXtkWzBdPXJbZ1tzXV07ZFsxXT1yW2dbKHMrMSklM11dO2Quc29ydChmKTt2YXIgdT1kLnRvU3RyaW5nKCk7dm9pZCAwPT09ZVt1XSYmKHFbMipwXT1kWzBdLHFbMipwKzFdPWRbMV0sZVt1XT0hMCxwKyspfWQ9bmV3IEZsb2F0MzJBcnJheSg2KnApO249MDtmb3IodD1wO248dDtuKyspZm9yKHM9MDsyPnM7cysrKXA9XG4gICAga1txWzIqbitzXV0sZz02Km4rMypzLGRbZyswXT1wLngsZFtnKzFdPXAueSxkW2crMl09cC56O2guYWRkQXR0cmlidXRlKFwicG9zaXRpb25cIixuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGQsMykpfWVsc2UgaWYoYS5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5KXtpZih2b2lkIDAhPT1hLmdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5kZXgpe2s9YS5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O3Q9YS5nZW9tZXRyeS5hdHRyaWJ1dGVzLmluZGV4LmFycmF5O2w9YS5nZW9tZXRyeS5kcmF3Y2FsbHM7cD0wOzA9PT1sLmxlbmd0aCYmKGw9W3tjb3VudDp0Lmxlbmd0aCxpbmRleDowLHN0YXJ0OjB9XSk7Zm9yKHZhciBxPW5ldyBVaW50MzJBcnJheSgyKnQubGVuZ3RoKSxyPTAsdj1sLmxlbmd0aDtyPHY7KytyKWZvcih2YXIgcz1sW3JdLnN0YXJ0LHU9bFtyXS5jb3VudCxnPWxbcl0uaW5kZXgsbj1zLHg9cyt1O248eDtuKz0zKWZvcihzPTA7Mz5zO3MrKylkWzBdPVxuICAgIGcrdFtuK3NdLGRbMV09Zyt0W24rKHMrMSklM10sZC5zb3J0KGYpLHU9ZC50b1N0cmluZygpLHZvaWQgMD09PWVbdV0mJihxWzIqcF09ZFswXSxxWzIqcCsxXT1kWzFdLGVbdV09ITAscCsrKTtkPW5ldyBGbG9hdDMyQXJyYXkoNipwKTtuPTA7Zm9yKHQ9cDtuPHQ7bisrKWZvcihzPTA7Mj5zO3MrKylnPTYqbiszKnMscD0zKnFbMipuK3NdLGRbZyswXT1rW3BdLGRbZysxXT1rW3ArMV0sZFtnKzJdPWtbcCsyXX1lbHNlIGZvcihrPWEuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSxwPWsubGVuZ3RoLzMscT1wLzMsZD1uZXcgRmxvYXQzMkFycmF5KDYqcCksbj0wLHQ9cTtuPHQ7bisrKWZvcihzPTA7Mz5zO3MrKylnPTE4Km4rNipzLHE9OSpuKzMqcyxkW2crMF09a1txXSxkW2crMV09a1txKzFdLGRbZysyXT1rW3ErMl0scD05Km4rKHMrMSklMyozLGRbZyszXT1rW3BdLGRbZys0XT1rW3ArMV0sZFtnKzVdPWtbcCsyXTtoLmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShkLFxuICAgIDMpKX1USFJFRS5MaW5lLmNhbGwodGhpcyxoLG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7Y29sb3I6Y30pLFRIUkVFLkxpbmVQaWVjZXMpO3RoaXMubWF0cml4PWEubWF0cml4V29ybGQ7dGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExfTtUSFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTGluZS5wcm90b3R5cGUpO1RIUkVFLldpcmVmcmFtZUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3I9VEhSRUUuV2lyZWZyYW1lSGVscGVyO1RIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdD1mdW5jdGlvbigpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy5yZW5kZXI9ZnVuY3Rpb24oYSl7fX07VEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3Q7XG5USFJFRS5Nb3JwaEJsZW5kTWVzaD1mdW5jdGlvbihhLGIpe1RIUkVFLk1lc2guY2FsbCh0aGlzLGEsYik7dGhpcy5hbmltYXRpb25zTWFwPXt9O3RoaXMuYW5pbWF0aW9uc0xpc3Q9W107dmFyIGM9dGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO3RoaXMuY3JlYXRlQW5pbWF0aW9uKFwiX19kZWZhdWx0XCIsMCxjLTEsYy8xKTt0aGlzLnNldEFuaW1hdGlvbldlaWdodChcIl9fZGVmYXVsdFwiLDEpfTtUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NZXNoLnByb3RvdHlwZSk7VEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRIUkVFLk1vcnBoQmxlbmRNZXNoO1xuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNyZWF0ZUFuaW1hdGlvbj1mdW5jdGlvbihhLGIsYyxkKXtiPXtzdGFydEZyYW1lOmIsZW5kRnJhbWU6YyxsZW5ndGg6Yy1iKzEsZnBzOmQsZHVyYXRpb246KGMtYikvZCxsYXN0RnJhbWU6MCxjdXJyZW50RnJhbWU6MCxhY3RpdmU6ITEsdGltZTowLGRpcmVjdGlvbjoxLHdlaWdodDoxLGRpcmVjdGlvbkJhY2t3YXJkczohMSxtaXJyb3JlZExvb3A6ITF9O3RoaXMuYW5pbWF0aW9uc01hcFthXT1iO3RoaXMuYW5pbWF0aW9uc0xpc3QucHVzaChiKX07XG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPS8oW2Etel0rKV8/KFxcZCspLyxjLGQ9e30sZT10aGlzLmdlb21ldHJ5LGY9MCxnPWUubW9ycGhUYXJnZXRzLmxlbmd0aDtmPGc7ZisrKXt2YXIgaD1lLm1vcnBoVGFyZ2V0c1tmXS5uYW1lLm1hdGNoKGIpO2lmKGgmJjE8aC5sZW5ndGgpe3ZhciBrPWhbMV07ZFtrXXx8KGRba109e3N0YXJ0OkluZmluaXR5LGVuZDotSW5maW5pdHl9KTtoPWRba107ZjxoLnN0YXJ0JiYoaC5zdGFydD1mKTtmPmguZW5kJiYoaC5lbmQ9Zik7Y3x8KGM9ayl9fWZvcihrIGluIGQpaD1kW2tdLHRoaXMuY3JlYXRlQW5pbWF0aW9uKGssaC5zdGFydCxoLmVuZCxhKTt0aGlzLmZpcnN0QW5pbWF0aW9uPWN9O1xuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQ9ZnVuY3Rpb24oYSl7aWYoYT10aGlzLmFuaW1hdGlvbnNNYXBbYV0pYS5kaXJlY3Rpb249MSxhLmRpcmVjdGlvbkJhY2t3YXJkcz0hMX07VEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkJhY2t3YXJkPWZ1bmN0aW9uKGEpe2lmKGE9dGhpcy5hbmltYXRpb25zTWFwW2FdKWEuZGlyZWN0aW9uPS0xLGEuZGlyZWN0aW9uQmFja3dhcmRzPSEwfTtUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRlBTPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5hbmltYXRpb25zTWFwW2FdO2MmJihjLmZwcz1iLGMuZHVyYXRpb249KGMuZW5kLWMuc3RhcnQpL2MuZnBzKX07XG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmFuaW1hdGlvbnNNYXBbYV07YyYmKGMuZHVyYXRpb249YixjLmZwcz0oYy5lbmQtYy5zdGFydCkvYy5kdXJhdGlvbil9O1RIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25XZWlnaHQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmFuaW1hdGlvbnNNYXBbYV07YyYmKGMud2VpZ2h0PWIpfTtUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuYW5pbWF0aW9uc01hcFthXTtjJiYoYy50aW1lPWIpfTtUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZT1mdW5jdGlvbihhKXt2YXIgYj0wO2lmKGE9dGhpcy5hbmltYXRpb25zTWFwW2FdKWI9YS50aW1lO3JldHVybiBifTtcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25EdXJhdGlvbj1mdW5jdGlvbihhKXt2YXIgYj0tMTtpZihhPXRoaXMuYW5pbWF0aW9uc01hcFthXSliPWEuZHVyYXRpb247cmV0dXJuIGJ9O1RIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYW5pbWF0aW9uc01hcFthXTtiPyhiLnRpbWU9MCxiLmFjdGl2ZT0hMCk6VEhSRUUud2FybihcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIrYStcIl0gdW5kZWZpbmVkIGluIC5wbGF5QW5pbWF0aW9uKClcIil9O1RIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uPWZ1bmN0aW9uKGEpe2lmKGE9dGhpcy5hbmltYXRpb25zTWFwW2FdKWEuYWN0aXZlPSExfTtcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTAsYz10aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDtiPGM7YisrKXt2YXIgZD10aGlzLmFuaW1hdGlvbnNMaXN0W2JdO2lmKGQuYWN0aXZlKXt2YXIgZT1kLmR1cmF0aW9uL2QubGVuZ3RoO2QudGltZSs9ZC5kaXJlY3Rpb24qYTtpZihkLm1pcnJvcmVkTG9vcCl7aWYoZC50aW1lPmQuZHVyYXRpb258fDA+ZC50aW1lKWQuZGlyZWN0aW9uKj0tMSxkLnRpbWU+ZC5kdXJhdGlvbiYmKGQudGltZT1kLmR1cmF0aW9uLGQuZGlyZWN0aW9uQmFja3dhcmRzPSEwKSwwPmQudGltZSYmKGQudGltZT0wLGQuZGlyZWN0aW9uQmFja3dhcmRzPSExKX1lbHNlIGQudGltZSU9ZC5kdXJhdGlvbiwwPmQudGltZSYmKGQudGltZSs9ZC5kdXJhdGlvbik7dmFyIGY9ZC5zdGFydEZyYW1lK1RIUkVFLk1hdGguY2xhbXAoTWF0aC5mbG9vcihkLnRpbWUvZSksMCxkLmxlbmd0aC0xKSxnPWQud2VpZ2h0O1xuICAgIGYhPT1kLmN1cnJlbnRGcmFtZSYmKHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2QubGFzdEZyYW1lXT0wLHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2QuY3VycmVudEZyYW1lXT0xKmcsdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbZl09MCxkLmxhc3RGcmFtZT1kLmN1cnJlbnRGcmFtZSxkLmN1cnJlbnRGcmFtZT1mKTtlPWQudGltZSVlL2U7ZC5kaXJlY3Rpb25CYWNrd2FyZHMmJihlPTEtZSk7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbZC5jdXJyZW50RnJhbWVdPWUqZzt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tkLmxhc3RGcmFtZV09KDEtZSkqZ319fTsiLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBuKG4pe2Z1bmN0aW9uIHQodCxyLGUsdSxpLG8pe2Zvcig7aT49MCYmbz5pO2krPW4pe3ZhciBhPXU/dVtpXTppO2U9cihlLHRbYV0sYSx0KX1yZXR1cm4gZX1yZXR1cm4gZnVuY3Rpb24ocixlLHUsaSl7ZT1iKGUsaSw0KTt2YXIgbz0hayhyKSYmbS5rZXlzKHIpLGE9KG98fHIpLmxlbmd0aCxjPW4+MD8wOmEtMTtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aDwzJiYodT1yW28/b1tjXTpjXSxjKz1uKSx0KHIsZSx1LG8sYyxhKX19ZnVuY3Rpb24gdChuKXtyZXR1cm4gZnVuY3Rpb24odCxyLGUpe3I9eChyLGUpO2Zvcih2YXIgdT1PKHQpLGk9bj4wPzA6dS0xO2k+PTAmJnU+aTtpKz1uKWlmKHIodFtpXSxpLHQpKXJldHVybiBpO3JldHVybi0xfX1mdW5jdGlvbiByKG4sdCxyKXtyZXR1cm4gZnVuY3Rpb24oZSx1LGkpe3ZhciBvPTAsYT1PKGUpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBpKW4+MD9vPWk+PTA/aTpNYXRoLm1heChpK2Esbyk6YT1pPj0wP01hdGgubWluKGkrMSxhKTppK2ErMTtlbHNlIGlmKHImJmkmJmEpcmV0dXJuIGk9cihlLHUpLGVbaV09PT11P2k6LTE7aWYodSE9PXUpcmV0dXJuIGk9dChsLmNhbGwoZSxvLGEpLG0uaXNOYU4pLGk+PTA/aStvOi0xO2ZvcihpPW4+MD9vOmEtMTtpPj0wJiZhPmk7aSs9bilpZihlW2ldPT09dSlyZXR1cm4gaTtyZXR1cm4tMX19ZnVuY3Rpb24gZShuLHQpe3ZhciByPUkubGVuZ3RoLGU9bi5jb25zdHJ1Y3Rvcix1PW0uaXNGdW5jdGlvbihlKSYmZS5wcm90b3R5cGV8fGEsaT1cImNvbnN0cnVjdG9yXCI7Zm9yKG0uaGFzKG4saSkmJiFtLmNvbnRhaW5zKHQsaSkmJnQucHVzaChpKTtyLS07KWk9SVtyXSxpIGluIG4mJm5baV0hPT11W2ldJiYhbS5jb250YWlucyh0LGkpJiZ0LnB1c2goaSl9dmFyIHU9dGhpcyxpPXUuXyxvPUFycmF5LnByb3RvdHlwZSxhPU9iamVjdC5wcm90b3R5cGUsYz1GdW5jdGlvbi5wcm90b3R5cGUsZj1vLnB1c2gsbD1vLnNsaWNlLHM9YS50b1N0cmluZyxwPWEuaGFzT3duUHJvcGVydHksaD1BcnJheS5pc0FycmF5LHY9T2JqZWN0LmtleXMsZz1jLmJpbmQseT1PYmplY3QuY3JlYXRlLGQ9ZnVuY3Rpb24oKXt9LG09ZnVuY3Rpb24obil7cmV0dXJuIG4gaW5zdGFuY2VvZiBtP246dGhpcyBpbnN0YW5jZW9mIG0/dm9pZCh0aGlzLl93cmFwcGVkPW4pOm5ldyBtKG4pfTtcInVuZGVmaW5lZFwiIT10eXBlb2YgZXhwb3J0cz8oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJihleHBvcnRzPW1vZHVsZS5leHBvcnRzPW0pLGV4cG9ydHMuXz1tKTp1Ll89bSxtLlZFUlNJT049XCIxLjguM1wiO3ZhciBiPWZ1bmN0aW9uKG4sdCxyKXtpZih0PT09dm9pZCAwKXJldHVybiBuO3N3aXRjaChudWxsPT1yPzM6cil7Y2FzZSAxOnJldHVybiBmdW5jdGlvbihyKXtyZXR1cm4gbi5jYWxsKHQscil9O2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24ocixlKXtyZXR1cm4gbi5jYWxsKHQscixlKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihyLGUsdSl7cmV0dXJuIG4uY2FsbCh0LHIsZSx1KX07Y2FzZSA0OnJldHVybiBmdW5jdGlvbihyLGUsdSxpKXtyZXR1cm4gbi5jYWxsKHQscixlLHUsaSl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuLmFwcGx5KHQsYXJndW1lbnRzKX19LHg9ZnVuY3Rpb24obix0LHIpe3JldHVybiBudWxsPT1uP20uaWRlbnRpdHk6bS5pc0Z1bmN0aW9uKG4pP2Iobix0LHIpOm0uaXNPYmplY3Qobik/bS5tYXRjaGVyKG4pOm0ucHJvcGVydHkobil9O20uaXRlcmF0ZWU9ZnVuY3Rpb24obix0KXtyZXR1cm4geChuLHQsMS8wKX07dmFyIF89ZnVuY3Rpb24obix0KXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIGU9YXJndW1lbnRzLmxlbmd0aDtpZigyPmV8fG51bGw9PXIpcmV0dXJuIHI7Zm9yKHZhciB1PTE7ZT51O3UrKylmb3IodmFyIGk9YXJndW1lbnRzW3VdLG89bihpKSxhPW8ubGVuZ3RoLGM9MDthPmM7YysrKXt2YXIgZj1vW2NdO3QmJnJbZl0hPT12b2lkIDB8fChyW2ZdPWlbZl0pfXJldHVybiByfX0saj1mdW5jdGlvbihuKXtpZighbS5pc09iamVjdChuKSlyZXR1cm57fTtpZih5KXJldHVybiB5KG4pO2QucHJvdG90eXBlPW47dmFyIHQ9bmV3IGQ7cmV0dXJuIGQucHJvdG90eXBlPW51bGwsdH0sdz1mdW5jdGlvbihuKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXQ/dm9pZCAwOnRbbl19fSxBPU1hdGgucG93KDIsNTMpLTEsTz13KFwibGVuZ3RoXCIpLGs9ZnVuY3Rpb24obil7dmFyIHQ9TyhuKTtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmdD49MCYmQT49dH07bS5lYWNoPW0uZm9yRWFjaD1mdW5jdGlvbihuLHQscil7dD1iKHQscik7dmFyIGUsdTtpZihrKG4pKWZvcihlPTAsdT1uLmxlbmd0aDt1PmU7ZSsrKXQobltlXSxlLG4pO2Vsc2V7dmFyIGk9bS5rZXlzKG4pO2ZvcihlPTAsdT1pLmxlbmd0aDt1PmU7ZSsrKXQobltpW2VdXSxpW2VdLG4pfXJldHVybiBufSxtLm1hcD1tLmNvbGxlY3Q9ZnVuY3Rpb24obix0LHIpe3Q9eCh0LHIpO2Zvcih2YXIgZT0hayhuKSYmbS5rZXlzKG4pLHU9KGV8fG4pLmxlbmd0aCxpPUFycmF5KHUpLG89MDt1Pm87bysrKXt2YXIgYT1lP2Vbb106bztpW29dPXQoblthXSxhLG4pfXJldHVybiBpfSxtLnJlZHVjZT1tLmZvbGRsPW0uaW5qZWN0PW4oMSksbS5yZWR1Y2VSaWdodD1tLmZvbGRyPW4oLTEpLG0uZmluZD1tLmRldGVjdD1mdW5jdGlvbihuLHQscil7dmFyIGU7cmV0dXJuIGU9ayhuKT9tLmZpbmRJbmRleChuLHQscik6bS5maW5kS2V5KG4sdCxyKSxlIT09dm9pZCAwJiZlIT09LTE/bltlXTp2b2lkIDB9LG0uZmlsdGVyPW0uc2VsZWN0PWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT1bXTtyZXR1cm4gdD14KHQsciksbS5lYWNoKG4sZnVuY3Rpb24obixyLHUpe3QobixyLHUpJiZlLnB1c2gobil9KSxlfSxtLnJlamVjdD1mdW5jdGlvbihuLHQscil7cmV0dXJuIG0uZmlsdGVyKG4sbS5uZWdhdGUoeCh0KSkscil9LG0uZXZlcnk9bS5hbGw9ZnVuY3Rpb24obix0LHIpe3Q9eCh0LHIpO2Zvcih2YXIgZT0hayhuKSYmbS5rZXlzKG4pLHU9KGV8fG4pLmxlbmd0aCxpPTA7dT5pO2krKyl7dmFyIG89ZT9lW2ldOmk7aWYoIXQobltvXSxvLG4pKXJldHVybiExfXJldHVybiEwfSxtLnNvbWU9bS5hbnk9ZnVuY3Rpb24obix0LHIpe3Q9eCh0LHIpO2Zvcih2YXIgZT0hayhuKSYmbS5rZXlzKG4pLHU9KGV8fG4pLmxlbmd0aCxpPTA7dT5pO2krKyl7dmFyIG89ZT9lW2ldOmk7aWYodChuW29dLG8sbikpcmV0dXJuITB9cmV0dXJuITF9LG0uY29udGFpbnM9bS5pbmNsdWRlcz1tLmluY2x1ZGU9ZnVuY3Rpb24obix0LHIsZSl7cmV0dXJuIGsobil8fChuPW0udmFsdWVzKG4pKSwoXCJudW1iZXJcIiE9dHlwZW9mIHJ8fGUpJiYocj0wKSxtLmluZGV4T2Yobix0LHIpPj0wfSxtLmludm9rZT1mdW5jdGlvbihuLHQpe3ZhciByPWwuY2FsbChhcmd1bWVudHMsMiksZT1tLmlzRnVuY3Rpb24odCk7cmV0dXJuIG0ubWFwKG4sZnVuY3Rpb24obil7dmFyIHU9ZT90Om5bdF07cmV0dXJuIG51bGw9PXU/dTp1LmFwcGx5KG4scil9KX0sbS5wbHVjaz1mdW5jdGlvbihuLHQpe3JldHVybiBtLm1hcChuLG0ucHJvcGVydHkodCkpfSxtLndoZXJlPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG0uZmlsdGVyKG4sbS5tYXRjaGVyKHQpKX0sbS5maW5kV2hlcmU9ZnVuY3Rpb24obix0KXtyZXR1cm4gbS5maW5kKG4sbS5tYXRjaGVyKHQpKX0sbS5tYXg9ZnVuY3Rpb24obix0LHIpe3ZhciBlLHUsaT0tMS8wLG89LTEvMDtpZihudWxsPT10JiZudWxsIT1uKXtuPWsobik/bjptLnZhbHVlcyhuKTtmb3IodmFyIGE9MCxjPW4ubGVuZ3RoO2M+YTthKyspZT1uW2FdLGU+aSYmKGk9ZSl9ZWxzZSB0PXgodCxyKSxtLmVhY2gobixmdW5jdGlvbihuLHIsZSl7dT10KG4scixlKSwodT5vfHx1PT09LTEvMCYmaT09PS0xLzApJiYoaT1uLG89dSl9KTtyZXR1cm4gaX0sbS5taW49ZnVuY3Rpb24obix0LHIpe3ZhciBlLHUsaT0xLzAsbz0xLzA7aWYobnVsbD09dCYmbnVsbCE9bil7bj1rKG4pP246bS52YWx1ZXMobik7Zm9yKHZhciBhPTAsYz1uLmxlbmd0aDtjPmE7YSsrKWU9blthXSxpPmUmJihpPWUpfWVsc2UgdD14KHQsciksbS5lYWNoKG4sZnVuY3Rpb24obixyLGUpe3U9dChuLHIsZSksKG8+dXx8MS8wPT09dSYmMS8wPT09aSkmJihpPW4sbz11KX0pO3JldHVybiBpfSxtLnNodWZmbGU9ZnVuY3Rpb24obil7Zm9yKHZhciB0LHI9ayhuKT9uOm0udmFsdWVzKG4pLGU9ci5sZW5ndGgsdT1BcnJheShlKSxpPTA7ZT5pO2krKyl0PW0ucmFuZG9tKDAsaSksdCE9PWkmJih1W2ldPXVbdF0pLHVbdF09cltpXTtyZXR1cm4gdX0sbS5zYW1wbGU9ZnVuY3Rpb24obix0LHIpe3JldHVybiBudWxsPT10fHxyPyhrKG4pfHwobj1tLnZhbHVlcyhuKSksblttLnJhbmRvbShuLmxlbmd0aC0xKV0pOm0uc2h1ZmZsZShuKS5zbGljZSgwLE1hdGgubWF4KDAsdCkpfSxtLnNvcnRCeT1mdW5jdGlvbihuLHQscil7cmV0dXJuIHQ9eCh0LHIpLG0ucGx1Y2sobS5tYXAobixmdW5jdGlvbihuLHIsZSl7cmV0dXJue3ZhbHVlOm4saW5kZXg6cixjcml0ZXJpYTp0KG4scixlKX19KS5zb3J0KGZ1bmN0aW9uKG4sdCl7dmFyIHI9bi5jcml0ZXJpYSxlPXQuY3JpdGVyaWE7aWYociE9PWUpe2lmKHI+ZXx8cj09PXZvaWQgMClyZXR1cm4gMTtpZihlPnJ8fGU9PT12b2lkIDApcmV0dXJuLTF9cmV0dXJuIG4uaW5kZXgtdC5pbmRleH0pLFwidmFsdWVcIil9O3ZhciBGPWZ1bmN0aW9uKG4pe3JldHVybiBmdW5jdGlvbih0LHIsZSl7dmFyIHU9e307cmV0dXJuIHI9eChyLGUpLG0uZWFjaCh0LGZ1bmN0aW9uKGUsaSl7dmFyIG89cihlLGksdCk7bih1LGUsbyl9KSx1fX07bS5ncm91cEJ5PUYoZnVuY3Rpb24obix0LHIpe20uaGFzKG4scik/bltyXS5wdXNoKHQpOm5bcl09W3RdfSksbS5pbmRleEJ5PUYoZnVuY3Rpb24obix0LHIpe25bcl09dH0pLG0uY291bnRCeT1GKGZ1bmN0aW9uKG4sdCxyKXttLmhhcyhuLHIpP25bcl0rKzpuW3JdPTF9KSxtLnRvQXJyYXk9ZnVuY3Rpb24obil7cmV0dXJuIG4/bS5pc0FycmF5KG4pP2wuY2FsbChuKTprKG4pP20ubWFwKG4sbS5pZGVudGl0eSk6bS52YWx1ZXMobik6W119LG0uc2l6ZT1mdW5jdGlvbihuKXtyZXR1cm4gbnVsbD09bj8wOmsobik/bi5sZW5ndGg6bS5rZXlzKG4pLmxlbmd0aH0sbS5wYXJ0aXRpb249ZnVuY3Rpb24obix0LHIpe3Q9eCh0LHIpO3ZhciBlPVtdLHU9W107cmV0dXJuIG0uZWFjaChuLGZ1bmN0aW9uKG4scixpKXsodChuLHIsaSk/ZTp1KS5wdXNoKG4pfSksW2UsdV19LG0uZmlyc3Q9bS5oZWFkPW0udGFrZT1mdW5jdGlvbihuLHQscil7cmV0dXJuIG51bGw9PW4/dm9pZCAwOm51bGw9PXR8fHI/blswXTptLmluaXRpYWwobixuLmxlbmd0aC10KX0sbS5pbml0aWFsPWZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbC5jYWxsKG4sMCxNYXRoLm1heCgwLG4ubGVuZ3RoLShudWxsPT10fHxyPzE6dCkpKX0sbS5sYXN0PWZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbnVsbD09bj92b2lkIDA6bnVsbD09dHx8cj9uW24ubGVuZ3RoLTFdOm0ucmVzdChuLE1hdGgubWF4KDAsbi5sZW5ndGgtdCkpfSxtLnJlc3Q9bS50YWlsPW0uZHJvcD1mdW5jdGlvbihuLHQscil7cmV0dXJuIGwuY2FsbChuLG51bGw9PXR8fHI/MTp0KX0sbS5jb21wYWN0PWZ1bmN0aW9uKG4pe3JldHVybiBtLmZpbHRlcihuLG0uaWRlbnRpdHkpfTt2YXIgUz1mdW5jdGlvbihuLHQscixlKXtmb3IodmFyIHU9W10saT0wLG89ZXx8MCxhPU8obik7YT5vO28rKyl7dmFyIGM9bltvXTtpZihrKGMpJiYobS5pc0FycmF5KGMpfHxtLmlzQXJndW1lbnRzKGMpKSl7dHx8KGM9UyhjLHQscikpO3ZhciBmPTAsbD1jLmxlbmd0aDtmb3IodS5sZW5ndGgrPWw7bD5mOyl1W2krK109Y1tmKytdfWVsc2Ugcnx8KHVbaSsrXT1jKX1yZXR1cm4gdX07bS5mbGF0dGVuPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIFMobix0LCExKX0sbS53aXRob3V0PWZ1bmN0aW9uKG4pe3JldHVybiBtLmRpZmZlcmVuY2UobixsLmNhbGwoYXJndW1lbnRzLDEpKX0sbS51bmlxPW0udW5pcXVlPWZ1bmN0aW9uKG4sdCxyLGUpe20uaXNCb29sZWFuKHQpfHwoZT1yLHI9dCx0PSExKSxudWxsIT1yJiYocj14KHIsZSkpO2Zvcih2YXIgdT1bXSxpPVtdLG89MCxhPU8obik7YT5vO28rKyl7dmFyIGM9bltvXSxmPXI/cihjLG8sbik6Yzt0PyhvJiZpPT09Znx8dS5wdXNoKGMpLGk9Zik6cj9tLmNvbnRhaW5zKGksZil8fChpLnB1c2goZiksdS5wdXNoKGMpKTptLmNvbnRhaW5zKHUsYyl8fHUucHVzaChjKX1yZXR1cm4gdX0sbS51bmlvbj1mdW5jdGlvbigpe3JldHVybiBtLnVuaXEoUyhhcmd1bWVudHMsITAsITApKX0sbS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24obil7Zm9yKHZhciB0PVtdLHI9YXJndW1lbnRzLmxlbmd0aCxlPTAsdT1PKG4pO3U+ZTtlKyspe3ZhciBpPW5bZV07aWYoIW0uY29udGFpbnModCxpKSl7Zm9yKHZhciBvPTE7cj5vJiZtLmNvbnRhaW5zKGFyZ3VtZW50c1tvXSxpKTtvKyspO289PT1yJiZ0LnB1c2goaSl9fXJldHVybiB0fSxtLmRpZmZlcmVuY2U9ZnVuY3Rpb24obil7dmFyIHQ9Uyhhcmd1bWVudHMsITAsITAsMSk7cmV0dXJuIG0uZmlsdGVyKG4sZnVuY3Rpb24obil7cmV0dXJuIW0uY29udGFpbnModCxuKX0pfSxtLnppcD1mdW5jdGlvbigpe3JldHVybiBtLnVuemlwKGFyZ3VtZW50cyl9LG0udW56aXA9ZnVuY3Rpb24obil7Zm9yKHZhciB0PW4mJm0ubWF4KG4sTykubGVuZ3RofHwwLHI9QXJyYXkodCksZT0wO3Q+ZTtlKyspcltlXT1tLnBsdWNrKG4sZSk7cmV0dXJuIHJ9LG0ub2JqZWN0PWZ1bmN0aW9uKG4sdCl7Zm9yKHZhciByPXt9LGU9MCx1PU8obik7dT5lO2UrKyl0P3JbbltlXV09dFtlXTpyW25bZV1bMF1dPW5bZV1bMV07cmV0dXJuIHJ9LG0uZmluZEluZGV4PXQoMSksbS5maW5kTGFzdEluZGV4PXQoLTEpLG0uc29ydGVkSW5kZXg9ZnVuY3Rpb24obix0LHIsZSl7cj14KHIsZSwxKTtmb3IodmFyIHU9cih0KSxpPTAsbz1PKG4pO28+aTspe3ZhciBhPU1hdGguZmxvb3IoKGkrbykvMik7cihuW2FdKTx1P2k9YSsxOm89YX1yZXR1cm4gaX0sbS5pbmRleE9mPXIoMSxtLmZpbmRJbmRleCxtLnNvcnRlZEluZGV4KSxtLmxhc3RJbmRleE9mPXIoLTEsbS5maW5kTGFzdEluZGV4KSxtLnJhbmdlPWZ1bmN0aW9uKG4sdCxyKXtudWxsPT10JiYodD1ufHwwLG49MCkscj1yfHwxO2Zvcih2YXIgZT1NYXRoLm1heChNYXRoLmNlaWwoKHQtbikvciksMCksdT1BcnJheShlKSxpPTA7ZT5pO2krKyxuKz1yKXVbaV09bjtyZXR1cm4gdX07dmFyIEU9ZnVuY3Rpb24obix0LHIsZSx1KXtpZighKGUgaW5zdGFuY2VvZiB0KSlyZXR1cm4gbi5hcHBseShyLHUpO3ZhciBpPWoobi5wcm90b3R5cGUpLG89bi5hcHBseShpLHUpO3JldHVybiBtLmlzT2JqZWN0KG8pP286aX07bS5iaW5kPWZ1bmN0aW9uKG4sdCl7aWYoZyYmbi5iaW5kPT09ZylyZXR1cm4gZy5hcHBseShuLGwuY2FsbChhcmd1bWVudHMsMSkpO2lmKCFtLmlzRnVuY3Rpb24obikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvblwiKTt2YXIgcj1sLmNhbGwoYXJndW1lbnRzLDIpLGU9ZnVuY3Rpb24oKXtyZXR1cm4gRShuLGUsdCx0aGlzLHIuY29uY2F0KGwuY2FsbChhcmd1bWVudHMpKSl9O3JldHVybiBlfSxtLnBhcnRpYWw9ZnVuY3Rpb24obil7dmFyIHQ9bC5jYWxsKGFyZ3VtZW50cywxKSxyPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPTAsdT10Lmxlbmd0aCxpPUFycmF5KHUpLG89MDt1Pm87bysrKWlbb109dFtvXT09PW0/YXJndW1lbnRzW2UrK106dFtvXTtmb3IoO2U8YXJndW1lbnRzLmxlbmd0aDspaS5wdXNoKGFyZ3VtZW50c1tlKytdKTtyZXR1cm4gRShuLHIsdGhpcyx0aGlzLGkpfTtyZXR1cm4gcn0sbS5iaW5kQWxsPWZ1bmN0aW9uKG4pe3ZhciB0LHIsZT1hcmd1bWVudHMubGVuZ3RoO2lmKDE+PWUpdGhyb3cgbmV3IEVycm9yKFwiYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lc1wiKTtmb3IodD0xO2U+dDt0Kyspcj1hcmd1bWVudHNbdF0sbltyXT1tLmJpbmQobltyXSxuKTtyZXR1cm4gbn0sbS5tZW1vaXplPWZ1bmN0aW9uKG4sdCl7dmFyIHI9ZnVuY3Rpb24oZSl7dmFyIHU9ci5jYWNoZSxpPVwiXCIrKHQ/dC5hcHBseSh0aGlzLGFyZ3VtZW50cyk6ZSk7cmV0dXJuIG0uaGFzKHUsaSl8fCh1W2ldPW4uYXBwbHkodGhpcyxhcmd1bWVudHMpKSx1W2ldfTtyZXR1cm4gci5jYWNoZT17fSxyfSxtLmRlbGF5PWZ1bmN0aW9uKG4sdCl7dmFyIHI9bC5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBuLmFwcGx5KG51bGwscil9LHQpfSxtLmRlZmVyPW0ucGFydGlhbChtLmRlbGF5LG0sMSksbS50aHJvdHRsZT1mdW5jdGlvbihuLHQscil7dmFyIGUsdSxpLG89bnVsbCxhPTA7cnx8KHI9e30pO3ZhciBjPWZ1bmN0aW9uKCl7YT1yLmxlYWRpbmc9PT0hMT8wOm0ubm93KCksbz1udWxsLGk9bi5hcHBseShlLHUpLG98fChlPXU9bnVsbCl9O3JldHVybiBmdW5jdGlvbigpe3ZhciBmPW0ubm93KCk7YXx8ci5sZWFkaW5nIT09ITF8fChhPWYpO3ZhciBsPXQtKGYtYSk7cmV0dXJuIGU9dGhpcyx1PWFyZ3VtZW50cywwPj1sfHxsPnQ/KG8mJihjbGVhclRpbWVvdXQobyksbz1udWxsKSxhPWYsaT1uLmFwcGx5KGUsdSksb3x8KGU9dT1udWxsKSk6b3x8ci50cmFpbGluZz09PSExfHwobz1zZXRUaW1lb3V0KGMsbCkpLGl9fSxtLmRlYm91bmNlPWZ1bmN0aW9uKG4sdCxyKXt2YXIgZSx1LGksbyxhLGM9ZnVuY3Rpb24oKXt2YXIgZj1tLm5vdygpLW87dD5mJiZmPj0wP2U9c2V0VGltZW91dChjLHQtZik6KGU9bnVsbCxyfHwoYT1uLmFwcGx5KGksdSksZXx8KGk9dT1udWxsKSkpfTtyZXR1cm4gZnVuY3Rpb24oKXtpPXRoaXMsdT1hcmd1bWVudHMsbz1tLm5vdygpO3ZhciBmPXImJiFlO3JldHVybiBlfHwoZT1zZXRUaW1lb3V0KGMsdCkpLGYmJihhPW4uYXBwbHkoaSx1KSxpPXU9bnVsbCksYX19LG0ud3JhcD1mdW5jdGlvbihuLHQpe3JldHVybiBtLnBhcnRpYWwodCxuKX0sbS5uZWdhdGU9ZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIW4uYXBwbHkodGhpcyxhcmd1bWVudHMpfX0sbS5jb21wb3NlPWZ1bmN0aW9uKCl7dmFyIG49YXJndW1lbnRzLHQ9bi5sZW5ndGgtMTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIHI9dCxlPW5bdF0uYXBwbHkodGhpcyxhcmd1bWVudHMpO3ItLTspZT1uW3JdLmNhbGwodGhpcyxlKTtyZXR1cm4gZX19LG0uYWZ0ZXI9ZnVuY3Rpb24obix0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4tLW48MT90LmFwcGx5KHRoaXMsYXJndW1lbnRzKTp2b2lkIDB9fSxtLmJlZm9yZT1mdW5jdGlvbihuLHQpe3ZhciByO3JldHVybiBmdW5jdGlvbigpe3JldHVybi0tbj4wJiYocj10LmFwcGx5KHRoaXMsYXJndW1lbnRzKSksMT49biYmKHQ9bnVsbCkscn19LG0ub25jZT1tLnBhcnRpYWwobS5iZWZvcmUsMik7dmFyIE09IXt0b1N0cmluZzpudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInRvU3RyaW5nXCIpLEk9W1widmFsdWVPZlwiLFwiaXNQcm90b3R5cGVPZlwiLFwidG9TdHJpbmdcIixcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsXCJoYXNPd25Qcm9wZXJ0eVwiLFwidG9Mb2NhbGVTdHJpbmdcIl07bS5rZXlzPWZ1bmN0aW9uKG4pe2lmKCFtLmlzT2JqZWN0KG4pKXJldHVybltdO2lmKHYpcmV0dXJuIHYobik7dmFyIHQ9W107Zm9yKHZhciByIGluIG4pbS5oYXMobixyKSYmdC5wdXNoKHIpO3JldHVybiBNJiZlKG4sdCksdH0sbS5hbGxLZXlzPWZ1bmN0aW9uKG4pe2lmKCFtLmlzT2JqZWN0KG4pKXJldHVybltdO3ZhciB0PVtdO2Zvcih2YXIgciBpbiBuKXQucHVzaChyKTtyZXR1cm4gTSYmZShuLHQpLHR9LG0udmFsdWVzPWZ1bmN0aW9uKG4pe2Zvcih2YXIgdD1tLmtleXMobikscj10Lmxlbmd0aCxlPUFycmF5KHIpLHU9MDtyPnU7dSsrKWVbdV09blt0W3VdXTtyZXR1cm4gZX0sbS5tYXBPYmplY3Q9ZnVuY3Rpb24obix0LHIpe3Q9eCh0LHIpO2Zvcih2YXIgZSx1PW0ua2V5cyhuKSxpPXUubGVuZ3RoLG89e30sYT0wO2k+YTthKyspZT11W2FdLG9bZV09dChuW2VdLGUsbik7cmV0dXJuIG99LG0ucGFpcnM9ZnVuY3Rpb24obil7Zm9yKHZhciB0PW0ua2V5cyhuKSxyPXQubGVuZ3RoLGU9QXJyYXkociksdT0wO3I+dTt1KyspZVt1XT1bdFt1XSxuW3RbdV1dXTtyZXR1cm4gZX0sbS5pbnZlcnQ9ZnVuY3Rpb24obil7Zm9yKHZhciB0PXt9LHI9bS5rZXlzKG4pLGU9MCx1PXIubGVuZ3RoO3U+ZTtlKyspdFtuW3JbZV1dXT1yW2VdO3JldHVybiB0fSxtLmZ1bmN0aW9ucz1tLm1ldGhvZHM9ZnVuY3Rpb24obil7dmFyIHQ9W107Zm9yKHZhciByIGluIG4pbS5pc0Z1bmN0aW9uKG5bcl0pJiZ0LnB1c2gocik7cmV0dXJuIHQuc29ydCgpfSxtLmV4dGVuZD1fKG0uYWxsS2V5cyksbS5leHRlbmRPd249bS5hc3NpZ249XyhtLmtleXMpLG0uZmluZEtleT1mdW5jdGlvbihuLHQscil7dD14KHQscik7Zm9yKHZhciBlLHU9bS5rZXlzKG4pLGk9MCxvPXUubGVuZ3RoO28+aTtpKyspaWYoZT11W2ldLHQobltlXSxlLG4pKXJldHVybiBlfSxtLnBpY2s9ZnVuY3Rpb24obix0LHIpe3ZhciBlLHUsaT17fSxvPW47aWYobnVsbD09bylyZXR1cm4gaTttLmlzRnVuY3Rpb24odCk/KHU9bS5hbGxLZXlzKG8pLGU9Yih0LHIpKToodT1TKGFyZ3VtZW50cywhMSwhMSwxKSxlPWZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gdCBpbiByfSxvPU9iamVjdChvKSk7Zm9yKHZhciBhPTAsYz11Lmxlbmd0aDtjPmE7YSsrKXt2YXIgZj11W2FdLGw9b1tmXTtlKGwsZixvKSYmKGlbZl09bCl9cmV0dXJuIGl9LG0ub21pdD1mdW5jdGlvbihuLHQscil7aWYobS5pc0Z1bmN0aW9uKHQpKXQ9bS5uZWdhdGUodCk7ZWxzZXt2YXIgZT1tLm1hcChTKGFyZ3VtZW50cywhMSwhMSwxKSxTdHJpbmcpO3Q9ZnVuY3Rpb24obix0KXtyZXR1cm4hbS5jb250YWlucyhlLHQpfX1yZXR1cm4gbS5waWNrKG4sdCxyKX0sbS5kZWZhdWx0cz1fKG0uYWxsS2V5cywhMCksbS5jcmVhdGU9ZnVuY3Rpb24obix0KXt2YXIgcj1qKG4pO3JldHVybiB0JiZtLmV4dGVuZE93bihyLHQpLHJ9LG0uY2xvbmU9ZnVuY3Rpb24obil7cmV0dXJuIG0uaXNPYmplY3Qobik/bS5pc0FycmF5KG4pP24uc2xpY2UoKTptLmV4dGVuZCh7fSxuKTpufSxtLnRhcD1mdW5jdGlvbihuLHQpe3JldHVybiB0KG4pLG59LG0uaXNNYXRjaD1mdW5jdGlvbihuLHQpe3ZhciByPW0ua2V5cyh0KSxlPXIubGVuZ3RoO2lmKG51bGw9PW4pcmV0dXJuIWU7Zm9yKHZhciB1PU9iamVjdChuKSxpPTA7ZT5pO2krKyl7dmFyIG89cltpXTtpZih0W29dIT09dVtvXXx8IShvIGluIHUpKXJldHVybiExfXJldHVybiEwfTt2YXIgTj1mdW5jdGlvbihuLHQscixlKXtpZihuPT09dClyZXR1cm4gMCE9PW58fDEvbj09PTEvdDtpZihudWxsPT1ufHxudWxsPT10KXJldHVybiBuPT09dDtuIGluc3RhbmNlb2YgbSYmKG49bi5fd3JhcHBlZCksdCBpbnN0YW5jZW9mIG0mJih0PXQuX3dyYXBwZWQpO3ZhciB1PXMuY2FsbChuKTtpZih1IT09cy5jYWxsKHQpKXJldHVybiExO3N3aXRjaCh1KXtjYXNlXCJbb2JqZWN0IFJlZ0V4cF1cIjpjYXNlXCJbb2JqZWN0IFN0cmluZ11cIjpyZXR1cm5cIlwiK249PVwiXCIrdDtjYXNlXCJbb2JqZWN0IE51bWJlcl1cIjpyZXR1cm4rbiE9PStuPyt0IT09K3Q6MD09PStuPzEvK249PT0xL3Q6K249PT0rdDtjYXNlXCJbb2JqZWN0IERhdGVdXCI6Y2FzZVwiW29iamVjdCBCb29sZWFuXVwiOnJldHVybituPT09K3R9dmFyIGk9XCJbb2JqZWN0IEFycmF5XVwiPT09dTtpZighaSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIG58fFwib2JqZWN0XCIhPXR5cGVvZiB0KXJldHVybiExO3ZhciBvPW4uY29uc3RydWN0b3IsYT10LmNvbnN0cnVjdG9yO2lmKG8hPT1hJiYhKG0uaXNGdW5jdGlvbihvKSYmbyBpbnN0YW5jZW9mIG8mJm0uaXNGdW5jdGlvbihhKSYmYSBpbnN0YW5jZW9mIGEpJiZcImNvbnN0cnVjdG9yXCJpbiBuJiZcImNvbnN0cnVjdG9yXCJpbiB0KXJldHVybiExfXI9cnx8W10sZT1lfHxbXTtmb3IodmFyIGM9ci5sZW5ndGg7Yy0tOylpZihyW2NdPT09bilyZXR1cm4gZVtjXT09PXQ7aWYoci5wdXNoKG4pLGUucHVzaCh0KSxpKXtpZihjPW4ubGVuZ3RoLGMhPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IoO2MtLTspaWYoIU4obltjXSx0W2NdLHIsZSkpcmV0dXJuITF9ZWxzZXt2YXIgZixsPW0ua2V5cyhuKTtpZihjPWwubGVuZ3RoLG0ua2V5cyh0KS5sZW5ndGghPT1jKXJldHVybiExO2Zvcig7Yy0tOylpZihmPWxbY10sIW0uaGFzKHQsZil8fCFOKG5bZl0sdFtmXSxyLGUpKXJldHVybiExfXJldHVybiByLnBvcCgpLGUucG9wKCksITB9O20uaXNFcXVhbD1mdW5jdGlvbihuLHQpe3JldHVybiBOKG4sdCl9LG0uaXNFbXB0eT1mdW5jdGlvbihuKXtyZXR1cm4gbnVsbD09bj8hMDprKG4pJiYobS5pc0FycmF5KG4pfHxtLmlzU3RyaW5nKG4pfHxtLmlzQXJndW1lbnRzKG4pKT8wPT09bi5sZW5ndGg6MD09PW0ua2V5cyhuKS5sZW5ndGh9LG0uaXNFbGVtZW50PWZ1bmN0aW9uKG4pe3JldHVybiEoIW58fDEhPT1uLm5vZGVUeXBlKX0sbS5pc0FycmF5PWh8fGZ1bmN0aW9uKG4pe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PXMuY2FsbChuKX0sbS5pc09iamVjdD1mdW5jdGlvbihuKXt2YXIgdD10eXBlb2YgbjtyZXR1cm5cImZ1bmN0aW9uXCI9PT10fHxcIm9iamVjdFwiPT09dCYmISFufSxtLmVhY2goW1wiQXJndW1lbnRzXCIsXCJGdW5jdGlvblwiLFwiU3RyaW5nXCIsXCJOdW1iZXJcIixcIkRhdGVcIixcIlJlZ0V4cFwiLFwiRXJyb3JcIl0sZnVuY3Rpb24obil7bVtcImlzXCIrbl09ZnVuY3Rpb24odCl7cmV0dXJuIHMuY2FsbCh0KT09PVwiW29iamVjdCBcIituK1wiXVwifX0pLG0uaXNBcmd1bWVudHMoYXJndW1lbnRzKXx8KG0uaXNBcmd1bWVudHM9ZnVuY3Rpb24obil7cmV0dXJuIG0uaGFzKG4sXCJjYWxsZWVcIil9KSxcImZ1bmN0aW9uXCIhPXR5cGVvZi8uLyYmXCJvYmplY3RcIiE9dHlwZW9mIEludDhBcnJheSYmKG0uaXNGdW5jdGlvbj1mdW5jdGlvbihuKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBufHwhMX0pLG0uaXNGaW5pdGU9ZnVuY3Rpb24obil7cmV0dXJuIGlzRmluaXRlKG4pJiYhaXNOYU4ocGFyc2VGbG9hdChuKSl9LG0uaXNOYU49ZnVuY3Rpb24obil7cmV0dXJuIG0uaXNOdW1iZXIobikmJm4hPT0rbn0sbS5pc0Jvb2xlYW49ZnVuY3Rpb24obil7cmV0dXJuIG49PT0hMHx8bj09PSExfHxcIltvYmplY3QgQm9vbGVhbl1cIj09PXMuY2FsbChuKX0sbS5pc051bGw9ZnVuY3Rpb24obil7cmV0dXJuIG51bGw9PT1ufSxtLmlzVW5kZWZpbmVkPWZ1bmN0aW9uKG4pe3JldHVybiBuPT09dm9pZCAwfSxtLmhhcz1mdW5jdGlvbihuLHQpe3JldHVybiBudWxsIT1uJiZwLmNhbGwobix0KX0sbS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHUuXz1pLHRoaXN9LG0uaWRlbnRpdHk9ZnVuY3Rpb24obil7cmV0dXJuIG59LG0uY29uc3RhbnQ9ZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG59fSxtLm5vb3A9ZnVuY3Rpb24oKXt9LG0ucHJvcGVydHk9dyxtLnByb3BlcnR5T2Y9ZnVuY3Rpb24obil7cmV0dXJuIG51bGw9PW4/ZnVuY3Rpb24oKXt9OmZ1bmN0aW9uKHQpe3JldHVybiBuW3RdfX0sbS5tYXRjaGVyPW0ubWF0Y2hlcz1mdW5jdGlvbihuKXtyZXR1cm4gbj1tLmV4dGVuZE93bih7fSxuKSxmdW5jdGlvbih0KXtyZXR1cm4gbS5pc01hdGNoKHQsbil9fSxtLnRpbWVzPWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT1BcnJheShNYXRoLm1heCgwLG4pKTt0PWIodCxyLDEpO2Zvcih2YXIgdT0wO24+dTt1KyspZVt1XT10KHUpO3JldHVybiBlfSxtLnJhbmRvbT1mdW5jdGlvbihuLHQpe3JldHVybiBudWxsPT10JiYodD1uLG49MCksbitNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKHQtbisxKSl9LG0ubm93PURhdGUubm93fHxmdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfTt2YXIgQj17XCImXCI6XCImYW1wO1wiLFwiPFwiOlwiJmx0O1wiLFwiPlwiOlwiJmd0O1wiLCdcIic6XCImcXVvdDtcIixcIidcIjpcIiYjeDI3O1wiLFwiYFwiOlwiJiN4NjA7XCJ9LFQ9bS5pbnZlcnQoQiksUj1mdW5jdGlvbihuKXt2YXIgdD1mdW5jdGlvbih0KXtyZXR1cm4gblt0XX0scj1cIig/OlwiK20ua2V5cyhuKS5qb2luKFwifFwiKStcIilcIixlPVJlZ0V4cChyKSx1PVJlZ0V4cChyLFwiZ1wiKTtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIG49bnVsbD09bj9cIlwiOlwiXCIrbixlLnRlc3Qobik/bi5yZXBsYWNlKHUsdCk6bn19O20uZXNjYXBlPVIoQiksbS51bmVzY2FwZT1SKFQpLG0ucmVzdWx0PWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT1udWxsPT1uP3ZvaWQgMDpuW3RdO3JldHVybiBlPT09dm9pZCAwJiYoZT1yKSxtLmlzRnVuY3Rpb24oZSk/ZS5jYWxsKG4pOmV9O3ZhciBxPTA7bS51bmlxdWVJZD1mdW5jdGlvbihuKXt2YXIgdD0rK3ErXCJcIjtyZXR1cm4gbj9uK3Q6dH0sbS50ZW1wbGF0ZVNldHRpbmdzPXtldmFsdWF0ZTovPCUoW1xcc1xcU10rPyklPi9nLGludGVycG9sYXRlOi88JT0oW1xcc1xcU10rPyklPi9nLGVzY2FwZTovPCUtKFtcXHNcXFNdKz8pJT4vZ307dmFyIEs9LyguKV4vLHo9e1wiJ1wiOlwiJ1wiLFwiXFxcXFwiOlwiXFxcXFwiLFwiXFxyXCI6XCJyXCIsXCJcXG5cIjpcIm5cIixcIlxcdTIwMjhcIjpcInUyMDI4XCIsXCJcXHUyMDI5XCI6XCJ1MjAyOVwifSxEPS9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZyxMPWZ1bmN0aW9uKG4pe3JldHVyblwiXFxcXFwiK3pbbl19O20udGVtcGxhdGU9ZnVuY3Rpb24obix0LHIpeyF0JiZyJiYodD1yKSx0PW0uZGVmYXVsdHMoe30sdCxtLnRlbXBsYXRlU2V0dGluZ3MpO3ZhciBlPVJlZ0V4cChbKHQuZXNjYXBlfHxLKS5zb3VyY2UsKHQuaW50ZXJwb2xhdGV8fEspLnNvdXJjZSwodC5ldmFsdWF0ZXx8Sykuc291cmNlXS5qb2luKFwifFwiKStcInwkXCIsXCJnXCIpLHU9MCxpPVwiX19wKz0nXCI7bi5yZXBsYWNlKGUsZnVuY3Rpb24odCxyLGUsbyxhKXtyZXR1cm4gaSs9bi5zbGljZSh1LGEpLnJlcGxhY2UoRCxMKSx1PWErdC5sZW5ndGgscj9pKz1cIicrXFxuKChfX3Q9KFwiK3IrXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI6ZT9pKz1cIicrXFxuKChfX3Q9KFwiK2UrXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjpvJiYoaSs9XCInO1xcblwiK28rXCJcXG5fX3ArPSdcIiksdH0pLGkrPVwiJztcXG5cIix0LnZhcmlhYmxlfHwoaT1cIndpdGgob2JqfHx7fSl7XFxuXCIraStcIn1cXG5cIiksaT1cInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIitcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIraStcInJldHVybiBfX3A7XFxuXCI7dHJ5e3ZhciBvPW5ldyBGdW5jdGlvbih0LnZhcmlhYmxlfHxcIm9ialwiLFwiX1wiLGkpfWNhdGNoKGEpe3Rocm93IGEuc291cmNlPWksYX12YXIgYz1mdW5jdGlvbihuKXtyZXR1cm4gby5jYWxsKHRoaXMsbixtKX0sZj10LnZhcmlhYmxlfHxcIm9ialwiO3JldHVybiBjLnNvdXJjZT1cImZ1bmN0aW9uKFwiK2YrXCIpe1xcblwiK2krXCJ9XCIsY30sbS5jaGFpbj1mdW5jdGlvbihuKXt2YXIgdD1tKG4pO3JldHVybiB0Ll9jaGFpbj0hMCx0fTt2YXIgUD1mdW5jdGlvbihuLHQpe3JldHVybiBuLl9jaGFpbj9tKHQpLmNoYWluKCk6dH07bS5taXhpbj1mdW5jdGlvbihuKXttLmVhY2gobS5mdW5jdGlvbnMobiksZnVuY3Rpb24odCl7dmFyIHI9bVt0XT1uW3RdO20ucHJvdG90eXBlW3RdPWZ1bmN0aW9uKCl7dmFyIG49W3RoaXMuX3dyYXBwZWRdO3JldHVybiBmLmFwcGx5KG4sYXJndW1lbnRzKSxQKHRoaXMsci5hcHBseShtLG4pKX19KX0sbS5taXhpbihtKSxtLmVhY2goW1wicG9wXCIsXCJwdXNoXCIsXCJyZXZlcnNlXCIsXCJzaGlmdFwiLFwic29ydFwiLFwic3BsaWNlXCIsXCJ1bnNoaWZ0XCJdLGZ1bmN0aW9uKG4pe3ZhciB0PW9bbl07bS5wcm90b3R5cGVbbl09ZnVuY3Rpb24oKXt2YXIgcj10aGlzLl93cmFwcGVkO3JldHVybiB0LmFwcGx5KHIsYXJndW1lbnRzKSxcInNoaWZ0XCIhPT1uJiZcInNwbGljZVwiIT09bnx8MCE9PXIubGVuZ3RofHxkZWxldGUgclswXSxQKHRoaXMscil9fSksbS5lYWNoKFtcImNvbmNhdFwiLFwiam9pblwiLFwic2xpY2VcIl0sZnVuY3Rpb24obil7dmFyIHQ9b1tuXTttLnByb3RvdHlwZVtuXT1mdW5jdGlvbigpe3JldHVybiBQKHRoaXMsdC5hcHBseSh0aGlzLl93cmFwcGVkLGFyZ3VtZW50cykpfX0pLG0ucHJvdG90eXBlLnZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyYXBwZWR9LG0ucHJvdG90eXBlLnZhbHVlT2Y9bS5wcm90b3R5cGUudG9KU09OPW0ucHJvdG90eXBlLnZhbHVlLG0ucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJcIit0aGlzLl93cmFwcGVkfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQmJmRlZmluZShcInVuZGVyc2NvcmVcIixbXSxmdW5jdGlvbigpe3JldHVybiBtfSl9KS5jYWxsKHRoaXMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5kZXJzY29yZS1taW4ubWFwIiwiLyoqXG4gKiBUaGUgTWFpbiBzaW5nbGV0b24gb2JqZWN0LlxuICogQ3JlYXRlZCBieSBIZW5yeSBvbiA2LzI3LzIwMTUuXG4gKi9cbnZhciAkID0gcmVxdWlyZShcIi4vbGliL2pxdWVyeS5qc1wiKTtcbnZhciBfID0gcmVxdWlyZShcIi4vbGliL3VuZGVyc2NvcmUuanNcIik7XG52YXIgVEhSRUUgPSByZXF1aXJlKFwiLi9saWIvdGhyZWUuanNcIik7XG52YXIgV29ybGQgPSByZXF1aXJlKFwiLi93b3JsZC5qc1wiKTtcbnZhciBJbnB1dCA9IHJlcXVpcmUoXCIuL2lucHV0LmpzXCIpO1xudmFyIFJlbmRlcmVyID0gcmVxdWlyZShcIi4vcmVuZGVyZXIuanNcIik7XG52YXIgT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCIuL2xpYi9vcmJpdGNvbnRyb2xzLmpzXCIpO1xuXG52YXIgTWFpbiA9IG5ldyBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZiBpbnN0YW5jZVxuICAgICAqIEB0eXBlIHtNYWlufVxuICAgICAqL1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHNlbGYua2V5TWFwID0ge1xuICAgICAgICBTSElGVDogMTZcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIE1haW4gc2luZ2xldG9uIGlzIGluaXRpYWxpemVkLlxuICAgICAqL1xuICAgIHNlbGYuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBDYW1lcmFcbiAgICAgICAgICogQHR5cGUge1RIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAxLCAxMDAwMCk7XG4gICAgICAgIHNlbGYuY2FtZXJhLnBvc2l0aW9uLnNldCg1MDAsIDgwMCwgMTMwMCk7XG4gICAgICAgIHNlbGYuY2FtZXJhLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygpKTtcblxuICAgICAgICBzZWxmLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cbiAgICAgICAgLy8gcm9sbC1vdmVyIGhlbHBlcnNcbiAgICAgICAgdmFyIHJvbGxPdmVyR2VvID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDUwLCA1MCwgNTApO1xuICAgICAgICBzZWxmLnJvbGxPdmVyTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe2NvbG9yOiAweGZmMDAwMCwgb3BhY2l0eTogMC41LCB0cmFuc3BhcmVudDogdHJ1ZX0pO1xuICAgICAgICBzZWxmLnJvbGxPdmVyTWVzaCA9IG5ldyBUSFJFRS5NZXNoKHJvbGxPdmVyR2VvLCBzZWxmLnJvbGxPdmVyTWF0ZXJpYWwpO1xuICAgICAgICBzZWxmLnNjZW5lLmFkZChzZWxmLnJvbGxPdmVyTWVzaCk7XG5cbiAgICAgICAgLy8gY3ViZXNcbiAgICAgICAgc2VsZi5jdWJlR2VvID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDUwLCA1MCwgNTApO1xuICAgICAgICBzZWxmLmN1YmVNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtjb2xvcjogMHhmZWI3NGMsIHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nLCBtYXA6IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoXCJ0ZXh0dXJlcy9zcXVhcmUtb3V0bGluZS10ZXh0dXJlZC5wbmdcIil9KTtcblxuICAgICAgICAvLyBEcmF3IGdyaWRcbiAgICAgICAgdmFyIHNpemUgPSA1MDAsIHN0ZXAgPSA1MDtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gLXNpemU7IGkgPD0gc2l6ZTsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKC1zaXplLCAwLCBpKSk7XG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHNpemUsIDAsIGkpKTtcblxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhpLCAwLCAtc2l6ZSkpO1xuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhpLCAwLCBzaXplKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe2NvbG9yOiAweDAwMDAwMCwgb3BhY2l0eTogMC4yLCB0cmFuc3BhcmVudDogdHJ1ZX0pO1xuXG4gICAgICAgIHZhciBsaW5lID0gbmV3IFRIUkVFLkxpbmUoZ2VvbWV0cnksIG1hdGVyaWFsLCBUSFJFRS5MaW5lUGllY2VzKTtcbiAgICAgICAgc2VsZi5zY2VuZS5hZGQobGluZSk7XG5cbiAgICAgICAgc2VsZi5yYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKCk7XG4gICAgICAgIHNlbGYubW91c2UgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KDEwMDAsIDEwMDApO1xuICAgICAgICBnZW9tZXRyeS5hcHBseU1hdHJpeChuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvblgoLU1hdGguUEkgLyAyKSk7XG5cbiAgICAgICAgc2VsZi5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5KTtcbiAgICAgICAgc2VsZi5wbGFuZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHNlbGYuc2NlbmUuYWRkKHNlbGYucGxhbmUpO1xuXG4gICAgICAgIFdvcmxkLmVudGl0aWVzLnB1c2goc2VsZi5wbGFuZSk7XG5cbiAgICAgICAgLy8gTGlnaHRzXG4gICAgICAgIHZhciBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4NjA2MDYwKTtcbiAgICAgICAgc2VsZi5zY2VuZS5hZGQoYW1iaWVudExpZ2h0KTtcblxuICAgICAgICB2YXIgZGlyZWN0aW9uYWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmKTtcbiAgICAgICAgZGlyZWN0aW9uYWxMaWdodC5wb3NpdGlvbi5zZXQoMSwgMC43NSwgMC41KS5ub3JtYWxpemUoKTtcbiAgICAgICAgc2VsZi5zY2VuZS5hZGQoZGlyZWN0aW9uYWxMaWdodCk7XG5cbiAgICAgICAgLy9Db250cm9sc1xuICAgICAgICBzZWxmLmNvbnRyb2xzID0gbmV3IE9yYml0Q29udHJvbHMoc2VsZi5jYW1lcmEsIFJlbmRlcmVyLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLmJpbmQoXCJtb3VzZW1vdmVcIiwgc2VsZi5vbk1vdXNlTW92ZSk7XG4gICAgICAgICQoZG9jdW1lbnQpLmJpbmQoXCJtb3VzZWRvd25cIiwgc2VsZi5vbk1vdXNlRG93bik7XG4gICAgICAgICQoZG9jdW1lbnQpLmJpbmQoXCJtb3VzZXVwXCIsIHNlbGYub25Nb3VzZVVwKTtcbiAgICAgICAgJCh3aW5kb3cpLmJpbmQoXCJyZXNpemVcIiwgc2VsZi5vbldpbmRvd1Jlc2l6ZSk7XG5cbiAgICAgICAgUmVuZGVyZXIucmVuZGVyV29ybGQoKTtcbiAgICB9O1xuXG4gICAgc2VsZi5vbldpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5jYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHNlbGYuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgICAgICBSZW5kZXJlci5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH07XG5cbiAgICBzZWxmLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgc2VsZi5tb3VzZS5zZXQoKCBldmVudC5jbGllbnRYIC8gd2luZG93LmlubmVyV2lkdGggKSAqIDIgLSAxLCAtKCBldmVudC5jbGllbnRZIC8gd2luZG93LmlubmVySGVpZ2h0ICkgKiAyICsgMSk7XG5cbiAgICAgICAgaWYgKCFzZWxmLmlzTWlkZGxlTW91c2VEb3duKSB7XG4gICAgICAgICAgICBzZWxmLmNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoKSk7XG4gICAgICAgICAgICBzZWxmLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHNlbGYubW91c2UsIHNlbGYuY2FtZXJhKTtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdHMgPSBzZWxmLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKFdvcmxkLmVudGl0aWVzKTtcblxuICAgICAgICAgICAgaWYgKGludGVyc2VjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBpbnRlcnNlY3RzWzBdO1xuICAgICAgICAgICAgICAgIHNlbGYucm9sbE92ZXJNZXNoLnBvc2l0aW9uLmNvcHkoaW50ZXJzZWN0LnBvaW50KS5hZGQoaW50ZXJzZWN0LmZhY2Uubm9ybWFsKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJvbGxPdmVyTWVzaC5wb3NpdGlvbi5kaXZpZGVTY2FsYXIoNTApLmZsb29yKCkubXVsdGlwbHlTY2FsYXIoNTApLmFkZFNjYWxhcigyNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZW5kZXJlci5yZW5kZXJXb3JsZCgpO1xuICAgIH07XG5cbiAgICBzZWxmLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgc2VsZi5tb3VzZS5zZXQoKCBldmVudC5jbGllbnRYIC8gd2luZG93LmlubmVyV2lkdGggKSAqIDIgLSAxLCAtKCBldmVudC5jbGllbnRZIC8gd2luZG93LmlubmVySGVpZ2h0ICkgKiAyICsgMSk7XG5cbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09IDIpIHtcbiAgICAgICAgICAgIHNlbGYuaXNNaWRkbGVNb3VzZURvd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzZWxmLm1vdXNlLCBzZWxmLmNhbWVyYSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0cyA9IHNlbGYucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHMoV29ybGQuZW50aXRpZXMpO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IGludGVyc2VjdHNbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5jb250YWlucyhJbnB1dC5wcmVzc2VkLCBzZWxmLmtleU1hcC5TSElGVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIGN1YmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdC5vYmplY3QgIT0gc2VsZi5wbGFuZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zY2VuZS5yZW1vdmUoaW50ZXJzZWN0Lm9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBXb3JsZC5lbnRpdGllcy5zcGxpY2UoV29ybGQuZW50aXRpZXMuaW5kZXhPZihpbnRlcnNlY3Qub2JqZWN0KSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgY3ViZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdm94ZWwgPSBuZXcgVEhSRUUuTWVzaChzZWxmLmN1YmVHZW8sIHNlbGYuY3ViZU1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgICAgICAgdm94ZWwucG9zaXRpb24uY29weShpbnRlcnNlY3QucG9pbnQpLmFkZChpbnRlcnNlY3QuZmFjZS5ub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICB2b3hlbC5wb3NpdGlvbi5kaXZpZGVTY2FsYXIoNTApLmZsb29yKCkubXVsdGlwbHlTY2FsYXIoNTApLmFkZFNjYWxhcigyNSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2NlbmUuYWRkKHZveGVsKTtcblxuICAgICAgICAgICAgICAgICAgICBXb3JsZC5lbnRpdGllcy5wdXNoKHZveGVsKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFJlbmRlcmVyLnJlbmRlcldvcmxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5vbk1vdXNlVXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS53aGljaCA9PSAyKSB7XG4gICAgICAgICAgICBzZWxmLmlzTWlkZGxlTW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYWluOyIsIi8qKlxuICogVGhlIFVJIGFuZCBXb3JsZCByZW5kZXJlclxuICogQ3JlYXRlZCBieSBIZW5yeSBvbiA2LzI4LzIwMTUuXG4gKi9cbnZhciAkID0gcmVxdWlyZShcIi4vbGliL2pxdWVyeS5qc1wiKTtcbnZhciBUSFJFRSA9IHJlcXVpcmUoXCIuL2xpYi90aHJlZS5qc1wiKTtcbnZhciBNYWluID0gcmVxdWlyZShcIi4vbWFpbi5qc1wiKTtcblxudmFyIFJlbmRlcmVyID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLmNvbnRhaW5lciA9ICQoXCI8ZGl2PlwiKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcblxuICAgIC8qKlxuICAgICAqIFdlYkdMIFJlbmRlcmVyXG4gICAgICovXG4gICAgc2VsZi5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHthbnRpYWxpYXM6IHRydWV9KTtcbiAgICBzZWxmLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhmMGYwZjApO1xuICAgIHNlbGYucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgc2VsZi5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHNlbGYuY29udGFpbmVyLmFwcGVuZChzZWxmLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgdXNlciBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgc2VsZi5yZW5kZXJVSSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJChcIjxkaXY+XCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJ1aVwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKFwiaGVhZGVyXCIpXG4gICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgJChcIjxoMT5cIilcbiAgICAgICAgICAgICAgICAuaHRtbChcIlZveGVsIE1vZGVsZXJcIilcbiAgICAgICAgKVxuICAgICAgICAgICAgLmFwcGVuZFRvKHNlbGYuY29udGFpbmVyKTtcblxuICAgICAgICAkKFwiPGRpdj5cIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcInVpXCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJwYW5lbFwiKVxuICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICQoXCI8ZGl2PlwiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjxoND5cIikuaHRtbChcIklucHV0IENvbnRyb2xcIikpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHA+XCIpLmh0bWwoXCJNaWRkbGUgLSBSb3RhdGVcIikpXG4gICAgICAgIClcbiAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAkKFwiPGJ1dHRvbj5cIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInR5cGVcIiwgXCJidXR0b25cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidG5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidG4tZGVmYXVsdFwiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxzcGFuPlwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJnbHlwaGljb25cIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZ2x5cGhpY29uLXBsdXNcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC8vLmJpbmQoXCJjbGlja1wiLCBNYWluLilcbiAgICAgICAgKS5hcHBlbmQoXG4gICAgICAgICAgICAkKFwiPGJ1dHRvbj5cIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInR5cGVcIiwgXCJidXR0b25cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidG5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidG4tZGVmYXVsdFwiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxzcGFuPlwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJnbHlwaGljb25cIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZ2x5cGhpY29uLXBlbmNpbFwiKVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgICAgICAuYXBwZW5kVG8oc2VsZi5jb250YWluZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB3b3JsZC5cbiAgICAgKi9cbiAgICBzZWxmLnJlbmRlcldvcmxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBNYWluID0gcmVxdWlyZShcIi4vbWFpbi5qc1wiKTtcbiAgICAgICAgc2VsZi5yZW5kZXJlci5yZW5kZXIoTWFpbi5zY2VuZSwgTWFpbi5jYW1lcmEpO1xuICAgIH07XG59O1xuXG5SZW5kZXJlci5yZW5kZXJVSSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyOyIsIi8qKlxuICogVGhlIFdvcmxkIHNpbmdsZXRvbiBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSB3b3JsZCBzcGFjZVxuICogQ3JlYXRlZCBieSBIZW5yeSBvbiA2LzI3LzIwMTUuXG4gKi9cbnZhciBUSFJFRSA9IHJlcXVpcmUoXCIuL2xpYi90aHJlZS5qc1wiKTtcblxudmFyIFdvcmxkID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBvYmplY3RzIGluIHRoZSB3b3JsZC5cbiAgICAgKiBAdHlwZSB7RW50aXR5fVxuICAgICAqL1xuICAgIHNlbGYuZW50aXRpZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIHRoZSB3b3JsZFxuICAgICAqIEBwYXJhbSBUaGUgZW50aXR5IHRvIGFkZFxuICAgICAqL1xuICAgIHNlbGYuYWRkID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgICBzZWxmLmVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JsZDsiXX0=
